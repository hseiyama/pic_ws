 AS V1.42 Beta [Bld 246] - Source File add_EMUBASIC.ASM - Page 1 - 9/2/2023 2:59:35


       1/       0 :                     	page	0
       2/       0 :                     	cpu	z80
       3/       0 :                     ;	EMUBASIC based on GRANT's BASIC
       4/       0 :                     ;	TARGET: EMUZ80
       5/       0 :                     ;	ASSEMBLER: ARCPIT XZ80.EXE
       6/       0 :                     ;
       7/       0 :                     ;	START UP ROUTINE
       8/       0 :                     ;	VERSION 1.0, 2022/02/15
       9/       0 :                     ;	WRITTEN by TETSUYA SUZUKI
      10/       0 :                     ;	Modified Akihito Honda
      11/       0 :                     ;
      12/       0 :                     
      13/       0 : =1H                 RAM12K = 1
      14/       0 : =0H                 RAM8K = 0
      15/       0 : =0H                 RAM4K = 0
      16/       0 :                     
      17/       0 : =>TRUE              	IF	RAM12K
      18/       0 : =0EEC0H             STACKU	equ	0EEC0H	; user stack
      19/       0 : =0C000H             RAMTOP	EQU	0C000H
      20/       0 : [17]                	ENDIF
      21/       0 :                     
      22/       0 : =>FALSE             	IF	RAM8K
      23/       0 :                     STACKU	equ	9EC0H	; user stack
      24/       0 :                     RAMTOP	EQU	08000H
      25/       0 : [22]                	ENDIF
      26/       0 :                     
      27/       0 : =>FALSE             	IF	RAM4K
      28/       0 :                     ; ORIGINAL MEMORY MAP for PIC18F47Q43
      29/       0 :                     STACKU	equ	8EC0H	; user stack
      30/       0 :                     RAMTOP	EQU	08000H
      31/       0 : [27]                	ENDIF
      32/       0 :                     
      33/       0 :                     ;	MEMORY ASIGN
      34/       0 : =2F00H              ROMTOP	EQU	2F00H		; 0000H - 2EFFH for unimon
      35/       0 :                     
      36/       0 :                     ;
      37/       0 :                     ;	RESET (RST 00H)
      38/    2F00 :                     	ORG	ROMTOP
      39/    2F00 : C3 06 2F            	JP	STARTB		; Jump for cold start
      40/    2F03 : C3 6B 2F            	JP	WARMST		; Jump for warm start
      41/    2F06 :                     
      42/    2F06 : =>FALSE             	if	0
      43/    2F06 :                     ;
      44/    2F06 :                     ;	PUT 1CHAR (RST 08H)
      45/    2F06 :                     ;	ORG	ROMTOP+08H
      46/    2F06 :                     	ds	ROMTOP+08H - $, 0x00
      47/    2F06 :                     	JP	TXA
      48/    2F06 :                     ;
      49/    2F06 :                     ;	GET 1CHAR (RST 10H)
      50/    2F06 :                     ;	ORG	ROMTOP+10H
      51/    2F06 :                     	ds	ROMTOP+10H - $, 0x00
      52/    2F06 :                     	JP	RXA
      53/    2F06 :                     ;
      54/    2F06 :                     ;	KBHIT (RST 18H)
      55/    2F06 :                     ;	ORG	ROMTOP+18H
      56/    2F06 :                     	ds	ROMTOP+18H - $, 0x00
      57/    2F06 :                     	JP	KBHIT
      58/    2F06 :                     ;
      59/    2F06 :                     ;	UART -> A
      60/    2F06 :                     RXA:	LD	A,(UARTCR)
      61/    2F06 :                     	BIT	0,A
      62/    2F06 :                     	JR	Z,RXA
      63/    2F06 :                     	LD	A,(UARTDR)
      64/    2F06 :                     	CP	'a'
      65/    2F06 :                     	RET	C
      66/    2F06 :                     	CP	'z'+1
      67/    2F06 :                     	RET	NC
      68/    2F06 :                     	AND	0DFH
      69/    2F06 :                     	RET
      70/    2F06 :                     ;
      71/    2F06 :                     ;	CHECK RECEIVE STATUS
      72/    2F06 :                     KBHIT:	LD	A,(UARTCR)
      73/    2F06 :                     	BIT	0,A
      74/    2F06 :                     	RET
      75/    2F06 :                     ;
      76/    2F06 :                     ;	A -> UART
      77/    2F06 :                     TXA:	PUSH	AF
      78/    2F06 :                     TXAST1:	LD	A,(UARTCR)
      79/    2F06 :                     	BIT	1,A
      80/    2F06 :                     	JR	Z,TXAST1
      81/    2F06 :                     	POP	AF
      82/    2F06 :                     	LD	(UARTDR),A
      83/    2F06 :                     	RET
      84/    2F06 : [42]                	endif
      85/    2F06 :                     ;
      86/    2F06 :                     ;==================================================================================
      87/    2F06 :                     ; The updates to the original BASIC within this file are copyright Grant Searle
      88/    2F06 :                     ;
      89/    2F06 :                     ; You have permission to use this for NON COMMERCIAL USE ONLY
      90/    2F06 :                     ; If you wish to use it elsewhere, please include an acknowledgement to myself.
      91/    2F06 :                     ;
      92/    2F06 :                     ; http://searle.hostei.com/grant/index.html
      93/    2F06 :                     ;
      94/    2F06 :                     ; eMail: home.micros01@btinternet.com
      95/    2F06 :                     ;
      96/    2F06 :                     ; If the above don't work, please perform an Internet search to see if I have
      97/    2F06 :                     ; updated the web page hosting service.
      98/    2F06 :                     ;
      99/    2F06 :                     ;==================================================================================
     100/    2F06 :                     ;
     101/    2F06 :                     ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
     102/    2F06 :                     ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
     103/    2F06 :                     ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
     104/    2F06 :                     ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
     105/    2F06 :                     ; the original ROM code (checksum A934H). PA
     106/    2F06 :                     ;
     107/    2F06 :                     ; GENERAL EQUATES
     108/    2F06 :                     ;
     109/    2F06 : =3H                 CTRLC	EQU	03H		; Control "C"
     110/    2F06 : =7H                 CTRLG	EQU	07H		; Control "G"
     111/    2F06 : =8H                 BKSP	EQU	08H		; Back space
     112/    2F06 : =0AH                LF	EQU	0AH		; Line feed
     113/    2F06 : =0CH                CS	EQU	0CH		; Clear screen
     114/    2F06 : =0DH                CR	EQU	0DH		; Carriage return
     115/    2F06 : =0FH                CTRLO	EQU	0FH		; Control "O"
     116/    2F06 : =11H                CTRLQ	EQU	11H		; Control "Q"
     117/    2F06 : =12H                CTRLR	EQU	12H		; Control "R"
     118/    2F06 : =13H                CTRLS	EQU	13H		; Control "S"
     119/    2F06 : =15H                CTRLU	EQU	15H		; Control "U"
     120/    2F06 : =1BH                ESC	EQU	1BH		; Escape
     121/    2F06 : =7FH                DEL	EQU	7FH		; Delete
     122/    2F06 :                     ;
     123/    2F06 :                     ; BASIC WORK SPACE LOCATIONS
     124/    2F06 :                     ;
     125/    2F06 : =0C045H             WRKSPC	EQU	RAMTOP + 45H	; BASIC Work space
     126/    2F06 : =0C048H             USR	EQU	WRKSPC+3H	; "USR (x)" jump
     127/    2F06 : =0C04BH             OUTSUB	EQU	WRKSPC+6H	; "OUT p,n"
     128/    2F06 : =0C04CH             OTPORT	EQU	WRKSPC+7H	; Port (p)
     129/    2F06 : =0C04EH             DIVSUP	EQU	WRKSPC+9H	; Division support routine
     130/    2F06 : =0C04FH             DIV1	EQU	WRKSPC+0AH	; <- Values
     131/    2F06 : =0C053H             DIV2	EQU	WRKSPC+0EH	; <- to
     132/    2F06 : =0C057H             DIV3	EQU	WRKSPC+12H	; <- be
     133/    2F06 : =0C05AH             DIV4	EQU	WRKSPC+15H	; <- inserted
     134/    2F06 : =0C05CH             SEED	EQU	WRKSPC+17H	; Random number seed
     135/    2F06 : =0C07FH             LSTRND	EQU	WRKSPC+3AH	; Last random number
     136/    2F06 : =0C083H             INPSUB	EQU	WRKSPC+3EH	; #INP (x)" Routine
     137/    2F06 : =0C084H             INPORT	EQU	WRKSPC+3FH	; PORT (x)
     138/    2F06 : =0C086H             NULLS	EQU	WRKSPC+41H	; Number of nulls
     139/    2F06 : =0C087H             LWIDTH	EQU	WRKSPC+42H	; Terminal width
     140/    2F06 : =0C088H             COMMAN	EQU	WRKSPC+43H	; Width for commas
     141/    2F06 : =0C089H             NULFLG	EQU	WRKSPC+44H	; Null after input byte flag
     142/    2F06 : =0C08AH             CTLOFG	EQU	WRKSPC+45H	; Control "O" flag
     143/    2F06 : =0C08BH             LINESC	EQU	WRKSPC+46H	; Lines counter
     144/    2F06 : =0C08DH             LINESN	EQU	WRKSPC+48H	; Lines number
     145/    2F06 : =0C08FH             CHKSUM	EQU	WRKSPC+4AH	; Array load/save check sum
     146/    2F06 : =0C091H             NMIFLG	EQU	WRKSPC+4CH	; Flag for NMI break routine
     147/    2F06 : =0C092H             BRKFLG	EQU	WRKSPC+4DH	; Break flag
     148/    2F06 : =0C093H             RINPUT	EQU	WRKSPC+4EH	; Input reflection
     149/    2F06 : =0C096H             POINT	EQU	WRKSPC+51H	; "POINT" reflection (unused)
     150/    2F06 : =0C099H             PSET	EQU	WRKSPC+54H	; "SET"	reflection
     151/    2F06 : =0C09CH             RESET	EQU	WRKSPC+57H	; "RESET" reflection
     152/    2F06 : =0C09FH             STRSPC	EQU	WRKSPC+5AH	; Bottom of string space
     153/    2F06 : =0C0A1H             LINEAT	EQU	WRKSPC+5CH	; Current line number
     154/    2F06 : =0C0A3H             BASTXT	EQU	WRKSPC+5EH	; Pointer to start of program
     155/    2F06 : =0C0A6H             BUFFER	EQU	WRKSPC+61H	; Input buffer
     156/    2F06 : =0C0ABH             STACK	EQU	WRKSPC+66H	; Initial stack
     157/    2F06 : =0C0F0H             CURPOS	EQU	WRKSPC+0ABH	; Character position on line
     158/    2F06 : =0C0F1H             LCRFLG	EQU	WRKSPC+0ACH	; Locate/Create flag
     159/    2F06 : =0C0F2H             TYPE	EQU	WRKSPC+0ADH	; Data type flag
     160/    2F06 : =0C0F3H             DATFLG	EQU	WRKSPC+0AEH	; Literal statement flag
     161/    2F06 : =0C0F4H             LSTRAM	EQU	WRKSPC+0AFH	; Last available RAM
     162/    2F06 : =0C0F6H             TMSTPT	EQU	WRKSPC+0B1H	; Temporary string pointer
     163/    2F06 : =0C0F8H             TMSTPL	EQU	WRKSPC+0B3H	; Temporary string pool
     164/    2F06 : =0C104H             TMPSTR	EQU	WRKSPC+0BFH	; Temporary string
     165/    2F06 : =0C108H             STRBOT	EQU	WRKSPC+0C3H	; Bottom of string space
     166/    2F06 : =0C10AH             CUROPR	EQU	WRKSPC+0C5H	; Current operator in EVAL
     167/    2F06 : =0C10CH             LOOPST	EQU	WRKSPC+0C7H	; First statement of loop
     168/    2F06 : =0C10EH             DATLIN	EQU	WRKSPC+0C9H	; Line of current DATA item
     169/    2F06 : =0C110H             FORFLG	EQU	WRKSPC+0CBH	; "FOR" loop flag
     170/    2F06 : =0C111H             LSTBIN	EQU	WRKSPC+0CCH	; Last byte entered
     171/    2F06 : =0C112H             READFG	EQU	WRKSPC+0CDH	; Read/Input flag
     172/    2F06 : =0C113H             BRKLIN	EQU	WRKSPC+0CEH	; Line of break
     173/    2F06 : =0C115H             NXTOPR	EQU	WRKSPC+0D0H	; Next operator in EVAL
     174/    2F06 : =0C117H             ERRLIN	EQU	WRKSPC+0D2H	; Line of error
     175/    2F06 : =0C119H             CONTAD	EQU	WRKSPC+0D4H	; Where to CONTinue
     176/    2F06 : =0C11BH             PROGND	EQU	WRKSPC+0D6H	; End of program
     177/    2F06 : =0C11DH             VAREND	EQU	WRKSPC+0D8H	; End of variables
     178/    2F06 : =0C11FH             ARREND	EQU	WRKSPC+0DAH	; End of arrays
     179/    2F06 : =0C121H             NXTDAT	EQU	WRKSPC+0DCH	; Next data item
     180/    2F06 : =0C123H             FNRGNM	EQU	WRKSPC+0DEH	; Name of FN argument
     181/    2F06 : =0C125H             FNARG	EQU	WRKSPC+0E0H	; FN argument value
     182/    2F06 : =0C129H             FPREG	EQU	WRKSPC+0E4H	; Floating point register
     183/    2F06 : =0C12CH             FPEXP	EQU	FPREG+3		; Floating point exponent
     184/    2F06 : =0C12DH             SGNRES	EQU	WRKSPC+0E8H	; Sign of result
     185/    2F06 : =0C12EH             PBUFF	EQU	WRKSPC+0E9H	; Number print buffer
     186/    2F06 : =0C13BH             MULVAL	EQU	WRKSPC+0F6H	; Multiplier
     187/    2F06 : =0C13EH             PROGST	EQU	WRKSPC+0F9H	; Start of program text area
     188/    2F06 : =0C1A2H             STLOOK	EQU	WRKSPC+15DH	; Start of memory test
     189/    2F06 :                     ;
     190/    2F06 :                     ; BASIC ERROR CODE VALUES
     191/    2F06 :                     ;
     192/    2F06 : =0H                 NF	EQU	00H		; NEXT without FOR
     193/    2F06 : =2H                 SN	EQU	02H		; Syntax error
     194/    2F06 : =4H                 RG	EQU	04H		; RETURN without GOSUB
     195/    2F06 : =6H                 OD	EQU	06H		; Out of DATA
     196/    2F06 : =8H                 FC	EQU	08H		; Function call error
     197/    2F06 : =0AH                OV	EQU	0AH		; Overflow
     198/    2F06 : =0CH                OM	EQU	0CH		; Out of memory
     199/    2F06 : =0EH                UL	EQU	0EH		; Undefined line number
     200/    2F06 : =10H                BS	EQU	10H		; Bad subscript
     201/    2F06 : =12H                RD	EQU	12H		; Re-DIMensioned array
     202/    2F06 : =14H                DZ	EQU	14H		; Division by zero (/0)
     203/    2F06 : =16H                ID	EQU	16H		; Illegal direct
     204/    2F06 : =18H                TM	EQU	18H		; Type miss-match
     205/    2F06 : =1AH                OS	EQU	1AH		; Out of string space
     206/    2F06 : =1CH                LS	EQU	1CH		; String too long
     207/    2F06 : =1EH                ST	EQU	1EH		; String formula too complex
     208/    2F06 : =20H                CN	EQU	20H		; Can't CONTinue
     209/    2F06 : =22H                UF	EQU	22H		; UnDEFined FN function
     210/    2F06 : =24H                MO	EQU	24H		; Missing operand
     211/    2F06 : =26H                HX	EQU	26H		; HEX error
     212/    2F06 : =28H                BN	EQU	28H		; BIN error
     213/    2F06 :                     ;
     214/    2F06 : C3 0D 2F            STARTB: JP	CSTART		; Jump to initialise
     215/    2F09 :                     ;
     216/    2F09 : AC 37               	DW	DEINT		; Get integer -32768 to 32767
     217/    2F0B : 22 3F               	DW	ABPASS		; Return integer in AB
     218/    2F0D :                     ;
     219/    2F0D : 21 45 C0            CSTART: LD	HL,WRKSPC	; Start of workspace RAM
     220/    2F10 : F9                  	LD	SP,HL		; Set up a temporary stack
     221/    2F11 : C3 37 4B            	JP	INITST		; Go to initialise
     222/    2F14 :                     ;
     223/    2F14 : 11 D5 31            INIT:	LD	DE,INITAB	; Initialise workspace
     224/    2F17 : 06 63               	LD	B,INITBE-INITAB+3; Bytes to copy
     225/    2F19 : 21 45 C0            	LD	HL,WRKSPC	; Into workspace RAM
     226/    2F1C : 1A                  COPY:	LD	A,(DE)		; Get source
     227/    2F1D : 77                  	LD	(HL),A		; To destination
     228/    2F1E : 23                  	INC	HL		; Next destination
     229/    2F1F : 13                  	INC	DE		; Next source
     230/    2F20 : 05                  	DEC	B		; Count bytes
     231/    2F21 : C2 1C 2F            	JP	NZ,COPY		; More to move
     232/    2F24 : F9                  	LD	SP,HL		; Temporary stack
     233/    2F25 : CD D6 33            	CALL	CLREG		; Clear registers and stack
     234/    2F28 : CD A2 39            	CALL	PRCRLF		; Output CRLF
     235/    2F2B : 32 EF C0            	LD	(BUFFER+72+1),A	; Mark end of buffer
     236/    2F2E : 32 3E C1            	LD	(PROGST),A	; Initialise program area
     237/    2F31 :                     ;MSIZE:	LD	HL,STLOOK	; Point to start of RAM
     238/    2F31 :                     ;MLOOP:	INC	HL		; Next byte
     239/    2F31 :                     ;	LD	A,H		; Above address FFFF ?
     240/    2F31 :                     ;	OR	L
     241/    2F31 :                     ;	JP	Z,SETTOP	; Yes - 64K RAM
     242/    2F31 :                     ;	LD	A,(HL)		; Get contents
     243/    2F31 :                     ;	LD	B,A		; Save it
     244/    2F31 :                     ;	CPL			; Flip all bits
     245/    2F31 :                     ;	LD	(HL),A		; Put it back
     246/    2F31 :                     ;	CP	(HL)		; RAM there if same
     247/    2F31 :                     ;	LD	(HL),B		; Restore old contents
     248/    2F31 :                     ;	JP	Z,MLOOP		; If RAM - test next byte
     249/    2F31 :                     ;
     250/    2F31 :                     ;SETTOP: DEC	HL		; Back one byte
     251/    2F31 : 21 C0 EE            	ld	hl,STACKU
     252/    2F34 : 11 A1 C1            	LD	DE,STLOOK-1	; See if enough RAM
     253/    2F37 : CD 6C 35            	CALL	CPDEHL		; Compare DE with HL
     254/    2F3A : DA 74 2F            	JP	C,NEMEM		; If not enough RAM
     255/    2F3D : 11 CE FF            	LD	DE,0-50		; 50 Bytes string space
     256/    2F40 : 22 F4 C0            	LD	(LSTRAM),HL	; Save last available RAM
     257/    2F43 : 19                  	ADD	HL,DE		; Allocate string space
     258/    2F44 : 22 9F C0            	LD	(STRSPC),HL	; Save string space
     259/    2F47 : CD B1 33            	CALL	CLRPTR		; Clear program area
     260/    2F4A : 2A 9F C0            	LD	HL,(STRSPC)	; Get end of memory
     261/    2F4D : 11 EF FF            	LD	DE,0-17		; Offset for free bytes
     262/    2F50 : 19                  	ADD	HL,DE		; Adjust HL
     263/    2F51 : 11 3E C1            	LD	DE,PROGST	; Start of program text
     264/    2F54 : 7D                  	LD	A,L		; Get LSB
     265/    2F55 : 93                  	SUB	E		; Adjust it
     266/    2F56 : 6F                  	LD	L,A		; Re-save
     267/    2F57 : 7C                  	LD	A,H		; Get MSB
     268/    2F58 : 9A                  	SBC	A,D		; Adjust it
     269/    2F59 : 67                  	LD	H,A		; Re-save
     270/    2F5A : E5                  	PUSH	HL		; Save bytes free
     271/    2F5B : 21 8C 2F            	LD	HL,SIGNON	; Sign-on message
     272/    2F5E : CD 40 40            	CALL	PRS		; Output string
     273/    2F61 : E1                  	POP	HL		; Get bytes free back
     274/    2F62 : CD E3 46            	CALL	PRNTHL		; Output amount of free memory
     275/    2F65 : 21 7D 2F            	LD	HL,BFREE	; " Bytes free" message
     276/    2F68 : CD 40 40            	CALL	PRS		; Output string
     277/    2F6B :                     ;
     278/    2F6B : 31 AB C0            WARMST: LD	SP,STACK	; Temporary stack
     279/    2F6E : CD D6 33            BRKRET: CALL	CLREG		; Clear registers and stack
     280/    2F71 : C3 EF 32            	JP	PRNTOK		; Go to get command line
     281/    2F74 :                     ;
     282/    2F74 : 21 C3 2F            NEMEM:	LD	HL,MEMMSG	; Memory size not enough
     283/    2F77 : CD 40 40            	CALL	PRS		; Print it
     284/    2F7A : C3 7A 2F            XXXXX:	JP	XXXXX		; Stop
     285/    2F7D :                     ;
     286/    2F7D : 20 42 79 74 65 73   BFREE:	DB	" Bytes free",CR,LF,0,0
             2F83 : 20 66 72 65 65 0D 
             2F89 : 0A 00 00          
     287/    2F8C :                     ;
     288/    2F8C : 5A 38 30 20 42 41   SIGNON: DB	"Z80 BASIC Ver 4.7b",CR,LF
             2F92 : 53 49 43 20 56 65 
             2F98 : 72 20 34 2E 37 62 
             2F9E : 0D 0A             
     289/    2FA0 : 43 6F 70 79 72 69   	DB	"Copyright ",40,"C",41
             2FA6 : 67 68 74 20 28 43 
             2FAC : 29                
     290/    2FAD : 20 31 39 37 38 20   	DB	" 1978 by Microsoft",CR,LF,0,0
             2FB3 : 62 79 20 4D 69 63 
             2FB9 : 72 6F 73 6F 66 74 
             2FBF : 0D 0A 00 00       
     291/    2FC3 :                     ;
     292/    2FC3 : 4D 65 6D 6F 72 79   MEMMSG: DB	"Memory size not enough",CR,LF
             2FC9 : 20 73 69 7A 65 20 
             2FCF : 6E 6F 74 20 65 6E 
             2FD5 : 6F 75 67 68 0D 0A 
     293/    2FDB : 54 68 65 20 73 79   	DB	"The system is stopped.",CR,LF,0,0
             2FE1 : 73 74 65 6D 20 69 
             2FE7 : 73 20 73 74 6F 70 
             2FED : 70 65 64 2E 0D 0A 
             2FF3 : 00 00             
     294/    2FF5 :                     ;
     295/    2FF5 :                     ; FUNCTION ADDRESS TABLE
     296/    2FF5 :                     ;
     297/    2FF5 : 58 45               FNCTAB: DW	SGN
     298/    2FF7 : 1C 46               	DW	INT
     299/    2FF9 : 6E 45               	DW	ABS
     300/    2FFB : 48 C0               	DW	USR
     301/    2FFD : 00 3F               	DW	FRE
     302/    2FFF : 85 42               	DW	INP
     303/    3001 : 2E 3F               	DW	POS
     304/    3003 : E2 47               	DW	SQR
     305/    3005 : C1 48               	DW	RND
     306/    3007 : FD 43               	DW	LOG
     307/    3009 : 30 48               	DW	EXP
     308/    300B : 36 49               	DW	COS
     309/    300D : 3C 49               	DW	SIN
     310/    300F : 9D 49               	DW	TAN
     311/    3011 : B2 49               	DW	ATN
     312/    3013 : D9 42               	DW	PEEK
     313/    3015 : 1C 4A               	DW	DEEK
     314/    3017 : 96 C0               	DW	POINT
     315/    3019 : B2 41               	DW	LEN
     316/    301B : CA 3F               	DW	STR
     317/    301D : 4C 42               	DW	VAL
     318/    301F : C1 41               	DW	ASC
     319/    3021 : D2 41               	DW	CHR
     320/    3023 : 3E 4A               	DW	HEX
     321/    3025 : D1 4A               	DW	BIN
     322/    3027 : E2 41               	DW	LEFT
     323/    3029 : 12 42               	DW	RIGHT
     324/    302B : 1C 42               	DW	MID
     325/    302D :                     ;
     326/    302D :                     ; RESERVED WORD LIST
     327/    302D :                     ;
     328/    302D : C5 4E 44            WORDS:	DB	0C5H,"ND"
     329/    3030 : C6 4F 52            	DB	0C6H,"OR"
     330/    3033 : CE 45 58 54         	DB	0CEH,"EXT"
     331/    3037 : C4 41 54 41         	DB	0C4H,"ATA"
     332/    303B : C9 4E 50 55 54      	DB	0C9H,"NPUT"
     333/    3040 : C4 49 4D            	DB	0C4H,"IM"
     334/    3043 : D2 45 41 44         	DB	0D2H,"EAD"
     335/    3047 : CC 45 54            	DB	0CCH,"ET"
     336/    304A : C7 4F 54 4F         	DB	0C7H,"OTO"
     337/    304E : D2 55 4E            	DB	0D2H,"UN"
     338/    3051 : C9 46               	DB	0C9H,"F"
     339/    3053 : D2 45 53 54 4F 52   	DB	0D2H,"ESTORE"
             3059 : 45                
     340/    305A : C7 4F 53 55 42      	DB	0C7H,"OSUB"
     341/    305F : D2 45 54 55 52 4E   	DB	0D2H,"ETURN"
     342/    3065 : D2 45 4D            	DB	0D2H,"EM"
     343/    3068 : D3 54 4F 50         	DB	0D3H,"TOP"
     344/    306C : CF 55 54            	DB	0CFH,"UT"
     345/    306F : CF 4E               	DB	0CFH,"N"
     346/    3071 : CE 55 4C 4C         	DB	0CEH,"ULL"
     347/    3075 : D7 41 49 54         	DB	0D7H,"AIT"
     348/    3079 : C4 45 46            	DB	0C4H,"EF"
     349/    307C : D0 4F 4B 45         	DB	0D0H,"OKE"
     350/    3080 : C4 4F 4B 45         	DB	0C4H,"OKE"
     351/    3084 : D3 43 52 45 45 4E   	DB	0D3H,"CREEN"
     352/    308A : CC 49 4E 45 53      	DB	0CCH,"INES"
     353/    308F : C3 4C 53            	DB	0C3H,"LS"
     354/    3092 : D7 49 44 54 48      	DB	0D7H,"IDTH"
     355/    3097 : CD 4F 4E 49 54 4F   	DB	0CDH,"ONITOR"
             309D : 52                
     356/    309E : D3 45 54            	DB	0D3H,"ET"
     357/    30A1 : D2 45 53 45 54      	DB	0D2H,"ESET"
     358/    30A6 : D0 52 49 4E 54      	DB	0D0H,"RINT"
     359/    30AB : C3 4F 4E 54         	DB	0C3H,"ONT"
     360/    30AF : CC 49 53 54         	DB	0CCH,"IST"
     361/    30B3 : C3 4C 45 41 52      	DB	0C3H,"LEAR"
     362/    30B8 : C3 4C 4F 41 44      	DB	0C3H,"LOAD"
     363/    30BD : C3 53 41 56 45      	DB	0C3H,"SAVE"
     364/    30C2 : CE 45 57            	DB	0CEH,"EW"
     365/    30C5 :                     ;
     366/    30C5 : D4 41 42 28         	DB	0D4H,"AB("
     367/    30C9 : D4 4F               	DB	0D4H,"O"
     368/    30CB : C6 4E               	DB	0C6H,"N"
     369/    30CD : D3 50 43 28         	DB	0D3H,"PC("
     370/    30D1 : D4 48 45 4E         	DB	0D4H,"HEN"
     371/    30D5 : CE 4F 54            	DB	0CEH,"OT"
     372/    30D8 : D3 54 45 50         	DB	0D3H,"TEP"
     373/    30DC :                     ;
     374/    30DC : AB                  	DB	0ABH
     375/    30DD : AD                  	DB	0ADH
     376/    30DE : AA                  	DB	0AAH
     377/    30DF : AF                  	DB	0AFH
     378/    30E0 : DE                  	DB	0DEH
     379/    30E1 : C1 4E 44            	DB	0C1H,"ND"
     380/    30E4 : CF 52               	DB	0CFH,"R"
     381/    30E6 : BE                  	DB	0BEH
     382/    30E7 : BD                  	DB	0BDH
     383/    30E8 : BC                  	DB	0BCH
     384/    30E9 :                     ;
     385/    30E9 : D3 47 4E            	DB	0D3H,"GN"
     386/    30EC : C9 4E 54            	DB	0C9H,"NT"
     387/    30EF : C1 42 53            	DB	0C1H,"BS"
     388/    30F2 : D5 53 52            	DB	0D5H,"SR"
     389/    30F5 : C6 52 45            	DB	0C6H,"RE"
     390/    30F8 : C9 4E 50            	DB	0C9H,"NP"
     391/    30FB : D0 4F 53            	DB	0D0H,"OS"
     392/    30FE : D3 51 52            	DB	0D3H,"QR"
     393/    3101 : D2 4E 44            	DB	0D2H,"ND"
     394/    3104 : CC 4F 47            	DB	0CCH,"OG"
     395/    3107 : C5 58 50            	DB	0C5H,"XP"
     396/    310A : C3 4F 53            	DB	0C3H,"OS"
     397/    310D : D3 49 4E            	DB	0D3H,"IN"
     398/    3110 : D4 41 4E            	DB	0D4H,"AN"
     399/    3113 : C1 54 4E            	DB	0C1H,"TN"
     400/    3116 : D0 45 45 4B         	DB	0D0H,"EEK"
     401/    311A : C4 45 45 4B         	DB	0C4H,"EEK"
     402/    311E : D0 4F 49 4E 54      	DB	0D0H,"OINT"
     403/    3123 : CC 45 4E            	DB	0CCH,"EN"
     404/    3126 : D3 54 52 24         	DB	0D3H,"TR$"
     405/    312A : D6 41 4C            	DB	0D6H,"AL"
     406/    312D : C1 53 43            	DB	0C1H,"SC"
     407/    3130 : C3 48 52 24         	DB	0C3H,"HR$"
     408/    3134 : C8 45 58 24         	DB	0C8H,"EX$"
     409/    3138 : C2 49 4E 24         	DB	0C2H,"IN$"
     410/    313C : CC 45 46 54 24      	DB	0CCH,"EFT$"
     411/    3141 : D2 49 47 48 54 24   	DB	0D2H,"IGHT$"
     412/    3147 : CD 49 44 24         	DB	0CDH,"ID$"
     413/    314B : 80                  	DB	80H		; End of list marker
     414/    314C :                     ;
     415/    314C :                     ; KEYWORD ADDRESS TABLE
     416/    314C :                     ;
     417/    314C : 44 37               WORDTB: DW	PEND
     418/    314E : 41 36               	DW	FOR
     419/    3150 : 1C 3B               	DW	NEXT
     420/    3152 : 91 38               	DW	DATA
     421/    3154 : 23 3A               	DW	INPUT
     422/    3156 : 58 3D               	DW	DIM
     423/    3158 : 52 3A               	DW	READ
     424/    315A : A8 38               	DW	LET
     425/    315C : 4E 38               	DW	GOTO
     426/    315E : 31 38               	DW	RUN
     427/    3160 : 20 39               	DW	IF_
     428/    3162 : 0A 37               	DW	RESTOR
     429/    3164 : 3D 38               	DW	GOSUB
     430/    3166 : 6C 38               	DW	RETURN
     431/    3168 : 93 38               	DW	REM
     432/    316A : 42 37               	DW	STOP
     433/    316C : 91 42               	DW	POUT
     434/    316E : 02 39               	DW	ON
     435/    3170 : 83 37               	DW	NULL
     436/    3172 : 97 42               	DW	WAIT
     437/    3174 : 36 3F               	DW	DEF
     438/    3176 : E0 42               	DW	POKE
     439/    3178 : 27 4A               	DW	DOKE
     440/    317A : 93 38               	DW	REM
     441/    317C : 0D 4A               	DW	LINES
     442/    317E : 01 4A               	DW	CLS
     443/    3180 : 05 4A               	DW	WIDTH
     444/    3182 : 33 4B               	DW	MONITR
     445/    3184 : 99 C0               	DW	PSET
     446/    3186 : 9C C0               	DW	RESET
     447/    3188 : 44 39               	DW	PRINT
     448/    318A : 70 37               	DW	CONT
     449/    318C : B6 35               	DW	LIST
     450/    318E : EB 37               	DW	CLEAR
     451/    3190 : 93 38               	DW	REM
     452/    3192 : 93 38               	DW	REM
     453/    3194 : B0 33               	DW	NEW
     454/    3196 :                     ;
     455/    3196 :                     ; RESERVED WORD TOKEN VALUES
     456/    3196 :                     ;
     457/    3196 : =80H                ZEND	EQU	080H		; END
     458/    3196 : =81H                ZFOR	EQU	081H		; FOR
     459/    3196 : =83H                ZDATA	EQU	083H		; DATA
     460/    3196 : =88H                ZGOTO	EQU	088H		; GOTO
     461/    3196 : =8CH                ZGOSUB	EQU	08CH		; GOSUB
     462/    3196 : =8EH                ZREM	EQU	08EH		; REM
     463/    3196 : =9EH                ZPRINT	EQU	09EH		; PRINT
     464/    3196 : =0A4H               ZNEW	EQU	0A4H		; NEW
     465/    3196 :                     ;
     466/    3196 : =0A5H               ZTAB	EQU	0A5H		; TAB
     467/    3196 : =0A6H               ZTO	EQU	0A6H		; TO
     468/    3196 : =0A7H               ZFN	EQU	0A7H		; FN
     469/    3196 : =0A8H               ZSPC	EQU	0A8H		; SPC
     470/    3196 : =0A9H               ZTHEN	EQU	0A9H		; THEN
     471/    3196 : =0AAH               ZNOT	EQU	0AAH		; NOT
     472/    3196 : =0ABH               ZSTEP	EQU	0ABH		; STEP
     473/    3196 :                     ;
     474/    3196 : =0ACH               ZPLUS	EQU	0ACH		; +
     475/    3196 : =0ADH               ZMINUS	EQU	0ADH		; -
     476/    3196 : =0AEH               ZTIMES	EQU	0AEH		; *
     477/    3196 : =0AFH               ZDIV	EQU	0AFH		; /
     478/    3196 : =0B2H               ZOR	EQU	0B2H		; OR
     479/    3196 : =0B3H               ZGTR	EQU	0B3H		; >
     480/    3196 : =0B4H               ZEQUAL	EQU	0B4H		; M
     481/    3196 : =0B5H               ZLTH	EQU	0B5H		; <
     482/    3196 : =0B6H               ZSGN	EQU	0B6H		; SGN
     483/    3196 : =0C7H               ZPOINT	EQU	0C7H		; POINT
     484/    3196 : =0CFH               ZLEFT	EQU	0CDH +2		; LEFT$
     485/    3196 :                     ;
     486/    3196 :                     ; ARITHMETIC PRECEDENCE TABLE
     487/    3196 :                     ;
     488/    3196 : 79                  PRITAB: DB	79H		; Precedence value
     489/    3197 : CA 46               	DW	PADD		; FPREG = <last> + FPREG
     490/    3199 :                     ;
     491/    3199 : 79                  	DB	79H		; Precedence value
     492/    319A : FE 42               	DW	PSUB		; FPREG = <last> - FPREG
     493/    319C :                     ;
     494/    319C : 7C                  	DB	7CH		; Precedence value
     495/    319D : 3C 44               	DW	MULT		; PPREG = <last> * FPREG
     496/    319F :                     ;
     497/    319F : 7C                  	DB	7CH		; Precedence value
     498/    31A0 : 9D 44               	DW	DIV		; FPREG = <last> / FPREG
     499/    31A2 :                     ;
     500/    31A2 : 7F                  	DB	7FH		; Precedence value
     501/    31A3 : EB 47               	DW	POWER		; FPREG = <last> ^ FPREG
     502/    31A5 :                     ;
     503/    31A5 : 50                  	DB	50H		; Precedence value
     504/    31A6 : B1 3C               	DW	PAND		; FPREG = <last> AND FPREG
     505/    31A8 :                     ;
     506/    31A8 : 46                  	DB	46H		; Precedence value
     507/    31A9 : B0 3C               	DW	POR		; FPREG = <last> OR FPREG
     508/    31AB :                     ;
     509/    31AB :                     ; BASIC ERROR CODE LIST
     510/    31AB :                     ;
     511/    31AB : 4E 46               ERRORS: DB	"NF"		; NEXT without FOR
     512/    31AD : 53 4E               	DB	"SN"		; Syntax error
     513/    31AF : 52 47               	DB	"RG"		; RETURN without GOSUB
     514/    31B1 : 4F 44               	DB	"OD"		; Out of DATA
     515/    31B3 : 46 43               	DB	"FC"		; Illegal function call
     516/    31B5 : 4F 56               	DB	"OV"		; Overflow error
     517/    31B7 : 4F 4D               	DB	"OM"		; Out of memory
     518/    31B9 : 55 4C               	DB	"UL"		; Undefined line
     519/    31BB : 42 53               	DB	"BS"		; Bad subscript
     520/    31BD : 44 44               	DB	"DD"		; Re-DIMensioned array
     521/    31BF : 2F 30               	DB	"/0"		; Division by zero
     522/    31C1 : 49 44               	DB	"ID"		; Illegal direct
     523/    31C3 : 54 4D               	DB	"TM"		; Type mis-match
     524/    31C5 : 4F 53               	DB	"OS"		; Out of string space
     525/    31C7 : 4C 53               	DB	"LS"		; String too long
     526/    31C9 : 53 54               	DB	"ST"		; String formula too complex
     527/    31CB : 43 4E               	DB	"CN"		; Can't CONTinue
     528/    31CD : 55 46               	DB	"UF"		; Undefined FN function
     529/    31CF : 4D 4F               	DB	"MO"		; Missing operand
     530/    31D1 : 48 58               	DB	"HX"		; HEX error
     531/    31D3 : 42 4E               	DB	"BN"		; BIN error
     532/    31D5 :                     ;
     533/    31D5 :                     ; INITIALISATION TABLE -------------------------------------------------------
     534/    31D5 :                     ;
     535/    31D5 : C3 6B 2F            INITAB: JP	WARMST		; Warm start jump
     536/    31D8 : C3 C1 37            	JP	FCERR		; "USR (X)" jump (Set to Error)
     537/    31DB : D3 00               	OUT	(0),A		; "OUT p,n" skeleton
     538/    31DD : C9                  	RET
     539/    31DE : D6 00               	SUB	0		; Division support routine
     540/    31E0 : 6F                  	LD	L,A
     541/    31E1 : 7C                  	LD	A,H
     542/    31E2 : DE 00               	SBC	A,0
     543/    31E4 : 67                  	LD	H,A
     544/    31E5 : 78                  	LD	A,B
     545/    31E6 : DE 00               	SBC	A,0
     546/    31E8 : 47                  	LD	B,A
     547/    31E9 : 3E 00               	LD	A,0
     548/    31EB : C9                  	RET
     549/    31EC : 00 00 00            	DB	0,0,0			; Random number seed table used by RND
     550/    31EF : 35 4A CA 99         	DB	035H,04AH,0CAH,099H	;-2.65145E+07
     551/    31F3 : 39 1C 76 98         	DB	039H,01CH,076H,098H	; 1.61291E+07
     552/    31F7 : 22 95 B3 98         	DB	022H,095H,0B3H,098H	;-1.17691E+07
     553/    31FB : 0A DD 47 98         	DB	00AH,0DDH,047H,098H	; 1.30983E+07
     554/    31FF : 53 D1 99 99         	DB	053H,0D1H,099H,099H	;-2-01612E+07
     555/    3203 : 0A 1A 9F 98         	DB	00AH,01AH,09FH,098H	;-1.04269E+07
     556/    3207 : 65 BC CD 98         	DB	065H,0BCH,0CDH,098H	;-1.34831E+07
     557/    320B : D6 77 3E 98         	DB	0D6H,077H,03EH,098H	; 1.24825E+07
     558/    320F : 52 C7 4F 80         	DB	052H,0C7H,04FH,080H	; Last random number
     559/    3213 : DB 00               	IN	A,(0)		; INP (x) skeleton
     560/    3215 : C9                  	RET
     561/    3216 : 01                  	DB	1		; POS (x) number (1)
     562/    3217 : FF                  	DB	255		; Terminal width (255 = no auto CRLF)
     563/    3218 : 1C                  	DB	28		; Width for commas (3 columns)
     564/    3219 : 00                  	DB	0		; No nulls after input bytes
     565/    321A : 00                  	DB	0		; Output enabled (^O off)
     566/    321B : 14 00               	DW	20		; Initial lines counter
     567/    321D : 14 00               	DW	20		; Initial lines number
     568/    321F : 00 00               	DW	0		; Array load/save check sum
     569/    3221 : 00                  	DB	0		; Break not by NMI
     570/    3222 : 00                  	DB	0		; Break flag
     571/    3223 : C3 E9 34            	JP	TTYLIN		; Input reflection (set to TTY)
     572/    3226 : C3 00 00            	JP	0000H		; POINT reflection unused
     573/    3229 : C3 00 00            	JP	0000H		; SET reflection
     574/    322C : C3 00 00            	JP	0000H			; RESET reflection
     575/    322F : A2 C1               	DW	STLOOK		; Temp string space
     576/    3231 : FE FF               	DW	-2		; Current line number (cold)
     577/    3233 : 3F C1               	DW	PROGST+1	; Start of program text
     578/    3235 :                     INITBE:			 
     579/    3235 :                     ;
     580/    3235 :                     ; END OF INITIALISATION TABLE ---------------------------------------------------
     581/    3235 :                     ;
     582/    3235 : 20 45 72 72 6F 72   ERRMSG: DB	" Error",0
             323B : 00                
     583/    323C : 20 69 6E 20 00      INMSG:	DB	" in ",0
     584/    3241 : =3240H              ZERBYT	EQU	$-1		; A zero byte
     585/    3241 : 4F 6B 0D 0A 00 00   OKMSG:	DB	"Ok",CR,LF,0,0
     586/    3247 : 42 72 65 61 6B 00   BRKMSG: DB	"Break",0
     587/    324D :                     ;
     588/    324D : 21 04 00            BAKSTK: LD	HL,4		; Look for "FOR" block with
     589/    3250 : 39                  	ADD	HL,SP		; same index as specified
     590/    3251 : 7E                  LOKFOR: LD	A,(HL)		; Get block ID
     591/    3252 : 23                  	INC	HL		; Point to index address
     592/    3253 : FE 81               	CP	ZFOR		; Is it a "FOR" token
     593/    3255 : C0                  	RET	NZ		; No - exit
     594/    3256 : 4E                  	LD	C,(HL)		; BC = Address of "FOR" index
     595/    3257 : 23                  	INC	HL
     596/    3258 : 46                  	LD	B,(HL)
     597/    3259 : 23                  	INC	HL		; Point to sign of STEP
     598/    325A : E5                  	PUSH	HL		; Save pointer to sign
     599/    325B : 69                  	LD	L,C		; HL = address of "FOR" index
     600/    325C : 60                  	LD	H,B
     601/    325D : 7A                  	LD	A,D		; See if an index was specified
     602/    325E : B3                  	OR	E		; DE = 0 if no index specified
     603/    325F : EB                  	EX	DE,HL		; Specified index into HL
     604/    3260 : CA 67 32            	JP	Z,INDFND	; Skip if no index given
     605/    3263 : EB                  	EX	DE,HL		; Index back into DE
     606/    3264 : CD 6C 35            	CALL	CPDEHL		; Compare index with one given
     607/    3267 : 01 0D 00            INDFND: LD	BC,16-3		; Offset to next block
     608/    326A : E1                  	POP	HL		; Restore pointer to sign
     609/    326B : C8                  	RET	Z		; Return if block found
     610/    326C : 09                  	ADD	HL,BC		; Point to next block
     611/    326D : C3 51 32            	JP	LOKFOR		; Keep on looking
     612/    3270 :                     ;
     613/    3270 : CD 8A 32            MOVUP:	CALL	ENFMEM		; See if enough memory
     614/    3273 : C5                  MOVSTR: PUSH	BC		; Save end of source
     615/    3274 : E3                  	EX	(SP),HL		; Swap source and dest" end
     616/    3275 : C1                  	POP	BC		; Get end of destination
     617/    3276 : CD 6C 35            MOVLP:	CALL	CPDEHL		; See if list moved
     618/    3279 : 7E                  	LD	A,(HL)		; Get byte
     619/    327A : 02                  	LD	(BC),A		; Move it
     620/    327B : C8                  	RET	Z		; Exit if all done
     621/    327C : 0B                  	DEC	BC		; Next byte to move to
     622/    327D : 2B                  	DEC	HL		; Next byte to move
     623/    327E : C3 76 32            	JP	MOVLP		; Loop until all bytes moved
     624/    3281 :                     ;
     625/    3281 : E5                  CHKSTK: PUSH	HL		; Save code string address
     626/    3282 : 2A 1F C1            	LD	HL,(ARREND)	; Lowest free memory
     627/    3285 : 06 00               	LD	B,0		; BC = Number of levels to test
     628/    3287 : 09                  	ADD	HL,BC		; 2 Bytes for each level
     629/    3288 : 09                  	ADD	HL,BC
     630/    3289 : 3E                  	DB	3EH		; Skip "PUSH HL"
     631/    328A : E5                  ENFMEM: PUSH	HL		; Save code string address
     632/    328B : 3E D0               	LD	A,0D0H		; LOW -48; 48 Bytes minimum RAM
     633/    328D : 95                  	SUB	L
     634/    328E : 6F                  	LD	L,A
     635/    328F : 3E FF               	LD	A,0FFH		; HIGH (-48); 48 Bytes minimum RAM
     636/    3291 : 9C                  	SBC	A,H
     637/    3292 : DA 99 32            	JP	C,OMERR		; Not enough - ?OM Error
     638/    3295 : 67                  	LD	H,A
     639/    3296 : 39                  	ADD	HL,SP		; Test if stack is overflowed
     640/    3297 : E1                  	POP	HL		; Restore code string address
     641/    3298 : D8                  	RET	C		; Return if enough mmory
     642/    3299 : 1E 0C               OMERR:	LD	E,OM		; ?OM Error
     643/    329B : C3 B8 32            	JP	ERROR_
     644/    329E :                     ;
     645/    329E : 2A 0E C1            DATSNR: LD	HL,(DATLIN)	; Get line of current DATA item
     646/    32A1 : 22 A1 C0            	LD	(LINEAT),HL	; Save as current line
     647/    32A4 : 1E 02               SNERR:	LD	E,SN		; ?SN Error
     648/    32A6 : 01                  	DB	01H		; Skip "LD E,DZ"
     649/    32A7 : 1E 14               DZERR:	LD	E,DZ		; ?/0 Error
     650/    32A9 : 01                  	DB	01H		; Skip "LD E,NF"
     651/    32AA : 1E 00               NFERR:	LD	E,NF		; ?NF Error
     652/    32AC : 01                  	DB	01H		; Skip "LD E,RD"
     653/    32AD : 1E 12               DDERR:	LD	E,RD		; ?DD Error
     654/    32AF : 01                  	DB	01H		; Skip "LD E,UF"
     655/    32B0 : 1E 22               UFERR:	LD	E,UF		; ?UF Error
     656/    32B2 : 01                  	DB	01H		; Skip "LD E,OV
     657/    32B3 : 1E 0A               OVERR:	LD	E,OV		; ?OV Error
     658/    32B5 : 01                  	DB	01H		; Skip "LD E,TM"
     659/    32B6 : 1E 18               TMERR:	LD	E,TM		; ?TM Error
     660/    32B8 :                     ;
     661/    32B8 : CD D6 33            ERROR_:	CALL	CLREG		; Clear registers and stack
     662/    32BB : 32 8A C0            	LD	(CTLOFG),A	; Enable output (A is 0)
     663/    32BE : CD 95 39            	CALL	STTLIN		; Start new line
     664/    32C1 : 21 AB 31            	LD	HL,ERRORS	; Point to error codes
     665/    32C4 : 57                  	LD	D,A		; D = 0 (A is 0)
     666/    32C5 : 3E 3F               	LD	A,'?'
     667/    32C7 : CD 7D 35            	CALL	OUTC		; Output '?'
     668/    32CA : 19                  	ADD	HL,DE		; Offset to correct error code
     669/    32CB : 7E                  	LD	A,(HL)		; First character
     670/    32CC : CD 7D 35            	CALL	OUTC		; Output it
     671/    32CF : CD FA 36            	CALL	GETCHR		; Get next character
     672/    32D2 : CD 7D 35            	CALL	OUTC		; Output it
     673/    32D5 : 21 35 32            	LD	HL,ERRMSG	; "Error" message
     674/    32D8 : CD 40 40            ERRIN:	CALL	PRS		; Output message
     675/    32DB : 2A A1 C0            	LD	HL,(LINEAT)	; Get line of error
     676/    32DE : 11 FE FF            	LD	DE,-2		; Cold start error if -2
     677/    32E1 : CD 6C 35            	CALL	CPDEHL		; See if cold start error
     678/    32E4 : CA 0D 2F            	JP	Z,CSTART	; Cold start error - Restart
     679/    32E7 : 7C                  	LD	A,H		; Was it a direct error?
     680/    32E8 : A5                  	AND	L		; Line = -1 if direct error
     681/    32E9 : 3C                  	INC	A
     682/    32EA : C4 DB 46            	CALL	NZ,LINEIN	; No - output line of error
     683/    32ED : 3E                  	DB	3EH		; Skip "POP BC"
     684/    32EE : C1                  POPNOK: POP	BC		; Drop address in input buffer
     685/    32EF :                     ;
     686/    32EF : AF                  PRNTOK: XOR	A		; Output "Ok" and get command
     687/    32F0 : 32 8A C0            	LD	(CTLOFG),A	; Enable output
     688/    32F3 : CD 95 39            	CALL	STTLIN		; Start new line
     689/    32F6 : 21 41 32            	LD	HL,OKMSG	; "Ok" message
     690/    32F9 : CD 40 40            	CALL	PRS		; Output "Ok"
     691/    32FC : 21 FF FF            GETCMD: LD	HL,-1		; Flag direct mode
     692/    32FF : 22 A1 C0            	LD	(LINEAT),HL	; Save as current line
     693/    3302 : CD E9 34            	CALL	GETLIN		; Get an input line
     694/    3305 : DA FC 32            	JP	C,GETCMD	; Get line again if break
     695/    3308 : CD FA 36            	CALL	GETCHR		; Get first character
     696/    330B : 3C                  	INC	A		; Test if end of line
     697/    330C : 3D                  	DEC	A		; Without affecting Carry
     698/    330D : CA FC 32            	JP	Z,GETCMD	; Nothing entered - Get another
     699/    3310 : F5                  	PUSH	AF		; Save Carry status
     700/    3311 : CD C6 37            	CALL	ATOH		; Get line number into DE
     701/    3314 : D5                  	PUSH	DE		; Save line number
     702/    3315 : CD 00 34            	CALL	CRUNCH		; Tokenise rest of line
     703/    3318 : 47                  	LD	B,A		; Length of tokenised line
     704/    3319 : D1                  	POP	DE		; Restore line number
     705/    331A : F1                  	POP	AF		; Restore Carry
     706/    331B : D2 DA 36            	JP	NC,EXCUTE	; No line number - Direct mode
     707/    331E : D5                  	PUSH	DE		; Save line number
     708/    331F : C5                  	PUSH	BC		; Save length of tokenised line
     709/    3320 : AF                  	XOR	A
     710/    3321 : 32 11 C1            	LD	(LSTBIN),A	; Clear last byte input
     711/    3324 : CD FA 36            	CALL	GETCHR		; Get next character
     712/    3327 : B7                  	OR	A		; Set flags
     713/    3328 : F5                  	PUSH	AF		; And save them
     714/    3329 : CD 90 33            	CALL	SRCHLN		; Search for line number in DE
     715/    332C : DA 35 33            	JP	C,LINFND	; Jump if line found
     716/    332F : F1                  	POP	AF		; Get status
     717/    3330 : F5                  	PUSH	AF		; And re-save
     718/    3331 : CA 67 38            	JP	Z,ULERR	; Nothing after number - Error
     719/    3334 : B7                  	OR	A		; Clear Carry
     720/    3335 : C5                  LINFND: PUSH	BC		; Save address of line in prog
     721/    3336 : D2 4C 33            	JP	NC,INEWLN	; Line not found - Insert new
     722/    3339 : EB                  	EX	DE,HL		; Next line address in DE
     723/    333A : 2A 1B C1            	LD	HL,(PROGND)	; End of program
     724/    333D : 1A                  SFTPRG: LD	A,(DE)		; Shift rest of program down
     725/    333E : 02                  	LD	(BC),A
     726/    333F : 03                  	INC	BC		; Next destination
     727/    3340 : 13                  	INC	DE		; Next source
     728/    3341 : CD 6C 35            	CALL	CPDEHL		; All done?
     729/    3344 : C2 3D 33            	JP	NZ,SFTPRG	; More to do
     730/    3347 : 60                  	LD	H,B		; HL - New end of program
     731/    3348 : 69                  	LD	L,C
     732/    3349 : 22 1B C1            	LD	(PROGND),HL	; Update end of program
     733/    334C :                     ;
     734/    334C : D1                  INEWLN: POP	DE		; Get address of line,
     735/    334D : F1                  	POP	AF		; Get status
     736/    334E : CA 73 33            	JP	Z,SETPTR	; No text - Set up pointers
     737/    3351 : 2A 1B C1            	LD	HL,(PROGND)	; Get end of program
     738/    3354 : E3                  	EX	(SP),HL		; Get length of input line
     739/    3355 : C1                  	POP	BC		; End of program to BC
     740/    3356 : 09                  	ADD	HL,BC		; Find new end
     741/    3357 : E5                  	PUSH	HL		; Save new end
     742/    3358 : CD 70 32            	CALL	MOVUP		; Make space for line
     743/    335B : E1                  	POP	HL		; Restore new end
     744/    335C : 22 1B C1            	LD	(PROGND),HL	; Update end of program pointer
     745/    335F : EB                  	EX	DE,HL		; Get line to move up in HL
     746/    3360 : 74                  	LD	(HL),H		; Save MSB
     747/    3361 : D1                  	POP	DE		; Get new line number
     748/    3362 : 23                  	INC	HL		; Skip pointer
     749/    3363 : 23                  	INC	HL
     750/    3364 : 73                  	LD	(HL),E		; Save LSB of line number
     751/    3365 : 23                  	INC	HL
     752/    3366 : 72                  	LD	(HL),D		; Save MSB of line number
     753/    3367 : 23                  	INC	HL		; To first byte in line
     754/    3368 : 11 A6 C0            	LD	DE,BUFFER	; Copy buffer to program
     755/    336B : 1A                  MOVBUF: LD	A,(DE)		; Get source
     756/    336C : 77                  	LD	(HL),A		; Save destinations
     757/    336D : 23                  	INC	HL		; Next source
     758/    336E : 13                  	INC	DE		; Next destination
     759/    336F : B7                  	OR	A		; Done?
     760/    3370 : C2 6B 33            	JP	NZ,MOVBUF	; No - Repeat
     761/    3373 : CD BC 33            SETPTR: CALL	RUNFST		; Set line pointers
     762/    3376 : 23                  	INC	HL		; To LSB of pointer
     763/    3377 : EB                  	EX	DE,HL		; Address to DE
     764/    3378 : 62                  PTRLP:	LD	H,D		; Address to HL
     765/    3379 : 6B                  	LD	L,E
     766/    337A : 7E                  	LD	A,(HL)		; Get LSB of pointer
     767/    337B : 23                  	INC	HL		; To MSB of pointer
     768/    337C : B6                  	OR	(HL)		; Compare with MSB pointer
     769/    337D : CA FC 32            	JP	Z,GETCMD	; Get command line if end
     770/    3380 : 23                  	INC	HL		; To LSB of line number
     771/    3381 : 23                  	INC	HL		; Skip line number
     772/    3382 : 23                  	INC	HL		; Point to first byte in line
     773/    3383 : AF                  	XOR	A		; Looking for 00 byte
     774/    3384 : BE                  FNDEND: CP	(HL)		; Found end of line?
     775/    3385 : 23                  	INC	HL		; Move to next byte
     776/    3386 : C2 84 33            	JP	NZ,FNDEND	; No - Keep looking
     777/    3389 : EB                  	EX	DE,HL		; Next line address to HL
     778/    338A : 73                  	LD	(HL),E		; Save LSB of pointer
     779/    338B : 23                  	INC	HL
     780/    338C : 72                  	LD	(HL),D		; Save MSB of pointer
     781/    338D : C3 78 33            	JP	PTRLP		; Do next line
     782/    3390 :                     ;
     783/    3390 : 2A A3 C0            SRCHLN: LD	HL,(BASTXT)	; Start of program text
     784/    3393 : 44                  SRCHLP: LD	B,H		; BC = Address to look at
     785/    3394 : 4D                  	LD	C,L
     786/    3395 : 7E                  	LD	A,(HL)		; Get address of next line
     787/    3396 : 23                  	INC	HL
     788/    3397 : B6                  	OR	(HL)		; End of program found?
     789/    3398 : 2B                  	DEC	HL
     790/    3399 : C8                  	RET	Z		; Yes - Line not found
     791/    339A : 23                  	INC	HL
     792/    339B : 23                  	INC	HL
     793/    339C : 7E                  	LD	A,(HL)		; Get LSB of line number
     794/    339D : 23                  	INC	HL
     795/    339E : 66                  	LD	H,(HL)		; Get MSB of line number
     796/    339F : 6F                  	LD	L,A
     797/    33A0 : CD 6C 35            	CALL	CPDEHL		; Compare with line in DE
     798/    33A3 : 60                  	LD	H,B		; HL = Start of this line
     799/    33A4 : 69                  	LD	L,C
     800/    33A5 : 7E                  	LD	A,(HL)		; Get LSB of next line address
     801/    33A6 : 23                  	INC	HL
     802/    33A7 : 66                  	LD	H,(HL)		; Get MSB of next line address
     803/    33A8 : 6F                  	LD	L,A		; Next line to HL
     804/    33A9 : 3F                  	CCF
     805/    33AA : C8                  	RET	Z		; Lines found - Exit
     806/    33AB : 3F                  	CCF
     807/    33AC : D0                  	RET	NC		; Line not found,at line after
     808/    33AD : C3 93 33            	JP	SRCHLP		; Keep looking
     809/    33B0 :                     ;
     810/    33B0 : C0                  NEW:	RET	NZ		; Return if any more on line
     811/    33B1 : 2A A3 C0            CLRPTR: LD	HL,(BASTXT)	; Point to start of program
     812/    33B4 : AF                  	XOR	A		; Set program area to empty
     813/    33B5 : 77                  	LD	(HL),A		; Save LSB = 00
     814/    33B6 : 23                  	INC	HL
     815/    33B7 : 77                  	LD	(HL),A		; Save MSB = 00
     816/    33B8 : 23                  	INC	HL
     817/    33B9 : 22 1B C1            	LD	(PROGND),HL	; Set program end
     818/    33BC :                     ;
     819/    33BC : 2A A3 C0            RUNFST: LD	HL,(BASTXT)	; Clear all variables
     820/    33BF : 2B                  	DEC	HL
     821/    33C0 :                     ;
     822/    33C0 : 22 13 C1            INTVAR: LD	(BRKLIN),HL	; Initialise RUN variables
     823/    33C3 : 2A F4 C0            	LD	HL,(LSTRAM)	; Get end of RAM
     824/    33C6 : 22 08 C1            	LD	(STRBOT),HL	; Clear string space
     825/    33C9 : AF                  	XOR	A
     826/    33CA : CD 0A 37            	CALL	RESTOR		; Reset DATA pointers
     827/    33CD : 2A 1B C1            	LD	HL,(PROGND)	; Get end of program
     828/    33D0 : 22 1D C1            	LD	(VAREND),HL	; Clear variables
     829/    33D3 : 22 1F C1            	LD	(ARREND),HL	; Clear arrays
     830/    33D6 :                     ;
     831/    33D6 : C1                  CLREG:	POP	BC		; Save return address
     832/    33D7 : 2A 9F C0            	LD	HL,(STRSPC)	; Get end of working RAN
     833/    33DA : F9                  	LD	SP,HL		; Set stack
     834/    33DB : 21 F8 C0            	LD	HL,TMSTPL	; Temporary string pool
     835/    33DE : 22 F6 C0            	LD	(TMSTPT),HL	; Reset temporary string ptr
     836/    33E1 : AF                  	XOR	A		; A = 00
     837/    33E2 : 6F                  	LD	L,A		; HL = 0000
     838/    33E3 : 67                  	LD	H,A
     839/    33E4 : 22 19 C1            	LD	(CONTAD),HL	; No CONTinue
     840/    33E7 : 32 10 C1            	LD	(FORFLG),A	; Clear FOR flag
     841/    33EA : 22 23 C1            	LD	(FNRGNM),HL	; Clear FN argument
     842/    33ED : E5                  	PUSH	HL		; HL = 0000
     843/    33EE : C5                  	PUSH	BC		; Put back return
     844/    33EF : 2A 13 C1            DOAGN:	LD	HL,(BRKLIN)	; Get address of code to RUN
     845/    33F2 : C9                  	RET			; Return to execution driver
     846/    33F3 :                     ;
     847/    33F3 : 3E 3F               PROMPT: LD	A,'?'		; '?'
     848/    33F5 : CD 7D 35            	CALL	OUTC		; Output character
     849/    33F8 : 3E 20               	LD	A,' '		; Space
     850/    33FA : CD 7D 35            	CALL	OUTC		; Output character
     851/    33FD : C3 93 C0            	JP	RINPUT		; Get input line
     852/    3400 :                     ;
     853/    3400 : AF                  CRUNCH: XOR	A		; Tokenise line @ HL to BUFFER
     854/    3401 : 32 F3 C0            	LD	(DATFLG),A	; Reset literal flag
     855/    3404 : 0E 05               	LD	C,2+3		; 2 byte number and 3 nulls
     856/    3406 : 11 A6 C0            	LD	DE,BUFFER	; Start of input buffer
     857/    3409 : 7E                  CRNCLP: LD	A,(HL)		; Get byte
     858/    340A : FE 20               	CP	' '		; Is it a space?
     859/    340C : CA 88 34            	JP	Z,MOVDIR	; Yes - Copy direct
     860/    340F : 47                  	LD	B,A		; Save character
     861/    3410 : FE 22               	CP	'"'		; Is it a quote?
     862/    3412 : CA A8 34            	JP	Z,CPYLIT	; Yes - Copy literal string
     863/    3415 : B7                  	OR	A		; Is it end of buffer?
     864/    3416 : CA AF 34            	JP	Z,ENDBUF	; Yes - End buffer
     865/    3419 : 3A F3 C0            	LD	A,(DATFLG)	; Get data type
     866/    341C : B7                  	OR	A		; Literal?
     867/    341D : 7E                  	LD	A,(HL)		; Get byte to copy
     868/    341E : C2 88 34            	JP	NZ,MOVDIR	; Literal - Copy direct
     869/    3421 : FE 3F               	CP	'?'		; Is it '?' short for PRINT
     870/    3423 : 3E 9E               	LD	A,ZPRINT	; "PRINT" token
     871/    3425 : CA 88 34            	JP	Z,MOVDIR	; Yes - replace it
     872/    3428 : 7E                  	LD	A,(HL)		; Get byte again
     873/    3429 : FE 30               	CP	'0'		; Is it less than '0'
     874/    342B : DA 33 34            	JP	C,FNDWRD	; Yes - Look for reserved words
     875/    342E : FE 3C               	CP	60		; ";"+1; Is it "0123456789:;" ?
     876/    3430 : DA 88 34            	JP	C,MOVDIR	; Yes - copy it direct
     877/    3433 : D5                  FNDWRD: PUSH	DE		; Look for reserved words
     878/    3434 : 11 2C 30            	LD	DE,WORDS-1	; Point to table
     879/    3437 : C5                  	PUSH	BC		; Save count
     880/    3438 : 01 84 34            	LD	BC,RETNAD	; Where to return to
     881/    343B : C5                  	PUSH	BC		; Save return address
     882/    343C : 06 7F               	LD	B,ZEND-1	; First token value -1
     883/    343E : 7E                  	LD	A,(HL)		; Get byte
     884/    343F : FE 61               	CP	'a'		; Less than 'a' ?
     885/    3441 : DA 4C 34            	JP	C,SEARCH	; Yes - search for words
     886/    3444 : FE 7B               	CP	'z'+1		; Greater than 'z' ?
     887/    3446 : D2 4C 34            	JP	NC,SEARCH	; Yes - search for words
     888/    3449 : E6 5F               	AND	01011111B	; Force upper case
     889/    344B : 77                  	LD	(HL),A		; Replace byte
     890/    344C : 4E                  SEARCH: LD	C,(HL)		; Search for a word
     891/    344D : EB                  	EX	DE,HL
     892/    344E : 23                  GETNXT: INC	HL		; Get next reserved word
     893/    344F : B6                  	OR	(HL)		; Start of word?
     894/    3450 : F2 4E 34            	JP	P,GETNXT	; No - move on
     895/    3453 : 04                  	INC	B		; Increment token value
     896/    3454 : 7E                  	LD	A, (HL)		; Get byte from table
     897/    3455 : E6 7F               	AND	01111111B	; Strip bit 7
     898/    3457 : C8                  	RET	Z		; Return if end of list
     899/    3458 : B9                  	CP	C		; Same character as in buffer?
     900/    3459 : C2 4E 34            	JP	NZ,GETNXT	; No - get next word
     901/    345C : EB                  	EX	DE,HL
     902/    345D : E5                  	PUSH	HL		; Save start of word
     903/    345E :                     ;
     904/    345E : 13                  NXTBYT: INC	DE		; Look through rest of word
     905/    345F : 1A                  	LD	A,(DE)		; Get byte from table
     906/    3460 : B7                  	OR	A		; End of word ?
     907/    3461 : FA 80 34            	JP	M,MATCH		; Yes - Match found
     908/    3464 : 4F                  	LD	C,A		; Save it
     909/    3465 : 78                  	LD	A,B		; Get token value
     910/    3466 : FE 88               	CP	ZGOTO		; Is it "GOTO" token ?
     911/    3468 : C2 6F 34            	JP	NZ,NOSPC	; No - Don't allow spaces
     912/    346B : CD FA 36            	CALL	GETCHR		; Get next character
     913/    346E : 2B                  	DEC	HL		; Cancel increment from GETCHR
     914/    346F : 23                  NOSPC:	INC	HL		; Next byte
     915/    3470 : 7E                  	LD	A,(HL)		; Get byte
     916/    3471 : FE 61               	CP	'a'		; Less than 'a' ?
     917/    3473 : DA 78 34            	JP	C,NOCHNG	; Yes - don't change
     918/    3476 : E6 5F               	AND	01011111B	; Make upper case
     919/    3478 : B9                  NOCHNG: CP	C		; Same as in buffer ?
     920/    3479 : CA 5E 34            	JP	Z,NXTBYT	; Yes - keep testing
     921/    347C : E1                  	POP	HL		; Get back start of word
     922/    347D : C3 4C 34            	JP	SEARCH		; Look at next word
     923/    3480 :                     ;
     924/    3480 : 48                  MATCH:	LD	C,B		; Word found - Save token value
     925/    3481 : F1                  	POP	AF		; Throw away return
     926/    3482 : EB                  	EX	DE,HL
     927/    3483 : C9                  	RET			; Return to "RETNAD"
     928/    3484 : EB                  RETNAD: EX	DE,HL		; Get address in string
     929/    3485 : 79                  	LD	A,C		; Get token value
     930/    3486 : C1                  	POP	BC		; Restore buffer length
     931/    3487 : D1                  	POP	DE		; Get destination address
     932/    3488 : 23                  MOVDIR: INC	HL		; Next source in buffer
     933/    3489 : 12                  	LD	(DE),A		; Put byte in buffer
     934/    348A : 13                  	INC	DE		; Move up buffer
     935/    348B : 0C                  	INC	C		; Increment length of buffer
     936/    348C : D6 3A               	SUB	':'		; End of statement?
     937/    348E : CA 96 34            	JP	Z,SETLIT	; Jump if multi-statement line
     938/    3491 : FE 49               	CP	ZDATA-3AH	; Is it DATA statement ?
     939/    3493 : C2 99 34            	JP	NZ,TSTREM	; No - see if REM
     940/    3496 : 32 F3 C0            SETLIT: LD	(DATFLG),A	; Set literal flag
     941/    3499 : D6 54               TSTREM: SUB	ZREM-3AH	; Is it REM?
     942/    349B : C2 09 34            	JP	NZ,CRNCLP	; No - Leave flag
     943/    349E : 47                  	LD	B,A		; Copy rest of buffer
     944/    349F : 7E                  NXTCHR: LD	A,(HL)		; Get byte
     945/    34A0 : B7                  	OR	A		; End of line ?
     946/    34A1 : CA AF 34            	JP	Z,ENDBUF	; Yes - Terminate buffer
     947/    34A4 : B8                  	CP	B		; End of statement ?
     948/    34A5 : CA 88 34            	JP	Z,MOVDIR	; Yes - Get next one
     949/    34A8 : 23                  CPYLIT: INC	HL		; Move up source string
     950/    34A9 : 12                  	LD	(DE),A		; Save in destination
     951/    34AA : 0C                  	INC	C		; Increment length
     952/    34AB : 13                  	INC	DE		; Move up destination
     953/    34AC : C3 9F 34            	JP	NXTCHR		; Repeat
     954/    34AF :                     ;
     955/    34AF : 21 A5 C0            ENDBUF: LD	HL,BUFFER-1	; Point to start of buffer
     956/    34B2 : 12                  	LD	(DE),A		; Mark end of buffer (A = 00)
     957/    34B3 : 13                  	INC	DE
     958/    34B4 : 12                  	LD	(DE),A		; A = 00
     959/    34B5 : 13                  	INC	DE
     960/    34B6 : 12                  	LD	(DE),A		; A = 00
     961/    34B7 : C9                  	RET
     962/    34B8 :                     ;
     963/    34B8 : 3A 89 C0            DODEL:	LD	A,(NULFLG)	; Get null flag status
     964/    34BB : B7                  	OR	A		; Is it zero?
     965/    34BC : 3E 00               	LD	A,0		; Zero A - Leave flags
     966/    34BE : 32 89 C0            	LD	(NULFLG),A	; Zero null flag
     967/    34C1 : C2 CC 34            	JP	NZ,ECHDEL	; Set - Echo it
     968/    34C4 : 05                  	DEC	B		; Decrement length
     969/    34C5 : CA E9 34            	JP	Z,GETLIN	; Get line again if empty
     970/    34C8 : CD 7D 35            	CALL	OUTC		; Output null character
     971/    34CB : 3E                  	DB	3EH		; Skip "DEC B"
     972/    34CC : 05                  ECHDEL: DEC	B		; Count bytes in buffer
     973/    34CD : 2B                  	DEC	HL		; Back space buffer
     974/    34CE : CA E0 34            	JP	Z,OTKLN		; No buffer - Try again
     975/    34D1 : 7E                  	LD	A,(HL)		; Get deleted byte
     976/    34D2 : CD 7D 35            	CALL	OUTC		; Echo it
     977/    34D5 : C3 F2 34            	JP	MORINP		; Get more input
     978/    34D8 :                     ;
     979/    34D8 : 05                  DELCHR: DEC	B		; Count bytes in buffer
     980/    34D9 : 2B                  	DEC	HL		; Back space buffer
     981/    34DA : CD 7D 35            	CALL	OUTC		; Output character in A
     982/    34DD : C2 F2 34            	JP	NZ,MORINP	; Not end - Get more
     983/    34E0 : CD 7D 35            OTKLN:	CALL	OUTC		; Output character in A
     984/    34E3 : CD A2 39            KILIN:	CALL	PRCRLF		; Output CRLF
     985/    34E6 : C3 E9 34            	JP	TTYLIN		; Get line again
     986/    34E9 :                     ;
     987/    34E9 :                     GETLIN:
     988/    34E9 : 21 A6 C0            TTYLIN: LD	HL,BUFFER	; Get a line by character
     989/    34EC : 06 01               	LD	B,1		; Set buffer as empty
     990/    34EE : AF                  	XOR	A
     991/    34EF : 32 89 C0            	LD	(NULFLG),A	; Clear null flag
     992/    34F2 : CD A5 35            MORINP: CALL	CLOTST		; Get character and test ^O
     993/    34F5 : 4F                  	LD	C,A		; Save character in C
     994/    34F6 : FE 7F               	CP	DEL		; Delete character?
     995/    34F8 : CA B8 34            	JP	Z,DODEL	; Yes - Process it
     996/    34FB : 3A 89 C0            	LD	A,(NULFLG)	; Get null flag
     997/    34FE : B7                  	OR	A		; Test null flag status
     998/    34FF : CA 0B 35            	JP	Z,PROCES	; Reset - Process character
     999/    3502 : 3E 00               	LD	A,0		; Set a null
    1000/    3504 : CD 7D 35            	CALL	OUTC		; Output null
    1001/    3507 : AF                  	XOR	A		; Clear A
    1002/    3508 : 32 89 C0            	LD	(NULFLG),A	; Reset null flag
    1003/    350B : 79                  PROCES: LD	A,C		; Get character
    1004/    350C : FE 07               	CP	CTRLG		; Bell?
    1005/    350E : CA 4F 35            	JP	Z,PUTCTL	; Yes - Save it
    1006/    3511 : FE 03               	CP	CTRLC		; Is it control "C"?
    1007/    3513 : CC A2 39            	CALL	Z,PRCRLF	; Yes - Output CRLF
    1008/    3516 : 37                  	SCF			; Flag break
    1009/    3517 : C8                  	RET	Z		; Return if control "C"
    1010/    3518 : FE 0D               	CP	CR		; Is it enter?
    1011/    351A : CA 9D 39            	JP	Z,ENDINP	; Yes - Terminate input
    1012/    351D : FE 15               	CP	CTRLU		; Is it control "U"?
    1013/    351F : CA E3 34            	JP	Z,KILIN		; Yes - Get another line
    1014/    3522 : FE 40               	CP	'@'		; Is it "kill line"?
    1015/    3524 : CA E0 34            	JP	Z,OTKLN		; Yes - Kill line
    1016/    3527 : FE 5F               	CP	'_'		; Is it delete?
    1017/    3529 : CA D8 34            	JP	Z,DELCHR	; Yes - Delete character
    1018/    352C : FE 08               	CP	BKSP		; Is it backspace?
    1019/    352E : CA D8 34            	JP	Z,DELCHR	; Yes - Delete character
    1020/    3531 : FE 12               	CP	CTRLR		; Is it control "R"?
    1021/    3533 : C2 4A 35            	JP	NZ,PUTBUF	; No - Put in buffer
    1022/    3536 : C5                  	PUSH	BC		; Save buffer length
    1023/    3537 : D5                  	PUSH	DE		; Save DE
    1024/    3538 : E5                  	PUSH	HL		; Save buffer address
    1025/    3539 : 36 00               	LD	(HL),0		; Mark end of buffer
    1026/    353B : CD 46 4B            	CALL	OUTNCR		; Output and do CRLF
    1027/    353E : 21 A6 C0            	LD	HL,BUFFER	; Point to buffer start
    1028/    3541 : CD 40 40            	CALL	PRS		; Output buffer
    1029/    3544 : E1                  	POP	HL		; Restore buffer address
    1030/    3545 : D1                  	POP	DE		; Restore DE
    1031/    3546 : C1                  	POP	BC		; Restore buffer length
    1032/    3547 : C3 F2 34            	JP	MORINP		; Get another character
    1033/    354A :                     ;
    1034/    354A : FE 20               PUTBUF: CP	' '		; Is it a control code?
    1035/    354C : DA F2 34            	JP	C,MORINP	; Yes - Ignore
    1036/    354F : 78                  PUTCTL: LD	A,B		; Get number of bytes in buffer
    1037/    3550 : FE 49               	CP	72+1		; Test for line overflow
    1038/    3552 : 3E 07               	LD	A,CTRLG		; Set a bell
    1039/    3554 : D2 64 35            	JP	NC,OUTNBS	; Ring bell if buffer full
    1040/    3557 : 79                  	LD	A,C		; Get character
    1041/    3558 : 71                  	LD	(HL),C		; Save in buffer
    1042/    3559 : 32 11 C1            	LD	(LSTBIN),A	; Save last input byte
    1043/    355C : 23                  	INC	HL		; Move up buffer
    1044/    355D : 04                  	INC	B		; Increment length
    1045/    355E : CD 7D 35            OUTIT:	CALL	OUTC		; Output the character entered
    1046/    3561 : C3 F2 34            	JP	MORINP		; Get another character
    1047/    3564 :                     ;
    1048/    3564 : CD 7D 35            OUTNBS: CALL	OUTC		; Output bell and back over it
    1049/    3567 : 3E 08               	LD	A,BKSP		; Set back space
    1050/    3569 : C3 5E 35            	JP	OUTIT		; Output it and get more
    1051/    356C :                     ;
    1052/    356C : 7C                  CPDEHL: LD	A,H		; Get H
    1053/    356D : 92                  	SUB	D		; Compare with D
    1054/    356E : C0                  	RET	NZ		; Different - Exit
    1055/    356F : 7D                  	LD	A,L		; Get L
    1056/    3570 : 93                  	SUB	E		; Compare with E
    1057/    3571 : C9                  	RET			; Return status
    1058/    3572 :                     ;
    1059/    3572 : 7E                  CHKSYN: LD	A,(HL)		; Check syntax of character
    1060/    3573 : E3                  	EX	(SP),HL		; Address of test byte
    1061/    3574 : BE                  	CP	(HL)		; Same as in code string?
    1062/    3575 : 23                  	INC	HL		; Return address
    1063/    3576 : E3                  	EX	(SP),HL		; Put it back
    1064/    3577 : CA FA 36            	JP	Z,GETCHR	; Yes - Get next character
    1065/    357A : C3 A4 32            	JP	SNERR		; Different - ?SN Error
    1066/    357D :                     ;
    1067/    357D : F5                  OUTC:	PUSH	AF		; Save character
    1068/    357E : 3A 8A C0            	LD	A,(CTLOFG)	; Get control "O" flag
    1069/    3581 : B7                  	OR	A		; Is it set?
    1070/    3582 : C2 75 40            	JP	NZ,POPAF	; Yes - don't output
    1071/    3585 : F1                  	POP	AF		; Restore character
    1072/    3586 : C5                  	PUSH	BC		; Save buffer length
    1073/    3587 : F5                  	PUSH	AF		; Save character
    1074/    3588 : FE 20               	CP	' '		; Is it a control code?
    1075/    358A : DA A1 35            	JP	C,DINPOS	; Yes - Don't INC POS(X)
    1076/    358D : 3A 87 C0            	LD	A,(LWIDTH)	; Get line width
    1077/    3590 : 47                  	LD	B,A		; To B
    1078/    3591 : 3A F0 C0            	LD	A,(CURPOS)	; Get cursor position
    1079/    3594 : 04                  	INC	B		; Width 255?
    1080/    3595 : CA 9D 35            	JP	Z,INCLEN	; Yes - No width limit
    1081/    3598 : 05                  	DEC	B		; Restore width
    1082/    3599 : B8                  	CP	B		; At end of line?
    1083/    359A : CC A2 39            	CALL	Z,PRCRLF	; Yes - output CRLF
    1084/    359D : 3C                  INCLEN: INC	A		; Move on one character
    1085/    359E : 32 F0 C0            	LD	(CURPOS),A	; Save new position
    1086/    35A1 : F1                  DINPOS: POP	AF		; Restore character
    1087/    35A2 : C1                  	POP	BC		; Restore buffer length
    1088/    35A3 :                     ;	CALL	MONOUT		; Send it
    1089/    35A3 : CF                  	rst	08h
    1090/    35A4 : C9                  	RET
    1091/    35A5 :                     ;
    1092/    35A5 : CD FF 49            CLOTST: CALL	GETINP		; Get input character
    1093/    35A8 : E6 7F               	AND	01111111B	; Strip bit 7
    1094/    35AA : FE 0F               	CP	CTRLO		; Is it control "O"?
    1095/    35AC : C0                  	RET	NZ		; No don't flip flag
    1096/    35AD : 3A 8A C0            	LD	A,(CTLOFG)	; Get flag
    1097/    35B0 : 2F                  	CPL			; Flip it
    1098/    35B1 : 32 8A C0            	LD	(CTLOFG),A	; Put it back
    1099/    35B4 : AF                  	XOR	A		; Null character
    1100/    35B5 : C9                  	RET
    1101/    35B6 :                     ;
    1102/    35B6 : CD C6 37            LIST:	CALL	ATOH		; ASCII number to DE
    1103/    35B9 : C0                  	RET	NZ		; Return if anything extra
    1104/    35BA : C1                  	POP	BC		; Rubbish - Not needed
    1105/    35BB : CD 90 33            	CALL	SRCHLN		; Search for line number in DE
    1106/    35BE : C5                  	PUSH	BC		; Save address of line
    1107/    35BF : CD 0C 36            	CALL	SETLIN		; Set up lines counter
    1108/    35C2 : E1                  LISTLP: POP	HL		; Restore address of line
    1109/    35C3 : 4E                  	LD	C,(HL)		; Get LSB of next line
    1110/    35C4 : 23                  	INC	HL
    1111/    35C5 : 46                  	LD	B,(HL)		; Get MSB of next line
    1112/    35C6 : 23                  	INC	HL
    1113/    35C7 : 78                  	LD	A,B		; BC = 0 (End of program)?
    1114/    35C8 : B1                  	OR	C
    1115/    35C9 : CA EF 32            	JP	Z,PRNTOK	; Yes - Go to command mode
    1116/    35CC : CD 15 36            	CALL	COUNT		; Count lines
    1117/    35CF : CD 25 37            	CALL	TSTBRK		; Test for break key
    1118/    35D2 : C5                  	PUSH	BC		; Save address of next line
    1119/    35D3 : CD A2 39            	CALL	PRCRLF		; Output CRLF
    1120/    35D6 : 5E                  	LD	E,(HL)		; Get LSB of line number
    1121/    35D7 : 23                  	INC	HL
    1122/    35D8 : 56                  	LD	D,(HL)		; Get MSB of line number
    1123/    35D9 : 23                  	INC	HL
    1124/    35DA : E5                  	PUSH	HL		; Save address of line start
    1125/    35DB : EB                  	EX	DE,HL		; Line number to HL
    1126/    35DC : CD E3 46            	CALL	PRNTHL		; Output line number in decimal
    1127/    35DF : 3E 20               	LD	A,' '		; Space after line number
    1128/    35E1 : E1                  	POP	HL		; Restore start of line address
    1129/    35E2 : CD 7D 35            LSTLP2: CALL	OUTC		; Output character in A
    1130/    35E5 : 7E                  LSTLP3: LD	A,(HL)		; Get next byte in line
    1131/    35E6 : B7                  	OR	A		; End of line?
    1132/    35E7 : 23                  	INC	HL		; To next byte in line
    1133/    35E8 : CA C2 35            	JP	Z,LISTLP	; Yes - get next line
    1134/    35EB : F2 E2 35            	JP	P,LSTLP2	; No token - output it
    1135/    35EE : D6 7F               	SUB	ZEND-1		; Find and output word
    1136/    35F0 : 4F                  	LD	C,A		; Token offset+1 to C
    1137/    35F1 : 11 2D 30            	LD	DE,WORDS	; Reserved word list
    1138/    35F4 : 1A                  FNDTOK: LD	A,(DE)		; Get character in list
    1139/    35F5 : 13                  	INC	DE		; Move on to next
    1140/    35F6 : B7                  	OR	A		; Is it start of word?
    1141/    35F7 : F2 F4 35            	JP	P,FNDTOK	; No - Keep looking for word
    1142/    35FA : 0D                  	DEC	C		; Count words
    1143/    35FB : C2 F4 35            	JP	NZ,FNDTOK	; Not there - keep looking
    1144/    35FE : E6 7F               OUTWRD: AND	01111111B	; Strip bit 7
    1145/    3600 : CD 7D 35            	CALL	OUTC		; Output first character
    1146/    3603 : 1A                  	LD	A,(DE)		; Get next character
    1147/    3604 : 13                  	INC	DE		; Move on to next
    1148/    3605 : B7                  	OR	A		; Is it end of word?
    1149/    3606 : F2 FE 35            	JP	P,OUTWRD	; No - output the rest
    1150/    3609 : C3 E5 35            	JP	LSTLP3		; Next byte in line
    1151/    360C :                     ;
    1152/    360C : E5                  SETLIN: PUSH	HL		; Set up LINES counter
    1153/    360D : 2A 8D C0            	LD	HL,(LINESN)	; Get LINES number
    1154/    3610 : 22 8B C0            	LD	(LINESC),HL	; Save in LINES counter
    1155/    3613 : E1                  	POP	HL
    1156/    3614 : C9                  	RET
    1157/    3615 :                     ;
    1158/    3615 : E5                  COUNT:	PUSH	HL		; Save code string address
    1159/    3616 : D5                  	PUSH	DE
    1160/    3617 : 2A 8B C0            	LD	HL,(LINESC)	; Get LINES counter
    1161/    361A : 11 FF FF            	LD	DE,-1
    1162/    361D : ED 5A               	ADC	HL,DE		; Decrement
    1163/    361F : 22 8B C0            	LD	(LINESC),HL	; Put it back
    1164/    3622 : D1                  	POP	DE
    1165/    3623 : E1                  	POP	HL		; Restore code string address
    1166/    3624 : F0                  	RET	P		; Return if more lines to go
    1167/    3625 : E5                  	PUSH	HL		; Save code string address
    1168/    3626 : 2A 8D C0            	LD	HL,(LINESN)	; Get LINES number
    1169/    3629 : 22 8B C0            	LD	(LINESC),HL	; Reset LINES counter
    1170/    362C : CD FF 49            	CALL	GETINP		; Get input character
    1171/    362F : FE 03               	CP	CTRLC		; Is it control "C"?
    1172/    3631 : CA 38 36            	JP	Z,RSLNBK	; Yes - Reset LINES and break
    1173/    3634 : E1                  	POP	HL		; Restore code string address
    1174/    3635 : C3 15 36            	JP	COUNT		; Keep on counting
    1175/    3638 :                     ;
    1176/    3638 : 2A 8D C0            RSLNBK: LD	HL,(LINESN)	; Get LINES number
    1177/    363B : 22 8B C0            	LD	(LINESC),HL	; Reset LINES counter
    1178/    363E : C3 6E 2F            	JP	BRKRET		; Go and output "Break"
    1179/    3641 :                     ;
    1180/    3641 : 3E 64               FOR:	LD	A,64H		; Flag "FOR" assignment
    1181/    3643 : 32 10 C1            	LD	(FORFLG),A	; Save "FOR" flag
    1182/    3646 : CD A8 38            	CALL	LET		; Set up initial index
    1183/    3649 : C1                  	POP	BC		; Drop RETurn address
    1184/    364A : E5                  	PUSH	HL		; Save code string address
    1185/    364B : CD 91 38            	CALL	DATA		; Get next statement address
    1186/    364E : 22 0C C1            	LD	(LOOPST),HL	; Save it for start of loop
    1187/    3651 : 21 02 00            	LD	HL,2		; Offset for "FOR" block
    1188/    3654 : 39                  	ADD	HL,SP		; Point to it
    1189/    3655 : CD 51 32            FORSLP: CALL	LOKFOR		; Look for existing "FOR" block
    1190/    3658 : D1                  	POP	DE		; Get code string address
    1191/    3659 : C2 71 36            	JP	NZ,FORFND	; No nesting found
    1192/    365C : 09                  	ADD	HL,BC		; Move into "FOR" block
    1193/    365D : D5                  	PUSH	DE		; Save code string address
    1194/    365E : 2B                  	DEC	HL
    1195/    365F : 56                  	LD	D,(HL)		; Get MSB of loop statement
    1196/    3660 : 2B                  	DEC	HL
    1197/    3661 : 5E                  	LD	E,(HL)		; Get LSB of loop statement
    1198/    3662 : 23                  	INC	HL
    1199/    3663 : 23                  	INC	HL
    1200/    3664 : E5                  	PUSH	HL		; Save block address
    1201/    3665 : 2A 0C C1            	LD	HL,(LOOPST)	; Get address of loop statement
    1202/    3668 : CD 6C 35            	CALL	CPDEHL		; Compare the FOR loops
    1203/    366B : E1                  	POP	HL		; Restore block address
    1204/    366C : C2 55 36            	JP	NZ,FORSLP	; Different FORs - Find another
    1205/    366F : D1                  	POP	DE		; Restore code string address
    1206/    3670 : F9                  	LD	SP,HL		; Remove all nested loops
    1207/    3671 :                     ;
    1208/    3671 : EB                  FORFND: EX	DE,HL		; Code string address to HL
    1209/    3672 : 0E 08               	LD	C,8
    1210/    3674 : CD 81 32            	CALL	CHKSTK		; Check for 8 levels of stack
    1211/    3677 : E5                  	PUSH	HL		; Save code string address
    1212/    3678 : 2A 0C C1            	LD	HL,(LOOPST)	; Get first statement of loop
    1213/    367B : E3                  	EX	(SP),HL		; Save and restore code string
    1214/    367C : E5                  	PUSH	HL		; Re-save code string address
    1215/    367D : 2A A1 C0            	LD	HL,(LINEAT)	; Get current line number
    1216/    3680 : E3                  	EX	(SP),HL		; Save and restore code string
    1217/    3681 : CD 6A 3B            	CALL	TSTNUM		; Make sure it's a number
    1218/    3684 : CD 72 35            	CALL	CHKSYN		; Make sure "TO" is next
    1219/    3687 : A6                  	DB	ZTO		; "TO" token
    1220/    3688 : CD 67 3B            	CALL	GETNUM		; Get "TO" expression value
    1221/    368B : E5                  	PUSH	HL		; Save code string address
    1222/    368C : CD 95 45            	CALL	BCDEFP		; Move "TO" value to BCDE
    1223/    368F : E1                  	POP	HL		; Restore code string address
    1224/    3690 : C5                  	PUSH	BC		; Save "TO" value in block
    1225/    3691 : D5                  	PUSH	DE
    1226/    3692 : 01 00 81            	LD	BC,8100H	; BCDE - 1 (default STEP)
    1227/    3695 : 51                  	LD	D,C		; C=0
    1228/    3696 : 5A                  	LD	E,D		; D=0
    1229/    3697 : 7E                  	LD	A,(HL)		; Get next byte in code string
    1230/    3698 : FE AB               	CP	ZSTEP		; See if "STEP" is stated
    1231/    369A : 3E 01               	LD	A,1		; Sign of step = 1
    1232/    369C : C2 AD 36            	JP	NZ,SAVSTP	; No STEP given - Default to 1
    1233/    369F : CD FA 36            	CALL	GETCHR		; Jump over "STEP" token
    1234/    36A2 : CD 67 3B            	CALL	GETNUM		; Get step value
    1235/    36A5 : E5                  	PUSH	HL		; Save code string address
    1236/    36A6 : CD 95 45            	CALL	BCDEFP		; Move STEP to BCDE
    1237/    36A9 : CD 49 45            	CALL	TSTSGN		; Test sign of FPREG
    1238/    36AC : E1                  	POP	HL		; Restore code string address
    1239/    36AD : C5                  SAVSTP: PUSH	BC		; Save the STEP value in block
    1240/    36AE : D5                  	PUSH	DE
    1241/    36AF : F5                  	PUSH	AF		; Save sign of STEP
    1242/    36B0 : 33                  	INC	SP		; Don't save flags
    1243/    36B1 : E5                  	PUSH	HL		; Save code string address
    1244/    36B2 : 2A 13 C1            	LD	HL,(BRKLIN)	; Get address of index variable
    1245/    36B5 : E3                  	EX	(SP),HL		; Save and restore code string
    1246/    36B6 : 06 81               PUTFID: LD	B,ZFOR		; "FOR" block marker
    1247/    36B8 : C5                  	PUSH	BC		; Save it
    1248/    36B9 : 33                  	INC	SP		; Don't save C
    1249/    36BA :                     ;
    1250/    36BA : CD 25 37            RUNCNT: CALL	TSTBRK		; Execution driver - Test break
    1251/    36BD : 22 13 C1            	LD	(BRKLIN),HL	; Save code address for break
    1252/    36C0 : 7E                  	LD	A,(HL)		; Get next byte in code string
    1253/    36C1 : FE 3A               	CP	':'		; Multi statement line?
    1254/    36C3 : CA DA 36            	JP	Z,EXCUTE	; Yes - Execute it
    1255/    36C6 : B7                  	OR	A		; End of line?
    1256/    36C7 : C2 A4 32            	JP	NZ,SNERR	; No - Syntax error
    1257/    36CA : 23                  	INC	HL		; Point to address of next line
    1258/    36CB : 7E                  	LD	A,(HL)		; Get LSB of line pointer
    1259/    36CC : 23                  	INC	HL
    1260/    36CD : B6                  	OR	(HL)		; Is it zero (End of prog)?
    1261/    36CE : CA 4C 37            	JP	Z,ENDPRG	; Yes - Terminate execution
    1262/    36D1 : 23                  	INC	HL		; Point to line number
    1263/    36D2 : 5E                  	LD	E,(HL)		; Get LSB of line number
    1264/    36D3 : 23                  	INC	HL
    1265/    36D4 : 56                  	LD	D,(HL)		; Get MSB of line number
    1266/    36D5 : EB                  	EX	DE,HL		; Line number to HL
    1267/    36D6 : 22 A1 C0            	LD	(LINEAT),HL	; Save as current line number
    1268/    36D9 : EB                  	EX	DE,HL		; Line number back to DE
    1269/    36DA : CD FA 36            EXCUTE: CALL	GETCHR		; Get key word
    1270/    36DD : 11 BA 36            	LD	DE,RUNCNT	; Where to RETurn to
    1271/    36E0 : D5                  	PUSH	DE		; Save for RETurn
    1272/    36E1 : C8                  IFJMP:	RET	Z		; Go to RUNCNT if end of STMT
    1273/    36E2 : D6 80               ONJMP:	SUB	ZEND		; Is it a token?
    1274/    36E4 : DA A8 38            	JP	C,LET		; No - try to assign it
    1275/    36E7 : FE 25               	CP	ZNEW+1-ZEND	; END to NEW ?
    1276/    36E9 : D2 A4 32            	JP	NC,SNERR	; Not a key word - ?SN Error
    1277/    36EC : 07                  	RLCA			; Double it
    1278/    36ED : 4F                  	LD	C,A		; BC = Offset into table
    1279/    36EE : 06 00               	LD	B,0
    1280/    36F0 : EB                  	EX	DE,HL		; Save code string address
    1281/    36F1 : 21 4C 31            	LD	HL,WORDTB	; Keyword address table
    1282/    36F4 : 09                  	ADD	HL,BC		; Point to routine address
    1283/    36F5 : 4E                  	LD	C,(HL)		; Get LSB of routine address
    1284/    36F6 : 23                  	INC	HL
    1285/    36F7 : 46                  	LD	B,(HL)		; Get MSB of routine address
    1286/    36F8 : C5                  	PUSH	BC		; Save routine address
    1287/    36F9 : EB                  	EX	DE,HL		; Restore code string address
    1288/    36FA :                     ;
    1289/    36FA : 23                  GETCHR: INC	HL		; Point to next character
    1290/    36FB : 7E                  	LD	A,(HL)		; Get next code string byte
    1291/    36FC : FE 3A               	CP	':'		; Z if ':'
    1292/    36FE : D0                  	RET	NC		; NC if > "9"
    1293/    36FF : FE 20               	CP	' '
    1294/    3701 : CA FA 36            	JP	Z,GETCHR	; Skip over spaces
    1295/    3704 : FE 30               	CP	'0'
    1296/    3706 : 3F                  	CCF			; NC if < '0'
    1297/    3707 : 3C                  	INC	A		; Test for zero - Leave carry
    1298/    3708 : 3D                  	DEC	A		; Z if Null
    1299/    3709 : C9                  	RET
    1300/    370A :                     ;
    1301/    370A : EB                  RESTOR: EX	DE,HL		; Save code string address
    1302/    370B : 2A A3 C0            	LD	HL,(BASTXT)	; Point to start of program
    1303/    370E : CA 1F 37            	JP	Z,RESTNL	; Just RESTORE - reset pointer
    1304/    3711 : EB                  	EX	DE,HL		; Restore code string address
    1305/    3712 : CD C6 37            	CALL	ATOH		; Get line number to DE
    1306/    3715 : E5                  	PUSH	HL		; Save code string address
    1307/    3716 : CD 90 33            	CALL	SRCHLN		; Search for line number in DE
    1308/    3719 : 60                  	LD	H,B		; HL = Address of line
    1309/    371A : 69                  	LD	L,C
    1310/    371B : D1                  	POP	DE		; Restore code string address
    1311/    371C : D2 67 38            	JP	NC,ULERR	; ?UL Error if not found
    1312/    371F : 2B                  RESTNL: DEC	HL		; Byte before DATA statement
    1313/    3720 : 22 21 C1            UPDATA: LD	(NXTDAT),HL	; Update DATA pointer
    1314/    3723 : EB                  	EX	DE,HL		; Restore code string address
    1315/    3724 : C9                  	RET
    1316/    3725 :                     ;
    1317/    3725 :                     
    1318/    3725 : DF                  TSTBRK: RST	18H		; Check input status
    1319/    3726 : C8                  	RET	Z		; No key, go back
    1320/    3727 : D7                  	RST	10H		; Get the key into A
    1321/    3728 : FE 1B               	CP	ESC		; Escape key?
    1322/    372A : 28 11               	JR	Z,BRK		; Yes, break
    1323/    372C : FE 03               	CP	CTRLC		; <Ctrl-C>
    1324/    372E : 28 0D               	JR	Z,BRK		; Yes, break
    1325/    3730 : FE 13               	CP	CTRLS		; Stop scrolling?
    1326/    3732 : C0                  	RET	NZ		; Other key, ignore
    1327/    3733 :                     ;
    1328/    3733 :                     
    1329/    3733 : D7                  STALL:	RST	10H		; Wait for key
    1330/    3734 : FE 11               	CP	CTRLQ		; Resume scrolling?
    1331/    3736 : C8                  	RET	Z		; Release the chokehold
    1332/    3737 : FE 03               	CP	CTRLC		; Second break?
    1333/    3739 : 28 07               	JR	Z,STOP		; Break during hold exits prog
    1334/    373B : 18 F6               	JR	STALL		; Loop until <Ctrl-Q> or <brk>
    1335/    373D :                     ;
    1336/    373D : 3E FF               BRK:	LD	A,0FFH		; Set BRKFLG
    1337/    373F : 32 92 C0            	LD	(BRKFLG),A	; Store it
    1338/    3742 :                     ;
    1339/    3742 :                     
    1340/    3742 : C0                  STOP:	RET	NZ		; Exit if anything else
    1341/    3743 : F6                  	DB	0F6H		; Flag "STOP"
    1342/    3744 : C0                  PEND:	RET	NZ		; Exit if anything else
    1343/    3745 : 22 13 C1            	LD	(BRKLIN),HL	; Save point of break
    1344/    3748 : 21                  	DB	21H		; Skip "OR 11111111B"
    1345/    3749 : F6 FF               INPBRK: OR	11111111B	; Flag "Break" wanted
    1346/    374B : C1                  	POP	BC		; Return not needed and more
    1347/    374C : 2A A1 C0            ENDPRG: LD	HL,(LINEAT)	; Get current line number
    1348/    374F : F5                  	PUSH	AF		; Save STOP / END status
    1349/    3750 : 7D                  	LD	A,L		; Is it direct break?
    1350/    3751 : A4                  	AND	H
    1351/    3752 : 3C                  	INC	A		; Line is -1 if direct break
    1352/    3753 : CA 5F 37            	JP	Z,NOLIN		; Yes - No line number
    1353/    3756 : 22 17 C1            	LD	(ERRLIN),HL	; Save line of break
    1354/    3759 : 2A 13 C1            	LD	HL,(BRKLIN)	; Get point of break
    1355/    375C : 22 19 C1            	LD	(CONTAD),HL	; Save point to CONTinue
    1356/    375F : AF                  NOLIN:	XOR	A
    1357/    3760 : 32 8A C0            	LD	(CTLOFG),A	; Enable output
    1358/    3763 : CD 95 39            	CALL	STTLIN		; Start a new line
    1359/    3766 : F1                  	POP	AF		; Restore STOP / END status
    1360/    3767 : 21 47 32            	LD	HL,BRKMSG	; "Break" message
    1361/    376A : C2 D8 32            	JP	NZ,ERRIN	; "in line" wanted?
    1362/    376D : C3 EF 32            	JP	PRNTOK		; Go to command mode
    1363/    3770 :                     ;
    1364/    3770 : 2A 19 C1            CONT:	LD	HL,(CONTAD)	; Get CONTinue address
    1365/    3773 : 7C                  	LD	A,H		; Is it zero?
    1366/    3774 : B5                  	OR	L
    1367/    3775 : 1E 20               	LD	E,CN		; ?CN Error
    1368/    3777 : CA B8 32            	JP	Z,ERROR_	; Yes - output "?CN Error"
    1369/    377A : EB                  	EX	DE,HL		; Save code string address
    1370/    377B : 2A 17 C1            	LD	HL,(ERRLIN)	; Get line of last break
    1371/    377E : 22 A1 C0            	LD	(LINEAT),HL	; Set up current line number
    1372/    3781 : EB                  	EX	DE,HL		; Restore code string address
    1373/    3782 : C9                  	RET			; CONTinue where left off
    1374/    3783 :                     ;
    1375/    3783 : CD C8 42            NULL:	CALL	GETINT		; Get integer 0-255
    1376/    3786 : C0                  	RET	NZ		; Return if bad value
    1377/    3787 : 32 86 C0            	LD	(NULLS),A	; Set nulls number
    1378/    378A : C9                  	RET
    1379/    378B :                     ;
    1380/    378B :                     
    1381/    378B : E5                  ACCSUM: PUSH	HL		; Save address in array
    1382/    378C : 2A 8F C0            	LD	HL,(CHKSUM)	; Get check sum
    1383/    378F : 06 00               	LD	B,0		; BC - Value of byte
    1384/    3791 : 4F                  	LD	C,A
    1385/    3792 : 09                  	ADD	HL,BC		; Add byte to check sum
    1386/    3793 : 22 8F C0            	LD	(CHKSUM),HL	; Re-save check sum
    1387/    3796 : E1                  	POP	HL		; Restore address in array
    1388/    3797 : C9                  	RET
    1389/    3798 :                     ;
    1390/    3798 : 7E                  CHKLTR: LD	A,(HL)		; Get byte
    1391/    3799 : FE 41               	CP	'A'		; < 'a' ?
    1392/    379B : D8                  	RET	C		; Carry set if not letter
    1393/    379C : FE 5B               	CP	'Z'+1		; > 'z' ?
    1394/    379E : 3F                  	CCF
    1395/    379F : C9                  	RET			; Carry set if not letter
    1396/    37A0 :                     ;
    1397/    37A0 : CD FA 36            FPSINT: CALL	GETCHR		; Get next character
    1398/    37A3 : CD 67 3B            POSINT: CALL	GETNUM		; Get integer 0 to 32767
    1399/    37A6 : CD 49 45            DEPINT: CALL	TSTSGN		; Test sign of FPREG
    1400/    37A9 : FA C1 37            	JP	M,FCERR		; Negative - ?FC Error
    1401/    37AC : 3A 2C C1            DEINT:	LD	A,(FPEXP)	; Get integer value to DE
    1402/    37AF : FE 90               	CP	80H+16		; Exponent in range (16 bits)?
    1403/    37B1 : DA F1 45            	JP	C,FPINT		; Yes - convert it
    1404/    37B4 : 01 80 90            	LD	BC,9080H	; BCDE = -32768
    1405/    37B7 : 11 00 00            	LD	DE,0000
    1406/    37BA : E5                  	PUSH	HL		; Save code string address
    1407/    37BB : CD C4 45            	CALL	CMPNUM		; Compare FPREG with BCDE
    1408/    37BE : E1                  	POP	HL		; Restore code string address
    1409/    37BF : 51                  	LD	D,C		; MSB to D
    1410/    37C0 : C8                  	RET	Z		; Return if in range
    1411/    37C1 : 1E 08               FCERR:	LD	E,FC		; ?FC Error
    1412/    37C3 : C3 B8 32            	JP	ERROR_		; Output error-
    1413/    37C6 :                     ;
    1414/    37C6 : 2B                  ATOH:	DEC	HL		; ASCII number to DE binary
    1415/    37C7 : 11 00 00            GETLN:	LD	DE,0		; Get number to DE
    1416/    37CA : CD FA 36            GTLNLP: CALL	GETCHR		; Get next character
    1417/    37CD : D0                  	RET	NC		; Exit if not a digit
    1418/    37CE : E5                  	PUSH	HL		; Save code string address
    1419/    37CF : F5                  	PUSH	AF		; Save digit
    1420/    37D0 : 21 98 19            	LD	HL,65529/10	; Largest number 65529
    1421/    37D3 : CD 6C 35            	CALL	CPDEHL		; Number in range?
    1422/    37D6 : DA A4 32            	JP	C,SNERR		; No - ?SN Error
    1423/    37D9 : 62                  	LD	H,D		; HL = Number
    1424/    37DA : 6B                  	LD	L,E
    1425/    37DB : 19                  	ADD	HL,DE		; Times 2
    1426/    37DC : 29                  	ADD	HL,HL		; Times 4
    1427/    37DD : 19                  	ADD	HL,DE		; Times 5
    1428/    37DE : 29                  	ADD	HL,HL		; Times 10
    1429/    37DF : F1                  	POP	AF		; Restore digit
    1430/    37E0 : D6 30               	SUB	'0'		; Make it 0 to 9
    1431/    37E2 : 5F                  	LD	E,A		; DE = Value of digit
    1432/    37E3 : 16 00               	LD	D,0
    1433/    37E5 : 19                  	ADD	HL,DE		; Add to number
    1434/    37E6 : EB                  	EX	DE,HL		; Number to DE
    1435/    37E7 : E1                  	POP	HL		; Restore code string address
    1436/    37E8 : C3 CA 37            	JP	GTLNLP		; Go to next character
    1437/    37EB :                     ;
    1438/    37EB : CA C0 33            CLEAR:	JP	Z,INTVAR	; Just "CLEAR" Keep parameters
    1439/    37EE : CD A3 37            	CALL	POSINT		; Get integer 0 to 32767 to DE
    1440/    37F1 : 2B                  	DEC	HL		; Cancel increment
    1441/    37F2 : CD FA 36            	CALL	GETCHR		; Get next character
    1442/    37F5 : E5                  	PUSH	HL		; Save code string address
    1443/    37F6 : 2A F4 C0            	LD	HL,(LSTRAM)	; Get end of RAM
    1444/    37F9 : CA 0E 38            	JP	Z,STORED	; No value given - Use stored
    1445/    37FC : E1                  	POP	HL		; Restore code string address
    1446/    37FD : CD 72 35            	CALL	CHKSYN		; Check for comma
    1447/    3800 : 2C                  	DB	','
    1448/    3801 : D5                  	PUSH	DE		; Save number
    1449/    3802 : CD A3 37            	CALL	POSINT		; Get integer 0 to 32767
    1450/    3805 : 2B                  	DEC	HL		; Cancel increment
    1451/    3806 : CD FA 36            	CALL	GETCHR		; Get next character
    1452/    3809 : C2 A4 32            	JP	NZ,SNERR	; ?SN Error if more on line
    1453/    380C : E3                  	EX	(SP),HL		; Save code string address
    1454/    380D : EB                  	EX	DE,HL		; Number to DE
    1455/    380E : 7D                  STORED: LD	A,L		; Get LSB of new RAM top
    1456/    380F : 93                  	SUB	E		; Subtract LSB of string space
    1457/    3810 : 5F                  	LD	E,A		; Save LSB
    1458/    3811 : 7C                  	LD	A,H		; Get MSB of new RAM top
    1459/    3812 : 9A                  	SBC	A,D		; Subtract MSB of string space
    1460/    3813 : 57                  	LD	D,A		; Save MSB
    1461/    3814 : DA 99 32            	JP	C,OMERR		; ?OM Error if not enough mem
    1462/    3817 : E5                  	PUSH	HL		; Save RAM top
    1463/    3818 : 2A 1B C1            	LD	HL,(PROGND)	; Get program end
    1464/    381B : 01 28 00            	LD	BC,40		; 40 Bytes minimum working RAM
    1465/    381E : 09                  	ADD	HL,BC		; Get lowest address
    1466/    381F : CD 6C 35            	CALL	CPDEHL		; Enough memory?
    1467/    3822 : D2 99 32            	JP	NC,OMERR	; No - ?OM Error
    1468/    3825 : EB                  	EX	DE,HL		; RAM top to HL
    1469/    3826 : 22 9F C0            	LD	(STRSPC),HL	; Set new string space
    1470/    3829 : E1                  	POP	HL		; End of memory to use
    1471/    382A : 22 F4 C0            	LD	(LSTRAM),HL	; Set new top of RAM
    1472/    382D : E1                  	POP	HL		; Restore code string address
    1473/    382E : C3 C0 33            	JP	INTVAR		; Initialise variables
    1474/    3831 :                     ;
    1475/    3831 : CA BC 33            RUN:	JP	Z,RUNFST	; RUN from start if just RUN
    1476/    3834 : CD C0 33            	CALL	INTVAR		; Initialise variables
    1477/    3837 : 01 BA 36            	LD	BC,RUNCNT	; Execution driver loop
    1478/    383A : C3 4D 38            	JP	RUNLIN		; RUN from line number
    1479/    383D :                     ;
    1480/    383D : 0E 03               GOSUB:	LD	C,3		; 3 Levels of stack needed
    1481/    383F : CD 81 32            	CALL	CHKSTK		; Check for 3 levels of stack
    1482/    3842 : C1                  	POP	BC		; Get return address
    1483/    3843 : E5                  	PUSH	HL		; Save code string for RETURN
    1484/    3844 : E5                  	PUSH	HL		; And for GOSUB routine
    1485/    3845 : 2A A1 C0            	LD	HL,(LINEAT)	; Get current line
    1486/    3848 : E3                  	EX	(SP),HL		; Into stack - Code string out
    1487/    3849 : 3E 8C               	LD	A,ZGOSUB	; "GOSUB" token
    1488/    384B : F5                  	PUSH	AF		; Save token
    1489/    384C : 33                  	INC	SP		; Don't save flags
    1490/    384D :                     ;
    1491/    384D : C5                  RUNLIN: PUSH	BC		; Save return address
    1492/    384E : CD C6 37            GOTO:	CALL	ATOH		; ASCII number to DE binary
    1493/    3851 : CD 93 38            	CALL	REM		; Get end of line
    1494/    3854 : E5                  	PUSH	HL		; Save end of line
    1495/    3855 : 2A A1 C0            	LD	HL,(LINEAT)	; Get current line
    1496/    3858 : CD 6C 35            	CALL	CPDEHL		; Line after current?
    1497/    385B : E1                  	POP	HL		; Restore end of line
    1498/    385C : 23                  	INC	HL		; Start of next line
    1499/    385D : DC 93 33            	CALL	C,SRCHLP	; Line is after current line
    1500/    3860 : D4 90 33            	CALL	NC,SRCHLN	; Line is before current line
    1501/    3863 : 60                  	LD	H,B		; Set up code string address
    1502/    3864 : 69                  	LD	L,C
    1503/    3865 : 2B                  	DEC	HL		; Incremented after
    1504/    3866 : D8                  	RET	C		; Line found
    1505/    3867 : 1E 0E               ULERR:	LD	E,UL		; ?UL Error
    1506/    3869 : C3 B8 32            	JP	ERROR_		; Output error message
    1507/    386C :                     ;
    1508/    386C : C0                  RETURN: RET	NZ		; Return if not just RETURN
    1509/    386D : 16 FF               	LD	D,-1		; Flag "GOSUB" search
    1510/    386F : CD 4D 32            	CALL	BAKSTK		; Look "GOSUB" block
    1511/    3872 : F9                  	LD	SP,HL		; Kill all FORs in subroutine
    1512/    3873 : FE 8C               	CP	ZGOSUB		; Test for "GOSUB" token
    1513/    3875 : 1E 04               	LD	E,RG		; ?RG Error
    1514/    3877 : C2 B8 32            	JP	NZ,ERROR_	; Error if no "GOSUB" found
    1515/    387A : E1                  	POP	HL		; Get RETURN line number
    1516/    387B : 22 A1 C0            	LD	(LINEAT),HL	; Save as current
    1517/    387E : 23                  	INC	HL		; Was it from direct statement?
    1518/    387F : 7C                  	LD	A,H
    1519/    3880 : B5                  	OR	L		; Return to line
    1520/    3881 : C2 8B 38            	JP	NZ,RETLIN	; No - Return to line
    1521/    3884 : 3A 11 C1            	LD	A,(LSTBIN)	; Any INPUT in subroutine?
    1522/    3887 : B7                  	OR	A		; If so buffer is corrupted
    1523/    3888 : C2 EE 32            	JP	NZ,POPNOK	; Yes - Go to command mode
    1524/    388B : 21 BA 36            RETLIN: LD	HL,RUNCNT	; Execution driver loop
    1525/    388E : E3                  	EX	(SP),HL		; Into stack - Code string out
    1526/    388F : 3E                  	DB	3EH		; Skip "POP HL"
    1527/    3890 : E1                  NXTDTA: POP	HL		; Restore code string address
    1528/    3891 :                     ;
    1529/    3891 : 01 3A               DATA:	DB	01H,3AH		; ':' End of statement
    1530/    3893 : 0E 00               REM:	LD	C,0		; 00	End of statement
    1531/    3895 : 06 00               	LD	B,0
    1532/    3897 : 79                  NXTSTL: LD	A,C		; Statement and byte
    1533/    3898 : 48                  	LD	C,B
    1534/    3899 : 47                  	LD	B,A		; Statement end byte
    1535/    389A : 7E                  NXTSTT: LD	A,(HL)		; Get byte
    1536/    389B : B7                  	OR	A		; End of line?
    1537/    389C : C8                  	RET	Z		; Yes - Exit
    1538/    389D : B8                  	CP	B		; End of statement?
    1539/    389E : C8                  	RET	Z		; Yes - Exit
    1540/    389F : 23                  	INC	HL		; Next byte
    1541/    38A0 : FE 22               	CP	'"'		; Literal string?
    1542/    38A2 : CA 97 38            	JP	Z,NXTSTL	; Yes - Look for another '"'
    1543/    38A5 : C3 9A 38            	JP	NXTSTT		; Keep looking
    1544/    38A8 :                     ;
    1545/    38A8 : CD 5D 3D            LET:	CALL	GETVAR		; Get variable name
    1546/    38AB : CD 72 35            	CALL	CHKSYN		; Make sure "=" follows
    1547/    38AE : B4                  	DB	ZEQUAL		; "=" token
    1548/    38AF : D5                  	PUSH	DE		; Save address of variable
    1549/    38B0 : 3A F2 C0            	LD	A,(TYPE)	; Get data type
    1550/    38B3 : F5                  	PUSH	AF		; Save type
    1551/    38B4 : CD 79 3B            	CALL	EVAL		; Evaluate expression
    1552/    38B7 : F1                  	POP	AF		; Restore type
    1553/    38B8 : E3                  	EX	(SP),HL		; Save code - Get var addr
    1554/    38B9 : 22 13 C1            	LD	(BRKLIN),HL	; Save address of variable
    1555/    38BC : 1F                  	RRA			; Adjust type
    1556/    38BD : CD 6C 3B            	CALL	CHKTYP		; Check types are the same
    1557/    38C0 : CA FB 38            	JP	Z,LETNUM	; Numeric - Move value
    1558/    38C3 : E5                  LETSTR: PUSH	HL		; Save address of string var
    1559/    38C4 : 2A 29 C1            	LD	HL,(FPREG)	; Pointer to string entry
    1560/    38C7 : E5                  	PUSH	HL		; Save it on stack
    1561/    38C8 : 23                  	INC	HL		; Skip over length
    1562/    38C9 : 23                  	INC	HL
    1563/    38CA : 5E                  	LD	E,(HL)		; LSB of string address
    1564/    38CB : 23                  	INC	HL
    1565/    38CC : 56                  	LD	D,(HL)		; MSB of string address
    1566/    38CD : 2A A3 C0            	LD	HL,(BASTXT)	; Point to start of program
    1567/    38D0 : CD 6C 35            	CALL	CPDEHL		; Is string before program?
    1568/    38D3 : D2 EA 38            	JP	NC,CRESTR	; Yes - Create string entry
    1569/    38D6 : 2A 9F C0            	LD	HL,(STRSPC)	; Point to string space
    1570/    38D9 : CD 6C 35            	CALL	CPDEHL		; Is string literal in program?
    1571/    38DC : D1                  	POP	DE		; Restore address of string
    1572/    38DD : D2 F2 38            	JP	NC,MVSTPT	; Yes - Set up pointer
    1573/    38E0 : 21 04 C1            	LD	HL,TMPSTR	; Temporary string pool
    1574/    38E3 : CD 6C 35            	CALL	CPDEHL		; Is string in temporary pool?
    1575/    38E6 : D2 F2 38            	JP	NC,MVSTPT	; No - Set up pointer
    1576/    38E9 : 3E                  	DB	3EH		; Skip "POP DE"
    1577/    38EA : D1                  CRESTR: POP	DE		; Restore address of string
    1578/    38EB : CD A1 41            	CALL	BAKTMP		; Back to last tmp-str entry
    1579/    38EE : EB                  	EX	DE,HL		; Address of string entry
    1580/    38EF : CD DA 3F            	CALL	SAVSTR		; Save string in string area
    1581/    38F2 : CD A1 41            MVSTPT: CALL	BAKTMP		; Back to last tmp-str entry
    1582/    38F5 : E1                  	POP	HL		; Get string pointer
    1583/    38F6 : CD A4 45            	CALL	DETHL4		; Move string pointer to var
    1584/    38F9 : E1                  	POP	HL		; Restore code string address
    1585/    38FA : C9                  	RET
    1586/    38FB :                     ;
    1587/    38FB : E5                  LETNUM: PUSH	HL		; Save address of variable
    1588/    38FC : CD A1 45            	CALL	FPTHL		; Move value to variable
    1589/    38FF : D1                  	POP	DE		; Restore address of variable
    1590/    3900 : E1                  	POP	HL		; Restore code string address
    1591/    3901 : C9                  	RET
    1592/    3902 :                     ;
    1593/    3902 : CD C8 42            ON:	CALL	GETINT		; Get integer 0-255
    1594/    3905 : 7E                  	LD	A,(HL)		; Get "GOTO" or "GOSUB" token
    1595/    3906 : 47                  	LD	B,A		; Save in B
    1596/    3907 : FE 8C               	CP	ZGOSUB		; "GOSUB" token?
    1597/    3909 : CA 11 39            	JP	Z,ONGO		; Yes - Find line number
    1598/    390C : CD 72 35            	CALL	CHKSYN		; Make sure it's "GOTO"
    1599/    390F : 88                  	DB	ZGOTO		; "GOTO" token
    1600/    3910 : 2B                  	DEC	HL		; Cancel increment
    1601/    3911 : 4B                  ONGO:	LD	C,E		; Integer of branch value
    1602/    3912 : 0D                  ONGOLP: DEC	C		; Count branches
    1603/    3913 : 78                  	LD	A,B		; Get "GOTO" or "GOSUB" token
    1604/    3914 : CA E2 36            	JP	Z,ONJMP		; Go to that line if right one
    1605/    3917 : CD C7 37            	CALL	GETLN		; Get line number to DE
    1606/    391A : FE 2C               	CP	','		; Another line number?
    1607/    391C : C0                  	RET	NZ		; No - Drop through
    1608/    391D : C3 12 39            	JP	ONGOLP		; Yes - loop
    1609/    3920 :                     ;
    1610/    3920 : CD 79 3B            IF_:	CALL	EVAL		; Evaluate expression
    1611/    3923 : 7E                  	LD	A,(HL)		; Get token
    1612/    3924 : FE 88               	CP	ZGOTO		; "GOTO" token?
    1613/    3926 : CA 2E 39            	JP	Z,IFGO		; Yes - Get line
    1614/    3929 : CD 72 35            	CALL	CHKSYN		; Make sure it's "THEN"
    1615/    392C : A9                  	DB	ZTHEN		; "THEN" token
    1616/    392D : 2B                  	DEC	HL		; Cancel increment
    1617/    392E : CD 6A 3B            IFGO:	CALL	TSTNUM		; Make sure it's numeric
    1618/    3931 : CD 49 45            	CALL	TSTSGN		; Test state of expression
    1619/    3934 : CA 93 38            	JP	Z,REM		; False - Drop through
    1620/    3937 : CD FA 36            	CALL	GETCHR		; Get next character
    1621/    393A : DA 4E 38            	JP	C,GOTO		; Number - GOTO that line
    1622/    393D : C3 E1 36            	JP	IFJMP		; Otherwise do statement
    1623/    3940 :                     ;
    1624/    3940 : 2B                  MRPRNT: DEC	HL		; DEC 'cos GETCHR INCs
    1625/    3941 : CD FA 36            	CALL	GETCHR		; Get next character
    1626/    3944 : CA A2 39            PRINT:	JP	Z,PRCRLF	; CRLF if just PRINT
    1627/    3947 : C8                  PRNTLP: RET	Z		; End of list - Exit
    1628/    3948 : FE A5               	CP	ZTAB		; "TAB(" token?
    1629/    394A : CA D5 39            	JP	Z,DOTAB		; Yes - Do TAB routine
    1630/    394D : FE A8               	CP	ZSPC		; "SPC(" token?
    1631/    394F : CA D5 39            	JP	Z,DOTAB		; Yes - Do SPC routine
    1632/    3952 : E5                  	PUSH	HL		; Save code string address
    1633/    3953 : FE 2C               	CP	','		; Comma?
    1634/    3955 : CA BE 39            	JP	Z,DOCOM		; Yes - Move to next zone
    1635/    3958 : FE 3B               	CP	59;";"		; Semi-colon?
    1636/    395A : CA F8 39            	JP	Z,NEXITM	; Do semi-colon routine
    1637/    395D : C1                  	POP	BC		; Code string address to BC
    1638/    395E : CD 79 3B            	CALL	EVAL		; Evaluate expression
    1639/    3961 : E5                  	PUSH	HL		; Save code string address
    1640/    3962 : 3A F2 C0            	LD	A,(TYPE)	; Get variable type
    1641/    3965 : B7                  	OR	A		; Is it a string variable?
    1642/    3966 : C2 8E 39            	JP	NZ,PRNTST	; Yes - Output string contents
    1643/    3969 : CD EE 46            	CALL	NUMASC		; Convert number to text
    1644/    396C : CD FE 3F            	CALL	CRTST		; Create temporary string
    1645/    396F : 36 20               	LD	(HL),' '	; Followed by a space
    1646/    3971 : 2A 29 C1            	LD	HL,(FPREG)	; Get length of output
    1647/    3974 : 34                  	INC	(HL)		; Plus 1 for the space
    1648/    3975 : 2A 29 C1            	LD	HL,(FPREG)	; < Not needed >
    1649/    3978 : 3A 87 C0            	LD	A,(LWIDTH)	; Get width of line
    1650/    397B : 47                  	LD	B,A		; To B
    1651/    397C : 04                  	INC	B		; Width 255 (No limit)?
    1652/    397D : CA 8A 39            	JP	Z,PRNTNB	; Yes - Output number string
    1653/    3980 : 04                  	INC	B		; Adjust it
    1654/    3981 : 3A F0 C0            	LD	A,(CURPOS)	; Get cursor position
    1655/    3984 : 86                  	ADD	A,(HL)		; Add length of string
    1656/    3985 : 3D                  	DEC	A		; Adjust it
    1657/    3986 : B8                  	CP	B		; Will output fit on this line?
    1658/    3987 : D4 A2 39            	CALL	NC,PRCRLF	; No - CRLF first
    1659/    398A : CD 43 40            PRNTNB: CALL	PRS1		; Output string at (HL)
    1660/    398D : AF                  	XOR	A		; Skip CALL by setting 'z' flag
    1661/    398E : C4 43 40            PRNTST: CALL	NZ,PRS1		; Output string at (HL)
    1662/    3991 : E1                  	POP	HL		; Restore code string address
    1663/    3992 : C3 40 39            	JP	MRPRNT		; See if more to PRINT
    1664/    3995 :                     ;
    1665/    3995 : 3A F0 C0            STTLIN: LD	A,(CURPOS)	; Make sure on new line
    1666/    3998 : B7                  	OR	A		; Already at start?
    1667/    3999 : C8                  	RET	Z		; Yes - Do nothing
    1668/    399A : C3 A2 39            	JP	PRCRLF		; Start a new line
    1669/    399D :                     ;
    1670/    399D : 36 00               ENDINP: LD	(HL),0		; Mark end of buffer
    1671/    399F : 21 A5 C0            	LD	HL,BUFFER-1	; Point to buffer
    1672/    39A2 : 3E 0D               PRCRLF: LD	A,CR		; Load a CR
    1673/    39A4 : CD 7D 35            	CALL	OUTC		; Output character
    1674/    39A7 : 3E 0A               	LD	A,LF		; Load a LF
    1675/    39A9 : CD 7D 35            	CALL	OUTC		; Output character
    1676/    39AC : AF                  DONULL: XOR	A		; Set to position 0
    1677/    39AD : 32 F0 C0            	LD	(CURPOS),A	; Store it
    1678/    39B0 : 3A 86 C0            	LD	A,(NULLS)	; Get number of nulls
    1679/    39B3 : 3D                  NULLP:	DEC	A		; Count them
    1680/    39B4 : C8                  	RET	Z		; Return if done
    1681/    39B5 : F5                  	PUSH	AF		; Save count
    1682/    39B6 : AF                  	XOR	A		; Load a null
    1683/    39B7 : CD 7D 35            	CALL	OUTC		; Output it
    1684/    39BA : F1                  	POP	AF		; Restore count
    1685/    39BB : C3 B3 39            	JP	NULLP		; Keep counting
    1686/    39BE :                     ;
    1687/    39BE : 3A 88 C0            DOCOM:	LD	A,(COMMAN)	; Get comma width
    1688/    39C1 : 47                  	LD	B,A		; Save in B
    1689/    39C2 : 3A F0 C0            	LD	A,(CURPOS)	; Get current position
    1690/    39C5 : B8                  	CP	B		; Within the limit?
    1691/    39C6 : D4 A2 39            	CALL	NC,PRCRLF	; No - output CRLF
    1692/    39C9 : D2 F8 39            	JP	NC,NEXITM	; Get next item
    1693/    39CC : D6 0E               ZONELP: SUB	14		; Next zone of 14 characters
    1694/    39CE : D2 CC 39            	JP	NC,ZONELP	; Repeat if more zones
    1695/    39D1 : 2F                  	CPL			; Number of spaces to output
    1696/    39D2 : C3 ED 39            	JP	ASPCS		; Output them
    1697/    39D5 :                     ;
    1698/    39D5 : F5                  DOTAB:	PUSH	AF		; Save token
    1699/    39D6 : CD C5 42            	CALL	FNDNUM		; Evaluate expression
    1700/    39D9 : CD 72 35            	CALL	CHKSYN		; Make sure ")" follows
    1701/    39DC : 29                  	DB	")"
    1702/    39DD : 2B                  	DEC	HL		; Back space on to ")"
    1703/    39DE : F1                  	POP	AF		; Restore token
    1704/    39DF : D6 A8               	SUB	ZSPC		; Was it "SPC(" ?
    1705/    39E1 : E5                  	PUSH	HL		; Save code string address
    1706/    39E2 : CA E8 39            	JP	Z,DOSPC	; Yes - Do 'E' spaces
    1707/    39E5 : 3A F0 C0            	LD	A,(CURPOS)	; Get current position
    1708/    39E8 : 2F                  DOSPC:	CPL			; Number of spaces to print to
    1709/    39E9 : 83                  	ADD	A,E		; Total number to print
    1710/    39EA : D2 F8 39            	JP	NC,NEXITM	; TAB < Current POS(X)
    1711/    39ED : 3C                  ASPCS:	INC	A		; Output A spaces
    1712/    39EE : 47                  	LD	B,A		; Save number to print
    1713/    39EF : 3E 20               	LD	A,' '		; Space
    1714/    39F1 : CD 7D 35            SPCLP:	CALL	OUTC		; Output character in A
    1715/    39F4 : 05                  	DEC	B		; Count them
    1716/    39F5 : C2 F1 39            	JP	NZ,SPCLP	; Repeat if more
    1717/    39F8 : E1                  NEXITM: POP	HL		; Restore code string address
    1718/    39F9 : CD FA 36            	CALL	GETCHR		; Get next character
    1719/    39FC : C3 47 39            	JP	PRNTLP		; More to print
    1720/    39FF :                     ;
    1721/    39FF : 3F 52 65 64 6F 20   REDO:	DB	"?Redo from start",CR,LF,0
             3A05 : 66 72 6F 6D 20 73 
             3A0B : 74 61 72 74 0D 0A 
             3A11 : 00                
    1722/    3A12 :                     ;
    1723/    3A12 : 3A 12 C1            BADINP: LD	A,(READFG)	; READ or INPUT?
    1724/    3A15 : B7                  	OR	A
    1725/    3A16 : C2 9E 32            	JP	NZ,DATSNR	; READ - ?SN Error
    1726/    3A19 : C1                  	POP	BC		; Throw away code string addr
    1727/    3A1A : 21 FF 39            	LD	HL,REDO		; "Redo from start" message
    1728/    3A1D : CD 40 40            	CALL	PRS		; Output string
    1729/    3A20 : C3 EF 33            	JP	DOAGN		; Do last INPUT again
    1730/    3A23 :                     ;
    1731/    3A23 : CD AB 3F            INPUT:	CALL	IDTEST		; Test for illegal direct
    1732/    3A26 : 7E                  	LD	A,(HL)		; Get character after "INPUT"
    1733/    3A27 : FE 22               	CP	'"'		; Is there a prompt string?
    1734/    3A29 : 3E 00               	LD	A,0		; Clear A and leave flags
    1735/    3A2B : 32 8A C0            	LD	(CTLOFG),A	; Enable output
    1736/    3A2E : C2 3D 3A            	JP	NZ,NOPMPT	; No prompt - get input
    1737/    3A31 : CD FF 3F            	CALL	QTSTR		; Get string terminated by '"'
    1738/    3A34 : CD 72 35            	CALL	CHKSYN		; Check for ';' after prompt
    1739/    3A37 : 3B                  	DB	';'
    1740/    3A38 : E5                  	PUSH	HL		; Save code string address
    1741/    3A39 : CD 43 40            	CALL	PRS1		; Output prompt string
    1742/    3A3C : 3E                  	DB	3EH		; Skip "PUSH HL"
    1743/    3A3D : E5                  NOPMPT: PUSH	HL		; Save code string address
    1744/    3A3E : CD F3 33            	CALL	PROMPT		; Get input with "? " prompt
    1745/    3A41 : C1                  	POP	BC		; Restore code string address
    1746/    3A42 : DA 49 37            	JP	C,INPBRK	; Break pressed - Exit
    1747/    3A45 : 23                  	INC	HL		; Next byte
    1748/    3A46 : 7E                  	LD	A,(HL)		; Get it
    1749/    3A47 : B7                  	OR	A		; End of line?
    1750/    3A48 : 2B                  	DEC	HL		; Back again
    1751/    3A49 : C5                  	PUSH	BC		; Re-save code string address
    1752/    3A4A : CA 90 38            	JP	Z,NXTDTA	; Yes - Find next DATA stmt
    1753/    3A4D : 36 2C               	LD	(HL),','	; Store comma as separator
    1754/    3A4F : C3 57 3A            	JP	NXTITM		; Get next item
    1755/    3A52 :                     ;
    1756/    3A52 : E5                  READ:	PUSH	HL		; Save code string address
    1757/    3A53 : 2A 21 C1            	LD	HL,(NXTDAT)	; Next DATA statement
    1758/    3A56 : F6                  	DB	0F6H		; Flag "READ"
    1759/    3A57 : AF                  NXTITM: XOR	A		; Flag "INPUT"
    1760/    3A58 : 32 12 C1            	LD	(READFG),A	; Save "READ"/"INPUT" flag
    1761/    3A5B : E3                  	EX	(SP),HL		; Get code str' , Save pointer
    1762/    3A5C : C3 63 3A            	JP	GTVLUS		; Get values
    1763/    3A5F :                     ;
    1764/    3A5F : CD 72 35            NEDMOR: CALL	CHKSYN		; Check for comma between items
    1765/    3A62 : 2C                  	DB	','
    1766/    3A63 : CD 5D 3D            GTVLUS: CALL	GETVAR		; Get variable name
    1767/    3A66 : E3                  	EX	(SP),HL		; Save code str" , Get pointer
    1768/    3A67 : D5                  	PUSH	DE		; Save variable address
    1769/    3A68 : 7E                  	LD	A,(HL)		; Get next "INPUT"/"DATA" byte
    1770/    3A69 : FE 2C               	CP	','		; Comma?
    1771/    3A6B : CA 8B 3A            	JP	Z,ANTVLU	; Yes - Get another value
    1772/    3A6E : 3A 12 C1            	LD	A,(READFG)	; Is it READ?
    1773/    3A71 : B7                  	OR	A
    1774/    3A72 : C2 F8 3A            	JP	NZ,FDTLP	; Yes - Find next DATA stmt
    1775/    3A75 : 3E 3F               	LD	A,'?'		; More INPUT needed
    1776/    3A77 : CD 7D 35            	CALL	OUTC		; Output character
    1777/    3A7A : CD F3 33            	CALL	PROMPT		; Get INPUT with prompt
    1778/    3A7D : D1                  	POP	DE		; Variable address
    1779/    3A7E : C1                  	POP	BC		; Code string address
    1780/    3A7F : DA 49 37            	JP	C,INPBRK	; Break pressed
    1781/    3A82 : 23                  	INC	HL		; Point to next DATA byte
    1782/    3A83 : 7E                  	LD	A,(HL)		; Get byte
    1783/    3A84 : B7                  	OR	A		; Is it zero (No input) ?
    1784/    3A85 : 2B                  	DEC	HL		; Back space INPUT pointer
    1785/    3A86 : C5                  	PUSH	BC		; Save code string address
    1786/    3A87 : CA 90 38            	JP	Z,NXTDTA	; Find end of buffer
    1787/    3A8A : D5                  	PUSH	DE		; Save variable address
    1788/    3A8B : 3A F2 C0            ANTVLU: LD	A,(TYPE)	; Check data type
    1789/    3A8E : B7                  	OR	A		; Is it numeric?
    1790/    3A8F : CA B5 3A            	JP	Z,INPBIN	; Yes - Convert to binary
    1791/    3A92 : CD FA 36            	CALL	GETCHR		; Get next character
    1792/    3A95 : 57                  	LD	D,A		; Save input character
    1793/    3A96 : 47                  	LD	B,A		; Again
    1794/    3A97 : FE 22               	CP	'"'		; Start of literal sting?
    1795/    3A99 : CA A9 3A            	JP	Z,STRENT	; Yes - Create string entry
    1796/    3A9C : 3A 12 C1            	LD	A,(READFG)	; "READ" or "INPUT" ?
    1797/    3A9F : B7                  	OR	A
    1798/    3AA0 : 57                  	LD	D,A		; Save 00 if "INPUT"
    1799/    3AA1 : CA A6 3A            	JP	Z,ITMSEP	; "INPUT" - End with 00
    1800/    3AA4 : 16 3A               	LD	D,':'		; "DATA" - End with 00 or ':'
    1801/    3AA6 : 06 2C               ITMSEP: LD	B,','		; Item separator
    1802/    3AA8 : 2B                  	DEC	HL		; Back space for DTSTR
    1803/    3AA9 : CD 02 40            STRENT: CALL	DTSTR		; Get string terminated by D
    1804/    3AAC : EB                  	EX	DE,HL		; String address to DE
    1805/    3AAD : 21 C0 3A            	LD	HL,LTSTND	; Where to go after LETSTR
    1806/    3AB0 : E3                  	EX	(SP),HL		; Save HL , get input pointer
    1807/    3AB1 : D5                  	PUSH	DE		; Save address of string
    1808/    3AB2 : C3 C3 38            	JP	LETSTR		; Assign string to variable
    1809/    3AB5 :                     ;
    1810/    3AB5 : CD FA 36            INPBIN: CALL	GETCHR		; Get next character
    1811/    3AB8 : CD 50 46            	CALL	ASCTFP		; Convert ASCII to FP number
    1812/    3ABB : E3                  	EX	(SP),HL		; Save input ptr, Get var addr
    1813/    3ABC : CD A1 45            	CALL	FPTHL		; Move FPREG to variable
    1814/    3ABF : E1                  	POP	HL		; Restore input pointer
    1815/    3AC0 : 2B                  LTSTND: DEC	HL		; DEC 'cos GETCHR INCs
    1816/    3AC1 : CD FA 36            	CALL	GETCHR		; Get next character
    1817/    3AC4 : CA CC 3A            	JP	Z,MORDT		; End of line - More needed?
    1818/    3AC7 : FE 2C               	CP	','		; Another value?
    1819/    3AC9 : C2 12 3A            	JP	NZ,BADINP	; No - Bad input
    1820/    3ACC : E3                  MORDT:	EX	(SP),HL		; Get code string address
    1821/    3ACD : 2B                  	DEC	HL		; DEC 'cos GETCHR INCs
    1822/    3ACE : CD FA 36            	CALL	GETCHR		; Get next character
    1823/    3AD1 : C2 5F 3A            	JP	NZ,NEDMOR	; More needed - Get it
    1824/    3AD4 : D1                  	POP	DE		; Restore DATA pointer
    1825/    3AD5 : 3A 12 C1            	LD	A,(READFG)	; "READ" or "INPUT" ?
    1826/    3AD8 : B7                  	OR	A
    1827/    3AD9 : EB                  	EX	DE,HL		; DATA pointer to HL
    1828/    3ADA : C2 20 37            	JP	NZ,UPDATA	; Update DATA pointer if "READ"
    1829/    3ADD : D5                  	PUSH	DE		; Save code string address
    1830/    3ADE : B6                  	OR	(HL)		; More input given?
    1831/    3ADF : 21 E7 3A            	LD	HL,EXTIG	; "?Extra ignored" message
    1832/    3AE2 : C4 40 40            	CALL	NZ,PRS		; Output string if extra given
    1833/    3AE5 : E1                  	POP	HL		; Restore code string address
    1834/    3AE6 : C9                  	RET
    1835/    3AE7 :                     ;
    1836/    3AE7 : 3F 45 78 74 72 61   EXTIG:	DB	"?Extra ignored",CR,LF,0
             3AED : 20 69 67 6E 6F 72 
             3AF3 : 65 64 0D 0A 00    
    1837/    3AF8 :                     ;
    1838/    3AF8 : CD 91 38            FDTLP:	CALL	DATA		; Get next statement
    1839/    3AFB : B7                  	OR	A		; End of line?
    1840/    3AFC : C2 11 3B            	JP	NZ,FANDT	; No - See if DATA statement
    1841/    3AFF : 23                  	INC	HL
    1842/    3B00 : 7E                  	LD	A,(HL)		; End of program?
    1843/    3B01 : 23                  	INC	HL
    1844/    3B02 : B6                  	OR	(HL)		; 00 00 Ends program
    1845/    3B03 : 1E 06               	LD	E,OD		; ?OD Error
    1846/    3B05 : CA B8 32            	JP	Z,ERROR_	; Yes - Out of DATA
    1847/    3B08 : 23                  	INC	HL
    1848/    3B09 : 5E                  	LD	E,(HL)		; LSB of line number
    1849/    3B0A : 23                  	INC	HL
    1850/    3B0B : 56                  	LD	D,(HL)		; MSB of line number
    1851/    3B0C : EB                  	EX	DE,HL
    1852/    3B0D : 22 0E C1            	LD	(DATLIN),HL	; Set line of current DATA item
    1853/    3B10 : EB                  	EX	DE,HL
    1854/    3B11 : CD FA 36            FANDT:	CALL	GETCHR		; Get next character
    1855/    3B14 : FE 83               	CP	ZDATA		; "DATA" token
    1856/    3B16 : C2 F8 3A            	JP	NZ,FDTLP	; No "DATA" - Keep looking
    1857/    3B19 : C3 8B 3A            	JP	ANTVLU		; Found - Convert input
    1858/    3B1C :                     ;
    1859/    3B1C : 11 00 00            NEXT:	LD	DE,0		; In case no index given
    1860/    3B1F : C4 5D 3D            NEXT1:	CALL	NZ,GETVAR	; Get index address
    1861/    3B22 : 22 13 C1            	LD	(BRKLIN),HL	; Save code string address
    1862/    3B25 : CD 4D 32            	CALL	BAKSTK		; Look for "FOR" block
    1863/    3B28 : C2 AA 32            	JP	NZ,NFERR	; No "FOR" - ?NF Error
    1864/    3B2B : F9                  	LD	SP,HL		; Clear nested loops
    1865/    3B2C : D5                  	PUSH	DE		; Save index address
    1866/    3B2D : 7E                  	LD	A,(HL)		; Get sign of STEP
    1867/    3B2E : 23                  	INC	HL
    1868/    3B2F : F5                  	PUSH	AF		; Save sign of STEP
    1869/    3B30 : D5                  	PUSH	DE		; Save index address
    1870/    3B31 : CD 87 45            	CALL	PHLTFP		; Move index value to FPREG
    1871/    3B34 : E3                  	EX	(SP),HL		; Save address of TO value
    1872/    3B35 : E5                  	PUSH	HL		; Save address of index
    1873/    3B36 : CD F4 42            	CALL	ADDPHL		; Add STEP to index value
    1874/    3B39 : E1                  	POP	HL		; Restore address of index
    1875/    3B3A : CD A1 45            	CALL	FPTHL		; Move value to index variable
    1876/    3B3D : E1                  	POP	HL		; Restore address of TO value
    1877/    3B3E : CD 98 45            	CALL	LOADFP		; Move TO value to BCDE
    1878/    3B41 : E5                  	PUSH	HL		; Save address of line of FOR
    1879/    3B42 : CD C4 45            	CALL	CMPNUM		; Compare index with TO value
    1880/    3B45 : E1                  	POP	HL		; Restore address of line num
    1881/    3B46 : C1                  	POP	BC		; Address of sign of STEP
    1882/    3B47 : 90                  	SUB	B		; Compare with expected sign
    1883/    3B48 : CD 98 45            	CALL	LOADFP		; BC = Loop stmt,DE = Line num
    1884/    3B4B : CA 57 3B            	JP	Z,KILFOR	; Loop finished - Terminate it
    1885/    3B4E : EB                  	EX	DE,HL		; Loop statement line number
    1886/    3B4F : 22 A1 C0            	LD	(LINEAT),HL	; Set loop line number
    1887/    3B52 : 69                  	LD	L,C		; Set code string to loop
    1888/    3B53 : 60                  	LD	H,B
    1889/    3B54 : C3 B6 36            	JP	PUTFID		; Put back "FOR" and continue
    1890/    3B57 :                     ;
    1891/    3B57 : F9                  KILFOR: LD	SP,HL		; Remove "FOR" block
    1892/    3B58 : 2A 13 C1            	LD	HL,(BRKLIN)	; Code string after "NEXT"
    1893/    3B5B : 7E                  	LD	A,(HL)		; Get next byte in code string
    1894/    3B5C : FE 2C               	CP	','		; More NEXTs ?
    1895/    3B5E : C2 BA 36            	JP	NZ,RUNCNT	; No - Do next statement
    1896/    3B61 : CD FA 36            	CALL	GETCHR		; Position to index name
    1897/    3B64 : CD 1F 3B            	CALL	NEXT1		; Re-enter NEXT routine
    1898/    3B67 :                     ; < will not RETurn to here , Exit to RUNCNT or Loop >
    1899/    3B67 :                     ;
    1900/    3B67 : CD 79 3B            GETNUM: CALL	EVAL		; Get a numeric expression
    1901/    3B6A : F6                  TSTNUM: DB	0F6H		; Clear carry (numeric)
    1902/    3B6B : 37                  TSTSTR: SCF			; Set carry (string)
    1903/    3B6C : 3A F2 C0            CHKTYP: LD	A,(TYPE)	; Check types match
    1904/    3B6F : 8F                  	ADC	A,A		; Expected + actual
    1905/    3B70 : B7                  	OR	A		; Clear carry , set parity
    1906/    3B71 : E8                  	RET	PE		; Even parity - Types match
    1907/    3B72 : C3 B6 32            	JP	TMERR		; Different types - Error
    1908/    3B75 :                     ;
    1909/    3B75 : CD 72 35            OPNPAR: CALL	CHKSYN		; Make sure "(" follows
    1910/    3B78 : 28                  	DB	"("
    1911/    3B79 : 2B                  EVAL:	DEC	HL		; Evaluate expression & save
    1912/    3B7A : 16 00               	LD	D,0		; Precedence value
    1913/    3B7C : D5                  EVAL1:	PUSH	DE		; Save precedence
    1914/    3B7D : 0E 01               	LD	C,1
    1915/    3B7F : CD 81 32            	CALL	CHKSTK		; Check for 1 level of stack
    1916/    3B82 : CD F0 3B            	CALL	OPRND		; Get next expression value
    1917/    3B85 : 22 15 C1            EVAL2:	LD	(NXTOPR),HL	; Save address of next operator
    1918/    3B88 : 2A 15 C1            EVAL3:	LD	HL,(NXTOPR)	; Restore address of next opr
    1919/    3B8B : C1                  	POP	BC		; Precedence value and operator
    1920/    3B8C : 78                  	LD	A,B		; Get precedence value
    1921/    3B8D : FE 78               	CP	78H		; "AND" or "OR" ?
    1922/    3B8F : D4 6A 3B            	CALL	NC,TSTNUM	; No - Make sure it's a number
    1923/    3B92 : 7E                  	LD	A,(HL)		; Get next operator / function
    1924/    3B93 : 16 00               	LD	D,0		; Clear Last relation
    1925/    3B95 : D6 B3               RLTLP:	SUB	ZGTR		; ">" Token
    1926/    3B97 : DA B1 3B            	JP	C,FOPRND	; + - * / ^ AND OR - Test it
    1927/    3B9A : FE 03               	CP	ZLTH+1-ZGTR	; < = >
    1928/    3B9C : D2 B1 3B            	JP	NC,FOPRND	; Function - Call it
    1929/    3B9F : FE 01               	CP	ZEQUAL-ZGTR	; "="
    1930/    3BA1 : 17                  	RLA			; <- Test for legal
    1931/    3BA2 : AA                  	XOR	D		; <- combinations of < = >
    1932/    3BA3 : BA                  	CP	D		; <- by combining last token
    1933/    3BA4 : 57                  	LD	D,A		; <- with current one
    1934/    3BA5 : DA A4 32            	JP	C,SNERR		; Error if "<<' '==" or ">>"
    1935/    3BA8 : 22 0A C1            	LD	(CUROPR),HL	; Save address of current token
    1936/    3BAB : CD FA 36            	CALL	GETCHR		; Get next character
    1937/    3BAE : C3 95 3B            	JP	RLTLP		; Treat the two as one
    1938/    3BB1 :                     ;
    1939/    3BB1 : 7A                  FOPRND: LD	A,D		; < = > found ?
    1940/    3BB2 : B7                  	OR	A
    1941/    3BB3 : C2 D8 3C            	JP	NZ,TSTRED	; Yes - Test for reduction
    1942/    3BB6 : 7E                  	LD	A,(HL)		; Get operator token
    1943/    3BB7 : 22 0A C1            	LD	(CUROPR),HL	; Save operator address
    1944/    3BBA : D6 AC               	SUB	ZPLUS		; Operator or function?
    1945/    3BBC : D8                  	RET	C		; Neither - Exit
    1946/    3BBD : FE 07               	CP	ZOR+1-ZPLUS	; Is it + - * / ^ AND OR ?
    1947/    3BBF : D0                  	RET	NC		; No - Exit
    1948/    3BC0 : 5F                  	LD	E,A		; Coded operator
    1949/    3BC1 : 3A F2 C0            	LD	A,(TYPE)	; Get data type
    1950/    3BC4 : 3D                  	DEC	A		; FF = numeric , 00 = string
    1951/    3BC5 : B3                  	OR	E		; Combine with coded operator
    1952/    3BC6 : 7B                  	LD	A,E		; Get coded operator
    1953/    3BC7 : CA 36 41            	JP	Z,CONCAT	; String concatenation
    1954/    3BCA : 07                  	RLCA			; Times 2
    1955/    3BCB : 83                  	ADD	A,E		; Times 3
    1956/    3BCC : 5F                  	LD	E,A		; To DE (D is 0)
    1957/    3BCD : 21 96 31            	LD	HL,PRITAB	; Precedence table
    1958/    3BD0 : 19                  	ADD	HL,DE		; To the operator concerned
    1959/    3BD1 : 78                  	LD	A,B		; Last operator precedence
    1960/    3BD2 : 56                  	LD	D,(HL)		; Get evaluation precedence
    1961/    3BD3 : BA                  	CP	D		; Compare with eval precedence
    1962/    3BD4 : D0                  	RET	NC		; Exit if higher precedence
    1963/    3BD5 : 23                  	INC	HL		; Point to routine address
    1964/    3BD6 : CD 6A 3B            	CALL	TSTNUM		; Make sure it's a number
    1965/    3BD9 :                     ;
    1966/    3BD9 : C5                  STKTHS: PUSH	BC		; Save last precedence & token
    1967/    3BDA : 01 88 3B            	LD	BC,EVAL3	; Where to go on prec' break
    1968/    3BDD : C5                  	PUSH	BC		; Save on stack for return
    1969/    3BDE : 43                  	LD	B,E		; Save operator
    1970/    3BDF : 4A                  	LD	C,D		; Save precedence
    1971/    3BE0 : CD 7A 45            	CALL	STAKFP		; Move value to stack
    1972/    3BE3 : 58                  	LD	E,B		; Restore operator
    1973/    3BE4 : 51                  	LD	D,C		; Restore precedence
    1974/    3BE5 : 4E                  	LD	C,(HL)		; Get LSB of routine address
    1975/    3BE6 : 23                  	INC	HL
    1976/    3BE7 : 46                  	LD	B,(HL)		; Get MSB of routine address
    1977/    3BE8 : 23                  	INC	HL
    1978/    3BE9 : C5                  	PUSH	BC		; Save routine address
    1979/    3BEA : 2A 0A C1            	LD	HL,(CUROPR)	; Address of current operator
    1980/    3BED : C3 7C 3B            	JP	EVAL1		; Loop until prec' break
    1981/    3BF0 :                     ;
    1982/    3BF0 : AF                  OPRND:	XOR	A		; Get operand routine
    1983/    3BF1 : 32 F2 C0            	LD	(TYPE),A	; Set numeric expected
    1984/    3BF4 : CD FA 36            	CALL	GETCHR		; Get next character
    1985/    3BF7 : 1E 24               	LD	E,MO		; ?MO Error
    1986/    3BF9 : CA B8 32            	JP	Z,ERROR_	; No operand - Error
    1987/    3BFC : DA 50 46            	JP	C,ASCTFP	; Number - Get value
    1988/    3BFF : CD 98 37            	CALL	CHKLTR		; See if a letter
    1989/    3C02 : D2 57 3C            	JP	NC,CONVAR	; Letter - Find variable
    1990/    3C05 : FE 26               	CP	'&'		; &H = HEX, &B = BINARY
    1991/    3C07 : 20 12               	JR	NZ, NOTAMP
    1992/    3C09 : CD FA 36            	CALL	GETCHR		; Get next character
    1993/    3C0C : FE 48               	CP	'H'		; Hex number indicated? [function added]
    1994/    3C0E : CA 93 4A            	JP	Z,HEXTFP	; Convert Hex to FPREG
    1995/    3C11 : FE 42               	CP	'B'		; Binary number indicated? [function added]
    1996/    3C13 : CA 03 4B            	JP	Z,BINTFP	; Convert Bin to FPREG
    1997/    3C16 : 1E 02               	LD	E,SN		; If neither then a ?SN Error
    1998/    3C18 : CA B8 32            	JP	Z,ERROR_
    1999/    3C1B : FE AC               NOTAMP: CP	ZPLUS		; '+' Token ?
    2000/    3C1D : CA F0 3B            	JP	Z,OPRND		; Yes - Look for operand
    2001/    3C20 : FE 2E               	CP	'.'		; '.' ?
    2002/    3C22 : CA 50 46            	JP	Z,ASCTFP	; Yes - Create FP number
    2003/    3C25 : FE AD               	CP	ZMINUS		; '-' Token ?
    2004/    3C27 : CA 46 3C            	JP	Z,MINUS		; Yes - Do minus
    2005/    3C2A : FE 22               	CP	'"'		; Literal string ?
    2006/    3C2C : CA FF 3F            	JP	Z,QTSTR		; Get string terminated by '"'
    2007/    3C2F : FE AA               	CP	ZNOT		; "NOT" Token ?
    2008/    3C31 : CA 38 3D            	JP	Z,EVNOT		; Yes - Eval NOT expression
    2009/    3C34 : FE A7               	CP	ZFN		; "FN" Token ?
    2010/    3C36 : CA 63 3F            	JP	Z,DOFN		; Yes - Do FN routine
    2011/    3C39 : D6 B6               	SUB	ZSGN		; Is it a function?
    2012/    3C3B : D2 68 3C            	JP	NC,FNOFST	; Yes - Evaluate function
    2013/    3C3E : CD 75 3B            EVLPAR: CALL	OPNPAR		; Evaluate expression in "()"
    2014/    3C41 : CD 72 35            	CALL	CHKSYN		; Make sure ")" follows
    2015/    3C44 : 29                  	DB	")"
    2016/    3C45 : C9                  	RET
    2017/    3C46 :                     ;
    2018/    3C46 : 16 7D               MINUS:	LD	D,7DH		; '-' precedence
    2019/    3C48 : CD 7C 3B            	CALL	EVAL1		; Evaluate until prec' break
    2020/    3C4B : 2A 15 C1            	LD	HL,(NXTOPR)	; Get next operator address
    2021/    3C4E : E5                  	PUSH	HL		; Save next operator address
    2022/    3C4F : CD 72 45            	CALL	INVSGN		; Negate value
    2023/    3C52 : CD 6A 3B            RETNUM: CALL	TSTNUM		; Make sure it's a number
    2024/    3C55 : E1                  	POP	HL		; Restore next operator address
    2025/    3C56 : C9                  	RET
    2026/    3C57 :                     ;
    2027/    3C57 : CD 5D 3D            CONVAR: CALL	GETVAR		; Get variable address to DE
    2028/    3C5A : E5                  FRMEVL: PUSH	HL		; Save code string address
    2029/    3C5B : EB                  	EX	DE,HL		; Variable address to HL
    2030/    3C5C : 22 29 C1            	LD	(FPREG),HL	; Save address of variable
    2031/    3C5F : 3A F2 C0            	LD	A,(TYPE)	; Get type
    2032/    3C62 : B7                  	OR	A		; Numeric?
    2033/    3C63 : CC 87 45            	CALL	Z,PHLTFP	; Yes - Move contents to FPREG
    2034/    3C66 : E1                  	POP	HL		; Restore code string address
    2035/    3C67 : C9                  	RET
    2036/    3C68 :                     ;
    2037/    3C68 : 06 00               FNOFST: LD	B,0		; Get address of function
    2038/    3C6A : 07                  	RLCA			; Double function offset
    2039/    3C6B : 4F                  	LD	C,A		; BC = Offset in function table
    2040/    3C6C : C5                  	PUSH	BC		; Save adjusted token value
    2041/    3C6D : CD FA 36            	CALL	GETCHR		; Get next character
    2042/    3C70 : 79                  	LD	A,C		; Get adjusted token value
    2043/    3C71 : FE 31               	CP	2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
    2044/    3C73 : DA 8F 3C            	JP	C,FNVAL		; No - Do function
    2045/    3C76 : CD 75 3B            	CALL	OPNPAR		; Evaluate expression	(X,...
    2046/    3C79 : CD 72 35            	CALL	CHKSYN		; Make sure ',' follows
    2047/    3C7C : 2C                  	DB	','
    2048/    3C7D : CD 6B 3B            	CALL	TSTSTR		; Make sure it's a string
    2049/    3C80 : EB                  	EX	DE,HL		; Save code string address
    2050/    3C81 : 2A 29 C1            	LD	HL,(FPREG)	; Get address of string
    2051/    3C84 : E3                  	EX	(SP),HL		; Save address of string
    2052/    3C85 : E5                  	PUSH	HL		; Save adjusted token value
    2053/    3C86 : EB                  	EX	DE,HL		; Restore code string address
    2054/    3C87 : CD C8 42            	CALL	GETINT		; Get integer 0-255
    2055/    3C8A : EB                  	EX	DE,HL		; Save code string address
    2056/    3C8B : E3                  	EX	(SP),HL		; Save integer,HL = adj' token
    2057/    3C8C : C3 97 3C            	JP	GOFUNC		; Jump to string function
    2058/    3C8F :                     ;
    2059/    3C8F : CD 3E 3C            FNVAL:	CALL	EVLPAR		; Evaluate expression
    2060/    3C92 : E3                  	EX	(SP),HL		; HL = Adjusted token value
    2061/    3C93 : 11 52 3C            	LD	DE,RETNUM	; Return number from function
    2062/    3C96 : D5                  	PUSH	DE		; Save on stack
    2063/    3C97 : 01 F5 2F            GOFUNC: LD	BC,FNCTAB	; Function routine addresses
    2064/    3C9A : 09                  	ADD	HL,BC		; Point to right address
    2065/    3C9B : 4E                  	LD	C,(HL)		; Get LSB of address
    2066/    3C9C : 23                  	INC	HL		;
    2067/    3C9D : 66                  	LD	H,(HL)		; Get MSB of address
    2068/    3C9E : 69                  	LD	L,C		; Address to HL
    2069/    3C9F : E9                  	JP	(HL)		; Jump to function
    2070/    3CA0 :                     ;
    2071/    3CA0 : 15                  SGNEXP: DEC	D		; Dee to flag negative exponent
    2072/    3CA1 : FE AD               	CP	ZMINUS		; '-' token ?
    2073/    3CA3 : C8                  	RET	Z		; Yes - Return
    2074/    3CA4 : FE 2D               	CP	'-'		; '-' ASCII ?
    2075/    3CA6 : C8                  	RET	Z		; Yes - Return
    2076/    3CA7 : 14                  	INC	D		; Inc to flag positive exponent
    2077/    3CA8 : FE 2B               	CP	'+'		; '+' ASCII ?
    2078/    3CAA : C8                  	RET	Z		; Yes - Return
    2079/    3CAB : FE AC               	CP	ZPLUS		; '+' token ?
    2080/    3CAD : C8                  	RET	Z		; Yes - Return
    2081/    3CAE : 2B                  	DEC	HL		; DEC 'cos GETCHR INCs
    2082/    3CAF : C9                  	RET			; Return "NZ"
    2083/    3CB0 :                     ;
    2084/    3CB0 : F6                  POR:	DB	0F6H		; Flag "OR"
    2085/    3CB1 : AF                  PAND:	XOR	A		; Flag "AND"
    2086/    3CB2 : F5                  	PUSH	AF		; Save "AND" / "OR" flag
    2087/    3CB3 : CD 6A 3B            	CALL	TSTNUM		; Make sure it's a number
    2088/    3CB6 : CD AC 37            	CALL	DEINT		; Get integer -32768 to 32767
    2089/    3CB9 : F1                  	POP	AF		; Restore "AND" / "OR" flag
    2090/    3CBA : EB                  	EX	DE,HL		; <- Get last
    2091/    3CBB : C1                  	POP	BC		; <- value
    2092/    3CBC : E3                  	EX	(SP),HL		; <- from
    2093/    3CBD : EB                  	EX	DE,HL		; <- stack
    2094/    3CBE : CD 8A 45            	CALL	FPBCDE		; Move last value to FPREG
    2095/    3CC1 : F5                  	PUSH	AF		; Save "AND" / "OR" flag
    2096/    3CC2 : CD AC 37            	CALL	DEINT		; Get integer -32768 to 32767
    2097/    3CC5 : F1                  	POP	AF		; Restore "AND" / "OR" flag
    2098/    3CC6 : C1                  	POP	BC		; Get value
    2099/    3CC7 : 79                  	LD	A,C		; Get LSB
    2100/    3CC8 : 21 21 3F            	LD	HL,ACPASS	; Address of save AC as current
    2101/    3CCB : C2 D3 3C            	JP	NZ,POR1		; Jump if OR
    2102/    3CCE : A3                  	AND	E		; "AND" LSBs
    2103/    3CCF : 4F                  	LD	C,A		; Save LSB
    2104/    3CD0 : 78                  	LD	A,B		; Get MBS
    2105/    3CD1 : A2                  	AND	D		; "AND" MSBs
    2106/    3CD2 : E9                  	JP	(HL)		; Save AC as current (ACPASS)
    2107/    3CD3 :                     ;
    2108/    3CD3 : B3                  POR1:	OR	E		; "OR" LSBs
    2109/    3CD4 : 4F                  	LD	C,A		; Save LSB
    2110/    3CD5 : 78                  	LD	A,B		; Get MSB
    2111/    3CD6 : B2                  	OR	D		; "OR" MSBs
    2112/    3CD7 : E9                  	JP	(HL)		; Save AC as current (ACPASS)
    2113/    3CD8 :                     ;
    2114/    3CD8 : 21 EA 3C            TSTRED: LD	HL,CMPLOG	; Logical compare routine
    2115/    3CDB : 3A F2 C0            	LD	A,(TYPE)	; Get data type
    2116/    3CDE : 1F                  	RRA			; Carry set = string
    2117/    3CDF : 7A                  	LD	A,D		; Get last precedence value
    2118/    3CE0 : 17                  	RLA			; Times 2 plus carry
    2119/    3CE1 : 5F                  	LD	E,A		; To E
    2120/    3CE2 : 16 64               	LD	D,64H		; Relational precedence
    2121/    3CE4 : 78                  	LD	A,B		; Get current precedence
    2122/    3CE5 : BA                  	CP	D		; Compare with last
    2123/    3CE6 : D0                  	RET	NC		; Eval if last was rel' or log'
    2124/    3CE7 : C3 D9 3B            	JP	STKTHS		; Stack this one and get next
    2125/    3CEA :                     ;
    2126/    3CEA : EC 3C               CMPLOG: DW	CMPLG1		; Compare two values / strings
    2127/    3CEC : 79                  CMPLG1: LD	A,C		; Get data type
    2128/    3CED : B7                  	OR	A
    2129/    3CEE : 1F                  	RRA
    2130/    3CEF : C1                  	POP	BC		; Get last expression to BCDE
    2131/    3CF0 : D1                  	POP	DE
    2132/    3CF1 : F5                  	PUSH	AF		; Save status
    2133/    3CF2 : CD 6C 3B            	CALL	CHKTYP		; Check that types match
    2134/    3CF5 : 21 2E 3D            	LD	HL,CMPRES	; Result to comparison
    2135/    3CF8 : E5                  	PUSH	HL		; Save for RETurn
    2136/    3CF9 : CA C4 45            	JP	Z,CMPNUM	; Compare values if numeric
    2137/    3CFC : AF                  	XOR	A		; Compare two strings
    2138/    3CFD : 32 F2 C0            	LD	(TYPE),A	; Set type to numeric
    2139/    3D00 : D5                  	PUSH	DE		; Save string name
    2140/    3D01 : CD 83 41            	CALL	GSTRCU		; Get current string
    2141/    3D04 : 7E                  	LD	A,(HL)		; Get length of string
    2142/    3D05 : 23                  	INC	HL
    2143/    3D06 : 23                  	INC	HL
    2144/    3D07 : 4E                  	LD	C,(HL)		; Get LSB of address
    2145/    3D08 : 23                  	INC	HL
    2146/    3D09 : 46                  	LD	B,(HL)		; Get MSB of address
    2147/    3D0A : D1                  	POP	DE		; Restore string name
    2148/    3D0B : C5                  	PUSH	BC		; Save address of string
    2149/    3D0C : F5                  	PUSH	AF		; Save length of string
    2150/    3D0D : CD 87 41            	CALL	GSTRDE		; Get second string
    2151/    3D10 : CD 98 45            	CALL	LOADFP		; Get address of second string
    2152/    3D13 : F1                  	POP	AF		; Restore length of string 1
    2153/    3D14 : 57                  	LD	D,A		; Length to D
    2154/    3D15 : E1                  	POP	HL		; Restore address of string 1
    2155/    3D16 : 7B                  CMPSTR: LD	A,E		; Bytes of string 2 to do
    2156/    3D17 : B2                  	OR	D		; Bytes of string 1 to do
    2157/    3D18 : C8                  	RET	Z		; Exit if all bytes compared
    2158/    3D19 : 7A                  	LD	A,D		; Get bytes of string 1 to do
    2159/    3D1A : D6 01               	SUB	1
    2160/    3D1C : D8                  	RET	C		; Exit if end of string 1
    2161/    3D1D : AF                  	XOR	A
    2162/    3D1E : BB                  	CP	E		; Bytes of string 2 to do
    2163/    3D1F : 3C                  	INC	A
    2164/    3D20 : D0                  	RET	NC		; Exit if end of string 2
    2165/    3D21 : 15                  	DEC	D		; Count bytes in string 1
    2166/    3D22 : 1D                  	DEC	E		; Count bytes in string 2
    2167/    3D23 : 0A                  	LD	A,(BC)		; Byte in string 2
    2168/    3D24 : BE                  	CP	(HL)		; Compare to byte in string 1
    2169/    3D25 : 23                  	INC	HL		; Move up string 1
    2170/    3D26 : 03                  	INC	BC		; Move up string 2
    2171/    3D27 : CA 16 3D            	JP	Z,CMPSTR	; Same - Try next bytes
    2172/    3D2A : 3F                  	CCF			; Flag difference (">" or "<")
    2173/    3D2B : C3 54 45            	JP	FLGDIF		; "<" gives -1 , ">" gives +1
    2174/    3D2E :                     ;
    2175/    3D2E : 3C                  CMPRES: INC	A		; Increment current value
    2176/    3D2F : 8F                  	ADC	A,A		; Double plus carry
    2177/    3D30 : C1                  	POP	BC		; Get other value
    2178/    3D31 : A0                  	AND	B		; Combine them
    2179/    3D32 : C6 FF               	ADD	A,-1		; Carry set if different
    2180/    3D34 : 9F                  	SBC	A,A		; 00 - Equal , FF - Different
    2181/    3D35 : C3 5B 45            	JP	FLGREL		; Set current value & continue
    2182/    3D38 :                     ;
    2183/    3D38 : 16 5A               EVNOT:	LD	D,5AH		; Precedence value for "NOT"
    2184/    3D3A : CD 7C 3B            	CALL	EVAL1		; Eval until precedence break
    2185/    3D3D : CD 6A 3B            	CALL	TSTNUM		; Make sure it's a number
    2186/    3D40 : CD AC 37            	CALL	DEINT		; Get integer -32768 - 32767
    2187/    3D43 : 7B                  	LD	A,E		; Get LSB
    2188/    3D44 : 2F                  	CPL			; Invert LSB
    2189/    3D45 : 4F                  	LD	C,A		; Save "NOT" of LSB
    2190/    3D46 : 7A                  	LD	A,D		; Get MSB
    2191/    3D47 : 2F                  	CPL			; Invert MSB
    2192/    3D48 : CD 21 3F            	CALL	ACPASS		; Save AC as current
    2193/    3D4B : C1                  	POP	BC		; Clean up stack
    2194/    3D4C : C3 88 3B            	JP	EVAL3		; Continue evaluation
    2195/    3D4F :                     ;
    2196/    3D4F : 2B                  DIMRET: DEC	HL		; DEC 'cos GETCHR INCs
    2197/    3D50 : CD FA 36            	CALL	GETCHR		; Get next character
    2198/    3D53 : C8                  	RET	Z		; End of DIM statement
    2199/    3D54 : CD 72 35            	CALL	CHKSYN		; Make sure ',' follows
    2200/    3D57 : 2C                  	DB	','
    2201/    3D58 : 01 4F 3D            DIM:	LD	BC,DIMRET	; Return to "DIMRET"
    2202/    3D5B : C5                  	PUSH	BC		; Save on stack
    2203/    3D5C : F6                  	DB	0F6H		; Flag "Create" variable
    2204/    3D5D : AF                  GETVAR: XOR	A		; Find variable address,to DE
    2205/    3D5E : 32 F1 C0            	LD	(LCRFLG),A	; Set locate / create flag
    2206/    3D61 : 46                  	LD	B,(HL)		; Get First byte of name
    2207/    3D62 : CD 98 37            GTFNAM: CALL	CHKLTR		; See if a letter
    2208/    3D65 : DA A4 32            	JP	C,SNERR		; ?SN Error if not a letter
    2209/    3D68 : AF                  	XOR	A
    2210/    3D69 : 4F                  	LD	C,A		; Clear second byte of name
    2211/    3D6A : 32 F2 C0            	LD	(TYPE),A	; Set type to numeric
    2212/    3D6D : CD FA 36            	CALL	GETCHR		; Get next character
    2213/    3D70 : DA 79 3D            	JP	C,SVNAM2	; Numeric - Save in name
    2214/    3D73 : CD 98 37            	CALL	CHKLTR		; See if a letter
    2215/    3D76 : DA 86 3D            	JP	C,CHARTY	; Not a letter - Check type
    2216/    3D79 : 4F                  SVNAM2: LD	C,A		; Save second byte of name
    2217/    3D7A : CD FA 36            ENDNAM: CALL	GETCHR		; Get next character
    2218/    3D7D : DA 7A 3D            	JP	C,ENDNAM	; Numeric - Get another
    2219/    3D80 : CD 98 37            	CALL	CHKLTR		; See if a letter
    2220/    3D83 : D2 7A 3D            	JP	NC,ENDNAM	; Letter - Get another
    2221/    3D86 : D6 24               CHARTY: SUB	'$'		; String variable?
    2222/    3D88 : C2 95 3D            	JP	NZ,NOTSTR	; No - Numeric variable
    2223/    3D8B : 3C                  	INC	A		; A = 1 (string type)
    2224/    3D8C : 32 F2 C0            	LD	(TYPE),A	; Set type to string
    2225/    3D8F : 0F                  	RRCA			; A = 80H , Flag for string
    2226/    3D90 : 81                  	ADD	A,C		; 2nd byte of name has bit 7 on
    2227/    3D91 : 4F                  	LD	C,A		; Resave second byte on name
    2228/    3D92 : CD FA 36            	CALL	GETCHR		; Get next character
    2229/    3D95 : 3A 10 C1            NOTSTR: LD	A,(FORFLG)	; Array name needed ?
    2230/    3D98 : 3D                  	DEC	A
    2231/    3D99 : CA 42 3E            	JP	Z,ARLDSV	; Yes - Get array name
    2232/    3D9C : F2 A5 3D            	JP	P,NSCFOR	; No array with "FOR" or "FN"
    2233/    3D9F : 7E                  	LD	A,(HL)		; Get byte again
    2234/    3DA0 : D6 28               	SUB	'('		; Subscripted variable?
    2235/    3DA2 : CA 1A 3E            	JP	Z,SBSCPT	; Yes - Sort out subscript
    2236/    3DA5 :                     ;
    2237/    3DA5 : AF                  NSCFOR: XOR	A		; Simple variable
    2238/    3DA6 : 32 10 C1            	LD	(FORFLG),A	; Clear "FOR" flag
    2239/    3DA9 : E5                  	PUSH	HL		; Save code string address
    2240/    3DAA : 50                  	LD	D,B		; DE = Variable name to find
    2241/    3DAB : 59                  	LD	E,C
    2242/    3DAC : 2A 23 C1            	LD	HL,(FNRGNM)	; FN argument name
    2243/    3DAF : CD 6C 35            	CALL	CPDEHL		; Is it the FN argument?
    2244/    3DB2 : 11 25 C1            	LD	DE,FNARG	; Point to argument value
    2245/    3DB5 : CA 8A 44            	JP	Z,POPHRT	; Yes - Return FN argument value
    2246/    3DB8 : 2A 1D C1            	LD	HL,(VAREND)	; End of variables
    2247/    3DBB : EB                  	EX	DE,HL		; Address of end of search
    2248/    3DBC : 2A 1B C1            	LD	HL,(PROGND)	; Start of variables address
    2249/    3DBF : CD 6C 35            FNDVAR: CALL	CPDEHL		; End of variable list table?
    2250/    3DC2 : CA D8 3D            	JP	Z,CFEVAL	; Yes - Called from EVAL?
    2251/    3DC5 : 79                  	LD	A,C		; Get second byte of name
    2252/    3DC6 : 96                  	SUB	(HL)		; Compare with name in list
    2253/    3DC7 : 23                  	INC	HL		; Move on to first byte
    2254/    3DC8 : C2 CD 3D            	JP	NZ,FNTHR	; Different - Find another
    2255/    3DCB : 78                  	LD	A,B		; Get first byte of name
    2256/    3DCC : 96                  	SUB	(HL)		; Compare with name in list
    2257/    3DCD : 23                  FNTHR:	INC	HL		; Move on to LSB of value
    2258/    3DCE : CA 0C 3E            	JP	Z,RETADR	; Found - Return address
    2259/    3DD1 : 23                  	INC	HL		; <- Skip
    2260/    3DD2 : 23                  	INC	HL		; <- over
    2261/    3DD3 : 23                  	INC	HL		; <- F.P.
    2262/    3DD4 : 23                  	INC	HL		; <- value
    2263/    3DD5 : C3 BF 3D            	JP	FNDVAR		; Keep looking
    2264/    3DD8 :                     ;
    2265/    3DD8 : E1                  CFEVAL: POP	HL		; Restore code string address
    2266/    3DD9 : E3                  	EX	(SP),HL		; Get return address
    2267/    3DDA : D5                  	PUSH	DE		; Save address of variable
    2268/    3DDB : 11 5A 3C            	LD	DE,FRMEVL	; Return address in EVAL
    2269/    3DDE : CD 6C 35            	CALL	CPDEHL		; Called from EVAL ?
    2270/    3DE1 : D1                  	POP	DE		; Restore address of variable
    2271/    3DE2 : CA 0F 3E            	JP	Z,RETNUL	; Yes - Return null variable
    2272/    3DE5 : E3                  	EX	(SP),HL		; Put back return
    2273/    3DE6 : E5                  	PUSH	HL		; Save code string address
    2274/    3DE7 : C5                  	PUSH	BC		; Save variable name
    2275/    3DE8 : 01 06 00            	LD	BC,6		; 2 byte name plus 4 byte data
    2276/    3DEB : 2A 1F C1            	LD	HL,(ARREND)	; End of arrays
    2277/    3DEE : E5                  	PUSH	HL		; Save end of arrays
    2278/    3DEF : 09                  	ADD	HL,BC		; Move up 6 bytes
    2279/    3DF0 : C1                  	POP	BC		; Source address in BC
    2280/    3DF1 : E5                  	PUSH	HL		; Save new end address
    2281/    3DF2 : CD 70 32            	CALL	MOVUP		; Move arrays up
    2282/    3DF5 : E1                  	POP	HL		; Restore new end address
    2283/    3DF6 : 22 1F C1            	LD	(ARREND),HL	; Set new end address
    2284/    3DF9 : 60                  	LD	H,B		; End of variables to HL
    2285/    3DFA : 69                  	LD	L,C
    2286/    3DFB : 22 1D C1            	LD	(VAREND),HL	; Set new end address
    2287/    3DFE :                     ;
    2288/    3DFE : 2B                  ZEROLP: DEC	HL		; Back through to zero variable
    2289/    3DFF : 36 00               	LD	(HL),0		; Zero byte in variable
    2290/    3E01 : CD 6C 35            	CALL	CPDEHL		; Done them all?
    2291/    3E04 : C2 FE 3D            	JP	NZ,ZEROLP	; No - Keep on going
    2292/    3E07 : D1                  	POP	DE		; Get variable name
    2293/    3E08 : 73                  	LD	(HL),E		; Store second character
    2294/    3E09 : 23                  	INC	HL
    2295/    3E0A : 72                  	LD	(HL),D		; Store first character
    2296/    3E0B : 23                  	INC	HL
    2297/    3E0C : EB                  RETADR: EX	DE,HL		; Address of variable in DE
    2298/    3E0D : E1                  	POP	HL		; Restore code string address
    2299/    3E0E : C9                  	RET
    2300/    3E0F :                     ;
    2301/    3E0F : 32 2C C1            RETNUL: LD	(FPEXP),A	; Set result to zero
    2302/    3E12 : 21 40 32            	LD	HL,ZERBYT	; Also set a null string
    2303/    3E15 : 22 29 C1            	LD	(FPREG),HL	; Save for EVAL
    2304/    3E18 : E1                  	POP	HL		; Restore code string address
    2305/    3E19 : C9                  	RET
    2306/    3E1A :                     ;
    2307/    3E1A : E5                  SBSCPT: PUSH	HL		; Save code string address
    2308/    3E1B : 2A F1 C0            	LD	HL,(LCRFLG)	; Locate/Create and Type
    2309/    3E1E : E3                  	EX	(SP),HL		; Save and get code string
    2310/    3E1F : 57                  	LD	D,A		; Zero number of dimensions
    2311/    3E20 : D5                  SCPTLP: PUSH	DE		; Save number of dimensions
    2312/    3E21 : C5                  	PUSH	BC		; Save array name
    2313/    3E22 : CD A0 37            	CALL	FPSINT		; Get subscript (0-32767)
    2314/    3E25 : C1                  	POP	BC		; Restore array name
    2315/    3E26 : F1                  	POP	AF		; Get number of dimensions
    2316/    3E27 : EB                  	EX	DE,HL
    2317/    3E28 : E3                  	EX	(SP),HL		; Save subscript value
    2318/    3E29 : E5                  	PUSH	HL		; Save LCRFLG and TYPE
    2319/    3E2A : EB                  	EX	DE,HL
    2320/    3E2B : 3C                  	INC	A		; Count dimensions
    2321/    3E2C : 57                  	LD	D,A		; Save in D
    2322/    3E2D : 7E                  	LD	A,(HL)		; Get next byte in code string
    2323/    3E2E : FE 2C               	CP	','		; Comma (more to come)?
    2324/    3E30 : CA 20 3E            	JP	Z,SCPTLP	; Yes - More subscripts
    2325/    3E33 : CD 72 35            	CALL	CHKSYN		; Make sure ")" follows
    2326/    3E36 : 29                  	DB	")"
    2327/    3E37 : 22 15 C1            	LD	(NXTOPR),HL	; Save code string address
    2328/    3E3A : E1                  	POP	HL		; Get LCRFLG and TYPE
    2329/    3E3B : 22 F1 C0            	LD	(LCRFLG),HL	; Restore Locate/create & type
    2330/    3E3E : 1E 00               	LD	E,0		; Flag not CSAVE* or CLOAD*
    2331/    3E40 : D5                  	PUSH	DE		; Save number of dimensions (D)
    2332/    3E41 : 11                  	DB	11H		; Skip "PUSH HL" and "PUSH AF'
    2333/    3E42 :                     ;
    2334/    3E42 : E5                  ARLDSV: PUSH	HL		; Save code string address
    2335/    3E43 : F5                  	PUSH	AF		; A = 00 , Flags set = Z,N
    2336/    3E44 : 2A 1D C1            	LD	HL,(VAREND)	; Start of arrays
    2337/    3E47 : 3E                  	DB	3EH		; Skip "ADD HL,DE"
    2338/    3E48 : 19                  FNDARY: ADD	HL,DE		; Move to next array start
    2339/    3E49 : EB                  	EX	DE,HL
    2340/    3E4A : 2A 1F C1            	LD	HL,(ARREND)	; End of arrays
    2341/    3E4D : EB                  	EX	DE,HL		; Current array pointer
    2342/    3E4E : CD 6C 35            	CALL	CPDEHL		; End of arrays found?
    2343/    3E51 : CA 7A 3E            	JP	Z,CREARY	; Yes - Create array
    2344/    3E54 : 7E                  	LD	A,(HL)		; Get second byte of name
    2345/    3E55 : B9                  	CP	C		; Compare with name given
    2346/    3E56 : 23                  	INC	HL		; Move on
    2347/    3E57 : C2 5C 3E            	JP	NZ,NXTARY	; Different - Find next array
    2348/    3E5A : 7E                  	LD	A,(HL)		; Get first byte of name
    2349/    3E5B : B8                  	CP	B		; Compare with name given
    2350/    3E5C : 23                  NXTARY: INC	HL		; Move on
    2351/    3E5D : 5E                  	LD	E,(HL)		; Get LSB of next array address
    2352/    3E5E : 23                  	INC	HL
    2353/    3E5F : 56                  	LD	D,(HL)		; Get MSB of next array address
    2354/    3E60 : 23                  	INC	HL
    2355/    3E61 : C2 48 3E            	JP	NZ,FNDARY	; Not found - Keep looking
    2356/    3E64 : 3A F1 C0            	LD	A,(LCRFLG)	; Found Locate or Create it?
    2357/    3E67 : B7                  	OR	A
    2358/    3E68 : C2 AD 32            	JP	NZ,DDERR	; Create - ?DD Error
    2359/    3E6B : F1                  	POP	AF		; Locate - Get number of dim'ns
    2360/    3E6C : 44                  	LD	B,H		; BC Points to array dim'ns
    2361/    3E6D : 4D                  	LD	C,L
    2362/    3E6E : CA 8A 44            	JP	Z,POPHRT	; Jump if array load/save
    2363/    3E71 : 96                  	SUB	(HL)		; Same number of dimensions?
    2364/    3E72 : CA D8 3E            	JP	Z,FINDEL	; Yes - Find element
    2365/    3E75 : 1E 10               BSERR:	LD	E,BS		; ?BS Error
    2366/    3E77 : C3 B8 32            	JP	ERROR_		; Output error
    2367/    3E7A :                     ;
    2368/    3E7A : 11 04 00            CREARY: LD	DE,4		; 4 Bytes per entry
    2369/    3E7D : F1                  	POP	AF		; Array to save or 0 dim'ns?
    2370/    3E7E : CA C1 37            	JP	Z,FCERR		; Yes - ?FC Error
    2371/    3E81 : 71                  	LD	(HL),C		; Save second byte of name
    2372/    3E82 : 23                  	INC	HL
    2373/    3E83 : 70                  	LD	(HL),B		; Save first byte of name
    2374/    3E84 : 23                  	INC	HL
    2375/    3E85 : 4F                  	LD	C,A		; Number of dimensions to C
    2376/    3E86 : CD 81 32            	CALL	CHKSTK		; Check if enough memory
    2377/    3E89 : 23                  	INC	HL		; Point to number of dimensions
    2378/    3E8A : 23                  	INC	HL
    2379/    3E8B : 22 0A C1            	LD	(CUROPR),HL	; Save address of pointer
    2380/    3E8E : 71                  	LD	(HL),C		; Set number of dimensions
    2381/    3E8F : 23                  	INC	HL
    2382/    3E90 : 3A F1 C0            	LD	A,(LCRFLG)	; Locate of Create?
    2383/    3E93 : 17                  	RLA			; Carry set = Create
    2384/    3E94 : 79                  	LD	A,C		; Get number of dimensions
    2385/    3E95 : 01 0B 00            CRARLP: LD	BC,10+1		; Default dimension size 10
    2386/    3E98 : D2 9D 3E            	JP	NC,DEFSIZ	; Locate - Set default size
    2387/    3E9B : C1                  	POP	BC		; Get specified dimension size
    2388/    3E9C : 03                  	INC	BC		; Include zero element
    2389/    3E9D : 71                  DEFSIZ: LD	(HL),C		; Save LSB of dimension size
    2390/    3E9E : 23                  	INC	HL
    2391/    3E9F : 70                  	LD	(HL),B		; Save MSB of dimension size
    2392/    3EA0 : 23                  	INC	HL
    2393/    3EA1 : F5                  	PUSH	AF		; Save num' of dim'ns an status
    2394/    3EA2 : E5                  	PUSH	HL		; Save address of dim'n size
    2395/    3EA3 : CD 35 46            	CALL	MLDEBC		; Multiply DE by BC to find
    2396/    3EA6 : EB                  	EX	DE,HL		; amount of mem needed (to DE)
    2397/    3EA7 : E1                  	POP	HL		; Restore address of dimension
    2398/    3EA8 : F1                  	POP	AF		; Restore number of dimensions
    2399/    3EA9 : 3D                  	DEC	A		; Count them
    2400/    3EAA : C2 95 3E            	JP	NZ,CRARLP	; Do next dimension if more
    2401/    3EAD : F5                  	PUSH	AF		; Save locate/create flag
    2402/    3EAE : 42                  	LD	B,D		; MSB of memory needed
    2403/    3EAF : 4B                  	LD	C,E		; LSB of memory needed
    2404/    3EB0 : EB                  	EX	DE,HL
    2405/    3EB1 : 19                  	ADD	HL,DE		; Add bytes to array start
    2406/    3EB2 : DA 99 32            	JP	C,OMERR		; Too big - Error
    2407/    3EB5 : CD 8A 32            	CALL	ENFMEM		; See if enough memory
    2408/    3EB8 : 22 1F C1            	LD	(ARREND),HL	; Save new end of array
    2409/    3EBB :                     ;
    2410/    3EBB : 2B                  ZERARY: DEC	HL		; Back through array data
    2411/    3EBC : 36 00               	LD	(HL),0		; Set array element to zero
    2412/    3EBE : CD 6C 35            	CALL	CPDEHL		; All elements zeroed?
    2413/    3EC1 : C2 BB 3E            	JP	NZ,ZERARY	; No - Keep on going
    2414/    3EC4 : 03                  	INC	BC		; Number of bytes + 1
    2415/    3EC5 : 57                  	LD	D,A		; A=0
    2416/    3EC6 : 2A 0A C1            	LD	HL,(CUROPR)	; Get address of array
    2417/    3EC9 : 5E                  	LD	E,(HL)		; Number of dimensions
    2418/    3ECA : EB                  	EX	DE,HL		; To HL
    2419/    3ECB : 29                  	ADD	HL,HL		; Two bytes per dimension size
    2420/    3ECC : 09                  	ADD	HL,BC		; Add number of bytes
    2421/    3ECD : EB                  	EX	DE,HL		; Bytes needed to DE
    2422/    3ECE : 2B                  	DEC	HL
    2423/    3ECF : 2B                  	DEC	HL
    2424/    3ED0 : 73                  	LD	(HL),E		; Save LSB of bytes needed
    2425/    3ED1 : 23                  	INC	HL
    2426/    3ED2 : 72                  	LD	(HL),D		; Save MSB of bytes needed
    2427/    3ED3 : 23                  	INC	HL
    2428/    3ED4 : F1                  	POP	AF		; Locate / Create?
    2429/    3ED5 : DA FC 3E            	JP	C,ENDDIM	; A is 0 , End if create
    2430/    3ED8 : 47                  FINDEL: LD	B,A		; Find array element
    2431/    3ED9 : 4F                  	LD	C,A
    2432/    3EDA : 7E                  	LD	A,(HL)		; Number of dimensions
    2433/    3EDB : 23                  	INC	HL
    2434/    3EDC : 16                  	DB	16H		; Skip "POP HL"
    2435/    3EDD : E1                  FNDELP: POP	HL		; Address of next dim' size
    2436/    3EDE : 5E                  	LD	E,(HL)		; Get LSB of dim'n size
    2437/    3EDF : 23                  	INC	HL
    2438/    3EE0 : 56                  	LD	D,(HL)		; Get MSB of dim'n size
    2439/    3EE1 : 23                  	INC	HL
    2440/    3EE2 : E3                  	EX	(SP),HL		; Save address - Get index
    2441/    3EE3 : F5                  	PUSH	AF		; Save number of dim'ns
    2442/    3EE4 : CD 6C 35            	CALL	CPDEHL		; Dimension too large?
    2443/    3EE7 : D2 75 3E            	JP	NC,BSERR	; Yes - ?BS Error
    2444/    3EEA : E5                  	PUSH	HL		; Save index
    2445/    3EEB : CD 35 46            	CALL	MLDEBC		; Multiply previous by size
    2446/    3EEE : D1                  	POP	DE		; Index supplied to DE
    2447/    3EEF : 19                  	ADD	HL,DE		; Add index to pointer
    2448/    3EF0 : F1                  	POP	AF		; Number of dimensions
    2449/    3EF1 : 3D                  	DEC	A		; Count them
    2450/    3EF2 : 44                  	LD	B,H		; MSB of pointer
    2451/    3EF3 : 4D                  	LD	C,L		; LSB of pointer
    2452/    3EF4 : C2 DD 3E            	JP	NZ,FNDELP	; More - Keep going
    2453/    3EF7 : 29                  	ADD	HL,HL		; 4 Bytes per element
    2454/    3EF8 : 29                  	ADD	HL,HL
    2455/    3EF9 : C1                  	POP	BC		; Start of array
    2456/    3EFA : 09                  	ADD	HL,BC		; Point to element
    2457/    3EFB : EB                  	EX	DE,HL		; Address of element to DE
    2458/    3EFC : 2A 15 C1            ENDDIM: LD	HL,(NXTOPR)	; Got code string address
    2459/    3EFF : C9                  	RET
    2460/    3F00 :                     ;
    2461/    3F00 : 2A 1F C1            FRE:	LD	HL,(ARREND)	; Start of free memory
    2462/    3F03 : EB                  	EX	DE,HL		; To DE
    2463/    3F04 : 21 00 00            	LD	HL,0		; End of free memory
    2464/    3F07 : 39                  	ADD	HL,SP		; Current stack value
    2465/    3F08 : 3A F2 C0            	LD	A,(TYPE)	; Dummy argument type
    2466/    3F0B : B7                  	OR	A
    2467/    3F0C : CA 1C 3F            	JP	Z,FRENUM	; Numeric - Free variable space
    2468/    3F0F : CD 83 41            	CALL	GSTRCU		; Current string to pool
    2469/    3F12 : CD 83 40            	CALL	GARBGE		; Garbage collection
    2470/    3F15 : 2A 9F C0            	LD	HL,(STRSPC)	; Bottom of string space in use
    2471/    3F18 : EB                  	EX	DE,HL		; To DE
    2472/    3F19 : 2A 08 C1            	LD	HL,(STRBOT)	; Bottom of string space
    2473/    3F1C : 7D                  FRENUM: LD	A,L		; Get LSB of end
    2474/    3F1D : 93                  	SUB	E		; Subtract LSB of beginning
    2475/    3F1E : 4F                  	LD	C,A		; Save difference if C
    2476/    3F1F : 7C                  	LD	A,H		; Get MSB of end
    2477/    3F20 : 9A                  	SBC	A,D		; Subtract MSB of beginning
    2478/    3F21 : 41                  ACPASS: LD	B,C		; Return integer AC
    2479/    3F22 : 50                  ABPASS: LD	D,B		; Return integer AB
    2480/    3F23 : 1E 00               	LD	E,0
    2481/    3F25 : 21 F2 C0            	LD	HL,TYPE		; Point to type
    2482/    3F28 : 73                  	LD	(HL),E		; Set type to numeric
    2483/    3F29 : 06 90               	LD	B,80H+16	; 16 bit integer
    2484/    3F2B : C3 60 45            	JP	RETINT		; Return the integr
    2485/    3F2E :                     ;
    2486/    3F2E : 3A F0 C0            POS:	LD	A,(CURPOS)	; Get cursor position
    2487/    3F31 : 47                  PASSA:	LD	B,A		; Put A into AB
    2488/    3F32 : AF                  	XOR	A		; Zero A
    2489/    3F33 : C3 22 3F            	JP	ABPASS		; Return integer AB
    2490/    3F36 :                     ;
    2491/    3F36 : CD B9 3F            DEF:	CALL	CHEKFN		; Get "FN" and name
    2492/    3F39 : CD AB 3F            	CALL	IDTEST		; Test for illegal direct
    2493/    3F3C : 01 91 38            	LD	BC,DATA		; To get next statement
    2494/    3F3F : C5                  	PUSH	BC		; Save address for RETurn
    2495/    3F40 : D5                  	PUSH	DE		; Save address of function ptr
    2496/    3F41 : CD 72 35            	CALL	CHKSYN		; Make sure "(" follows
    2497/    3F44 : 28                  	DB	"("
    2498/    3F45 : CD 5D 3D            	CALL	GETVAR		; Get argument variable name
    2499/    3F48 : E5                  	PUSH	HL		; Save code string address
    2500/    3F49 : EB                  	EX	DE,HL		; Argument address to HL
    2501/    3F4A : 2B                  	DEC	HL
    2502/    3F4B : 56                  	LD	D,(HL)		; Get first byte of arg name
    2503/    3F4C : 2B                  	DEC	HL
    2504/    3F4D : 5E                  	LD	E,(HL)		; Get second byte of arg name
    2505/    3F4E : E1                  	POP	HL		; Restore code string address
    2506/    3F4F : CD 6A 3B            	CALL	TSTNUM		; Make sure numeric argument
    2507/    3F52 : CD 72 35            	CALL	CHKSYN		; Make sure ")" follows
    2508/    3F55 : 29                  	DB	")"
    2509/    3F56 : CD 72 35            	CALL	CHKSYN		; Make sure "=" follows
    2510/    3F59 : B4                  	DB	ZEQUAL		; "=" token
    2511/    3F5A : 44                  	LD	B,H		; Code string address to BC
    2512/    3F5B : 4D                  	LD	C,L
    2513/    3F5C : E3                  	EX	(SP),HL		; Save code str , Get FN ptr
    2514/    3F5D : 71                  	LD	(HL),C		; Save LSB of FN code string
    2515/    3F5E : 23                  	INC	HL
    2516/    3F5F : 70                  	LD	(HL),B		; Save MSB of FN code string
    2517/    3F60 : C3 F8 3F            	JP	SVSTAD		; Save address and do function
    2518/    3F63 :                     ;
    2519/    3F63 : CD B9 3F            DOFN:	CALL	CHEKFN		; Make sure FN follows
    2520/    3F66 : D5                  	PUSH	DE		; Save function pointer address
    2521/    3F67 : CD 3E 3C            	CALL	EVLPAR		; Evaluate expression in "()"
    2522/    3F6A : CD 6A 3B            	CALL	TSTNUM		; Make sure numeric result
    2523/    3F6D : E3                  	EX	(SP),HL		; Save code str , Get FN ptr
    2524/    3F6E : 5E                  	LD	E,(HL)		; Get LSB of FN code string
    2525/    3F6F : 23                  	INC	HL
    2526/    3F70 : 56                  	LD	D,(HL)		; Get MSB of FN code string
    2527/    3F71 : 23                  	INC	HL
    2528/    3F72 : 7A                  	LD	A,D		; And function DEFined?
    2529/    3F73 : B3                  	OR	E
    2530/    3F74 : CA B0 32            	JP	Z,UFERR		; No - ?UF Error
    2531/    3F77 : 7E                  	LD	A,(HL)		; Get LSB of argument address
    2532/    3F78 : 23                  	INC	HL
    2533/    3F79 : 66                  	LD	H,(HL)		; Get MSB of argument address
    2534/    3F7A : 6F                  	LD	L,A		; HL = Arg variable address
    2535/    3F7B : E5                  	PUSH	HL		; Save it
    2536/    3F7C : 2A 23 C1            	LD	HL,(FNRGNM)	; Get old argument name
    2537/    3F7F : E3                  	EX	(SP),HL;	; Save old , Get new
    2538/    3F80 : 22 23 C1            	LD	(FNRGNM),HL	; Set new argument name
    2539/    3F83 : 2A 27 C1            	LD	HL,(FNARG+2)	; Get LSB,NLSB of old arg value
    2540/    3F86 : E5                  	PUSH	HL		; Save it
    2541/    3F87 : 2A 25 C1            	LD	HL,(FNARG)	; Get MSB,EXP of old arg value
    2542/    3F8A : E5                  	PUSH	HL		; Save it
    2543/    3F8B : 21 25 C1            	LD	HL,FNARG	; HL = Value of argument
    2544/    3F8E : D5                  	PUSH	DE		; Save FN code string address
    2545/    3F8F : CD A1 45            	CALL	FPTHL		; Move FPREG to argument
    2546/    3F92 : E1                  	POP	HL		; Get FN code string address
    2547/    3F93 : CD 67 3B            	CALL	GETNUM		; Get value from function
    2548/    3F96 : 2B                  	DEC	HL		; DEC 'cos GETCHR INCs
    2549/    3F97 : CD FA 36            	CALL	GETCHR		; Get next character
    2550/    3F9A : C2 A4 32            	JP	NZ,SNERR	; Bad character in FN - Error
    2551/    3F9D : E1                  	POP	HL		; Get MSB,EXP of old arg
    2552/    3F9E : 22 25 C1            	LD	(FNARG),HL	; Restore it
    2553/    3FA1 : E1                  	POP	HL		; Get LSB,NLSB of old arg
    2554/    3FA2 : 22 27 C1            	LD	(FNARG+2),HL	; Restore it
    2555/    3FA5 : E1                  	POP	HL		; Get name of old arg
    2556/    3FA6 : 22 23 C1            	LD	(FNRGNM),HL	; Restore it
    2557/    3FA9 : E1                  	POP	HL		; Restore code string address
    2558/    3FAA : C9                  	RET
    2559/    3FAB :                     ;
    2560/    3FAB : E5                  IDTEST: PUSH	HL		; Save code string address
    2561/    3FAC : 2A A1 C0            	LD	HL,(LINEAT)	; Get current line number
    2562/    3FAF : 23                  	INC	HL		; -1 means direct statement
    2563/    3FB0 : 7C                  	LD	A,H
    2564/    3FB1 : B5                  	OR	L
    2565/    3FB2 : E1                  	POP	HL		; Restore code string address
    2566/    3FB3 : C0                  	RET	NZ		; Return if in program
    2567/    3FB4 : 1E 16               	LD	E,ID		; ?ID Error
    2568/    3FB6 : C3 B8 32            	JP	ERROR_
    2569/    3FB9 :                     ;
    2570/    3FB9 : CD 72 35            CHEKFN: CALL	CHKSYN		; Make sure FN follows
    2571/    3FBC : A7                  	DB	ZFN		; "FN" token
    2572/    3FBD : 3E 80               	LD	A,80H
    2573/    3FBF : 32 10 C1            	LD	(FORFLG),A	; Flag FN name to find
    2574/    3FC2 : B6                  	OR	(HL)		; FN name has bit 7 set
    2575/    3FC3 : 47                  	LD	B,A		; in first byte of name
    2576/    3FC4 : CD 62 3D            	CALL	GTFNAM		; Get FN name
    2577/    3FC7 : C3 6A 3B            	JP	TSTNUM		; Make sure numeric function
    2578/    3FCA :                     ;
    2579/    3FCA : CD 6A 3B            STR:	CALL	TSTNUM		; Make sure it's a number
    2580/    3FCD : CD EE 46            	CALL	NUMASC		; Turn number into text
    2581/    3FD0 : CD FE 3F            STR1:	CALL	CRTST		; Create string entry for it
    2582/    3FD3 : CD 83 41            	CALL	GSTRCU		; Current string to pool
    2583/    3FD6 : 01 DE 41            	LD	BC,TOPOOL	; Save in string pool
    2584/    3FD9 : C5                  	PUSH	BC		; Save address on stack
    2585/    3FDA :                     ;
    2586/    3FDA : 7E                  SAVSTR: LD	A,(HL)		; Get string length
    2587/    3FDB : 23                  	INC	HL
    2588/    3FDC : 23                  	INC	HL
    2589/    3FDD : E5                  	PUSH	HL		; Save pointer to string
    2590/    3FDE : CD 59 40            	CALL	TESTR		; See if enough string space
    2591/    3FE1 : E1                  	POP	HL		; Restore pointer to string
    2592/    3FE2 : 4E                  	LD	C,(HL)		; Get LSB of address
    2593/    3FE3 : 23                  	INC	HL
    2594/    3FE4 : 46                  	LD	B,(HL)		; Get MSB of address
    2595/    3FE5 : CD F2 3F            	CALL	CRTMST		; Create string entry
    2596/    3FE8 : E5                  	PUSH	HL		; Save pointer to MSB of addr
    2597/    3FE9 : 6F                  	LD	L,A		; Length of string
    2598/    3FEA : CD 76 41            	CALL	TOSTRA		; Move to string area
    2599/    3FED : D1                  	POP	DE		; Restore pointer to MSB
    2600/    3FEE : C9                  	RET
    2601/    3FEF :                     ;
    2602/    3FEF : CD 59 40            MKTMST: CALL	TESTR		; See if enough string space
    2603/    3FF2 : 21 04 C1            CRTMST: LD	HL,TMPSTR	; Temporary string
    2604/    3FF5 : E5                  	PUSH	HL		; Save it
    2605/    3FF6 : 77                  	LD	(HL),A		; Save length of string
    2606/    3FF7 : 23                  	INC	HL
    2607/    3FF8 : 23                  SVSTAD: INC	HL
    2608/    3FF9 : 73                  	LD	(HL),E		; Save LSB of address
    2609/    3FFA : 23                  	INC	HL
    2610/    3FFB : 72                  	LD	(HL),D		; Save MSB of address
    2611/    3FFC : E1                  	POP	HL		; Restore pointer
    2612/    3FFD : C9                  	RET
    2613/    3FFE :                     ;
    2614/    3FFE : 2B                  CRTST:	DEC	HL		; DEC - INCed after
    2615/    3FFF : 06 22               QTSTR:	LD	B,'"'		; Terminating quote
    2616/    4001 : 50                  	LD	D,B		; Quote to D
    2617/    4002 : E5                  DTSTR:	PUSH	HL		; Save start
    2618/    4003 : 0E FF               	LD	C,-1		; Set counter to -1
    2619/    4005 : 23                  QTSTLP: INC	HL		; Move on
    2620/    4006 : 7E                  	LD	A,(HL)		; Get byte
    2621/    4007 : 0C                  	INC	C		; Count bytes
    2622/    4008 : B7                  	OR	A		; End of line?
    2623/    4009 : CA 14 40            	JP	Z,CRTSTE	; Yes - Create string entry
    2624/    400C : BA                  	CP	D		; Terminator D found?
    2625/    400D : CA 14 40            	JP	Z,CRTSTE	; Yes - Create string entry
    2626/    4010 : B8                  	CP	B		; Terminator B found?
    2627/    4011 : C2 05 40            	JP	NZ,QTSTLP	; No - Keep looking
    2628/    4014 : FE 22               CRTSTE: CP	'"'		; End with '"'?
    2629/    4016 : CC FA 36            	CALL	Z,GETCHR	; Yes - Get next character
    2630/    4019 : E3                  	EX	(SP),HL		; Starting quote
    2631/    401A : 23                  	INC	HL		; First byte of string
    2632/    401B : EB                  	EX	DE,HL		; To DE
    2633/    401C : 79                  	LD	A,C		; Get length
    2634/    401D : CD F2 3F            	CALL	CRTMST		; Create string entry
    2635/    4020 : 11 04 C1            TSTOPL: LD	DE,TMPSTR	; Temporary string
    2636/    4023 : 2A F6 C0            	LD	HL,(TMSTPT)	; Temporary string pool pointer
    2637/    4026 : 22 29 C1            	LD	(FPREG),HL	; Save address of string ptr
    2638/    4029 : 3E 01               	LD	A,1
    2639/    402B : 32 F2 C0            	LD	(TYPE),A	; Set type to string
    2640/    402E : CD A4 45            	CALL	DETHL4		; Move string to pool
    2641/    4031 : CD 6C 35            	CALL	CPDEHL		; Out of string pool?
    2642/    4034 : 22 F6 C0            	LD	(TMSTPT),HL	; Save new pointer
    2643/    4037 : E1                  	POP	HL		; Restore code string address
    2644/    4038 : 7E                  	LD	A,(HL)		; Get next code byte
    2645/    4039 : C0                  	RET	NZ		; Return if pool OK
    2646/    403A : 1E 1E               	LD	E,ST		; ?ST Error
    2647/    403C : C3 B8 32            	JP	ERROR_		; String pool overflow
    2648/    403F :                     ;
    2649/    403F : 23                  PRNUMS: INC	HL		; Skip leading space
    2650/    4040 : CD FE 3F            PRS:	CALL	CRTST		; Create string entry for it
    2651/    4043 : CD 83 41            PRS1:	CALL	GSTRCU		; Current string to pool
    2652/    4046 : CD 98 45            	CALL	LOADFP		; Move string block to BCDE
    2653/    4049 : 1C                  	INC	E		; Length + 1
    2654/    404A : 1D                  PRSLP:	DEC	E		; Count characters
    2655/    404B : C8                  	RET	Z		; End of string
    2656/    404C : 0A                  	LD	A,(BC)		; Get byte to output
    2657/    404D : CD 7D 35            	CALL	OUTC		; Output character in A
    2658/    4050 : FE 0D               	CP	CR		; Return?
    2659/    4052 : CC AC 39            	CALL	Z,DONULL	; Yes - Do nulls
    2660/    4055 : 03                  	INC	BC		; Next byte in string
    2661/    4056 : C3 4A 40            	JP	PRSLP		; More characters to output
    2662/    4059 :                     ;
    2663/    4059 : B7                  TESTR:	OR	A		; Test if enough room
    2664/    405A : 0E                  	DB	0EH		; No garbage collection done
    2665/    405B : F1                  GRBDON: POP	AF		; Garbage collection done
    2666/    405C : F5                  	PUSH	AF		; Save status
    2667/    405D : 2A 9F C0            	LD	HL,(STRSPC)	; Bottom of string space in use
    2668/    4060 : EB                  	EX	DE,HL		; To DE
    2669/    4061 : 2A 08 C1            	LD	HL,(STRBOT)	; Bottom of string area
    2670/    4064 : 2F                  	CPL			; Negate length (Top down)
    2671/    4065 : 4F                  	LD	C,A		; -Length to BC
    2672/    4066 : 06 FF               	LD	B,-1		; BC = -ve length of string
    2673/    4068 : 09                  	ADD	HL,BC		; Add to bottom of space in use
    2674/    4069 : 23                  	INC	HL		; Plus one for 2's complement
    2675/    406A : CD 6C 35            	CALL	CPDEHL		; Below string RAM area?
    2676/    406D : DA 77 40            	JP	C,TESTOS	; Tidy up if not done else err
    2677/    4070 : 22 08 C1            	LD	(STRBOT),HL	; Save new bottom of area
    2678/    4073 : 23                  	INC	HL		; Point to first byte of string
    2679/    4074 : EB                  	EX	DE,HL		; Address to DE
    2680/    4075 : F1                  POPAF:	POP	AF		; Throw away status push
    2681/    4076 : C9                  	RET
    2682/    4077 :                     ;
    2683/    4077 : F1                  TESTOS: POP	AF		; Garbage collect been done?
    2684/    4078 : 1E 1A               	LD	E,OS		; ?OS Error
    2685/    407A : CA B8 32            	JP	Z,ERROR_	; Yes - Not enough string apace
    2686/    407D : BF                  	CP	A		; Flag garbage collect done
    2687/    407E : F5                  	PUSH	AF		; Save status
    2688/    407F : 01 5B 40            	LD	BC,GRBDON	; Garbage collection done
    2689/    4082 : C5                  	PUSH	BC		; Save for RETurn
    2690/    4083 : 2A F4 C0            GARBGE: LD	HL,(LSTRAM)	; Get end of RAM pointer
    2691/    4086 : 22 08 C1            GARBLP: LD	(STRBOT),HL	; Reset string pointer
    2692/    4089 : 21 00 00            	LD	HL,0
    2693/    408C : E5                  	PUSH	HL		; Flag no string found
    2694/    408D : 2A 9F C0            	LD	HL,(STRSPC)	; Get bottom of string space
    2695/    4090 : E5                  	PUSH	HL		; Save bottom of string space
    2696/    4091 : 21 F8 C0            	LD	HL,TMSTPL	; Temporary string pool
    2697/    4094 : EB                  GRBLP:	EX	DE,HL
    2698/    4095 : 2A F6 C0            	LD	HL,(TMSTPT)	; Temporary string pool pointer
    2699/    4098 : EB                  	EX	DE,HL
    2700/    4099 : CD 6C 35            	CALL	CPDEHL		; Temporary string pool done?
    2701/    409C : 01 94 40            	LD	BC,GRBLP	; Loop until string pool done
    2702/    409F : C2 E8 40            	JP	NZ,STPOOL	; No - See if in string area
    2703/    40A2 : 2A 1B C1            	LD	HL,(PROGND)	; Start of simple variables
    2704/    40A5 : EB                  SMPVAR: EX	DE,HL
    2705/    40A6 : 2A 1D C1            	LD	HL,(VAREND)	; End of simple variables
    2706/    40A9 : EB                  	EX	DE,HL
    2707/    40AA : CD 6C 35            	CALL	CPDEHL		; All simple strings done?
    2708/    40AD : CA BB 40            	JP	Z,ARRLP		; Yes - Do string arrays
    2709/    40B0 : 7E                  	LD	A,(HL)		; Get type of variable
    2710/    40B1 : 23                  	INC	HL
    2711/    40B2 : 23                  	INC	HL
    2712/    40B3 : B7                  	OR	A		; "S" flag set if string
    2713/    40B4 : CD EB 40            	CALL	STRADD		; See if string in string area
    2714/    40B7 : C3 A5 40            	JP	SMPVAR		; Loop until simple ones done
    2715/    40BA :                     ;
    2716/    40BA : C1                  GNXARY: POP	BC		; Scrap address of this array
    2717/    40BB : EB                  ARRLP:	EX	DE,HL
    2718/    40BC : 2A 1F C1            	LD	HL,(ARREND)	; End of string arrays
    2719/    40BF : EB                  	EX	DE,HL
    2720/    40C0 : CD 6C 35            	CALL	CPDEHL		; All string arrays done?
    2721/    40C3 : CA 11 41            	JP	Z,SCNEND	; Yes - Move string if found
    2722/    40C6 : CD 98 45            	CALL	LOADFP		; Get array name to BCDE
    2723/    40C9 : 7B                  	LD	A,E		; Get type of array	
    2724/    40CA : E5                  	PUSH	HL		; Save address of num of dim'ns
    2725/    40CB : 09                  	ADD	HL,BC		; Start of next array
    2726/    40CC : B7                  	OR	A		; Test type of array
    2727/    40CD : F2 BA 40            	JP	P,GNXARY	; Numeric array - Ignore it
    2728/    40D0 : 22 0A C1            	LD	(CUROPR),HL	; Save address of next array
    2729/    40D3 : E1                  	POP	HL		; Get address of num of dim'ns
    2730/    40D4 : 4E                  	LD	C,(HL)		; BC = Number of dimensions
    2731/    40D5 : 06 00               	LD	B,0
    2732/    40D7 : 09                  	ADD	HL,BC		; Two bytes per dimension size
    2733/    40D8 : 09                  	ADD	HL,BC
    2734/    40D9 : 23                  	INC	HL		; Plus one for number of dim'ns
    2735/    40DA : EB                  GRBARY: EX	DE,HL
    2736/    40DB : 2A 0A C1            	LD	HL,(CUROPR)	; Get address of next array
    2737/    40DE : EB                  	EX	DE,HL
    2738/    40DF : CD 6C 35            	CALL	CPDEHL		; Is this array finished?
    2739/    40E2 : CA BB 40            	JP	Z,ARRLP		; Yes - Get next one
    2740/    40E5 : 01 DA 40            	LD	BC,GRBARY	; Loop until array all done
    2741/    40E8 : C5                  STPOOL: PUSH	BC		; Save return address
    2742/    40E9 : F6 80               	OR	80H		; Flag string type
    2743/    40EB : 7E                  STRADD: LD	A,(HL)		; Get string length
    2744/    40EC : 23                  	INC	HL
    2745/    40ED : 23                  	INC	HL
    2746/    40EE : 5E                  	LD	E,(HL)		; Get LSB of string address
    2747/    40EF : 23                  	INC	HL
    2748/    40F0 : 56                  	LD	D,(HL)		; Get MSB of string address
    2749/    40F1 : 23                  	INC	HL
    2750/    40F2 : F0                  	RET	P		; Not a string - Return
    2751/    40F3 : B7                  	OR	A		; Set flags on string length
    2752/    40F4 : C8                  	RET	Z		; Null string - Return
    2753/    40F5 : 44                  	LD	B,H		; Save variable pointer
    2754/    40F6 : 4D                  	LD	C,L
    2755/    40F7 : 2A 08 C1            	LD	HL,(STRBOT)	; Bottom of new area
    2756/    40FA : CD 6C 35            	CALL	CPDEHL		; String been done?
    2757/    40FD : 60                  	LD	H,B		; Restore variable pointer
    2758/    40FE : 69                  	LD	L,C
    2759/    40FF : D8                  	RET	C		; String done - Ignore
    2760/    4100 : E1                  	POP	HL		; Return address
    2761/    4101 : E3                  	EX	(SP),HL		; Lowest available string area
    2762/    4102 : CD 6C 35            	CALL	CPDEHL		; String within string area?
    2763/    4105 : E3                  	EX	(SP),HL		; Lowest available string area
    2764/    4106 : E5                  	PUSH	HL		; Re-save return address
    2765/    4107 : 60                  	LD	H,B		; Restore variable pointer
    2766/    4108 : 69                  	LD	L,C
    2767/    4109 : D0                  	RET	NC		; Outside string area - Ignore
    2768/    410A : C1                  	POP	BC		; Get return , Throw 2 away
    2769/    410B : F1                  	POP	AF		; 
    2770/    410C : F1                  	POP	AF		; 
    2771/    410D : E5                  	PUSH	HL		; Save variable pointer
    2772/    410E : D5                  	PUSH	DE		; Save address of current
    2773/    410F : C5                  	PUSH	BC		; Put back return address
    2774/    4110 : C9                  	RET			; Go to it
    2775/    4111 :                     ;
    2776/    4111 : D1                  SCNEND: POP	DE		; Addresses of strings
    2777/    4112 : E1                  	POP	HL		; 
    2778/    4113 : 7D                  	LD	A,L		; HL = 0 if no more to do
    2779/    4114 : B4                  	OR	H
    2780/    4115 : C8                  	RET	Z		; No more to do - Return
    2781/    4116 : 2B                  	DEC	HL
    2782/    4117 : 46                  	LD	B,(HL)		; MSB of address of string
    2783/    4118 : 2B                  	DEC	HL
    2784/    4119 : 4E                  	LD	C,(HL)		; LSB of address of string
    2785/    411A : E5                  	PUSH	HL		; Save variable address
    2786/    411B : 2B                  	DEC	HL
    2787/    411C : 2B                  	DEC	HL
    2788/    411D : 6E                  	LD	L,(HL)		; HL = Length of string
    2789/    411E : 26 00               	LD	H,0
    2790/    4120 : 09                  	ADD	HL,BC		; Address of end of string+1
    2791/    4121 : 50                  	LD	D,B		; String address to DE
    2792/    4122 : 59                  	LD	E,C
    2793/    4123 : 2B                  	DEC	HL		; Last byte in string
    2794/    4124 : 44                  	LD	B,H		; Address to BC
    2795/    4125 : 4D                  	LD	C,L
    2796/    4126 : 2A 08 C1            	LD	HL,(STRBOT)	; Current bottom of string area
    2797/    4129 : CD 73 32            	CALL	MOVSTR		; Move string to new address
    2798/    412C : E1                  	POP	HL		; Restore variable address
    2799/    412D : 71                  	LD	(HL),C		; Save new LSB of address
    2800/    412E : 23                  	INC	HL
    2801/    412F : 70                  	LD	(HL),B		; Save new MSB of address
    2802/    4130 : 69                  	LD	L,C		; Next string area+1 to HL
    2803/    4131 : 60                  	LD	H,B
    2804/    4132 : 2B                  	DEC	HL		; Next string area address
    2805/    4133 : C3 86 40            	JP	GARBLP		; Look for more strings
    2806/    4136 :                     ;
    2807/    4136 : C5                  CONCAT: PUSH	BC		; Save prec' opr & code string
    2808/    4137 : E5                  	PUSH	HL		; 
    2809/    4138 : 2A 29 C1            	LD	HL,(FPREG)	; Get first string
    2810/    413B : E3                  	EX	(SP),HL		; Save first string
    2811/    413C : CD F0 3B            	CALL	OPRND		; Get second string
    2812/    413F : E3                  	EX	(SP),HL		; Restore first string
    2813/    4140 : CD 6B 3B            	CALL	TSTSTR		; Make sure it's a string
    2814/    4143 : 7E                  	LD	A,(HL)		; Get length of second string
    2815/    4144 : E5                  	PUSH	HL		; Save first string
    2816/    4145 : 2A 29 C1            	LD	HL,(FPREG)	; Get second string
    2817/    4148 : E5                  	PUSH	HL		; Save second string
    2818/    4149 : 86                  	ADD	A,(HL)		; Add length of second string
    2819/    414A : 1E 1C               	LD	E,LS		; ?LS Error
    2820/    414C : DA B8 32            	JP	C,ERROR_	; String too long - Error
    2821/    414F : CD EF 3F            	CALL	MKTMST		; Make temporary string
    2822/    4152 : D1                  	POP	DE		; Get second string to DE
    2823/    4153 : CD 87 41            	CALL	GSTRDE		; Move to string pool if needed
    2824/    4156 : E3                  	EX	(SP),HL		; Get first string
    2825/    4157 : CD 86 41            	CALL	GSTRHL		; Move to string pool if needed
    2826/    415A : E5                  	PUSH	HL		; Save first string
    2827/    415B : 2A 06 C1            	LD	HL,(TMPSTR+2)	; Temporary string address
    2828/    415E : EB                  	EX	DE,HL		; To DE
    2829/    415F : CD 6D 41            	CALL	SSTSA		; First string to string area
    2830/    4162 : CD 6D 41            	CALL	SSTSA		; Second string to string area
    2831/    4165 : 21 85 3B            	LD	HL,EVAL2	; Return to evaluation loop
    2832/    4168 : E3                  	EX	(SP),HL		; Save return,get code string
    2833/    4169 : E5                  	PUSH	HL		; Save code string address
    2834/    416A : C3 20 40            	JP	TSTOPL		; To temporary string to pool
    2835/    416D :                     ;
    2836/    416D : E1                  SSTSA:	POP	HL		; Return address
    2837/    416E : E3                  	EX	(SP),HL		; Get string block,save return
    2838/    416F : 7E                  	LD	A,(HL)		; Get length of string
    2839/    4170 : 23                  	INC	HL
    2840/    4171 : 23                  	INC	HL
    2841/    4172 : 4E                  	LD	C,(HL)		; Get LSB of string address
    2842/    4173 : 23                  	INC	HL
    2843/    4174 : 46                  	LD	B,(HL)		; Get MSB of string address
    2844/    4175 : 6F                  	LD	L,A		; Length to L
    2845/    4176 : 2C                  TOSTRA: INC	L		; INC - DECed after
    2846/    4177 : 2D                  TSALP:	DEC	L		; Count bytes moved
    2847/    4178 : C8                  	RET	Z		; End of string - Return
    2848/    4179 : 0A                  	LD	A,(BC)		; Get source
    2849/    417A : 12                  	LD	(DE),A		; Save destination
    2850/    417B : 03                  	INC	BC		; Next source
    2851/    417C : 13                  	INC	DE		; Next destination
    2852/    417D : C3 77 41            	JP	TSALP		; Loop until string moved
    2853/    4180 :                     ;
    2854/    4180 : CD 6B 3B            GETSTR: CALL	TSTSTR		; Make sure it's a string
    2855/    4183 : 2A 29 C1            GSTRCU: LD	HL,(FPREG)	; Get current string
    2856/    4186 : EB                  GSTRHL: EX	DE,HL		; Save DE
    2857/    4187 : CD A1 41            GSTRDE: CALL	BAKTMP		; Was it last tmp-str?
    2858/    418A : EB                  	EX	DE,HL		; Restore DE
    2859/    418B : C0                  	RET	NZ		; No - Return
    2860/    418C : D5                  	PUSH	DE		; Save string
    2861/    418D : 50                  	LD	D,B		; String block address to DE
    2862/    418E : 59                  	LD	E,C
    2863/    418F : 1B                  	DEC	DE		; Point to length
    2864/    4190 : 4E                  	LD	C,(HL)		; Get string length
    2865/    4191 : 2A 08 C1            	LD	HL,(STRBOT)	; Current bottom of string area
    2866/    4194 : CD 6C 35            	CALL	CPDEHL		; Last one in string area?
    2867/    4197 : C2 9F 41            	JP	NZ,POPHL	; No - Return
    2868/    419A : 47                  	LD	B,A		; Clear B (A=0)
    2869/    419B : 09                  	ADD	HL,BC		; Remove string from str' area
    2870/    419C : 22 08 C1            	LD	(STRBOT),HL	; Save new bottom of str' area
    2871/    419F : E1                  POPHL:	POP	HL		; Restore string
    2872/    41A0 : C9                  	RET
    2873/    41A1 :                     ;
    2874/    41A1 : 2A F6 C0            BAKTMP: LD	HL,(TMSTPT)	; Get temporary string pool top
    2875/    41A4 : 2B                  	DEC	HL		; Back
    2876/    41A5 : 46                  	LD	B,(HL)		; Get MSB of address
    2877/    41A6 : 2B                  	DEC	HL		; Back
    2878/    41A7 : 4E                  	LD	C,(HL)		; Get LSB of address
    2879/    41A8 : 2B                  	DEC	HL		; Back
    2880/    41A9 : 2B                  	DEC	HL		; Back
    2881/    41AA : CD 6C 35            	CALL	CPDEHL		; String last in string pool?
    2882/    41AD : C0                  	RET	NZ		; Yes - Leave it
    2883/    41AE : 22 F6 C0            	LD	(TMSTPT),HL	; Save new string pool top
    2884/    41B1 : C9                  	RET
    2885/    41B2 :                     ;
    2886/    41B2 : 01 31 3F            LEN:	LD	BC,PASSA	; To return integer A
    2887/    41B5 : C5                  	PUSH	BC		; Save address
    2888/    41B6 : CD 80 41            GETLEN: CALL	GETSTR		; Get string and its length
    2889/    41B9 : AF                  	XOR	A
    2890/    41BA : 57                  	LD	D,A		; Clear D
    2891/    41BB : 32 F2 C0            	LD	(TYPE),A	; Set type to numeric
    2892/    41BE : 7E                  	LD	A,(HL)		; Get length of string
    2893/    41BF : B7                  	OR	A		; Set status flags
    2894/    41C0 : C9                  	RET
    2895/    41C1 :                     ;
    2896/    41C1 : 01 31 3F            ASC:	LD	BC,PASSA	; To return integer A
    2897/    41C4 : C5                  	PUSH	BC		; Save address
    2898/    41C5 : CD B6 41            GTFLNM: CALL	GETLEN		; Get length of string
    2899/    41C8 : CA C1 37            	JP	Z,FCERR		; Null string - Error
    2900/    41CB : 23                  	INC	HL
    2901/    41CC : 23                  	INC	HL
    2902/    41CD : 5E                  	LD	E,(HL)		; Get LSB of address
    2903/    41CE : 23                  	INC	HL
    2904/    41CF : 56                  	LD	D,(HL)		; Get MSB of address
    2905/    41D0 : 1A                  	LD	A,(DE)		; Get first byte of string
    2906/    41D1 : C9                  	RET
    2907/    41D2 :                     ;
    2908/    41D2 : 3E 01               CHR:	LD	A,1		; One character string
    2909/    41D4 : CD EF 3F            	CALL	MKTMST		; Make a temporary string
    2910/    41D7 : CD CB 42            	CALL	MAKINT		; Make it integer A
    2911/    41DA : 2A 06 C1            	LD	HL,(TMPSTR+2)	; Get address of string
    2912/    41DD : 73                  	LD	(HL),E		; Save character
    2913/    41DE : C1                  TOPOOL: POP	BC		; Clean up stack
    2914/    41DF : C3 20 40            	JP	TSTOPL		; Temporary string to pool
    2915/    41E2 :                     ;
    2916/    41E2 : CD 7B 42            LEFT:	CALL	LFRGNM		; Get number and ending ")"
    2917/    41E5 : AF                  	XOR	A		; Start at first byte in string
    2918/    41E6 : E3                  RIGHT1: EX	(SP),HL		; Save code string,Get string
    2919/    41E7 : 4F                  	LD	C,A		; Starting position in string
    2920/    41E8 : E5                  MID1:	PUSH	HL		; Save string block address
    2921/    41E9 : 7E                  	LD	A,(HL)		; Get length of string
    2922/    41EA : B8                  	CP	B		; Compare with number given
    2923/    41EB : DA F0 41            	JP	C,ALLFOL	; All following bytes required
    2924/    41EE : 78                  	LD	A,B		; Get new length
    2925/    41EF : 11                  	DB	11H		; Skip "LD C,0"
    2926/    41F0 : 0E 00               ALLFOL: LD	C,0		; First byte of string
    2927/    41F2 : C5                  	PUSH	BC		; Save position in string
    2928/    41F3 : CD 59 40            	CALL	TESTR		; See if enough string space
    2929/    41F6 : C1                  	POP	BC		; Get position in string
    2930/    41F7 : E1                  	POP	HL		; Restore string block address
    2931/    41F8 : E5                  	PUSH	HL		; And re-save it
    2932/    41F9 : 23                  	INC	HL
    2933/    41FA : 23                  	INC	HL
    2934/    41FB : 46                  	LD	B,(HL)		; Get LSB of address
    2935/    41FC : 23                  	INC	HL
    2936/    41FD : 66                  	LD	H,(HL)		; Get MSB of address
    2937/    41FE : 68                  	LD	L,B		; HL = address of string
    2938/    41FF : 06 00               	LD	B,0		; BC = starting address
    2939/    4201 : 09                  	ADD	HL,BC		; Point to that byte
    2940/    4202 : 44                  	LD	B,H		; BC = source string
    2941/    4203 : 4D                  	LD	C,L
    2942/    4204 : CD F2 3F            	CALL	CRTMST		; Create a string entry
    2943/    4207 : 6F                  	LD	L,A		; Length of new string
    2944/    4208 : CD 76 41            	CALL	TOSTRA		; Move string to string area
    2945/    420B : D1                  	POP	DE		; Clear stack
    2946/    420C : CD 87 41            	CALL	GSTRDE		; Move to string pool if needed
    2947/    420F : C3 20 40            	JP	TSTOPL		; Temporary string to pool
    2948/    4212 :                     ;
    2949/    4212 : CD 7B 42            RIGHT:	CALL	LFRGNM		; Get number and ending ")"
    2950/    4215 : D1                  	POP	DE		; Get string length
    2951/    4216 : D5                  	PUSH	DE		; And re-save
    2952/    4217 : 1A                  	LD	A,(DE)		; Get length
    2953/    4218 : 90                  	SUB	B		; Move back N bytes
    2954/    4219 : C3 E6 41            	JP	RIGHT1		; Go and get sub-string
    2955/    421C :                     ;
    2956/    421C : EB                  MID:	EX	DE,HL		; Get code string address
    2957/    421D : 7E                  	LD	A,(HL)		; Get next byte ',' or ")"
    2958/    421E : CD 80 42            	CALL	MIDNUM		; Get number supplied
    2959/    4221 : 04                  	INC	B		; Is it character zero?
    2960/    4222 : 05                  	DEC	B
    2961/    4223 : CA C1 37            	JP	Z,FCERR		; Yes - Error
    2962/    4226 : C5                  	PUSH	BC		; Save starting position
    2963/    4227 : 1E FF               	LD	E,255		; All of string
    2964/    4229 : FE 29               	CP	')'		; Any length given?
    2965/    422B : CA 35 42            	JP	Z,RSTSTR	; No - Rest of string
    2966/    422E : CD 72 35            	CALL	CHKSYN		; Make sure ',' follows
    2967/    4231 : 2C                  	DB	','
    2968/    4232 : CD C8 42            	CALL	GETINT		; Get integer 0-255
    2969/    4235 : CD 72 35            RSTSTR: CALL	CHKSYN		; Make sure ")" follows
    2970/    4238 : 29                  	DB	")"
    2971/    4239 : F1                  	POP	AF		; Restore starting position
    2972/    423A : E3                  	EX	(SP),HL		; Get string,8ave code string
    2973/    423B : 01 E8 41            	LD	BC,MID1		; Continuation of MID$ routine
    2974/    423E : C5                  	PUSH	BC		; Save for return
    2975/    423F : 3D                  	DEC	A		; Starting position-1
    2976/    4240 : BE                  	CP	(HL)		; Compare with length
    2977/    4241 : 06 00               	LD	B,0		; Zero bytes length
    2978/    4243 : D0                  	RET	NC		; Null string if start past end
    2979/    4244 : 4F                  	LD	C,A		; Save starting position-1
    2980/    4245 : 7E                  	LD	A,(HL)		; Get length of string
    2981/    4246 : 91                  	SUB	C		; Subtract start
    2982/    4247 : BB                  	CP	E		; Enough string for it?
    2983/    4248 : 47                  	LD	B,A		; Save maximum length available
    2984/    4249 : D8                  	RET	C		; Truncate string if needed
    2985/    424A : 43                  	LD	B,E		; Set specified length
    2986/    424B : C9                  	RET			; Go and create string
    2987/    424C :                     ;
    2988/    424C : CD B6 41            VAL:	CALL	GETLEN		; Get length of string
    2989/    424F : CA 69 43            	JP	Z,RESZER	; Result zero
    2990/    4252 : 5F                  	LD	E,A		; Save length
    2991/    4253 : 23                  	INC	HL
    2992/    4254 : 23                  	INC	HL
    2993/    4255 : 7E                  	LD	A,(HL)		; Get LSB of address
    2994/    4256 : 23                  	INC	HL
    2995/    4257 : 66                  	LD	H,(HL)		; Get MSB of address
    2996/    4258 : 6F                  	LD	L,A		; HL = String address
    2997/    4259 : E5                  	PUSH	HL		; Save string address
    2998/    425A : 19                  	ADD	HL,DE
    2999/    425B : 46                  	LD	B,(HL)		; Get end of string+1 byte
    3000/    425C : 72                  	LD	(HL),D		; Zero it to terminate
    3001/    425D : E3                  	EX	(SP),HL		; Save string end,get start
    3002/    425E : C5                  	PUSH	BC		; Save end+1 byte
    3003/    425F : 7E                  	LD	A,(HL)		; Get starting byte
    3004/    4260 : FE 24               	CP	'$'		; Hex number indicated? [function added]
    3005/    4262 : C2 6A 42            	JP	NZ,VAL1
    3006/    4265 : CD 93 4A            	CALL	HEXTFP		; Convert Hex to FPREG
    3007/    4268 : 18 0D               	JR	VAL3
    3008/    426A : FE 25               VAL1:	CP	'%'		; Binary number indicated? [function added]
    3009/    426C : C2 74 42            	JP	NZ,VAL2
    3010/    426F : CD 03 4B            	CALL	BINTFP		; Convert Bin to FPREG
    3011/    4272 : 18 03               	JR	VAL3
    3012/    4274 : CD 50 46            VAL2:	CALL	ASCTFP		; Convert ASCII string to FP
    3013/    4277 : C1                  VAL3:	POP	BC		; Restore end+1 byte
    3014/    4278 : E1                  	POP	HL		; Restore end+1 address
    3015/    4279 : 70                  	LD	(HL),B		; Put back original byte
    3016/    427A : C9                  	RET
    3017/    427B :                     ;
    3018/    427B : EB                  LFRGNM: EX	DE,HL		; Code string address to HL
    3019/    427C : CD 72 35            	CALL	CHKSYN		; Make sure ")" follows
    3020/    427F : 29                  	DB	")"
    3021/    4280 : C1                  MIDNUM: POP	BC		; Get return address
    3022/    4281 : D1                  	POP	DE		; Get number supplied
    3023/    4282 : C5                  	PUSH	BC		; Re-save return address
    3024/    4283 : 43                  	LD	B,E		; Number to B
    3025/    4284 : C9                  	RET
    3026/    4285 :                     ;
    3027/    4285 : CD CB 42            INP:	CALL	MAKINT		; Make it integer A
    3028/    4288 : 32 84 C0            	LD	(INPORT),A	; Set input port
    3029/    428B : CD 83 C0            	CALL	INPSUB		; Get input from port
    3030/    428E : C3 31 3F            	JP	PASSA		; Return integer A
    3031/    4291 :                     ;
    3032/    4291 : CD B5 42            POUT:	CALL	SETIO		; Set up port number
    3033/    4294 : C3 4B C0            	JP	OUTSUB		; Output data and return
    3034/    4297 :                     ;
    3035/    4297 : CD B5 42            WAIT:	CALL	SETIO		; Set up port number
    3036/    429A : F5                  	PUSH	AF		; Save AND mask
    3037/    429B : 1E 00               	LD	E,0		; Assume zero if none given
    3038/    429D : 2B                  	DEC	HL		; DEC 'cos GETCHR INCs
    3039/    429E : CD FA 36            	CALL	GETCHR		; Get next character
    3040/    42A1 : CA AB 42            	JP	Z,NOXOR		; No XOR byte given
    3041/    42A4 : CD 72 35            	CALL	CHKSYN		; Make sure ',' follows
    3042/    42A7 : 2C                  	DB	','
    3043/    42A8 : CD C8 42            	CALL	GETINT		; Get integer 0-255 to XOR with
    3044/    42AB : C1                  NOXOR:	POP	BC		; Restore AND mask
    3045/    42AC : CD 83 C0            WAITLP: CALL	INPSUB		; Get input
    3046/    42AF : AB                  	XOR	E		; Flip selected bits
    3047/    42B0 : A0                  	AND	B		; Result non-zero?
    3048/    42B1 : CA AC 42            	JP	Z,WAITLP	; No = keep waiting
    3049/    42B4 : C9                  	RET
    3050/    42B5 :                     ;
    3051/    42B5 : CD C8 42            SETIO:	CALL	GETINT		; Get integer 0-255
    3052/    42B8 : 32 84 C0            	LD	(INPORT),A	; Set input port
    3053/    42BB : 32 4C C0            	LD	(OTPORT),A	; Set output port
    3054/    42BE : CD 72 35            	CALL	CHKSYN		; Make sure ',' follows
    3055/    42C1 : 2C                  	DB	','
    3056/    42C2 : C3 C8 42            	JP	GETINT		; Get integer 0-255 and return
    3057/    42C5 :                     ;
    3058/    42C5 : CD FA 36            FNDNUM: CALL	GETCHR		; Get next character
    3059/    42C8 : CD 67 3B            GETINT: CALL	GETNUM		; Get a number from 0 to 255
    3060/    42CB : CD A6 37            MAKINT: CALL	DEPINT		; Make sure value 0 - 255
    3061/    42CE : 7A                  	LD	A,D		; Get MSB of number
    3062/    42CF : B7                  	OR	A		; Zero?
    3063/    42D0 : C2 C1 37            	JP	NZ,FCERR	; No - Error
    3064/    42D3 : 2B                  	DEC	HL		; DEC 'cos GETCHR INCs
    3065/    42D4 : CD FA 36            	CALL	GETCHR		; Get next character
    3066/    42D7 : 7B                  	LD	A,E		; Get number to A
    3067/    42D8 : C9                  	RET
    3068/    42D9 :                     ;
    3069/    42D9 : CD AC 37            PEEK:	CALL	DEINT		; Get memory address
    3070/    42DC : 1A                  	LD	A,(DE)		; Get byte in memory
    3071/    42DD : C3 31 3F            	JP	PASSA		; Return integer A
    3072/    42E0 :                     ;
    3073/    42E0 : CD 67 3B            POKE:	CALL	GETNUM		; Get memory address
    3074/    42E3 : CD AC 37            	CALL	DEINT		; Get integer -32768 to 3276
    3075/    42E6 : D5                  	PUSH	DE		; Save memory address
    3076/    42E7 : CD 72 35            	CALL	CHKSYN		; Make sure ',' follows
    3077/    42EA : 2C                  	DB	','
    3078/    42EB : CD C8 42            	CALL	GETINT		; Get integer 0-255
    3079/    42EE : D1                  	POP	DE		; Restore memory address
    3080/    42EF : 12                  	LD	(DE),A		; Load it into memory
    3081/    42F0 : C9                  	RET
    3082/    42F1 :                     ;
    3083/    42F1 : 21 C7 47            ROUND:	LD	HL,HALF		; Add 0.5 to FPREG
    3084/    42F4 : CD 98 45            ADDPHL: CALL	LOADFP		; Load FP at (HL) to BCDE
    3085/    42F7 : C3 03 43            	JP	FPADD		; Add BCDE to FPREG
    3086/    42FA :                     ;
    3087/    42FA : CD 98 45            SUBPHL: CALL	LOADFP		; FPREG = -FPREG + number at HL
    3088/    42FD : 21                  	DB	21H		; Skip "POP BC" and "POP DE"
    3089/    42FE : C1                  PSUB:	POP	BC		; Get FP number from stack
    3090/    42FF : D1                  	POP	DE
    3091/    4300 : CD 72 45            SUBCDE: CALL	INVSGN		; Negate FPREG
    3092/    4303 : 78                  FPADD:	LD	A,B		; Get FP exponent
    3093/    4304 : B7                  	OR	A		; Is number zero?
    3094/    4305 : C8                  	RET	Z		; Yes - Nothing to add
    3095/    4306 : 3A 2C C1            	LD	A,(FPEXP)	; Get FPREG exponent
    3096/    4309 : B7                  	OR	A		; Is this number zero?
    3097/    430A : CA 8A 45            	JP	Z,FPBCDE	; Yes - Move BCDE to FPREG
    3098/    430D : 90                  	SUB	B		; BCDE number larger?
    3099/    430E : D2 1D 43            	JP	NC,NOSWAP	; No - Don't swap them
    3100/    4311 : 2F                  	CPL			; Two's complement
    3101/    4312 : 3C                  	INC	A		;	FP exponent
    3102/    4313 : EB                  	EX	DE,HL
    3103/    4314 : CD 7A 45            	CALL	STAKFP		; Put FPREG on stack
    3104/    4317 : EB                  	EX	DE,HL
    3105/    4318 : CD 8A 45            	CALL	FPBCDE		; Move BCDE to FPREG
    3106/    431B : C1                  	POP	BC		; Restore number from stack
    3107/    431C : D1                  	POP	DE
    3108/    431D : FE 19               NOSWAP: CP	24+1		; Second number insignificant?
    3109/    431F : D0                  	RET	NC		; Yes - First number is result
    3110/    4320 : F5                  	PUSH	AF		; Save number of bits to scale
    3111/    4321 : CD AF 45            	CALL	SIGNS		; Set MSBs & sign of result
    3112/    4324 : 67                  	LD	H,A		; Save sign of result
    3113/    4325 : F1                  	POP	AF		; Restore scaling factor
    3114/    4326 : CD C8 43            	CALL	SCALE		; Scale BCDE to same exponent
    3115/    4329 : B4                  	OR	H		; Result to be positive?
    3116/    432A : 21 29 C1            	LD	HL,FPREG	; Point to FPREG
    3117/    432D : F2 43 43            	JP	P,MINCDE	; No - Subtract FPREG from CDE
    3118/    4330 : CD A8 43            	CALL	PLUCDE		; Add FPREG to CDE
    3119/    4333 : D2 89 43            	JP	NC,RONDUP	; No overflow - Round it up
    3120/    4336 : 23                  	INC	HL		; Point to exponent
    3121/    4337 : 34                  	INC	(HL)		; Increment it
    3122/    4338 : CA B3 32            	JP	Z,OVERR		; Number overflowed - Error
    3123/    433B : 2E 01               	LD	L,1		; 1 bit to shift right
    3124/    433D : CD DE 43            	CALL	SHRT1		; Shift result right
    3125/    4340 : C3 89 43            	JP	RONDUP		; Round it up
    3126/    4343 :                     ;
    3127/    4343 : AF                  MINCDE: XOR	A		; Clear A and carry
    3128/    4344 : 90                  	SUB	B		; Negate exponent
    3129/    4345 : 47                  	LD	B,A		; Re-save exponent
    3130/    4346 : 7E                  	LD	A,(HL)		; Get LSB of FPREG
    3131/    4347 : 9B                  	SBC	A, E		; Subtract LSB of BCDE
    3132/    4348 : 5F                  	LD	E,A		; Save LSB of BCDE
    3133/    4349 : 23                  	INC	HL
    3134/    434A : 7E                  	LD	A,(HL)		; Get NMSB of FPREG
    3135/    434B : 9A                  	SBC	A,D		; Subtract NMSB of BCDE
    3136/    434C : 57                  	LD	D,A		; Save NMSB of BCDE
    3137/    434D : 23                  	INC	HL
    3138/    434E : 7E                  	LD	A,(HL)		; Get MSB of FPREG
    3139/    434F : 99                  	SBC	A,C		; Subtract MSB of BCDE
    3140/    4350 : 4F                  	LD	C,A		; Save MSB of BCDE
    3141/    4351 : DC B4 43            CONPOS: CALL	C,COMPL		; Overflow - Make it positive
    3142/    4354 :                     ;
    3143/    4354 : 68                  BNORM:	LD	L,B		; L = Exponent
    3144/    4355 : 63                  	LD	H,E		; H = LSB
    3145/    4356 : AF                  	XOR	A
    3146/    4357 : 47                  BNRMLP: LD	B,A		; Save bit count
    3147/    4358 : 79                  	LD	A,C		; Get MSB
    3148/    4359 : B7                  	OR	A		; Is it zero?
    3149/    435A : C2 76 43            	JP	NZ,PNORM	; No - Do it bit at a time
    3150/    435D : 4A                  	LD	C,D		; MSB = NMSB
    3151/    435E : 54                  	LD	D,H		; NMSB= LSB
    3152/    435F : 65                  	LD	H,L		; LSB = VLSB
    3153/    4360 : 6F                  	LD	L,A		; VLSB= 0
    3154/    4361 : 78                  	LD	A,B		; Get exponent
    3155/    4362 : D6 08               	SUB	8		; Count 8 bits
    3156/    4364 : FE E0               	CP	0E0H		; -24-8 Was number zero?
    3157/    4366 : C2 57 43            	JP	NZ,BNRMLP	; No - Keep normalising
    3158/    4369 : AF                  RESZER: XOR	A		; Result is zero
    3159/    436A : 32 2C C1            SAVEXP: LD	(FPEXP),A	; Save result as zero
    3160/    436D : C9                  	RET
    3161/    436E :                     ;
    3162/    436E : 05                  NORMAL: DEC	B		; Count bits
    3163/    436F : 29                  	ADD	HL,HL		; Shift HL left
    3164/    4370 : 7A                  	LD	A,D		; Get NMSB
    3165/    4371 : 17                  	RLA			; Shift left with last bit
    3166/    4372 : 57                  	LD	D,A		; Save NMSB
    3167/    4373 : 79                  	LD	A,C		; Get MSB
    3168/    4374 : 8F                  	ADC	A,A		; Shift left with last bit
    3169/    4375 : 4F                  	LD	C,A		; Save MSB
    3170/    4376 : F2 6E 43            PNORM:	JP	P,NORMAL	; Not done - Keep going
    3171/    4379 : 78                  	LD	A,B		; Number of bits shifted
    3172/    437A : 5C                  	LD	E,H		; Save HL in EB
    3173/    437B : 45                  	LD	B,L
    3174/    437C : B7                  	OR	A		; Any shifting done?
    3175/    437D : CA 89 43            	JP	Z,RONDUP	; No - Round it up
    3176/    4380 : 21 2C C1            	LD	HL,FPEXP	; Point to exponent
    3177/    4383 : 86                  	ADD	A,(HL)		; Add shifted bits
    3178/    4384 : 77                  	LD	(HL),A		; Re-save exponent
    3179/    4385 : D2 69 43            	JP	NC,RESZER	; Underflow - Result is zero
    3180/    4388 : C8                  	RET	Z		; Result is zero
    3181/    4389 : 78                  RONDUP: LD	A,B		; Get VLSB of number
    3182/    438A : 21 2C C1            RONDB:	LD	HL,FPEXP	; Point to exponent
    3183/    438D : B7                  	OR	A		; Any rounding?
    3184/    438E : FC 9B 43            	CALL	M,FPROND	; Yes - Round number up
    3185/    4391 : 46                  	LD	B,(HL)		; B = Exponent
    3186/    4392 : 23                  	INC	HL
    3187/    4393 : 7E                  	LD	A,(HL)		; Get sign of result
    3188/    4394 : E6 80               	AND	10000000B	; Only bit 7 needed
    3189/    4396 : A9                  	XOR	C		; Set correct sign
    3190/    4397 : 4F                  	LD	C,A		; Save correct sign in number
    3191/    4398 : C3 8A 45            	JP	FPBCDE		; Move BCDE to FPREG
    3192/    439B :                     ;
    3193/    439B : 1C                  FPROND: INC	E		; Round LSB
    3194/    439C : C0                  	RET	NZ		; Return if ok
    3195/    439D : 14                  	INC	D		; Round NMSB
    3196/    439E : C0                  	RET	NZ		; Return if ok
    3197/    439F : 0C                  	INC	C		; Round MSB
    3198/    43A0 : C0                  	RET	NZ		; Return if ok
    3199/    43A1 : 0E 80               	LD	C,80H		; Set normal value
    3200/    43A3 : 34                  	INC	(HL)		; Increment exponent
    3201/    43A4 : C0                  	RET	NZ		; Return if ok
    3202/    43A5 : C3 B3 32            	JP	OVERR		; Overflow error
    3203/    43A8 :                     ;
    3204/    43A8 : 7E                  PLUCDE: LD	A,(HL)		; Get LSB of FPREG
    3205/    43A9 : 83                  	ADD	A,E		; Add LSB of BCDE
    3206/    43AA : 5F                  	LD	E,A		; Save LSB of BCDE
    3207/    43AB : 23                  	INC	HL
    3208/    43AC : 7E                  	LD	A,(HL)		; Get NMSB of FPREG
    3209/    43AD : 8A                  	ADC	A,D		; Add NMSB of BCDE
    3210/    43AE : 57                  	LD	D,A		; Save NMSB of BCDE
    3211/    43AF : 23                  	INC	HL
    3212/    43B0 : 7E                  	LD	A,(HL)		; Get MSB of FPREG
    3213/    43B1 : 89                  	ADC	A,C		; Add MSB of BCDE
    3214/    43B2 : 4F                  	LD	C,A		; Save MSB of BCDE
    3215/    43B3 : C9                  	RET
    3216/    43B4 :                     ;
    3217/    43B4 : 21 2D C1            COMPL:	LD	HL,SGNRES	; Sign of result
    3218/    43B7 : 7E                  	LD	A,(HL)		; Get sign of result
    3219/    43B8 : 2F                  	CPL			; Negate it
    3220/    43B9 : 77                  	LD	(HL),A		; Put it back
    3221/    43BA : AF                  	XOR	A
    3222/    43BB : 6F                  	LD	L,A		; Set L to zero
    3223/    43BC : 90                  	SUB	B		; Negate exponent,set carry
    3224/    43BD : 47                  	LD	B,A		; Re-save exponent
    3225/    43BE : 7D                  	LD	A,L		; Load zero
    3226/    43BF : 9B                  	SBC	A,E		; Negate LSB
    3227/    43C0 : 5F                  	LD	E,A		; Re-save LSB
    3228/    43C1 : 7D                  	LD	A,L		; Load zero
    3229/    43C2 : 9A                  	SBC	A,D		; Negate NMSB
    3230/    43C3 : 57                  	LD	D,A		; Re-save NMSB
    3231/    43C4 : 7D                  	LD	A,L		; Load zero
    3232/    43C5 : 99                  	SBC	A,C		; Negate MSB
    3233/    43C6 : 4F                  	LD	C,A		; Re-save MSB
    3234/    43C7 : C9                  	RET
    3235/    43C8 :                     ;
    3236/    43C8 : 06 00               SCALE:	LD	B,0		; Clear underflow
    3237/    43CA : D6 08               SCALLP: SUB	8		; 8 bits (a whole byte)?
    3238/    43CC : DA D7 43            	JP	C,SHRITE	; No - Shift right A bits
    3239/    43CF : 43                  	LD	B,E		; <- Shift
    3240/    43D0 : 5A                  	LD	E,D		; <- right
    3241/    43D1 : 51                  	LD	D,C		; <- eight
    3242/    43D2 : 0E 00               	LD	C,0		; <- bits
    3243/    43D4 : C3 CA 43            	JP	SCALLP		; More bits to shift
    3244/    43D7 :                     ;
    3245/    43D7 : C6 09               SHRITE: ADD	A,8+1		; Adjust count
    3246/    43D9 : 6F                  	LD	L,A		; Save bits to shift
    3247/    43DA : AF                  SHRLP:	XOR	A		; Flag for all done
    3248/    43DB : 2D                  	DEC	L		; All shifting done?
    3249/    43DC : C8                  	RET	Z		; Yes - Return
    3250/    43DD : 79                  	LD	A,C		; Get MSB
    3251/    43DE : 1F                  SHRT1:	RRA			; Shift it right
    3252/    43DF : 4F                  	LD	C,A		; Re-save
    3253/    43E0 : 7A                  	LD	A,D		; Get NMSB
    3254/    43E1 : 1F                  	RRA			; Shift right with last bit
    3255/    43E2 : 57                  	LD	D,A		; Re-save it
    3256/    43E3 : 7B                  	LD	A,E		; Get LSB
    3257/    43E4 : 1F                  	RRA			; Shift right with last bit
    3258/    43E5 : 5F                  	LD	E,A		; Re-save it
    3259/    43E6 : 78                  	LD	A,B		; Get underflow
    3260/    43E7 : 1F                  	RRA			; Shift right with last bit
    3261/    43E8 : 47                  	LD	B,A		; Re-save underflow
    3262/    43E9 : C3 DA 43            	JP	SHRLP		; More bits to do
    3263/    43EC :                     ;
    3264/    43EC : 00 00 00 81         UNITY:	DB	 000H,000H,000H,081H	; 1.00000
    3265/    43F0 :                     ;
    3266/    43F0 : 03                  LOGTAB: DB	3			; Table used by LOG
    3267/    43F1 : AA 56 19 80         	DB	0AAH,056H,019H,080H	; 0.59898
    3268/    43F5 : F1 22 76 80         	DB	0F1H,022H,076H,080H	; 0.96147
    3269/    43F9 : 45 AA 38 82         	DB	045H,0AAH,038H,082H	; 2.88539
    3270/    43FD :                     ;
    3271/    43FD : CD 49 45            LOG:	CALL	TSTSGN		; Test sign of value
    3272/    4400 : B7                  	OR	A
    3273/    4401 : EA C1 37            	JP	PE,FCERR	; ?FC Error if <= zero
    3274/    4404 : 21 2C C1            	LD	HL,FPEXP	; Point to exponent
    3275/    4407 : 7E                  	LD	A,(HL)		; Get exponent
    3276/    4408 : 01 35 80            	LD	BC,8035H	; BCDE = SQR(1/2)
    3277/    440B : 11 F3 04            	LD	DE,04F3H
    3278/    440E : 90                  	SUB	B		; Scale value to be < 1
    3279/    440F : F5                  	PUSH	AF		; Save scale factor
    3280/    4410 : 70                  	LD	(HL),B		; Save new exponent
    3281/    4411 : D5                  	PUSH	DE		; Save SQR(1/2)
    3282/    4412 : C5                  	PUSH	BC
    3283/    4413 : CD 03 43            	CALL	FPADD		; Add SQR(1/2) to value
    3284/    4416 : C1                  	POP	BC		; Restore SQR(1/2)
    3285/    4417 : D1                  	POP	DE
    3286/    4418 : 04                  	INC	B		; Make it SQR(2)
    3287/    4419 : CD 9F 44            	CALL	DVBCDE		; Divide by SQR(2)
    3288/    441C : 21 EC 43            	LD	HL,UNITY	; Point to 1.
    3289/    441F : CD FA 42            	CALL	SUBPHL		; Subtract FPREG from 1
    3290/    4422 : 21 F0 43            	LD	HL,LOGTAB	; Coefficient table
    3291/    4425 : CD 91 48            	CALL	SUMSER		; Evaluate sum of series
    3292/    4428 : 01 80 80            	LD	BC,8080H	; BCDE = -0.5
    3293/    442B : 11 00 00            	LD	DE,0000H
    3294/    442E : CD 03 43            	CALL	FPADD		; Subtract 0.5 from FPREG
    3295/    4431 : F1                  	POP	AF		; Restore scale factor
    3296/    4432 : CD C4 46            	CALL	RSCALE		; Re-scale number
    3297/    4435 : 01 31 80            MULLN2: LD	BC,8031H	; BCDE = Ln(2)
    3298/    4438 : 11 18 72            	LD	DE,7218H
    3299/    443B : 21                  	DB	21H		; Skip "POP BC" and "POP DE"
    3300/    443C :                     ;
    3301/    443C : C1                  MULT:	POP	BC		; Get number from stack
    3302/    443D : D1                  	POP	DE
    3303/    443E : CD 49 45            FPMULT: CALL	TSTSGN		; Test sign of FPREG
    3304/    4441 : C8                  	RET	Z		; Return zero if zero
    3305/    4442 : 2E 00               	LD	L,0		; Flag add exponents
    3306/    4444 : CD 07 45            	CALL	ADDEXP		; Add exponents
    3307/    4447 : 79                  	LD	A,C		; Get MSB of multiplier
    3308/    4448 : 32 3B C1            	LD	(MULVAL),A	; Save MSB of multiplier
    3309/    444B : EB                  	EX	DE,HL
    3310/    444C : 22 3C C1            	LD	(MULVAL+1),HL	; Save rest of multiplier
    3311/    444F : 01 00 00            	LD	BC,0		; Partial product (BCDE) = zero
    3312/    4452 : 50                  	LD	D,B
    3313/    4453 : 58                  	LD	E,B
    3314/    4454 : 21 54 43            	LD	HL,BNORM	; Address of normalise
    3315/    4457 : E5                  	PUSH	HL		; Save for return
    3316/    4458 : 21 60 44            	LD	HL,MULT8	; Address of 8 bit multiply
    3317/    445B : E5                  	PUSH	HL		; Save for NMSB,MSB
    3318/    445C : E5                  	PUSH	HL		; 
    3319/    445D : 21 29 C1            	LD	HL,FPREG	; Point to number
    3320/    4460 : 7E                  MULT8:	LD	A,(HL)		; Get LSB of number
    3321/    4461 : 23                  	INC	HL		; Point to NMSB
    3322/    4462 : B7                  	OR	A		; Test LSB
    3323/    4463 : CA 8C 44            	JP	Z,BYTSFT	; Zero - shift to next byte
    3324/    4466 : E5                  	PUSH	HL		; Save address of number
    3325/    4467 : 2E 08               	LD	L,8		; 8 bits to multiply by
    3326/    4469 : 1F                  MUL8LP: RRA			; Shift LSB right
    3327/    446A : 67                  	LD	H,A		; Save LSB
    3328/    446B : 79                  	LD	A,C		; Get MSB
    3329/    446C : D2 7A 44            	JP	NC,NOMADD	; Bit was zero - Don't add
    3330/    446F : E5                  	PUSH	HL		; Save LSB and count
    3331/    4470 : 2A 3C C1            	LD	HL,(MULVAL+1)	; Get LSB and NMSB
    3332/    4473 : 19                  	ADD	HL,DE		; Add NMSB and LSB
    3333/    4474 : EB                  	EX	DE,HL		; Leave sum in DE
    3334/    4475 : E1                  	POP	HL		; Restore MSB and count
    3335/    4476 : 3A 3B C1            	LD	A,(MULVAL)	; Get MSB of multiplier
    3336/    4479 : 89                  	ADC	A,C		; Add MSB
    3337/    447A : 1F                  NOMADD: RRA			; Shift MSB right
    3338/    447B : 4F                  	LD	C,A		; Re-save MSB
    3339/    447C : 7A                  	LD	A,D		; Get NMSB
    3340/    447D : 1F                  	RRA			; Shift NMSB right
    3341/    447E : 57                  	LD	D,A		; Re-save NMSB
    3342/    447F : 7B                  	LD	A,E		; Get LSB
    3343/    4480 : 1F                  	RRA			; Shift LSB right
    3344/    4481 : 5F                  	LD	E,A		; Re-save LSB
    3345/    4482 : 78                  	LD	A,B		; Get VLSB
    3346/    4483 : 1F                  	RRA			; Shift VLSB right
    3347/    4484 : 47                  	LD	B,A		; Re-save VLSB
    3348/    4485 : 2D                  	DEC	L		; Count bits multiplied
    3349/    4486 : 7C                  	LD	A,H		; Get LSB of multiplier
    3350/    4487 : C2 69 44            	JP	NZ,MUL8LP	; More - Do it
    3351/    448A : E1                  POPHRT: POP	HL		; Restore address of number
    3352/    448B : C9                  	RET
    3353/    448C :                     ;
    3354/    448C : 43                  BYTSFT: LD	B,E		; Shift partial product left
    3355/    448D : 5A                  	LD	E,D
    3356/    448E : 51                  	LD	D,C
    3357/    448F : 4F                  	LD	C,A
    3358/    4490 : C9                  	RET
    3359/    4491 :                     ;
    3360/    4491 : CD 7A 45            DIV10:	CALL	STAKFP		; Save FPREG on stack
    3361/    4494 : 01 20 84            	LD	BC,8420H	; BCDE = 10.
    3362/    4497 : 11 00 00            	LD	DE,0000H
    3363/    449A : CD 8A 45            	CALL	FPBCDE		; Move 10 to FPREG
    3364/    449D :                     ;
    3365/    449D : C1                  DIV:	POP	BC		; Get number from stack
    3366/    449E : D1                  	POP	DE
    3367/    449F : CD 49 45            DVBCDE: CALL	TSTSGN		; Test sign of FPREG
    3368/    44A2 : CA A7 32            	JP	Z,DZERR		; Error if division by zero
    3369/    44A5 : 2E FF               	LD	L,-1		; Flag subtract exponents
    3370/    44A7 : CD 07 45            	CALL	ADDEXP		; Subtract exponents
    3371/    44AA : 34                  	INC	(HL)		; Add 2 to exponent to adjust
    3372/    44AB : 34                  	INC	(HL)
    3373/    44AC : 2B                  	DEC	HL		; Point to MSB
    3374/    44AD : 7E                  	LD	A,(HL)		; Get MSB of dividend
    3375/    44AE : 32 57 C0            	LD	(DIV3),A	; Save for subtraction
    3376/    44B1 : 2B                  	DEC	HL
    3377/    44B2 : 7E                  	LD	A,(HL)		; Get NMSB of dividend
    3378/    44B3 : 32 53 C0            	LD	(DIV2),A	; Save for subtraction
    3379/    44B6 : 2B                  	DEC	HL
    3380/    44B7 : 7E                  	LD	A,(HL)		; Get MSB of dividend
    3381/    44B8 : 32 4F C0            	LD	(DIV1),A	; Save for subtraction
    3382/    44BB : 41                  	LD	B,C		; Get MSB
    3383/    44BC : EB                  	EX	DE,HL		; NMSB,LSB to HL
    3384/    44BD : AF                  	XOR	A
    3385/    44BE : 4F                  	LD	C,A		; Clear MSB of quotient
    3386/    44BF : 57                  	LD	D,A		; Clear NMSB of quotient
    3387/    44C0 : 5F                  	LD	E,A		; Clear LSB of quotient
    3388/    44C1 : 32 5A C0            	LD	(DIV4),A	; Clear overflow count
    3389/    44C4 : E5                  DIVLP:	PUSH	HL		; Save divisor
    3390/    44C5 : C5                  	PUSH	BC
    3391/    44C6 : 7D                  	LD	A,L		; Get LSB of number
    3392/    44C7 : CD 4E C0            	CALL	DIVSUP		; Subt' divisor from dividend
    3393/    44CA : DE 00               	SBC	A,0		; Count for overflows
    3394/    44CC : 3F                  	CCF
    3395/    44CD : D2 D7 44            	JP	NC,RESDIV	; Restore divisor if borrow
    3396/    44D0 : 32 5A C0            	LD	(DIV4),A	; Re-save overflow count
    3397/    44D3 : F1                  	POP	AF		; Scrap divisor
    3398/    44D4 : F1                  	POP	AF
    3399/    44D5 : 37                  	SCF			; Set carry to
    3400/    44D6 : D2                  	DB	0D2H		; Skip "POP BC" and "POP HL"
    3401/    44D7 :                     ;
    3402/    44D7 : C1                  RESDIV: POP	BC		; Restore divisor
    3403/    44D8 : E1                  	POP	HL
    3404/    44D9 : 79                  	LD	A,C		; Get MSB of quotient
    3405/    44DA : 3C                  	INC	A
    3406/    44DB : 3D                  	DEC	A
    3407/    44DC : 1F                  	RRA			; Bit 0 to bit 7
    3408/    44DD : FA 8A 43            	JP	M,RONDB		; Done - Normalise result
    3409/    44E0 : 17                  	RLA			; Restore carry
    3410/    44E1 : 7B                  	LD	A,E		; Get LSB of quotient
    3411/    44E2 : 17                  	RLA			; Double it
    3412/    44E3 : 5F                  	LD	E,A		; Put it back
    3413/    44E4 : 7A                  	LD	A,D		; Get NMSB of quotient
    3414/    44E5 : 17                  	RLA			; Double it
    3415/    44E6 : 57                  	LD	D,A		; Put it back
    3416/    44E7 : 79                  	LD	A,C		; Get MSB of quotient
    3417/    44E8 : 17                  	RLA			; Double it
    3418/    44E9 : 4F                  	LD	C,A		; Put it back
    3419/    44EA : 29                  	ADD	HL,HL		; Double NMSB,LSB of divisor
    3420/    44EB : 78                  	LD	A,B		; Get MSB of divisor
    3421/    44EC : 17                  	RLA			; Double it
    3422/    44ED : 47                  	LD	B,A		; Put it back
    3423/    44EE : 3A 5A C0            	LD	A,(DIV4)	; Get VLSB of quotient
    3424/    44F1 : 17                  	RLA			; Double it
    3425/    44F2 : 32 5A C0            	LD	(DIV4),A	; Put it back
    3426/    44F5 : 79                  	LD	A,C		; Get MSB of quotient
    3427/    44F6 : B2                  	OR	D		; Merge NMSB
    3428/    44F7 : B3                  	OR	E		; Merge LSB
    3429/    44F8 : C2 C4 44            	JP	NZ,DIVLP	; Not done - Keep dividing
    3430/    44FB : E5                  	PUSH	HL		; Save divisor
    3431/    44FC : 21 2C C1            	LD	HL,FPEXP	; Point to exponent
    3432/    44FF : 35                  	DEC	(HL)		; Divide by 2
    3433/    4500 : E1                  	POP	HL		; Restore divisor
    3434/    4501 : C2 C4 44            	JP	NZ,DIVLP	; Ok - Keep going
    3435/    4504 : C3 B3 32            	JP	OVERR		; Overflow error
    3436/    4507 :                     ;
    3437/    4507 : 78                  ADDEXP: LD	A,B		; Get exponent of dividend
    3438/    4508 : B7                  	OR	A		; Test it
    3439/    4509 : CA 2B 45            	JP	Z,OVTST3	; Zero - Result zero
    3440/    450C : 7D                  	LD	A,L		; Get add/subtract flag
    3441/    450D : 21 2C C1            	LD	HL,FPEXP	; Point to exponent
    3442/    4510 : AE                  	XOR	(HL)		; Add or subtract it
    3443/    4511 : 80                  	ADD	A,B		; Add the other exponent
    3444/    4512 : 47                  	LD	B,A		; Save new exponent
    3445/    4513 : 1F                  	RRA			; Test exponent for overflow
    3446/    4514 : A8                  	XOR	B
    3447/    4515 : 78                  	LD	A,B		; Get exponent
    3448/    4516 : F2 2A 45            	JP	P,OVTST2	; Positive - Test for overflow
    3449/    4519 : C6 80               	ADD	A,80H		; Add excess 128
    3450/    451B : 77                  	LD	(HL),A		; Save new exponent
    3451/    451C : CA 8A 44            	JP	Z,POPHRT	; Zero - Result zero
    3452/    451F : CD AF 45            	CALL	SIGNS		; Set MSBs and sign of result
    3453/    4522 : 77                  	LD	(HL),A		; Save new exponent
    3454/    4523 : 2B                  	DEC	HL		; Point to MSB
    3455/    4524 : C9                  	RET
    3456/    4525 :                     ;
    3457/    4525 : CD 49 45            OVTST1: CALL	TSTSGN		; Test sign of FPREG
    3458/    4528 : 2F                  	CPL			; Invert sign
    3459/    4529 : E1                  	POP	HL		; Clean up stack
    3460/    452A : B7                  OVTST2: OR	A		; Test if new exponent zero
    3461/    452B : E1                  OVTST3: POP	HL		; Clear off return address
    3462/    452C : F2 69 43            	JP	P,RESZER	; Result zero
    3463/    452F : C3 B3 32            	JP	OVERR		; Overflow error
    3464/    4532 :                     ;
    3465/    4532 : CD 95 45            MLSP10: CALL	BCDEFP		; Move FPREG to BCDE
    3466/    4535 : 78                  	LD	A,B		; Get exponent
    3467/    4536 : B7                  	OR	A		; Is it zero?
    3468/    4537 : C8                  	RET	Z		; Yes - Result is zero
    3469/    4538 : C6 02               	ADD	A,2		; Multiply by 4
    3470/    453A : DA B3 32            	JP	C,OVERR		; Overflow - ?OV Error
    3471/    453D : 47                  	LD	B,A		; Re-save exponent
    3472/    453E : CD 03 43            	CALL	FPADD		; Add BCDE to FPREG (Times 5)
    3473/    4541 : 21 2C C1            	LD	HL,FPEXP	; Point to exponent
    3474/    4544 : 34                  	INC	(HL)		; Double number (Times 10)
    3475/    4545 : C0                  	RET	NZ		; Ok - Return
    3476/    4546 : C3 B3 32            	JP	OVERR		; Overflow error
    3477/    4549 :                     ;
    3478/    4549 : 3A 2C C1            TSTSGN: LD	A,(FPEXP)	; Get sign of FPREG
    3479/    454C : B7                  	OR	A
    3480/    454D : C8                  	RET	Z		; RETurn if number is zero
    3481/    454E : 3A 2B C1            	LD	A,(FPREG+2)	; Get MSB of FPREG
    3482/    4551 : FE                  	DB	0FEH		; Test sign
    3483/    4552 : 2F                  RETREL: CPL			; Invert sign
    3484/    4553 : 17                  	RLA			; Sign bit to carry
    3485/    4554 : 9F                  FLGDIF: SBC	A,A		; Carry to all bits of A
    3486/    4555 : C0                  	RET	NZ		; Return -1 if negative
    3487/    4556 : 3C                  	INC	A		; Bump to +1
    3488/    4557 : C9                  	RET			; Positive - Return +1
    3489/    4558 :                     ;
    3490/    4558 : CD 49 45            SGN:	CALL	TSTSGN		; Test sign of FPREG
    3491/    455B : 06 88               FLGREL: LD	B,80H+8		; 8 bit integer in exponent
    3492/    455D : 11 00 00            	LD	DE,0		; Zero NMSB and LSB
    3493/    4560 : 21 2C C1            RETINT: LD	HL,FPEXP	; Point to exponent
    3494/    4563 : 4F                  	LD	C,A		; CDE = MSB,NMSB and LSB
    3495/    4564 : 70                  	LD	(HL),B		; Save exponent
    3496/    4565 : 06 00               	LD	B,0		; CDE = integer to normalise
    3497/    4567 : 23                  	INC	HL		; Point to sign of result
    3498/    4568 : 36 80               	LD	(HL),80H	; Set sign of result
    3499/    456A : 17                  	RLA			; Carry = sign of integer
    3500/    456B : C3 51 43            	JP	CONPOS		; Set sign of result
    3501/    456E :                     ;
    3502/    456E : CD 49 45            ABS:	CALL	TSTSGN		; Test sign of FPREG
    3503/    4571 : F0                  	RET	P		; Return if positive
    3504/    4572 : 21 2B C1            INVSGN: LD	HL,FPREG+2	; Point to MSB
    3505/    4575 : 7E                  	LD	A,(HL)		; Get sign of mantissa
    3506/    4576 : EE 80               	XOR	80H		; Invert sign of mantissa
    3507/    4578 : 77                  	LD	(HL),A		; Re-save sign of mantissa
    3508/    4579 : C9                  	RET
    3509/    457A :                     ;
    3510/    457A : EB                  STAKFP: EX	DE,HL		; Save code string address
    3511/    457B : 2A 29 C1            	LD	HL,(FPREG)	; LSB,NLSB of FPREG
    3512/    457E : E3                  	EX	(SP),HL		; Stack them,get return
    3513/    457F : E5                  	PUSH	HL		; Re-save return
    3514/    4580 : 2A 2B C1            	LD	HL,(FPREG+2)	; MSB and exponent of FPREG
    3515/    4583 : E3                  	EX	(SP),HL		; Stack them,get return
    3516/    4584 : E5                  	PUSH	HL		; Re-save return
    3517/    4585 : EB                  	EX	DE,HL		; Restore code string address
    3518/    4586 : C9                  	RET
    3519/    4587 :                     ;
    3520/    4587 : CD 98 45            PHLTFP: CALL	LOADFP		; Number at HL to BCDE
    3521/    458A : EB                  FPBCDE: EX	DE,HL		; Save code string address
    3522/    458B : 22 29 C1            	LD	(FPREG),HL	; Save LSB,NLSB of number
    3523/    458E : 60                  	LD	H,B		; Exponent of number
    3524/    458F : 69                  	LD	L,C		; MSB of number
    3525/    4590 : 22 2B C1            	LD	(FPREG+2),HL	; Save MSB and exponent
    3526/    4593 : EB                  	EX	DE,HL		; Restore code string address
    3527/    4594 : C9                  	RET
    3528/    4595 :                     ;
    3529/    4595 : 21 29 C1            BCDEFP: LD	HL,FPREG	; Point to FPREG
    3530/    4598 : 5E                  LOADFP: LD	E,(HL)		; Get LSB of number
    3531/    4599 : 23                  	INC	HL
    3532/    459A : 56                  	LD	D,(HL)		; Get NMSB of number
    3533/    459B : 23                  	INC	HL
    3534/    459C : 4E                  	LD	C,(HL)		; Get MSB of number
    3535/    459D : 23                  	INC	HL
    3536/    459E : 46                  	LD	B,(HL)		; Get exponent of number
    3537/    459F : 23                  INCHL:	INC	HL		; Used for conditional "INC HL"
    3538/    45A0 : C9                  	RET
    3539/    45A1 :                     ;
    3540/    45A1 : 11 29 C1            FPTHL:	LD	DE,FPREG	; Point to FPREG
    3541/    45A4 : 06 04               DETHL4: LD	B,4		; 4 bytes to move
    3542/    45A6 : 1A                  DETHLB: LD	A,(DE)		; Get source
    3543/    45A7 : 77                  	LD	(HL),A		; Save destination
    3544/    45A8 : 13                  	INC	DE		; Next source
    3545/    45A9 : 23                  	INC	HL		; Next destination
    3546/    45AA : 05                  	DEC	B		; Count bytes
    3547/    45AB : C2 A6 45            	JP	NZ,DETHLB	; Loop if more
    3548/    45AE : C9                  	RET
    3549/    45AF :                     ;
    3550/    45AF : 21 2B C1            SIGNS:	LD	HL,FPREG+2	; Point to MSB of FPREG
    3551/    45B2 : 7E                  	LD	A,(HL)		; Get MSB
    3552/    45B3 : 07                  	RLCA			; Old sign to carry
    3553/    45B4 : 37                  	SCF			; Set MSBit
    3554/    45B5 : 1F                  	RRA			; Set MSBit of MSB
    3555/    45B6 : 77                  	LD	(HL),A		; Save new MSB
    3556/    45B7 : 3F                  	CCF			; Complement sign
    3557/    45B8 : 1F                  	RRA			; Old sign to carry
    3558/    45B9 : 23                  	INC	HL
    3559/    45BA : 23                  	INC	HL
    3560/    45BB : 77                  	LD	(HL),A		; Set sign of result
    3561/    45BC : 79                  	LD	A,C		; Get MSB
    3562/    45BD : 07                  	RLCA			; Old sign to carry
    3563/    45BE : 37                  	SCF			; Set MSBit
    3564/    45BF : 1F                  	RRA			; Set MSBit of MSB
    3565/    45C0 : 4F                  	LD	C,A		; Save MSB
    3566/    45C1 : 1F                  	RRA
    3567/    45C2 : AE                  	XOR	(HL)		; New sign of result
    3568/    45C3 : C9                  	RET
    3569/    45C4 :                     ;
    3570/    45C4 : 78                  CMPNUM: LD	A,B		; Get exponent of number
    3571/    45C5 : B7                  	OR	A
    3572/    45C6 : CA 49 45            	JP	Z,TSTSGN	; Zero - Test sign of FPREG
    3573/    45C9 : 21 52 45            	LD	HL,RETREL	; Return relation routine
    3574/    45CC : E5                  	PUSH	HL		; Save for return
    3575/    45CD : CD 49 45            	CALL	TSTSGN		; Test sign of FPREG
    3576/    45D0 : 79                  	LD	A,C		; Get MSB of number
    3577/    45D1 : C8                  	RET	Z		; FPREG zero - Number's MSB
    3578/    45D2 : 21 2B C1            	LD	HL,FPREG+2	; MSB of FPREG
    3579/    45D5 : AE                  	XOR	(HL)		; Combine signs
    3580/    45D6 : 79                  	LD	A,C		; Get MSB of number
    3581/    45D7 : F8                  	RET	M		; Exit if signs different
    3582/    45D8 : CD DE 45            	CALL	CMPFP		; Compare FP numbers
    3583/    45DB : 1F                  	RRA			; Get carry to sign
    3584/    45DC : A9                  	XOR	C		; Combine with MSB of number
    3585/    45DD : C9                  	RET
    3586/    45DE :                     ;
    3587/    45DE : 23                  CMPFP:	INC	HL		; Point to exponent
    3588/    45DF : 78                  	LD	A,B		; Get exponent
    3589/    45E0 : BE                  	CP	(HL)		; Compare exponents
    3590/    45E1 : C0                  	RET	NZ		; Different
    3591/    45E2 : 2B                  	DEC	HL		; Point to MBS
    3592/    45E3 : 79                  	LD	A,C		; Get MSB
    3593/    45E4 : BE                  	CP	(HL)		; Compare MSBs
    3594/    45E5 : C0                  	RET	NZ		; Different
    3595/    45E6 : 2B                  	DEC	HL		; Point to NMSB
    3596/    45E7 : 7A                  	LD	A,D		; Get NMSB
    3597/    45E8 : BE                  	CP	(HL)		; Compare NMSBs
    3598/    45E9 : C0                  	RET	NZ		; Different
    3599/    45EA : 2B                  	DEC	HL		; Point to LSB
    3600/    45EB : 7B                  	LD	A,E		; Get LSB
    3601/    45EC : 96                  	SUB	(HL)		; Compare LSBs
    3602/    45ED : C0                  	RET	NZ		; Different
    3603/    45EE : E1                  	POP	HL		; Drop RETurn
    3604/    45EF : E1                  	POP	HL		; Drop another RETurn
    3605/    45F0 : C9                  	RET
    3606/    45F1 :                     ;
    3607/    45F1 : 47                  FPINT:	LD	B,A		; <- Move
    3608/    45F2 : 4F                  	LD	C,A		; <- exponent
    3609/    45F3 : 57                  	LD	D,A		; <- to all
    3610/    45F4 : 5F                  	LD	E,A		; <- bits
    3611/    45F5 : B7                  	OR	A		; Test exponent
    3612/    45F6 : C8                  	RET	Z		; Zero - Return zero
    3613/    45F7 : E5                  	PUSH	HL		; Save pointer to number
    3614/    45F8 : CD 95 45            	CALL	BCDEFP		; Move FPREG to BCDE
    3615/    45FB : CD AF 45            	CALL	SIGNS		; Set MSBs & sign of result
    3616/    45FE : AE                  	XOR	(HL)		; Combine with sign of FPREG
    3617/    45FF : 67                  	LD	H,A		; Save combined signs
    3618/    4600 : FC 15 46            	CALL	M,DCBCDE	; Negative - Decrement BCDE
    3619/    4603 : 3E 98               	LD	A,80H+24	; 24 bits
    3620/    4605 : 90                  	SUB	B		; Bits to shift
    3621/    4606 : CD C8 43            	CALL	SCALE		; Shift BCDE
    3622/    4609 : 7C                  	LD	A,H		; Get combined sign
    3623/    460A : 17                  	RLA			; Sign to carry
    3624/    460B : DC 9B 43            	CALL	C,FPROND	; Negative - Round number up
    3625/    460E : 06 00               	LD	B,0		; Zero exponent
    3626/    4610 : DC B4 43            	CALL	C,COMPL		; If negative make positive
    3627/    4613 : E1                  	POP	HL		; Restore pointer to number
    3628/    4614 : C9                  	RET
    3629/    4615 :                     ;
    3630/    4615 : 1B                  DCBCDE: DEC	DE		; Decrement BCDE
    3631/    4616 : 7A                  	LD	A,D		; Test LSBs
    3632/    4617 : A3                  	AND	E
    3633/    4618 : 3C                  	INC	A
    3634/    4619 : C0                  	RET	NZ		; Exit if LSBs not FFFF
    3635/    461A : 0B                  	DEC	BC		; Decrement MSBs
    3636/    461B : C9                  	RET
    3637/    461C :                     ;
    3638/    461C : 21 2C C1            INT:	LD	HL,FPEXP	; Point to exponent
    3639/    461F : 7E                  	LD	A,(HL)		; Get exponent
    3640/    4620 : FE 98               	CP	80H+24		; Integer accuracy only?
    3641/    4622 : 3A 29 C1            	LD	A,(FPREG)	; Get LSB
    3642/    4625 : D0                  	RET	NC		; Yes - Already integer
    3643/    4626 : 7E                  	LD	A,(HL)		; Get exponent
    3644/    4627 : CD F1 45            	CALL	FPINT		; F.P to integer
    3645/    462A : 36 98               	LD	(HL),80H+24	; Save 24 bit integer
    3646/    462C : 7B                  	LD	A,E		; Get LSB of number
    3647/    462D : F5                  	PUSH	AF		; Save LSB
    3648/    462E : 79                  	LD	A,C		; Get MSB of number
    3649/    462F : 17                  	RLA			; Sign to carry
    3650/    4630 : CD 51 43            	CALL	CONPOS		; Set sign of result
    3651/    4633 : F1                  	POP	AF		; Restore LSB of number
    3652/    4634 : C9                  	RET
    3653/    4635 :                     ;
    3654/    4635 : 21 00 00            MLDEBC: LD	HL,0		; Clear partial product
    3655/    4638 : 78                  	LD	A,B		; Test multiplier
    3656/    4639 : B1                  	OR	C
    3657/    463A : C8                  	RET	Z		; Return zero if zero
    3658/    463B : 3E 10               	LD	A,16		; 16 bits
    3659/    463D : 29                  MLDBLP: ADD	HL,HL		; Shift P.P left
    3660/    463E : DA 75 3E            	JP	C,BSERR		; ?BS Error if overflow
    3661/    4641 : EB                  	EX	DE,HL
    3662/    4642 : 29                  	ADD	HL,HL		; Shift multiplier left
    3663/    4643 : EB                  	EX	DE,HL
    3664/    4644 : D2 4B 46            	JP	NC,NOMLAD	; Bit was zero - No add
    3665/    4647 : 09                  	ADD	HL,BC		; Add multiplicand
    3666/    4648 : DA 75 3E            	JP	C,BSERR		; ?BS Error if overflow
    3667/    464B : 3D                  NOMLAD: DEC	A		; Count bits
    3668/    464C : C2 3D 46            	JP	NZ,MLDBLP	; More
    3669/    464F : C9                  	RET
    3670/    4650 :                     ;
    3671/    4650 : FE 2D               ASCTFP: CP	'-'		; Negative?
    3672/    4652 : F5                  	PUSH	AF		; Save it and flags
    3673/    4653 : CA 5C 46            	JP	Z,CNVNUM	; Yes - Convert number
    3674/    4656 : FE 2B               	CP	'+'		; Positive?
    3675/    4658 : CA 5C 46            	JP	Z,CNVNUM	; Yes - Convert number
    3676/    465B : 2B                  	DEC	HL		; DEC 'cos GETCHR INCs
    3677/    465C : CD 69 43            CNVNUM: CALL	RESZER		; Set result to zero
    3678/    465F : 47                  	LD	B,A		; Digits after point counter
    3679/    4660 : 57                  	LD	D,A		; Sign of exponent
    3680/    4661 : 5F                  	LD	E,A		; Exponent of ten
    3681/    4662 : 2F                  	CPL
    3682/    4663 : 4F                  	LD	C,A		; Before or after point flag
    3683/    4664 : CD FA 36            MANLP:	CALL	GETCHR		; Get next character
    3684/    4667 : DA AD 46            	JP	C,ADDIG		; Digit - Add to number
    3685/    466A : FE 2E               	CP	'.'
    3686/    466C : CA 88 46            	JP	Z,DPOINT	; '.' - Flag point
    3687/    466F : FE 45               	CP	'E'
    3688/    4671 : C2 8C 46            	JP	NZ,CONEXP	; Not 'E' - Scale number
    3689/    4674 : CD FA 36            	CALL	GETCHR		; Get next character
    3690/    4677 : CD A0 3C            	CALL	SGNEXP		; Get sign of exponent
    3691/    467A : CD FA 36            EXPLP:	CALL	GETCHR		; Get next character
    3692/    467D : DA CF 46            	JP	C,EDIGIT	; Digit - Add to exponent
    3693/    4680 : 14                  	INC	D		; Is sign negative?
    3694/    4681 : C2 8C 46            	JP	NZ,CONEXP	; No - Scale number
    3695/    4684 : AF                  	XOR	A
    3696/    4685 : 93                  	SUB	E		; Negate exponent
    3697/    4686 : 5F                  	LD	E,A		; And re-save it
    3698/    4687 : 0C                  	INC	C		; Flag end of number
    3699/    4688 : 0C                  DPOINT: INC	C		; Flag point passed
    3700/    4689 : CA 64 46            	JP	Z,MANLP		; Zero - Get another digit
    3701/    468C : E5                  CONEXP: PUSH	HL		; Save code string address
    3702/    468D : 7B                  	LD	A,E		; Get exponent
    3703/    468E : 90                  	SUB	B		; Subtract digits after point
    3704/    468F : F4 A5 46            SCALMI: CALL	P,SCALPL	; Positive - Multiply number
    3705/    4692 : F2 9B 46            	JP	P,ENDCON	; Positive - All done
    3706/    4695 : F5                  	PUSH	AF		; Save number of times to /10
    3707/    4696 : CD 91 44            	CALL	DIV10		; Divide by 10
    3708/    4699 : F1                  	POP	AF		; Restore count
    3709/    469A : 3C                  	INC	A		; Count divides
    3710/    469B :                     ;
    3711/    469B : C2 8F 46            ENDCON: JP	NZ,SCALMI	; More to do
    3712/    469E : D1                  	POP	DE		; Restore code string address
    3713/    469F : F1                  	POP	AF		; Restore sign of number
    3714/    46A0 : CC 72 45            	CALL	Z,INVSGN	; Negative - Negate number
    3715/    46A3 : EB                  	EX	DE,HL		; Code string address to HL
    3716/    46A4 : C9                  	RET
    3717/    46A5 :                     ;
    3718/    46A5 : C8                  SCALPL: RET	Z		; Exit if no scaling needed
    3719/    46A6 : F5                  MULTEN: PUSH	AF		; Save count
    3720/    46A7 : CD 32 45            	CALL	MLSP10		; Multiply number by 10
    3721/    46AA : F1                  	POP	AF		; Restore count
    3722/    46AB : 3D                  	DEC	A		; Count multiplies
    3723/    46AC : C9                  	RET
    3724/    46AD :                     ;
    3725/    46AD : D5                  ADDIG:	PUSH	DE		; Save sign of exponent
    3726/    46AE : 57                  	LD	D,A		; Save digit
    3727/    46AF : 78                  	LD	A,B		; Get digits after point
    3728/    46B0 : 89                  	ADC	A,C		; Add one if after point
    3729/    46B1 : 47                  	LD	B,A		; Re-save counter
    3730/    46B2 : C5                  	PUSH	BC		; Save point flags
    3731/    46B3 : E5                  	PUSH	HL		; Save code string address
    3732/    46B4 : D5                  	PUSH	DE		; Save digit
    3733/    46B5 : CD 32 45            	CALL	MLSP10		; Multiply number by 10
    3734/    46B8 : F1                  	POP	AF		; Restore digit
    3735/    46B9 : D6 30               	SUB	'0'		; Make it absolute
    3736/    46BB : CD C4 46            	CALL	RSCALE		; Re-scale number
    3737/    46BE : E1                  	POP	HL		; Restore code string address
    3738/    46BF : C1                  	POP	BC		; Restore point flags
    3739/    46C0 : D1                  	POP	DE		; Restore sign of exponent
    3740/    46C1 : C3 64 46            	JP	MANLP		; Get another digit
    3741/    46C4 :                     ;
    3742/    46C4 : CD 7A 45            RSCALE: CALL	STAKFP		; Put number on stack
    3743/    46C7 : CD 5B 45            	CALL	FLGREL		; Digit to add to FPREG
    3744/    46CA : C1                  PADD:	POP	BC		; Restore number
    3745/    46CB : D1                  	POP	DE
    3746/    46CC : C3 03 43            	JP	FPADD		; Add BCDE to FPREG and return
    3747/    46CF :                     ;
    3748/    46CF : 7B                  EDIGIT: LD	A,E		; Get digit
    3749/    46D0 : 07                  	RLCA			; Times 2
    3750/    46D1 : 07                  	RLCA			; Times 4
    3751/    46D2 : 83                  	ADD	A,E		; Times 5
    3752/    46D3 : 07                  	RLCA			; Times 10
    3753/    46D4 : 86                  	ADD	A,(HL)		; Add next digit
    3754/    46D5 : D6 30               	SUB	'0'		; Make it absolute
    3755/    46D7 : 5F                  	LD	E,A		; Save new digit
    3756/    46D8 : C3 7A 46            	JP	EXPLP		; Look for another digit
    3757/    46DB :                     ;
    3758/    46DB : E5                  LINEIN: PUSH	HL		; Save code string address
    3759/    46DC : 21 3C 32            	LD	HL,INMSG	; Output " in "
    3760/    46DF : CD 40 40            	CALL	PRS		; Output string at HL
    3761/    46E2 : E1                  	POP	HL		; Restore code string address
    3762/    46E3 : EB                  PRNTHL: EX	DE,HL		; Code string address to DE
    3763/    46E4 : AF                  	XOR	A
    3764/    46E5 : 06 98               	LD	B,80H+24	; 24 bits
    3765/    46E7 : CD 60 45            	CALL	RETINT		; Return the integer
    3766/    46EA : 21 3F 40            	LD	HL,PRNUMS	; Print number string
    3767/    46ED : E5                  	PUSH	HL		; Save for return
    3768/    46EE : 21 2E C1            NUMASC: LD	HL,PBUFF	; Convert number to ASCII
    3769/    46F1 : E5                  	PUSH	HL		; Save for return
    3770/    46F2 : CD 49 45            	CALL	TSTSGN		; Test sign of FPREG
    3771/    46F5 : 36 20               	LD	(HL),' '	; Space at start
    3772/    46F7 : F2 FC 46            	JP	P,SPCFST	; Positive - Space to start
    3773/    46FA : 36 2D               	LD	(HL),'-'	; '-' sign at start
    3774/    46FC : 23                  SPCFST: INC	HL		; First byte of number
    3775/    46FD : 36 30               	LD	(HL),'0'	; '0' if zero
    3776/    46FF : CA B2 47            	JP	Z,JSTZER	; Return '0' if zero
    3777/    4702 : E5                  	PUSH	HL		; Save buffer address
    3778/    4703 : FC 72 45            	CALL	M,INVSGN	; Negate FPREG if negative
    3779/    4706 : AF                  	XOR	A		; Zero A
    3780/    4707 : F5                  	PUSH	AF		; Save it
    3781/    4708 : CD B8 47            	CALL	RNGTST		; Test number is in range
    3782/    470B : 01 43 91            SIXDIG: LD	BC,9143H	; BCDE - 99999.9
    3783/    470E : 11 F8 4F            	LD	DE,4FF8H
    3784/    4711 : CD C4 45            	CALL	CMPNUM		; Compare numbers
    3785/    4714 : B7                  	OR	A
    3786/    4715 : E2 29 47            	JP	PO,INRNG	; > 99999.9 - Sort it out
    3787/    4718 : F1                  	POP	AF		; Restore count
    3788/    4719 : CD A6 46            	CALL	MULTEN		; Multiply by ten
    3789/    471C : F5                  	PUSH	AF		; Re-save count
    3790/    471D : C3 0B 47            	JP	SIXDIG		; Test it again
    3791/    4720 :                     ;
    3792/    4720 : CD 91 44            GTSIXD: CALL	DIV10		; Divide by 10
    3793/    4723 : F1                  	POP	AF		; Get count
    3794/    4724 : 3C                  	INC	A		; Count divides
    3795/    4725 : F5                  	PUSH	AF		; Re-save count
    3796/    4726 : CD B8 47            	CALL	RNGTST		; Test number is in range
    3797/    4729 : CD F1 42            INRNG:	CALL	ROUND		; Add 0.5 to FPREG
    3798/    472C : 3C                  	INC	A
    3799/    472D : CD F1 45            	CALL	FPINT		; F.P to integer
    3800/    4730 : CD 8A 45            	CALL	FPBCDE		; Move BCDE to FPREG
    3801/    4733 : 01 06 03            	LD	BC,0306H	; 1E+06 to 1E-03 range
    3802/    4736 : F1                  	POP	AF		; Restore count
    3803/    4737 : 81                  	ADD	A,C		; 6 digits before point
    3804/    4738 : 3C                  	INC	A		; Add one
    3805/    4739 : FA 45 47            	JP	M,MAKNUM	; Do it in 'E' form if < 1E-02
    3806/    473C : FE 08               	CP	6+1+1		; More than 999999 ?
    3807/    473E : D2 45 47            	JP	NC,MAKNUM	; Yes - Do it in 'E' form
    3808/    4741 : 3C                  	INC	A		; Adjust for exponent
    3809/    4742 : 47                  	LD	B,A		; Exponent of number
    3810/    4743 : 3E 02               	LD	A,2		; Make it zero after
    3811/    4745 :                     ;
    3812/    4745 : 3D                  MAKNUM: DEC	A		; Adjust for digits to do
    3813/    4746 : 3D                  	DEC	A
    3814/    4747 : E1                  	POP	HL		; Restore buffer address
    3815/    4748 : F5                  	PUSH	AF		; Save count
    3816/    4749 : 11 CB 47            	LD	DE,POWERS	; Powers of ten
    3817/    474C : 05                  	DEC	B		; Count digits before point
    3818/    474D : C2 56 47            	JP	NZ,DIGTXT	; Not zero - Do number
    3819/    4750 : 36 2E               	LD	(HL),'.'	; Save point
    3820/    4752 : 23                  	INC	HL		; Move on
    3821/    4753 : 36 30               	LD	(HL),'0'	; Save zero
    3822/    4755 : 23                  	INC	HL		; Move on
    3823/    4756 : 05                  DIGTXT: DEC	B		; Count digits before point
    3824/    4757 : 36 2E               	LD	(HL),'.'	; Save point in case
    3825/    4759 : CC 9F 45            	CALL	Z,INCHL		; Last digit - move on
    3826/    475C : C5                  	PUSH	BC		; Save digits before point
    3827/    475D : E5                  	PUSH	HL		; Save buffer address
    3828/    475E : D5                  	PUSH	DE		; Save powers of ten
    3829/    475F : CD 95 45            	CALL	BCDEFP		; Move FPREG to BCDE
    3830/    4762 : E1                  	POP	HL		; Powers of ten table
    3831/    4763 : 06 2F               	LD	B, '0'-1	; ASCII '0' - 1
    3832/    4765 : 04                  TRYAGN: INC	B		; Count subtractions
    3833/    4766 : 7B                  	LD	A,E		; Get LSB
    3834/    4767 : 96                  	SUB	(HL)		; Subtract LSB
    3835/    4768 : 5F                  	LD	E,A		; Save LSB
    3836/    4769 : 23                  	INC	HL
    3837/    476A : 7A                  	LD	A,D		; Get NMSB
    3838/    476B : 9E                  	SBC	A,(HL)		; Subtract NMSB
    3839/    476C : 57                  	LD	D,A		; Save NMSB
    3840/    476D : 23                  	INC	HL
    3841/    476E : 79                  	LD	A,C		; Get MSB
    3842/    476F : 9E                  	SBC	A,(HL)		; Subtract MSB
    3843/    4770 : 4F                  	LD	C,A		; Save MSB
    3844/    4771 : 2B                  	DEC	HL		; Point back to start
    3845/    4772 : 2B                  	DEC	HL
    3846/    4773 : D2 65 47            	JP	NC,TRYAGN	; No overflow - Try again
    3847/    4776 : CD A8 43            	CALL	PLUCDE		; Restore number
    3848/    4779 : 23                  	INC	HL		; Start of next number
    3849/    477A : CD 8A 45            	CALL	FPBCDE		; Move BCDE to FPREG
    3850/    477D : EB                  	EX	DE,HL		; Save point in table
    3851/    477E : E1                  	POP	HL		; Restore buffer address
    3852/    477F : 70                  	LD	(HL),B		; Save digit in buffer
    3853/    4780 : 23                  	INC	HL		; And move on
    3854/    4781 : C1                  	POP	BC		; Restore digit count
    3855/    4782 : 0D                  	DEC	C		; Count digits
    3856/    4783 : C2 56 47            	JP	NZ,DIGTXT	; More - Do them
    3857/    4786 : 05                  	DEC	B		; Any decimal part?
    3858/    4787 : CA 96 47            	JP	Z,DOEBIT	; No - Do 'E' bit
    3859/    478A : 2B                  SUPTLZ: DEC	HL		; Move back through buffer
    3860/    478B : 7E                  	LD	A,(HL)		; Get character
    3861/    478C : FE 30               	CP	'0'		; '0' character?
    3862/    478E : CA 8A 47            	JP	Z,SUPTLZ	; Yes - Look back for more
    3863/    4791 : FE 2E               	CP	'.'		; A decimal point?
    3864/    4793 : C4 9F 45            	CALL	NZ,INCHL	; Move back over digit
    3865/    4796 :                     ;
    3866/    4796 : F1                  DOEBIT: POP	AF		; Get 'E' flag
    3867/    4797 : CA B5 47            	JP	Z,NOENED	; No 'E' needed - End buffer
    3868/    479A : 36 45               	LD	(HL),'E'	; Put 'E' in buffer
    3869/    479C : 23                  	INC	HL		; And move on
    3870/    479D : 36 2B               	LD	(HL),'+'	; Put '+' in buffer
    3871/    479F : F2 A6 47            	JP	P,OUTEXP	; Positive - Output exponent
    3872/    47A2 : 36 2D               	LD	(HL),'-'	; Put '-' in buffer
    3873/    47A4 : 2F                  	CPL			; Negate exponent
    3874/    47A5 : 3C                  	INC	A
    3875/    47A6 : 06 2F               OUTEXP: LD	B,'0'-1		; ASCII '0' - 1
    3876/    47A8 : 04                  EXPTEN: INC	B		; Count subtractions
    3877/    47A9 : D6 0A               	SUB	10		; Tens digit
    3878/    47AB : D2 A8 47            	JP	NC,EXPTEN	; More to do
    3879/    47AE : C6 3A               	ADD	A,'0'+10	; Restore and make ASCII
    3880/    47B0 : 23                  	INC	HL		; Move on
    3881/    47B1 : 70                  	LD	(HL),B		; Save MSB of exponent
    3882/    47B2 : 23                  JSTZER: INC	HL		;
    3883/    47B3 : 77                  	LD	(HL),A		; Save LSB of exponent
    3884/    47B4 : 23                  	INC	HL
    3885/    47B5 : 71                  NOENED: LD	(HL),C		; Mark end of buffer
    3886/    47B6 : E1                  	POP	HL		; Restore code string address
    3887/    47B7 : C9                  	RET
    3888/    47B8 :                     ;
    3889/    47B8 : 01 74 94            RNGTST: LD	BC,9474H	; BCDE = 999999.
    3890/    47BB : 11 F7 23            	LD	DE,23F7H
    3891/    47BE : CD C4 45            	CALL	CMPNUM		; Compare numbers
    3892/    47C1 : B7                  	OR	A
    3893/    47C2 : E1                  	POP	HL		; Return address to HL
    3894/    47C3 : E2 20 47            	JP	PO,GTSIXD	; Too big - Divide by ten
    3895/    47C6 : E9                  	JP	(HL)		; Otherwise return to caller
    3896/    47C7 :                     ;
    3897/    47C7 : 00 00 00 80         HALF:	DB	00H,00H,00H,80H	; 0.5
    3898/    47CB :                     ;
    3899/    47CB : A0 86 01            POWERS: DB	0A0H,086H,001H	; 100000
    3900/    47CE : 10 27 00            	DB	010H,027H,000H	; 10000
    3901/    47D1 : E8 03 00            	DB	0E8H,003H,000H	; 1000
    3902/    47D4 : 64 00 00            	DB	064H,000H,000H	; 100
    3903/    47D7 : 0A 00 00            	DB	00AH,000H,000H	; 10
    3904/    47DA : 01 00 00            	DB	001H,000H,000H	; 1
    3905/    47DD :                     ;
    3906/    47DD : 21 72 45            NEGAFT: LD	HL,INVSGN	; Negate result
    3907/    47E0 : E3                  	EX	(SP),HL		; To be done after caller
    3908/    47E1 : E9                  	JP	(HL)		; Return to caller
    3909/    47E2 :                     ;
    3910/    47E2 : CD 7A 45            SQR:	CALL	STAKFP		; Put value on stack
    3911/    47E5 : 21 C7 47            	LD	HL,HALF		; Set power to 1/2
    3912/    47E8 : CD 87 45            	CALL	PHLTFP		; Move 1/2 to FPREG
    3913/    47EB :                     ;
    3914/    47EB : C1                  POWER:	POP	BC		; Get base
    3915/    47EC : D1                  	POP	DE
    3916/    47ED : CD 49 45            	CALL	TSTSGN		; Test sign of power
    3917/    47F0 : 78                  	LD	A,B		; Get exponent of base
    3918/    47F1 : CA 30 48            	JP	Z,EXP		; Make result 1 if zero
    3919/    47F4 : F2 FB 47            	JP	P,POWER1	; Positive base - Ok
    3920/    47F7 : B7                  	OR	A		; Zero to negative power?
    3921/    47F8 : CA A7 32            	JP	Z,DZERR		; Yes - ?/0 Error
    3922/    47FB : B7                  POWER1: OR	A		; Base zero?
    3923/    47FC : CA 6A 43            	JP	Z,SAVEXP	; Yes - Return zero
    3924/    47FF : D5                  	PUSH	DE		; Save base
    3925/    4800 : C5                  	PUSH	BC
    3926/    4801 : 79                  	LD	A,C		; Get MSB of base
    3927/    4802 : F6 7F               	OR	01111111B	; Get sign status
    3928/    4804 : CD 95 45            	CALL	BCDEFP		; Move power to BCDE
    3929/    4807 : F2 18 48            	JP	P,POWER2	; Positive base - Ok
    3930/    480A : D5                  	PUSH	DE		; Save power
    3931/    480B : C5                  	PUSH	BC
    3932/    480C : CD 1C 46            	CALL	INT		; Get integer of power
    3933/    480F : C1                  	POP	BC		; Restore power
    3934/    4810 : D1                  	POP	DE
    3935/    4811 : F5                  	PUSH	AF		; MSB of base
    3936/    4812 : CD C4 45            	CALL	CMPNUM		; Power an integer?
    3937/    4815 : E1                  	POP	HL		; Restore MSB of base
    3938/    4816 : 7C                  	LD	A,H		; but don't affect flags
    3939/    4817 : 1F                  	RRA			; Exponent odd or even?
    3940/    4818 : E1                  POWER2: POP	HL		; Restore MSB and exponent
    3941/    4819 : 22 2B C1            	LD	(FPREG+2),HL	; Save base in FPREG
    3942/    481C : E1                  	POP	HL		; LSBs of base
    3943/    481D : 22 29 C1            	LD	(FPREG),HL	; Save in FPREG
    3944/    4820 : DC DD 47            	CALL	C,NEGAFT	; Odd power - Negate result
    3945/    4823 : CC 72 45            	CALL	Z,INVSGN	; Negative base - Negate it
    3946/    4826 : D5                  	PUSH	DE		; Save power
    3947/    4827 : C5                  	PUSH	BC
    3948/    4828 : CD FD 43            	CALL	LOG		; Get LOG of base
    3949/    482B : C1                  	POP	BC		; Restore power
    3950/    482C : D1                  	POP	DE
    3951/    482D : CD 3E 44            	CALL	FPMULT		; Multiply LOG by power
    3952/    4830 :                     ;
    3953/    4830 : CD 7A 45            EXP:	CALL	STAKFP		; Put value on stack
    3954/    4833 : 01 38 81            	LD	BC,08138H	; BCDE = 1/Ln(2)
    3955/    4836 : 11 3B AA            	LD	DE,0AA3BH
    3956/    4839 : CD 3E 44            	CALL	FPMULT		; Multiply value by 1/LN(2)
    3957/    483C : 3A 2C C1            	LD	A,(FPEXP)	; Get exponent
    3958/    483F : FE 88               	CP	80H+8		; Is it in range?
    3959/    4841 : D2 25 45            	JP	NC,OVTST1	; No - Test for overflow
    3960/    4844 : CD 1C 46            	CALL	INT		; Get INT of FPREG
    3961/    4847 : C6 80               	ADD	A,80H		; For excess 128
    3962/    4849 : C6 02               	ADD	A,2		; Exponent > 126?
    3963/    484B : DA 25 45            	JP	C,OVTST1	; Yes - Test for overflow
    3964/    484E : F5                  	PUSH	AF		; Save scaling factor
    3965/    484F : 21 EC 43            	LD	HL,UNITY	; Point to 1.
    3966/    4852 : CD F4 42            	CALL	ADDPHL		; Add 1 to FPREG
    3967/    4855 : CD 35 44            	CALL	MULLN2		; Multiply by LN(2)
    3968/    4858 : F1                  	POP	AF		; Restore scaling factor
    3969/    4859 : C1                  	POP	BC		; Restore exponent
    3970/    485A : D1                  	POP	DE
    3971/    485B : F5                  	PUSH	AF		; Save scaling factor
    3972/    485C : CD 00 43            	CALL	SUBCDE		; Subtract exponent from FPREG
    3973/    485F : CD 72 45            	CALL	INVSGN		; Negate result
    3974/    4862 : 21 70 48            	LD	HL,EXPTAB	; Coefficient table
    3975/    4865 : CD A0 48            	CALL	SMSER1		; Sum the series
    3976/    4868 : 11 00 00            	LD	DE,0		; Zero LSBs
    3977/    486B : C1                  	POP	BC		; Scaling factor
    3978/    486C : 4A                  	LD	C,D		; Zero MSB
    3979/    486D : C3 3E 44            	JP	FPMULT		; Scale result to correct value
    3980/    4870 :                     ;
    3981/    4870 : 08                  EXPTAB: DB	8			; Table used by EXP
    3982/    4871 : 40 2E 94 74         	DB	040H,02EH,094H,074H	; -1/7! (-1/5040)
    3983/    4875 : 70 4F 2E 77         	DB	070H,04FH,02EH,077H	;  1/6! ( 1/720)
    3984/    4879 : 6E 02 88 7A         	DB	06EH,002H,088H,07AH	; -1/5! (-1/120)
    3985/    487D : E6 A0 2A 7C         	DB	0E6H,0A0H,02AH,07CH	;  1/4! ( 1/24)
    3986/    4881 : 50 AA AA 7E         	DB	050H,0AAH,0AAH,07EH	; -1/3! (-1/6)
    3987/    4885 : FF FF 7F 7F         	DB	0FFH,0FFH,07FH,07FH	;  1/2! ( 1/2)
    3988/    4889 : 00 00 80 81         	DB	000H,000H,080H,081H	; -1/1! (-1/1)
    3989/    488D : 00 00 00 81         	DB	000H,000H,000H,081H	;  1/0! ( 1/1)
    3990/    4891 :                     ;
    3991/    4891 : CD 7A 45            SUMSER: CALL	STAKFP		; Put FPREG on stack
    3992/    4894 : 11 3C 44            	LD	DE,MULT		; Multiply by "X"
    3993/    4897 : D5                  	PUSH	DE		; To be done after
    3994/    4898 : E5                  	PUSH	HL		; Save address of table
    3995/    4899 : CD 95 45            	CALL	BCDEFP		; Move FPREG to BCDE
    3996/    489C : CD 3E 44            	CALL	FPMULT		; Square the value
    3997/    489F : E1                  	POP	HL		; Restore address of table
    3998/    48A0 : CD 7A 45            SMSER1: CALL	STAKFP		; Put value on stack
    3999/    48A3 : 7E                  	LD	A,(HL)		; Get number of coefficients
    4000/    48A4 : 23                  	INC	HL		; Point to start of table
    4001/    48A5 : CD 87 45            	CALL	PHLTFP		; Move coefficient to FPREG
    4002/    48A8 : 06                  	DB	06H		; Skip "POP AF"
    4003/    48A9 : F1                  SUMLP:	POP	AF		; Restore count
    4004/    48AA : C1                  	POP	BC		; Restore number
    4005/    48AB : D1                  	POP	DE
    4006/    48AC : 3D                  	DEC	A		; Cont coefficients
    4007/    48AD : C8                  	RET	Z		; All done
    4008/    48AE : D5                  	PUSH	DE		; Save number
    4009/    48AF : C5                  	PUSH	BC
    4010/    48B0 : F5                  	PUSH	AF		; Save count
    4011/    48B1 : E5                  	PUSH	HL		; Save address in table
    4012/    48B2 : CD 3E 44            	CALL	FPMULT		; Multiply FPREG by BCDE
    4013/    48B5 : E1                  	POP	HL		; Restore address in table
    4014/    48B6 : CD 98 45            	CALL	LOADFP		; Number at HL to BCDE
    4015/    48B9 : E5                  	PUSH	HL		; Save address in table
    4016/    48BA : CD 03 43            	CALL	FPADD		; Add coefficient to FPREG
    4017/    48BD : E1                  	POP	HL		; Restore address in table
    4018/    48BE : C3 A9 48            	JP	SUMLP		; More coefficients
    4019/    48C1 :                     ;
    4020/    48C1 : CD 49 45            RND:	CALL	TSTSGN		; Test sign of FPREG
    4021/    48C4 : 21 5E C0            	LD	HL,SEED+2	; Random number seed
    4022/    48C7 : FA 22 49            	JP	M,RESEED	; Negative - Re-seed
    4023/    48CA : 21 7F C0            	LD	HL,LSTRND	; Last random number
    4024/    48CD : CD 87 45            	CALL	PHLTFP		; Move last RND to FPREG
    4025/    48D0 : 21 5E C0            	LD	HL,SEED+2	; Random number seed
    4026/    48D3 : C8                  	RET	Z		; Return if RND(0)
    4027/    48D4 : 86                  	ADD	A,(HL)		; Add (SEED)+2)
    4028/    48D5 : E6 07               	AND	00000111B	; 0 to 7
    4029/    48D7 : 06 00               	LD	B,0
    4030/    48D9 : 77                  	LD	(HL),A		; Re-save seed
    4031/    48DA : 23                  	INC	HL		; Move to coefficient table
    4032/    48DB : 87                  	ADD	A,A		; 4 bytes
    4033/    48DC : 87                  	ADD	A,A		; per entry
    4034/    48DD : 4F                  	LD	C,A		; BC = Offset into table
    4035/    48DE : 09                  	ADD	HL,BC		; Point to coefficient
    4036/    48DF : CD 98 45            	CALL	LOADFP		; Coefficient to BCDE
    4037/    48E2 : CD 3E 44            	CALL	FPMULT	;	; Multiply FPREG by coefficient
    4038/    48E5 : 3A 5D C0            	LD	A,(SEED+1)	; Get (SEED+1)
    4039/    48E8 : 3C                  	INC	A		; Add 1
    4040/    48E9 : E6 03               	AND	00000011B	; 0 to 3
    4041/    48EB : 06 00               	LD	B,0
    4042/    48ED : FE 01               	CP	1		; Is it zero?
    4043/    48EF : 88                  	ADC	A,B		; Yes - Make it 1
    4044/    48F0 : 32 5D C0            	LD	(SEED+1),A	; Re-save seed
    4045/    48F3 : 21 26 49            	LD	HL,RNDTAB-4	; Addition table
    4046/    48F6 : 87                  	ADD	A,A		; 4 bytes
    4047/    48F7 : 87                  	ADD	A,A		; per entry
    4048/    48F8 : 4F                  	LD	C,A		; BC = Offset into table
    4049/    48F9 : 09                  	ADD	HL,BC		; Point to value
    4050/    48FA : CD F4 42            	CALL	ADDPHL		; Add value to FPREG
    4051/    48FD : CD 95 45            RND1:	CALL	BCDEFP		; Move FPREG to BCDE
    4052/    4900 : 7B                  	LD	A,E		; Get LSB
    4053/    4901 : 59                  	LD	E,C		; LSB = MSB
    4054/    4902 : EE 4F               	XOR	01001111B	; Fiddle around
    4055/    4904 : 4F                  	LD	C,A		; New MSB
    4056/    4905 : 36 80               	LD	(HL),80H	; Set exponent
    4057/    4907 : 2B                  	DEC	HL		; Point to MSB
    4058/    4908 : 46                  	LD	B,(HL)		; Get MSB
    4059/    4909 : 36 80               	LD	(HL),80H	; Make value -0.5
    4060/    490B : 21 5C C0            	LD	HL,SEED		; Random number seed
    4061/    490E : 34                  	INC	(HL)		; Count seed
    4062/    490F : 7E                  	LD	A,(HL)		; Get seed
    4063/    4910 : D6 AB               	SUB	171		; Do it modulo 171
    4064/    4912 : C2 19 49            	JP	NZ,RND2		; Non-zero - Ok
    4065/    4915 : 77                  	LD	(HL),A		; Zero seed
    4066/    4916 : 0C                  	INC	C		; Fillde about
    4067/    4917 : 15                  	DEC	D		; with the
    4068/    4918 : 1C                  	INC	E		; number
    4069/    4919 : CD 54 43            RND2:	CALL	BNORM		; Normalise number
    4070/    491C : 21 7F C0            	LD	HL,LSTRND	; Save random number
    4071/    491F : C3 A1 45            	JP	FPTHL		; Move FPREG to last and return
    4072/    4922 :                     ;
    4073/    4922 : 77                  RESEED: LD	(HL),A		; Re-seed random numbers
    4074/    4923 : 2B                  	DEC	HL
    4075/    4924 : 77                  	LD	(HL),A
    4076/    4925 : 2B                  	DEC	HL
    4077/    4926 : 77                  	LD	(HL),A
    4078/    4927 : C3 FD 48            	JP	RND1		; Return RND seed
    4079/    492A :                     ;
    4080/    492A : 68 B1 46 68         RNDTAB: DB	068H,0B1H,046H,068H	; Table used by RND
    4081/    492E : 99 E9 92 69         	DB	099H,0E9H,092H,069H
    4082/    4932 : 10 D1 75 68         	DB	010H,0D1H,075H,068H
    4083/    4936 :                     ;
    4084/    4936 : 21 80 49            COS:	LD	HL,HALFPI	; Point to PI/2
    4085/    4939 : CD F4 42            	CALL	ADDPHL		; Add it to PPREG
    4086/    493C : CD 7A 45            SIN:	CALL	STAKFP		; Put angle on stack
    4087/    493F : 01 49 83            	LD	BC,8349H	; BCDE = 2 PI
    4088/    4942 : 11 DB 0F            	LD	DE,0FDBH
    4089/    4945 : CD 8A 45            	CALL	FPBCDE		; Move 2 PI to FPREG
    4090/    4948 : C1                  	POP	BC		; Restore angle
    4091/    4949 : D1                  	POP	DE
    4092/    494A : CD 9F 44            	CALL	DVBCDE		; Divide angle by 2 PI
    4093/    494D : CD 7A 45            	CALL	STAKFP		; Put it on stack
    4094/    4950 : CD 1C 46            	CALL	INT		; Get INT of result
    4095/    4953 : C1                  	POP	BC		; Restore number
    4096/    4954 : D1                  	POP	DE
    4097/    4955 : CD 00 43            	CALL	SUBCDE		; Make it 0 <= value < 1
    4098/    4958 : 21 84 49            	LD	HL,QUARTR	; Point to 0.25
    4099/    495B : CD FA 42            	CALL	SUBPHL		; Subtract value from 0.25
    4100/    495E : CD 49 45            	CALL	TSTSGN		; Test sign of value
    4101/    4961 : 37                  	SCF			; Flag positive
    4102/    4962 : F2 6C 49            	JP	P,SIN1		; Positive - Ok
    4103/    4965 : CD F1 42            	CALL	ROUND		; Add 0.5 to value
    4104/    4968 : CD 49 45            	CALL	TSTSGN		; Test sign of value
    4105/    496B : B7                  	OR	A		; Flag negative
    4106/    496C : F5                  SIN1:	PUSH	AF		; Save sign
    4107/    496D : F4 72 45            	CALL	P,INVSGN	; Negate value if positive
    4108/    4970 : 21 84 49            	LD	HL,QUARTR	; Point to 0.25
    4109/    4973 : CD F4 42            	CALL	ADDPHL		; Add 0.25 to value
    4110/    4976 : F1                  	POP	AF		; Restore sign
    4111/    4977 : D4 72 45            	CALL	NC,INVSGN	; Negative - Make positive
    4112/    497A : 21 88 49            	LD	HL,SINTAB	; Coefficient table
    4113/    497D : C3 91 48            	JP	SUMSER		; Evaluate sum of series
    4114/    4980 :                     ;
    4115/    4980 : DB 0F 49 81         HALFPI: DB	0DBH,00FH,049H,081H	; 1.5708 (PI/2)
    4116/    4984 :                     ;
    4117/    4984 : 00 00 00 7F         QUARTR: DB	000H,000H,000H,07FH	; 0.25
    4118/    4988 :                     ;
    4119/    4988 : 05                  SINTAB: DB	5			; Table used by SIN
    4120/    4989 : BA D7 1E 86         	DB	0BAH,0D7H,01EH,086H	; 39.711
    4121/    498D : 64 26 99 87         	DB	064H,026H,099H,087H	;-76.575
    4122/    4991 : 58 34 23 87         	DB	058H,034H,023H,087H	; 81.602
    4123/    4995 : E0 5D A5 86         	DB	0E0H,05DH,0A5H,086H	;-41.342
    4124/    4999 : DA 0F 49 83         	DB	0DAH,00FH,049H,083H	; 6.2832
    4125/    499D :                     ;
    4126/    499D : CD 7A 45            TAN:	CALL	STAKFP		; Put angle on stack
    4127/    49A0 : CD 3C 49            	CALL	SIN		; Get SIN of angle
    4128/    49A3 : C1                  	POP	BC		; Restore angle
    4129/    49A4 : E1                  	POP	HL
    4130/    49A5 : CD 7A 45            	CALL	STAKFP		; Save SIN of angle
    4131/    49A8 : EB                  	EX	DE,HL		; BCDE = Angle
    4132/    49A9 : CD 8A 45            	CALL	FPBCDE		; Angle to FPREG
    4133/    49AC : CD 36 49            	CALL	COS		; Get COS of angle
    4134/    49AF : C3 9D 44            	JP	DIV		; TAN = SIN / COS
    4135/    49B2 :                     ;
    4136/    49B2 : CD 49 45            ATN:	CALL	TSTSGN		; Test sign of value
    4137/    49B5 : FC DD 47            	CALL	M,NEGAFT	; Negate result after if -ve
    4138/    49B8 : FC 72 45            	CALL	M,INVSGN	; Negate value if -ve
    4139/    49BB : 3A 2C C1            	LD	A,(FPEXP)	; Get exponent
    4140/    49BE : FE 81               	CP	81H		; Number less than 1?
    4141/    49C0 : DA CF 49            	JP	C,ATN1		; Yes - Get arc tangnt
    4142/    49C3 : 01 00 81            	LD	BC,8100H	; BCDE = 1
    4143/    49C6 : 51                  	LD	D,C
    4144/    49C7 : 59                  	LD	E,C
    4145/    49C8 : CD 9F 44            	CALL	DVBCDE		; Get reciprocal of number
    4146/    49CB : 21 FA 42            	LD	HL,SUBPHL	; Sub angle from PI/2
    4147/    49CE : E5                  	PUSH	HL		; Save for angle > 1
    4148/    49CF : 21 D9 49            ATN1:	LD	HL,ATNTAB	; Coefficient table
    4149/    49D2 : CD 91 48            	CALL	SUMSER		; Evaluate sum of series
    4150/    49D5 : 21 80 49            	LD	HL,HALFPI	; PI/2 - angle in case > 1
    4151/    49D8 : C9                  	RET			; Number > 1 - Sub from PI/2
    4152/    49D9 :                     ;
    4153/    49D9 : 09                  ATNTAB: DB	9			; Table used by ATN
    4154/    49DA : 4A D7 3B 78         	DB	04AH,0D7H,03BH,078H	; 1/17
    4155/    49DE : 02 6E 84 7B         	DB	002H,06EH,084H,07BH	;-1/15
    4156/    49E2 : FE C1 2F 7C         	DB	0FEH,0C1H,02FH,07CH	; 1/13
    4157/    49E6 : 74 31 9A 7D         	DB	074H,031H,09AH,07DH	;-1/11
    4158/    49EA : 84 3D 5A 7D         	DB	084H,03DH,05AH,07DH	; 1/9
    4159/    49EE : C8 7F 91 7E         	DB	0C8H,07FH,091H,07EH	;-1/7
    4160/    49F2 : E4 BB 4C 7E         	DB	0E4H,0BBH,04CH,07EH	; 1/5
    4161/    49F6 : 6C AA AA 7F         	DB	06CH,0AAH,0AAH,07FH	;-1/3
    4162/    49FA : 00 00 00 81         	DB	000H,000H,000H,081H	; 1/1
    4163/    49FE :                     ;
    4164/    49FE :                     
    4165/    49FE : C9                  ARET:	RET			; A RETurn instruction
    4166/    49FF :                     ;
    4167/    49FF : D7                  GETINP: RST	10H		;input a character
    4168/    4A00 : C9                  	RET
    4169/    4A01 :                     ;
    4170/    4A01 :                     CLS: 
    4171/    4A01 : 3E 0C               	LD	A,CS		; ASCII Clear screen
    4172/    4A03 :                     ;	JP	MONOUT		; Output character
    4173/    4A03 : CF                  	rst	08h
    4174/    4A04 : C9                  	ret
    4175/    4A05 :                     ;
    4176/    4A05 : CD C8 42            WIDTH:	CALL	GETINT		; Get integer 0-255
    4177/    4A08 : 7B                  	LD	A,E		; Width to A
    4178/    4A09 : 32 87 C0            	LD	(LWIDTH),A	; Set width
    4179/    4A0C : C9                  	RET
    4180/    4A0D :                     ;
    4181/    4A0D : CD 67 3B            LINES:	CALL	GETNUM		; Get a number
    4182/    4A10 : CD AC 37            	CALL	DEINT		; Get integer -32768 to 32767
    4183/    4A13 : ED 53 8B C0         	LD	(LINESC),DE	; Set lines counter
    4184/    4A17 : ED 53 8D C0         	LD	(LINESN),DE	; Set lines number
    4185/    4A1B : C9                  	RET
    4186/    4A1C :                     ;
    4187/    4A1C : CD AC 37            DEEK:	CALL	DEINT		; Get integer -32768 to 32767
    4188/    4A1F : D5                  	PUSH	DE		; Save number
    4189/    4A20 : E1                  	POP	HL		; Number to HL
    4190/    4A21 : 46                  	LD	B,(HL)		; Get LSB of contents
    4191/    4A22 : 23                  	INC	HL
    4192/    4A23 : 7E                  	LD	A,(HL)		; Get MSB of contents
    4193/    4A24 : C3 22 3F            	JP	ABPASS		; Return integer AB
    4194/    4A27 :                     ;
    4195/    4A27 : CD 67 3B            DOKE:	CALL	GETNUM		; Get a number
    4196/    4A2A : CD AC 37            	CALL	DEINT		; Get integer -32768 to 32767
    4197/    4A2D : D5                  	PUSH	DE		; Save address
    4198/    4A2E : CD 72 35            	CALL	CHKSYN		; Make sure ',' follows
    4199/    4A31 : 2C                  	DB	','
    4200/    4A32 : CD 67 3B            	CALL	GETNUM		; Get a number
    4201/    4A35 : CD AC 37            	CALL	DEINT		; Get integer -32768 to 32767
    4202/    4A38 : E3                  	EX	(SP),HL		; Save value,get address
    4203/    4A39 : 73                  	LD	(HL),E		; Save LSB of value
    4204/    4A3A : 23                  	INC	HL
    4205/    4A3B : 72                  	LD	(HL),D		; Save MSB of value
    4206/    4A3C : E1                  	POP	HL		; Restore code string address
    4207/    4A3D : C9                  	RET
    4208/    4A3E :                     ;
    4209/    4A3E :                     
    4210/    4A3E :                     ; HEX$(nn) Convert 16 bit number to Hexadecimal string
    4211/    4A3E :                     ;
    4212/    4A3E : CD 6A 3B            HEX: 	CALL	TSTNUM		; Verify it's a number
    4213/    4A41 : CD AC 37            	CALL	DEINT		; Get integer -32768 to 32767
    4214/    4A44 : C5                  	PUSH	BC		; Save contents of BC
    4215/    4A45 : 21 2E C1            	LD	HL,PBUFF
    4216/    4A48 : 7A                  	LD	A,D		; Get high order into A
    4217/    4A49 : FE 00               	CP	0
    4218/    4A4B : 28 0C               	JR	Z,HEX2		; Skip output if both high digits are zero
    4219/    4A4D : CD 76 4A            	CALL	BYT2ASC		; Convert D to ASCII
    4220/    4A50 : 78                  	LD	A,B
    4221/    4A51 : FE 30               	CP	'0'
    4222/    4A53 : 28 02               	JR	Z,HEX1		; Don't store high digit if zero
    4223/    4A55 : 70                  	LD	(HL),B		; Store it to PBUFF
    4224/    4A56 : 23                  	INC	HL		; Next location
    4225/    4A57 : 71                  HEX1:	LD	(HL),C		; Store C to PBUFF+1
    4226/    4A58 : 23                  	INC	HL		; Next location
    4227/    4A59 : 7B                  HEX2:	LD	A,E		; Get lower byte
    4228/    4A5A : CD 76 4A            	CALL	BYT2ASC		; Convert E to ASCII
    4229/    4A5D : 7A                  	LD	A,D
    4230/    4A5E : FE 00               	CP	0
    4231/    4A60 : 20 05               	JR	NZ,HEX3		; If upper byte was not zero then always print lower byte
    4232/    4A62 : 78                  	LD	A,B
    4233/    4A63 : FE 30               	CP	'0'		; If high digit of lower byte is zero then don't print
    4234/    4A65 : 28 02               	JR	Z,HEX4
    4235/    4A67 : 70                  HEX3:	LD	(HL),B		; to PBUFF+2
    4236/    4A68 : 23                  	INC	HL		; Next location
    4237/    4A69 : 71                  HEX4:	LD	(HL),C		; to PBUFF+3
    4238/    4A6A : 23                  	INC	HL		; PBUFF+4 to zero
    4239/    4A6B : AF                  	XOR	A		; Terminating character
    4240/    4A6C : 77                  	LD	(HL),A		; Store zero to terminate
    4241/    4A6D : 23                  	INC	HL		; Make sure PBUFF is terminated
    4242/    4A6E : 77                  	LD	(HL),A		; Store the double zero there
    4243/    4A6F : C1                  	POP	BC		; Get BC back
    4244/    4A70 : 21 2E C1            	LD	HL,PBUFF	; Reset to start of PBUFF
    4245/    4A73 : C3 D0 3F            	JP	STR1		; Convert the PBUFF to a string and return it
    4246/    4A76 :                     ;
    4247/    4A76 : 47                  BYT2ASC: LD	B,A		; Save original value
    4248/    4A77 : E6 0F               	AND	0FH		; Strip off upper nybble
    4249/    4A79 : FE 0A               	CP	0AH		; 0-9?
    4250/    4A7B : 38 02               	JR	C,ADD30		; If A-F, add 7 more
    4251/    4A7D : C6 07               	ADD	A,07H		; Bring value up to ASCII A-F
    4252/    4A7F : C6 30               ADD30:	ADD	A,30H		; And make ASCII
    4253/    4A81 : 4F                  	LD	C,A		; Save converted char to C
    4254/    4A82 : 78                  	LD	A,B		; Retrieve original value
    4255/    4A83 : 0F                  	RRCA			; and Rotate it right
    4256/    4A84 : 0F                  	RRCA
    4257/    4A85 : 0F                  	RRCA
    4258/    4A86 : 0F                  	RRCA
    4259/    4A87 : E6 0F               	AND	0FH		; Mask off upper nybble
    4260/    4A89 : FE 0A               	CP	0AH		; 0-9? < A hex?
    4261/    4A8B : 38 02               	JR	C,ADD301	; Skip Add 7
    4262/    4A8D : C6 07               	ADD	A,07H		; Bring it up to ASCII A-F
    4263/    4A8F : C6 30               ADD301:	ADD	A,30H		; And make it full ASCII
    4264/    4A91 : 47                  	LD	B,A		; Store high order byte
    4265/    4A92 : C9                  	RET	
    4266/    4A93 :                     ;
    4267/    4A93 :                     ; Convert "&Hnnnn" to FPREG
    4268/    4A93 :                     ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
    4269/    4A93 :                     ; Char is in A, NC if char is;<=>?@ A-z, CY is set if 0-9
    4270/    4A93 : EB                  HEXTFP:	EX	DE,HL		; Move code string pointer to DE
    4271/    4A94 : 21 00 00            	LD	HL,0000H	; Zero out the value
    4272/    4A97 : CD AC 4A            	CALL	GETHEX		; Check the number for valid hex
    4273/    4A9A : DA CC 4A            	JP	C,HXERR		; First value wasn't hex, HX error
    4274/    4A9D : 18 05               	JR	HEXLP1		; Convert first character
    4275/    4A9F : CD AC 4A            HEXLP:	CALL	GETHEX		; Get second and addtional characters
    4276/    4AA2 : 38 1F               	JR	C,HEXIT		; Exit if not a hex character
    4277/    4AA4 : 29                  HEXLP1:	ADD	HL,HL		; Rotate 4 bits to the left
    4278/    4AA5 : 29                  	ADD	HL,HL
    4279/    4AA6 : 29                  	ADD	HL,HL
    4280/    4AA7 : 29                  	ADD	HL,HL
    4281/    4AA8 : B5                  	OR	L		; Add in D0-D3 into L
    4282/    4AA9 : 6F                  	LD	L,A		; Save new value
    4283/    4AAA : 18 F3               	JR	HEXLP		; And continue until all hex characters are in
    4284/    4AAC :                     ;
    4285/    4AAC : 13                  GETHEX:	INC	DE		; Next location
    4286/    4AAD : 1A                  	LD	A,(DE)		; Load character at pointer
    4287/    4AAE : FE 20               	CP	' '
    4288/    4AB0 : CA AC 4A            	JP	Z,GETHEX	; Skip spaces
    4289/    4AB3 : D6 30               	SUB	30H		; Get absolute value
    4290/    4AB5 : D8                  	RET	C		; < "0", error
    4291/    4AB6 : FE 0A               	CP	0AH
    4292/    4AB8 : 38 05               	JR	C,NOSUB7	; Is already in the range 0-9
    4293/    4ABA : D6 07               	SUB	07H		; Reduce to A-F
    4294/    4ABC : FE 0A               	CP	0AH		; Value should be $0A-$0F at this point
    4295/    4ABE : D8                  	RET	C		; CY set if was :		; < = > ? @
    4296/    4ABF : FE 10               NOSUB7:	CP	10H		; > Greater than "F"?
    4297/    4AC1 : 3F                  	CCF
    4298/    4AC2 : C9                  	RET			; CY set if it wasn't valid hex
    4299/    4AC3 :                     	
    4300/    4AC3 : EB                  HEXIT:	EX	DE,HL		; Value into DE, Code string into HL
    4301/    4AC4 : 7A                  	LD	A,D		; Load DE into AC
    4302/    4AC5 : 4B                  	LD	C,E		; For prep to 
    4303/    4AC6 : E5                  	PUSH	HL
    4304/    4AC7 : CD 21 3F            	CALL	ACPASS		; ACPASS to set AC as integer into FPREG
    4305/    4ACA : E1                  	POP	HL
    4306/    4ACB : C9                  	RET
    4307/    4ACC :                     ;
    4308/    4ACC : 1E 26               HXERR:	LD	E,HX		; ?HEX Error
    4309/    4ACE : C3 B8 32            	JP	ERROR_
    4310/    4AD1 :                     ;
    4311/    4AD1 :                     ; BIN$(NN) Convert integer to a 1-16 char binary string
    4312/    4AD1 : CD 6A 3B            BIN:	CALL	TSTNUM		; Verify it's a number
    4313/    4AD4 : CD AC 37            	CALL	DEINT		; Get integer -32768 to 32767
    4314/    4AD7 : C5                  BIN2:	PUSH	BC		; Save contents of BC
    4315/    4AD8 : 21 2E C1            	LD	HL,PBUFF
    4316/    4ADB : 06 11               	LD	B,17		; One higher than max char count
    4317/    4ADD :                     ZEROSUP:			; Suppress leading zeros
    4318/    4ADD : 05                  	DEC	B		; Max 16 chars
    4319/    4ADE : 78                  	LD	A,B
    4320/    4ADF : FE 01               	CP	01H
    4321/    4AE1 : 28 08               	JR	Z,BITOUT	; Always output at least one character
    4322/    4AE3 : CB 13               	RL	E
    4323/    4AE5 : CB 12               	RL	D
    4324/    4AE7 : 30 F4               	JR	NC,ZEROSUP
    4325/    4AE9 : 18 04               	JR	BITOUT2
    4326/    4AEB :                     BITOUT:	
    4327/    4AEB : CB 13               	RL	E
    4328/    4AED : CB 12               	RL	D		; Top bit now in carry
    4329/    4AEF :                     BITOUT2:
    4330/    4AEF : 3E 30               	LD	A,'0'		; Char for '0'
    4331/    4AF1 : CE 00               	ADC	A,0		; If carry set then '0' --> '1'
    4332/    4AF3 : 77                  	LD	(HL),A
    4333/    4AF4 : 23                  	INC	HL
    4334/    4AF5 : 05                  	DEC	B
    4335/    4AF6 : 20 F3               	JR	NZ,BITOUT
    4336/    4AF8 : AF                  	XOR	A		; Terminating character
    4337/    4AF9 : 77                  	LD	(HL),A		; Store zero to terminate
    4338/    4AFA : 23                  	INC	HL		; Make sure PBUFF is terminated
    4339/    4AFB : 77                  	LD	(HL),A		; Store the double zero there
    4340/    4AFC : C1                  	POP	BC
    4341/    4AFD : 21 2E C1            	LD	HL,PBUFF
    4342/    4B00 : C3 D0 3F            	JP	STR1
    4343/    4B03 :                     ;
    4344/    4B03 :                     ; Convert "&Bnnnn" to FPREG
    4345/    4B03 :                     ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
    4346/    4B03 : EB                  BINTFP: EX	DE,HL		; Move code string pointer to DE
    4347/    4B04 : 21 00 00            	LD	HL,0000H	; Zero out the value
    4348/    4B07 : CD 20 4B            	CALL	CHKBIN		; Check the number for valid bin
    4349/    4B0A : DA 2E 4B            	JP	C,BINERR	; First value wasn't bin, HX error
    4350/    4B0D : D6 30               BINIT:	SUB	'0'
    4351/    4B0F : 29                  	ADD	HL,HL		; Rotate HL left
    4352/    4B10 : B5                  	OR	L
    4353/    4B11 : 6F                  	LD	L,A
    4354/    4B12 : CD 20 4B            	CALL	CHKBIN		; Get second and addtional characters
    4355/    4B15 : 30 F6               	JR	NC,BINIT	; Process if a bin character
    4356/    4B17 : EB                  	EX	DE,HL		; Value into DE, Code string into HL
    4357/    4B18 : 7A                  	LD	A,D		; Load DE into AC
    4358/    4B19 : 4B                  	LD	C,E		; For prep to 
    4359/    4B1A : E5                  	PUSH	HL
    4360/    4B1B : CD 21 3F            	CALL	ACPASS		; ACPASS to set AC as integer into FPREG
    4361/    4B1E : E1                  	POP	HL
    4362/    4B1F : C9                  	RET
    4363/    4B20 :                     ;
    4364/    4B20 :                     ; Char is in A, NC if char is 0 or 1
    4365/    4B20 : 13                  CHKBIN: INC	DE
    4366/    4B21 : 1A                  	LD	A,(DE)
    4367/    4B22 : FE 20               	CP	' '
    4368/    4B24 : CA 20 4B            	JP	Z,CHKBIN	; Skip spaces
    4369/    4B27 : FE 30               	CP	'0'		; Set C if < '0'
    4370/    4B29 : D8                  	RET	C
    4371/    4B2A : FE 32               	CP	'2'
    4372/    4B2C : 3F                  	CCF			; Set C if > '1'
    4373/    4B2D : C9                  	RET
    4374/    4B2E :                     ;
    4375/    4B2E : 1E 28               BINERR: LD	E,BN		; ?BIN Error
    4376/    4B30 : C3 B8 32            	JP	ERROR_
    4377/    4B33 :                     ;
    4378/    4B33 :                     ;JJUMP1: JP	CSTART		; Go and initialise
    4379/    4B33 :                     ;
    4380/    4B33 :                     ;MONOUT: JP	TXA		; output a char
    4381/    4B33 :                     ;
    4382/    4B33 :                     MONITR: 
    4383/    4B33 :                     ;JP	UNI_CST		; Restart unimon
    4384/    4B33 : 0E 01               	ld	c, 1
    4385/    4B35 : F7                  	rst	30h
    4386/    4B36 : C9                  	ret
    4387/    4B37 :                     ;
    4388/    4B37 : 3E 00               INITST: LD	A,0		; Clear break flag
    4389/    4B39 : 32 92 C0            	LD	(BRKFLG),A
    4390/    4B3C : C3 14 2F            	JP	INIT
    4391/    4B3F :                     ;
    4392/    4B3F : F5                  TSTBIT: PUSH	AF		; Save bit mask
    4393/    4B40 : A0                  	AND	B		; Get common bits
    4394/    4B41 : C1                  	POP	BC		; Restore bit mask
    4395/    4B42 : B8                  	CP	B		; Same bit set?
    4396/    4B43 : 3E 00               	LD	A,0		; Return 0 in A
    4397/    4B45 : C9                  	RET
    4398/    4B46 :                     ;
    4399/    4B46 : CD 7D 35            OUTNCR: CALL	OUTC		; Output character in A
    4400/    4B49 : C3 A2 39            	JP	PRCRLF		; Output CRLF
    4401/    4B4C :                     
    4402/    4B4C : FF FF FF FF FF FF   	db	($ & 0FF00H)+100H-$ dup(0FFH)
             4B52 : FF FF FF FF FF FF 
             4B58 : FF FF FF FF FF FF 
             4B5E : FF FF FF FF FF FF 
             4B64 : FF FF FF FF FF FF 
             4B6A : FF FF FF FF FF FF 
             4B70 : FF FF FF FF FF FF 
             4B76 : FF FF FF FF FF FF 
             4B7C : FF FF FF FF FF FF 
             4B82 : FF FF FF FF FF FF 
             4B88 : FF FF FF FF FF FF 
             4B8E : FF FF FF FF FF FF 
             4B94 : FF FF FF FF FF FF 
             4B9A : FF FF FF FF FF FF 
             4BA0 : FF FF FF FF FF FF 
             4BA6 : FF FF FF FF FF FF 
             4BAC : FF FF FF FF FF FF 
             4BB2 : FF FF FF FF FF FF 
             4BB8 : FF FF FF FF FF FF 
             4BBE : FF FF FF FF FF FF 
             4BC4 : FF FF FF FF FF FF 
             4BCA : FF FF FF FF FF FF 
             4BD0 : FF FF FF FF FF FF 
             4BD6 : FF FF FF FF FF FF 
             4BDC : FF FF FF FF FF FF 
             4BE2 : FF FF FF FF FF FF 
             4BE8 : FF FF FF FF FF FF 
             4BEE : FF FF FF FF FF FF 
             4BF4 : FF FF FF FF FF FF 
             4BFA : FF FF FF FF FF FF 
    4403/    4C00 :                     
    4404/    4C00 :                     	END
 AS V1.42 Beta [Bld 246] - Source File add_EMUBASIC.ASM - Page 2 - 9/2/2023 2:59:35


  Symbol Table (* = unused):
  --------------------------

 ABPASS :                      3F22 C |  ABS :                         456E C |
*ACCSUM :                      378B C |  ACPASS :                      3F21 C |
 ADD30 :                       4A7F C |  ADD301 :                      4A8F C |
 ADDEXP :                      4507 C |  ADDIG :                       46AD C |
 ADDPHL :                      42F4 C |  ALLFOL :                      41F0 C |
 ANTVLU :                      3A8B C |
*ARCHITECTURE :                                        "i386-unknown-win32" - |
*ARET :                        49FE C |  ARLDSV :                      3E42 C |
 ARREND :                     0C11F - |  ARRLP :                       40BB C |
 ASC :                         41C1 C |  ASCTFP :                      4650 C |
 ASPCS :                       39ED C |  ATN :                         49B2 C |
 ATN1 :                        49CF C |  ATNTAB :                      49D9 C |
 ATOH :                        37C6 C |  BADINP :                      3A12 C |
 BAKSTK :                      324D C |  BAKTMP :                      41A1 C |
 BASTXT :                     0C0A3 - |  BCDEFP :                      4595 C |
 BFREE :                       2F7D C |  BIN :                         4AD1 C |
*BIN2 :                        4AD7 C |  BINERR :                      4B2E C |
 BINIT :                       4B0D C |  BINTFP :                      4B03 C |
 BITOUT :                      4AEB C |  BITOUT2 :                     4AEF C |
 BKSP :                           8 - |  BN :                            28 - |
 BNORM :                       4354 C |  BNRMLP :                      4357 C |
 BRK :                         373D C |  BRKFLG :                     0C092 - |
 BRKLIN :                     0C113 - |  BRKMSG :                      3247 C |
 BRKRET :                      2F6E C |  BS :                            10 - |
 BSERR :                       3E75 C |  BUFFER :                     0C0A6 - |
 BYT2ASC :                     4A76 C |  BYTSFT :                      448C C |
*CASESENSITIVE :                  0 - |  CFEVAL :                      3DD8 C |
 CHARTY :                      3D86 C |  CHEKFN :                      3FB9 C |
 CHKBIN :                      4B20 C |  CHKLTR :                      3798 C |
 CHKSTK :                      3281 C |  CHKSUM :                     0C08F - |
 CHKSYN :                      3572 C |  CHKTYP :                      3B6C C |
 CHR :                         41D2 C |  CLEAR :                       37EB C |
 CLOTST :                      35A5 C |  CLREG :                       33D6 C |
 CLRPTR :                      33B1 C |  CLS :                         4A01 C |
 CMPFP :                       45DE C |  CMPLG1 :                      3CEC C |
 CMPLOG :                      3CEA C |  CMPNUM :                      45C4 C |
 CMPRES :                      3D2E C |  CMPSTR :                      3D16 C |
 CN :                            20 - |  CNVNUM :                      465C C |
 COMMAN :                     0C088 - |  COMPL :                       43B4 C |
 CONCAT :                      4136 C |  CONEXP :                      468C C |
 CONPOS :                      4351 C | *CONSTPI :        3.141592653589793 - |
 CONT :                        3770 C |  CONTAD :                     0C119 - |
 CONVAR :                      3C57 C |  COPY :                        2F1C C |
 COS :                         4936 C |  COUNT :                       3615 C |
 CPDEHL :                      356C C |  CPYLIT :                      34A8 C |
 CR :                            0D - |  CRARLP :                      3E95 C |
 CREARY :                      3E7A C |  CRESTR :                      38EA C |
 CRNCLP :                      3409 C |  CRTMST :                      3FF2 C |
 CRTST :                       3FFE C |  CRTSTE :                      4014 C |
 CRUNCH :                      3400 C |  CS :                            0C - |
 CSTART :                      2F0D C |  CTLOFG :                     0C08A - |
 CTRLC :                          3 - |  CTRLG :                          7 - |
 CTRLO :                         0F - |  CTRLQ :                         11 - |
 CTRLR :                         12 - |  CTRLS :                         13 - |
 CTRLU :                         15 - |  CUROPR :                     0C10A - |
 CURPOS :                     0C0F0 - |  DATA :                        3891 C |
*DATE :                  "9/2/2023" - |  DATFLG :                     0C0F3 - |
 DATLIN :                     0C10E - |  DATSNR :                      329E C |
 DCBCDE :                      4615 C |  DDERR :                       32AD C |
 DEEK :                        4A1C C |  DEF :                         3F36 C |
 DEFSIZ :                      3E9D C |  DEINT :                       37AC C |
 DEL :                           7F - |  DELCHR :                      34D8 C |
 DEPINT :                      37A6 C |  DETHL4 :                      45A4 C |
 DETHLB :                      45A6 C |  DIGTXT :                      4756 C |
 DIM :                         3D58 C |  DIMRET :                      3D4F C |
 DINPOS :                      35A1 C |  DIV :                         449D C |
 DIV1 :                       0C04F - |  DIV10 :                       4491 C |
 DIV2 :                       0C053 - |  DIV3 :                       0C057 - |
 DIV4 :                       0C05A - |  DIVLP :                       44C4 C |
 DIVSUP :                     0C04E - |  DOAGN :                       33EF C |
 DOCOM :                       39BE C |  DODEL :                       34B8 C |
 DOEBIT :                      4796 C |  DOFN :                        3F63 C |
 DOKE :                        4A27 C |  DONULL :                      39AC C |
 DOSPC :                       39E8 C |  DOTAB :                       39D5 C |
 DPOINT :                      4688 C |  DTSTR :                       4002 C |
 DVBCDE :                      449F C |  DZ :                            14 - |
 DZERR :                       32A7 C |  ECHDEL :                      34CC C |
 EDIGIT :                      46CF C |  ENDBUF :                      34AF C |
 ENDCON :                      469B C |  ENDDIM :                      3EFC C |
 ENDINP :                      399D C |  ENDNAM :                      3D7A C |
 ENDPRG :                      374C C |  ENFMEM :                      328A C |
 ERRIN :                       32D8 C |  ERRLIN :                     0C117 - |
 ERRMSG :                      3235 C |  ERRORS :                      31AB C |
 ERROR_ :                      32B8 C |  ESC :                           1B - |
 EVAL :                        3B79 C |  EVAL1 :                       3B7C C |
 EVAL2 :                       3B85 C |  EVAL3 :                       3B88 C |
 EVLPAR :                      3C3E C |  EVNOT :                       3D38 C |
 EXCUTE :                      36DA C |  EXP :                         4830 C |
 EXPLP :                       467A C |  EXPTAB :                      4870 C |
 EXPTEN :                      47A8 C |  EXTIG :                       3AE7 C |
*FALSE :                          0 - |  FANDT :                       3B11 C |
 FC :                             8 - |  FCERR :                       37C1 C |
 FDTLP :                       3AF8 C |  FINDEL :                      3ED8 C |
 FLGDIF :                      4554 C |  FLGREL :                      455B C |
 FNARG :                      0C125 - |  FNCTAB :                      2FF5 C |
 FNDARY :                      3E48 C |  FNDELP :                      3EDD C |
 FNDEND :                      3384 C |  FNDNUM :                      42C5 C |
 FNDTOK :                      35F4 C |  FNDVAR :                      3DBF C |
 FNDWRD :                      3433 C |  FNOFST :                      3C68 C |
 FNRGNM :                     0C123 - |  FNTHR :                       3DCD C |
 FNVAL :                       3C8F C |  FOPRND :                      3BB1 C |
 FOR :                         3641 C |  FORFLG :                     0C110 - |
 FORFND :                      3671 C |  FORSLP :                      3655 C |
 FPADD :                       4303 C |  FPBCDE :                      458A C |
 FPEXP :                      0C12C - |  FPINT :                       45F1 C |
 FPMULT :                      443E C |  FPREG :                      0C129 - |
 FPROND :                      439B C |  FPSINT :                      37A0 C |
 FPTHL :                       45A1 C |  FRE :                         3F00 C |
 FRENUM :                      3F1C C |  FRMEVL :                      3C5A C |
*FULLPMMU :                       1 - |  GARBGE :                      4083 C |
 GARBLP :                      4086 C |  GETCHR :                      36FA C |
 GETCMD :                      32FC C |  GETHEX :                      4AAC C |
 GETINP :                      49FF C |  GETINT :                      42C8 C |
 GETLEN :                      41B6 C |  GETLIN :                      34E9 C |
 GETLN :                       37C7 C |  GETNUM :                      3B67 C |
 GETNXT :                      344E C |  GETSTR :                      4180 C |
 GETVAR :                      3D5D C |  GNXARY :                      40BA C |
 GOFUNC :                      3C97 C |  GOSUB :                       383D C |
 GOTO :                        384E C |  GRBARY :                      40DA C |
 GRBDON :                      405B C |  GRBLP :                       4094 C |
 GSTRCU :                      4183 C |  GSTRDE :                      4187 C |
 GSTRHL :                      4186 C | *GTFLNM :                      41C5 C |
 GTFNAM :                      3D62 C |  GTLNLP :                      37CA C |
 GTSIXD :                      4720 C |  GTVLUS :                      3A63 C |
 HALF :                        47C7 C |  HALFPI :                      4980 C |
*HAS64 :                          0 - | *HASFPU :                         0 - |
*HASPMMU :                        0 - |  HEX :                         4A3E C |
 HEX1 :                        4A57 C |  HEX2 :                        4A59 C |
 HEX3 :                        4A67 C |  HEX4 :                        4A69 C |
 HEXIT :                       4AC3 C |  HEXLP :                       4A9F C |
 HEXLP1 :                      4AA4 C |  HEXTFP :                      4A93 C |
 HX :                            26 - |  HXERR :                       4ACC C |
 ID :                            16 - |  IDTEST :                      3FAB C |
 IFGO :                        392E C |  IFJMP :                       36E1 C |
 IF_ :                         3920 C |  INCHL :                       459F C |
 INCLEN :                      359D C |  INDFND :                      3267 C |
 INEWLN :                      334C C |  INIT :                        2F14 C |
 INITAB :                      31D5 C |  INITBE :                      3235 C |
 INITST :                      4B37 C |  INMSG :                       323C C |
 INP :                         4285 C |  INPBIN :                      3AB5 C |
 INPBRK :                      3749 C |  INPORT :                     0C084 - |
 INPSUB :                     0C083 - |  INPUT :                       3A23 C |
 INRNG :                       4729 C | *INSUPMODE :                      0 - |
 INT :                         461C C |  INTVAR :                      33C0 C |
 INVSGN :                      4572 C |  ITMSEP :                      3AA6 C |
 JSTZER :                      47B2 C |  KILFOR :                      3B57 C |
 KILIN :                       34E3 C |  LCRFLG :                     0C0F1 - |
 LEFT :                        41E2 C |  LEN :                         41B2 C |
 LET :                         38A8 C |  LETNUM :                      38FB C |
 LETSTR :                      38C3 C |  LF :                            0A - |
 LFRGNM :                      427B C |  LINEAT :                     0C0A1 - |
 LINEIN :                      46DB C |  LINES :                       4A0D C |
 LINESC :                     0C08B - |  LINESN :                     0C08D - |
 LINFND :                      3335 C |  LIST :                        35B6 C |
 LISTLP :                      35C2 C | *LISTON :                         1 - |
 LOADFP :                      4598 C |  LOG :                         43FD C |
 LOGTAB :                      43F0 C |  LOKFOR :                      3251 C |
 LOOPST :                     0C10C - |  LS :                            1C - |
 LSTBIN :                     0C111 - |  LSTLP2 :                      35E2 C |
 LSTLP3 :                      35E5 C |  LSTRAM :                     0C0F4 - |
 LSTRND :                     0C07F - |  LTSTND :                      3AC0 C |
 LWIDTH :                     0C087 - | *MACEXP :                         7 - |
 MAKINT :                      42CB C |  MAKNUM :                      4745 C |
 MANLP :                       4664 C |  MATCH :                       3480 C |
 MEMMSG :                      2FC3 C |  MID :                         421C C |
 MID1 :                        41E8 C |  MIDNUM :                      4280 C |
 MINCDE :                      4343 C |  MINUS :                       3C46 C |
 MKTMST :                      3FEF C |  MLDBLP :                      463D C |
 MLDEBC :                      4635 C |  MLSP10 :                      4532 C |
 MO :                            24 - | *MOMCPU :                        80 - |
*MOMCPUNAME :                 "Z80" - |  MONITR :                      4B33 C |
 MORDT :                       3ACC C |  MORINP :                      34F2 C |
 MOVBUF :                      336B C |  MOVDIR :                      3488 C |
 MOVLP :                       3276 C |  MOVSTR :                      3273 C |
 MOVUP :                       3270 C |  MRPRNT :                      3940 C |
 MUL8LP :                      4469 C |  MULLN2 :                      4435 C |
 MULT :                        443C C |  MULT8 :                       4460 C |
 MULTEN :                      46A6 C |  MULVAL :                     0C13B - |
 MVSTPT :                      38F2 C |  NEDMOR :                      3A5F C |
 NEGAFT :                      47DD C |  NEMEM :                       2F74 C |
*NESTMAX :                      100 - |  NEW :                         33B0 C |
 NEXITM :                      39F8 C |  NEXT :                        3B1C C |
 NEXT1 :                       3B1F C |  NF :                             0 - |
 NFERR :                       32AA C | *NMIFLG :                     0C091 - |
 NOCHNG :                      3478 C |  NOENED :                      47B5 C |
 NOLIN :                       375F C |  NOMADD :                      447A C |
 NOMLAD :                      464B C |  NOPMPT :                      3A3D C |
 NORMAL :                      436E C |  NOSPC :                       346F C |
 NOSUB7 :                      4ABF C |  NOSWAP :                      431D C |
 NOTAMP :                      3C1B C |  NOTSTR :                      3D95 C |
 NOXOR :                       42AB C |  NSCFOR :                      3DA5 C |
 NULFLG :                     0C089 - |  NULL :                        3783 C |
 NULLP :                       39B3 C |  NULLS :                      0C086 - |
 NUMASC :                      46EE C |  NXTARY :                      3E5C C |
 NXTBYT :                      345E C |  NXTCHR :                      349F C |
 NXTDAT :                     0C121 - |  NXTDTA :                      3890 C |
 NXTITM :                      3A57 C |  NXTOPR :                     0C115 - |
 NXTSTL :                      3897 C |  NXTSTT :                      389A C |
 OD :                             6 - |  OKMSG :                       3241 C |
 OM :                            0C - |  OMERR :                       3299 C |
 ON :                          3902 C |  ONGO :                        3911 C |
 ONGOLP :                      3912 C |  ONJMP :                       36E2 C |
 OPNPAR :                      3B75 C |  OPRND :                       3BF0 C |
 OS :                            1A - |  OTKLN :                       34E0 C |
 OTPORT :                     0C04C - |  OUTC :                        357D C |
 OUTEXP :                      47A6 C |  OUTIT :                       355E C |
 OUTNBS :                      3564 C |  OUTNCR :                      4B46 C |
 OUTSUB :                     0C04B - |  OUTWRD :                      35FE C |
 OV :                            0A - |  OVERR :                       32B3 C |
 OVTST1 :                      4525 C |  OVTST2 :                      452A C |
 OVTST3 :                      452B C |  PADD :                        46CA C |
*PADDING :                        1 - |  PAND :                        3CB1 C |
 PASSA :                       3F31 C |  PBUFF :                      0C12E - |
 PEEK :                        42D9 C |  PEND :                        3744 C |
 PHLTFP :                      4587 C |  PLUCDE :                      43A8 C |
 PNORM :                       4376 C |  POINT :                      0C096 - |
 POKE :                        42E0 C |  POPAF :                       4075 C |
 POPHL :                       419F C |  POPHRT :                      448A C |
 POPNOK :                      32EE C |  POR :                         3CB0 C |
 POR1 :                        3CD3 C |  POS :                         3F2E C |
 POSINT :                      37A3 C |  POUT :                        4291 C |
 POWER :                       47EB C |  POWER1 :                      47FB C |
 POWER2 :                      4818 C |  POWERS :                      47CB C |
 PRCRLF :                      39A2 C |  PRINT :                       3944 C |
 PRITAB :                      3196 C |  PRNTHL :                      46E3 C |
 PRNTLP :                      3947 C |  PRNTNB :                      398A C |
 PRNTOK :                      32EF C |  PRNTST :                      398E C |
 PRNUMS :                      403F C |  PROCES :                      350B C |
 PROGND :                     0C11B - |  PROGST :                     0C13E - |
 PROMPT :                      33F3 C |  PRS :                         4040 C |
 PRS1 :                        4043 C |  PRSLP :                       404A C |
 PSET :                       0C099 - |  PSUB :                        42FE C |
 PTRLP :                       3378 C |  PUTBUF :                      354A C |
 PUTCTL :                      354F C |  PUTFID :                      36B6 C |
 QTSTLP :                      4005 C |  QTSTR :                       3FFF C |
 QUARTR :                      4984 C |  RAM12K :                         1 - |
 RAM4K :                          0 - |  RAM8K :                          0 - |
 RAMTOP :                     0C000 - |  RD :                            12 - |
 READ :                        3A52 C |  READFG :                     0C112 - |
 REDO :                        39FF C | *RELAXED :                        0 - |
 REM :                         3893 C |  RESDIV :                      44D7 C |
 RESEED :                      4922 C |  RESET :                      0C09C - |
 RESTNL :                      371F C |  RESTOR :                      370A C |
 RESZER :                      4369 C |  RETADR :                      3E0C C |
 RETINT :                      4560 C |  RETLIN :                      388B C |
 RETNAD :                      3484 C |  RETNUL :                      3E0F C |
 RETNUM :                      3C52 C |  RETREL :                      4552 C |
 RETURN :                      386C C |  RG :                             4 - |
 RIGHT :                       4212 C |  RIGHT1 :                      41E6 C |
 RINPUT :                     0C093 - |  RLTLP :                       3B95 C |
 RND :                         48C1 C |  RND1 :                        48FD C |
 RND2 :                        4919 C |  RNDTAB :                      492A C |
 RNGTST :                      47B8 C |  ROMTOP :                      2F00 - |
 RONDB :                       438A C |  RONDUP :                      4389 C |
 ROUND :                       42F1 C |  RSCALE :                      46C4 C |
 RSLNBK :                      3638 C |  RSTSTR :                      4235 C |
 RUN :                         3831 C |  RUNCNT :                      36BA C |
 RUNFST :                      33BC C |  RUNLIN :                      384D C |
 SAVEXP :                      436A C |  SAVSTP :                      36AD C |
 SAVSTR :                      3FDA C |  SBSCPT :                      3E1A C |
 SCALE :                       43C8 C |  SCALLP :                      43CA C |
 SCALMI :                      468F C |  SCALPL :                      46A5 C |
 SCNEND :                      4111 C |  SCPTLP :                      3E20 C |
 SEARCH :                      344C C |  SEED :                       0C05C - |
 SETIO :                       42B5 C |  SETLIN :                      360C C |
 SETLIT :                      3496 C |  SETPTR :                      3373 C |
 SFTPRG :                      333D C |  SGN :                         4558 C |
 SGNEXP :                      3CA0 C |  SGNRES :                     0C12D - |
 SHRITE :                      43D7 C |  SHRLP :                       43DA C |
 SHRT1 :                       43DE C |  SIGNON :                      2F8C C |
 SIGNS :                       45AF C |  SIN :                         493C C |
 SIN1 :                        496C C |  SINTAB :                      4988 C |
 SIXDIG :                      470B C |  SMPVAR :                      40A5 C |
 SMSER1 :                      48A0 C |  SN :                             2 - |
 SNERR :                       32A4 C |  SPCFST :                      46FC C |
 SPCLP :                       39F1 C |  SQR :                         47E2 C |
 SRCHLN :                      3390 C |  SRCHLP :                      3393 C |
 SSTSA :                       416D C |  ST :                            1E - |
 STACK :                      0C0AB - |  STACKU :                     0EEC0 - |
 STAKFP :                      457A C |  STALL :                       3733 C |
 STARTB :                      2F06 C |  STKTHS :                      3BD9 C |
 STLOOK :                     0C1A2 - |  STOP :                        3742 C |
 STORED :                      380E C |  STPOOL :                      40E8 C |
 STR :                         3FCA C |  STR1 :                        3FD0 C |
 STRADD :                      40EB C |  STRBOT :                     0C108 - |
 STRENT :                      3AA9 C |  STRSPC :                     0C09F - |
 STTLIN :                      3995 C |  SUBCDE :                      4300 C |
 SUBPHL :                      42FA C |  SUMLP :                       48A9 C |
 SUMSER :                      4891 C |  SUPTLZ :                      478A C |
 SVNAM2 :                      3D79 C |  SVSTAD :                      3FF8 C |
 TAN :                         499D C |  TESTOS :                      4077 C |
 TESTR :                       4059 C | *TIME :                   "2:59:35" - |
 TM :                            18 - |  TMERR :                       32B6 C |
 TMPSTR :                     0C104 - |  TMSTPL :                     0C0F8 - |
 TMSTPT :                     0C0F6 - |  TOPOOL :                      41DE C |
 TOSTRA :                      4176 C | *TRUE :                           1 - |
 TRYAGN :                      4765 C |  TSALP :                       4177 C |
*TSTBIT :                      4B3F C |  TSTBRK :                      3725 C |
 TSTNUM :                      3B6A C |  TSTOPL :                      4020 C |
 TSTRED :                      3CD8 C |  TSTREM :                      3499 C |
 TSTSGN :                      4549 C |  TSTSTR :                      3B6B C |
 TTYLIN :                      34E9 C |  TYPE :                       0C0F2 - |
 UF :                            22 - |  UFERR :                       32B0 C |
 UL :                            0E - |  ULERR :                       3867 C |
 UNITY :                       43EC C |  UPDATA :                      3720 C |
 USR :                        0C048 - |  VAL :                         424C C |
 VAL1 :                        426A C |  VAL2 :                        4274 C |
 VAL3 :                        4277 C |  VAREND :                     0C11D - |
*VERSION :                     142F - |  WAIT :                        4297 C |
 WAITLP :                      42AC C |  WARMST :                      2F6B C |
 WIDTH :                       4A05 C |  WORDS :                       302D C |
 WORDTB :                      314C C |  WRKSPC :                     0C045 - |
 XXXXX :                       2F7A C |  ZDATA :                         83 - |
*ZDIV :                         0AF - |  ZEND :                          80 - |
 ZEQUAL :                       0B4 - |  ZERARY :                      3EBB C |
 ZERBYT :                      3240 - |  ZEROLP :                      3DFE C |
 ZEROSUP :                     4ADD C |  ZFN :                          0A7 - |
 ZFOR :                          81 - |  ZGOSUB :                        8C - |
 ZGOTO :                         88 - |  ZGTR :                         0B3 - |
 ZLEFT :                        0CF - |  ZLTH :                         0B5 - |
 ZMINUS :                       0AD - |  ZNEW :                         0A4 - |
 ZNOT :                         0AA - |  ZONELP :                      39CC C |
 ZOR :                          0B2 - |  ZPLUS :                        0AC - |
*ZPOINT :                       0C7 - |  ZPRINT :                        9E - |
 ZREM :                          8E - |  ZSGN :                         0B6 - |
 ZSPC :                         0A8 - |  ZSTEP :                        0AB - |
 ZTAB :                         0A5 - |  ZTHEN :                        0A9 - |
*ZTIMES :                       0AE - |  ZTO :                          0A6 - |

    654 symbols
     29 unused symbols

 AS V1.42 Beta [Bld 246] - Source File add_EMUBASIC.ASM - Page 3 - 9/2/2023 2:59:35


  Code Pages:
  ----------

STANDARD (0 changed characters)

1 code page

0.07 seconds assembly time

   4405 lines source file
      2 passes
      0 errors
      0 warnings
