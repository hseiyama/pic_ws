 AS V1.42 Beta [Bld 246] - Source File add_EMUBASIC_SMEZ.ASM - Page 1 - 9/22/2023 19:27:59


       1/       0 :                     	page	0
       2/       0 :                     	cpu	z80
       3/       0 :                     ;	EMUBASIC based on GRANT's BASIC
       4/       0 :                     ;	TARGET: EMUZ80
       5/       0 :                     ;	ASSEMBLER: ARCPIT XZ80.EXE
       6/       0 :                     ;
       7/       0 :                     ;	START UP ROUTINE
       8/       0 :                     ;	VERSION 1.0, 2022/02/15
       9/       0 :                     ;	WRITTEN by TETSUYA SUZUKI
      10/       0 :                     ;	Modified Akihito Honda
      11/       0 :                     ;
      12/       0 :                     
      13/       0 : =0H                 AKI80 = 0
      14/       0 : =1H                 SuperMEZ80 = 1
      15/       0 : =0H                 RAM12K = 0
      16/       0 : =0H                 RAM8K = 0
      17/       0 : =0H                 RAM4K = 0
      18/       0 :                     
      19/       0 : =>FALSE             	IF	AKI80
      20/       0 :                     STACKU	equ	0FE90H	; user stack
      21/       0 :                     RAMTOP	EQU	8000H
      22/       0 : [19]                	ENDIF
      23/       0 :                     
      24/       0 : =>TRUE              	IF	SuperMEZ80
      25/       0 : =0FEC0H             STACKU	equ	0FEC0H	; user stack
      26/       0 : =1D00H              RAMTOP	EQU	1D00H
      27/       0 : [24]                	ENDIF
      28/       0 :                     
      29/       0 : =>FALSE             	IF	RAM12K
      30/       0 :                     STACKU	equ	0EEC0H	; user stack
      31/       0 :                     RAMTOP	EQU	0C000H
      32/       0 : [29]                	ENDIF
      33/       0 :                     
      34/       0 : =>FALSE             	IF	RAM8K
      35/       0 :                     STACKU	equ	9EC0H	; user stack
      36/       0 :                     RAMTOP	EQU	08000H
      37/       0 : [34]                	ENDIF
      38/       0 :                     
      39/       0 : =>FALSE             	IF	RAM4K
      40/       0 :                     ; ORIGINAL MEMORY MAP for PIC18F47Q43
      41/       0 :                     STACKU	equ	8EC0H	; user stack
      42/       0 :                     RAMTOP	EQU	08000H
      43/       0 : [39]                	ENDIF
      44/       0 :                     
      45/       0 :                     ;	MEMORY ASIGN
      46/       0 : =>TRUE              	IF SuperMEZ80
      47/       0 : =40H                ROMTOP	EQU	0040H		; 0000H - 003FH for boot
      48/       0 : =>FALSE             	ELSE
      49/       0 :                     ROMTOP	EQU	2F00H		; 0000H - 2EFFH for unimon
      50/       0 : [46]                	ENDIF
      51/       0 :                     
      52/       0 :                     ;
      53/       0 :                     ;	RESET (RST 00H)
      54/      40 :                     	ORG	ROMTOP
      55/      40 : C3 46 00            	JP	STARTB		; Jump for cold start
      56/      43 : C3 AB 00            	JP	WARMST		; Jump for warm start
      57/      46 :                     
      58/      46 : =>FALSE             	if	0
      59/      46 :                     ;
      60/      46 :                     ;	PUT 1CHAR (RST 08H)
      61/      46 :                     ;	ORG	ROMTOP+08H
      62/      46 :                     	ds	ROMTOP+08H - $, 0x00
      63/      46 :                     	JP	TXA
      64/      46 :                     ;
      65/      46 :                     ;	GET 1CHAR (RST 10H)
      66/      46 :                     ;	ORG	ROMTOP+10H
      67/      46 :                     	ds	ROMTOP+10H - $, 0x00
      68/      46 :                     	JP	RXA
      69/      46 :                     ;
      70/      46 :                     ;	KBHIT (RST 18H)
      71/      46 :                     ;	ORG	ROMTOP+18H
      72/      46 :                     	ds	ROMTOP+18H - $, 0x00
      73/      46 :                     	JP	KBHIT
      74/      46 :                     ;
      75/      46 :                     ;	UART -> A
      76/      46 :                     RXA:	LD	A,(UARTCR)
      77/      46 :                     	BIT	0,A
      78/      46 :                     	JR	Z,RXA
      79/      46 :                     	LD	A,(UARTDR)
      80/      46 :                     	CP	'a'
      81/      46 :                     	RET	C
      82/      46 :                     	CP	'z'+1
      83/      46 :                     	RET	NC
      84/      46 :                     	AND	0DFH
      85/      46 :                     	RET
      86/      46 :                     ;
      87/      46 :                     ;	CHECK RECEIVE STATUS
      88/      46 :                     KBHIT:	LD	A,(UARTCR)
      89/      46 :                     	BIT	0,A
      90/      46 :                     	RET
      91/      46 :                     ;
      92/      46 :                     ;	A -> UART
      93/      46 :                     TXA:	PUSH	AF
      94/      46 :                     TXAST1:	LD	A,(UARTCR)
      95/      46 :                     	BIT	1,A
      96/      46 :                     	JR	Z,TXAST1
      97/      46 :                     	POP	AF
      98/      46 :                     	LD	(UARTDR),A
      99/      46 :                     	RET
     100/      46 : [58]                	endif
     101/      46 :                     ;
     102/      46 :                     ;==================================================================================
     103/      46 :                     ; The updates to the original BASIC within this file are copyright Grant Searle
     104/      46 :                     ;
     105/      46 :                     ; You have permission to use this for NON COMMERCIAL USE ONLY
     106/      46 :                     ; If you wish to use it elsewhere, please include an acknowledgement to myself.
     107/      46 :                     ;
     108/      46 :                     ; http://searle.hostei.com/grant/index.html
     109/      46 :                     ;
     110/      46 :                     ; eMail: home.micros01@btinternet.com
     111/      46 :                     ;
     112/      46 :                     ; If the above don't work, please perform an Internet search to see if I have
     113/      46 :                     ; updated the web page hosting service.
     114/      46 :                     ;
     115/      46 :                     ;==================================================================================
     116/      46 :                     ;
     117/      46 :                     ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
     118/      46 :                     ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
     119/      46 :                     ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
     120/      46 :                     ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
     121/      46 :                     ; the original ROM code (checksum A934H). PA
     122/      46 :                     ;
     123/      46 :                     ; GENERAL EQUATES
     124/      46 :                     ;
     125/      46 : =3H                 CTRLC	EQU	03H		; Control "C"
     126/      46 : =7H                 CTRLG	EQU	07H		; Control "G"
     127/      46 : =8H                 BKSP	EQU	08H		; Back space
     128/      46 : =0AH                LF	EQU	0AH		; Line feed
     129/      46 : =0CH                CS	EQU	0CH		; Clear screen
     130/      46 : =0DH                CR	EQU	0DH		; Carriage return
     131/      46 : =0FH                CTRLO	EQU	0FH		; Control "O"
     132/      46 : =11H                CTRLQ	EQU	11H		; Control "Q"
     133/      46 : =12H                CTRLR	EQU	12H		; Control "R"
     134/      46 : =13H                CTRLS	EQU	13H		; Control "S"
     135/      46 : =15H                CTRLU	EQU	15H		; Control "U"
     136/      46 : =1BH                ESC	EQU	1BH		; Escape
     137/      46 : =7FH                DEL	EQU	7FH		; Delete
     138/      46 :                     ;
     139/      46 :                     ; BASIC WORK SPACE LOCATIONS
     140/      46 :                     ;
     141/      46 : =1D45H              WRKSPC	EQU	RAMTOP + 45H	; BASIC Work space
     142/      46 : =1D48H              USR	EQU	WRKSPC+3H	; "USR (x)" jump
     143/      46 : =1D4BH              OUTSUB	EQU	WRKSPC+6H	; "OUT p,n"
     144/      46 : =1D4CH              OTPORT	EQU	WRKSPC+7H	; Port (p)
     145/      46 : =1D4EH              DIVSUP	EQU	WRKSPC+9H	; Division support routine
     146/      46 : =1D4FH              DIV1	EQU	WRKSPC+0AH	; <- Values
     147/      46 : =1D53H              DIV2	EQU	WRKSPC+0EH	; <- to
     148/      46 : =1D57H              DIV3	EQU	WRKSPC+12H	; <- be
     149/      46 : =1D5AH              DIV4	EQU	WRKSPC+15H	; <- inserted
     150/      46 : =1D5CH              SEED	EQU	WRKSPC+17H	; Random number seed
     151/      46 : =1D7FH              LSTRND	EQU	WRKSPC+3AH	; Last random number
     152/      46 : =1D83H              INPSUB	EQU	WRKSPC+3EH	; #INP (x)" Routine
     153/      46 : =1D84H              INPORT	EQU	WRKSPC+3FH	; PORT (x)
     154/      46 : =1D86H              NULLS	EQU	WRKSPC+41H	; Number of nulls
     155/      46 : =1D87H              LWIDTH	EQU	WRKSPC+42H	; Terminal width
     156/      46 : =1D88H              COMMAN	EQU	WRKSPC+43H	; Width for commas
     157/      46 : =1D89H              NULFLG	EQU	WRKSPC+44H	; Null after input byte flag
     158/      46 : =1D8AH              CTLOFG	EQU	WRKSPC+45H	; Control "O" flag
     159/      46 : =1D8BH              LINESC	EQU	WRKSPC+46H	; Lines counter
     160/      46 : =1D8DH              LINESN	EQU	WRKSPC+48H	; Lines number
     161/      46 : =1D8FH              CHKSUM	EQU	WRKSPC+4AH	; Array load/save check sum
     162/      46 : =1D91H              NMIFLG	EQU	WRKSPC+4CH	; Flag for NMI break routine
     163/      46 : =1D92H              BRKFLG	EQU	WRKSPC+4DH	; Break flag
     164/      46 : =1D93H              RINPUT	EQU	WRKSPC+4EH	; Input reflection
     165/      46 : =1D96H              POINT	EQU	WRKSPC+51H	; "POINT" reflection (unused)
     166/      46 : =1D99H              PSET	EQU	WRKSPC+54H	; "SET"	reflection
     167/      46 : =1D9CH              RESET	EQU	WRKSPC+57H	; "RESET" reflection
     168/      46 : =1D9FH              STRSPC	EQU	WRKSPC+5AH	; Bottom of string space
     169/      46 : =1DA1H              LINEAT	EQU	WRKSPC+5CH	; Current line number
     170/      46 : =1DA3H              BASTXT	EQU	WRKSPC+5EH	; Pointer to start of program
     171/      46 : =1DA6H              BUFFER	EQU	WRKSPC+61H	; Input buffer
     172/      46 : =1DABH              STACK	EQU	WRKSPC+66H	; Initial stack
     173/      46 : =1DF0H              CURPOS	EQU	WRKSPC+0ABH	; Character position on line
     174/      46 : =1DF1H              LCRFLG	EQU	WRKSPC+0ACH	; Locate/Create flag
     175/      46 : =1DF2H              TYPE	EQU	WRKSPC+0ADH	; Data type flag
     176/      46 : =1DF3H              DATFLG	EQU	WRKSPC+0AEH	; Literal statement flag
     177/      46 : =1DF4H              LSTRAM	EQU	WRKSPC+0AFH	; Last available RAM
     178/      46 : =1DF6H              TMSTPT	EQU	WRKSPC+0B1H	; Temporary string pointer
     179/      46 : =1DF8H              TMSTPL	EQU	WRKSPC+0B3H	; Temporary string pool
     180/      46 : =1E04H              TMPSTR	EQU	WRKSPC+0BFH	; Temporary string
     181/      46 : =1E08H              STRBOT	EQU	WRKSPC+0C3H	; Bottom of string space
     182/      46 : =1E0AH              CUROPR	EQU	WRKSPC+0C5H	; Current operator in EVAL
     183/      46 : =1E0CH              LOOPST	EQU	WRKSPC+0C7H	; First statement of loop
     184/      46 : =1E0EH              DATLIN	EQU	WRKSPC+0C9H	; Line of current DATA item
     185/      46 : =1E10H              FORFLG	EQU	WRKSPC+0CBH	; "FOR" loop flag
     186/      46 : =1E11H              LSTBIN	EQU	WRKSPC+0CCH	; Last byte entered
     187/      46 : =1E12H              READFG	EQU	WRKSPC+0CDH	; Read/Input flag
     188/      46 : =1E13H              BRKLIN	EQU	WRKSPC+0CEH	; Line of break
     189/      46 : =1E15H              NXTOPR	EQU	WRKSPC+0D0H	; Next operator in EVAL
     190/      46 : =1E17H              ERRLIN	EQU	WRKSPC+0D2H	; Line of error
     191/      46 : =1E19H              CONTAD	EQU	WRKSPC+0D4H	; Where to CONTinue
     192/      46 : =1E1BH              PROGND	EQU	WRKSPC+0D6H	; End of program
     193/      46 : =1E1DH              VAREND	EQU	WRKSPC+0D8H	; End of variables
     194/      46 : =1E1FH              ARREND	EQU	WRKSPC+0DAH	; End of arrays
     195/      46 : =1E21H              NXTDAT	EQU	WRKSPC+0DCH	; Next data item
     196/      46 : =1E23H              FNRGNM	EQU	WRKSPC+0DEH	; Name of FN argument
     197/      46 : =1E25H              FNARG	EQU	WRKSPC+0E0H	; FN argument value
     198/      46 : =1E29H              FPREG	EQU	WRKSPC+0E4H	; Floating point register
     199/      46 : =1E2CH              FPEXP	EQU	FPREG+3		; Floating point exponent
     200/      46 : =1E2DH              SGNRES	EQU	WRKSPC+0E8H	; Sign of result
     201/      46 : =1E2EH              PBUFF	EQU	WRKSPC+0E9H	; Number print buffer
     202/      46 : =1E3BH              MULVAL	EQU	WRKSPC+0F6H	; Multiplier
     203/      46 : =1E3EH              PROGST	EQU	WRKSPC+0F9H	; Start of program text area
     204/      46 : =1EA2H              STLOOK	EQU	WRKSPC+15DH	; Start of memory test
     205/      46 :                     ;
     206/      46 :                     ; BASIC ERROR CODE VALUES
     207/      46 :                     ;
     208/      46 : =0H                 NF	EQU	00H		; NEXT without FOR
     209/      46 : =2H                 SN	EQU	02H		; Syntax error
     210/      46 : =4H                 RG	EQU	04H		; RETURN without GOSUB
     211/      46 : =6H                 OD	EQU	06H		; Out of DATA
     212/      46 : =8H                 FC	EQU	08H		; Function call error
     213/      46 : =0AH                OV	EQU	0AH		; Overflow
     214/      46 : =0CH                OM	EQU	0CH		; Out of memory
     215/      46 : =0EH                UL	EQU	0EH		; Undefined line number
     216/      46 : =10H                BS	EQU	10H		; Bad subscript
     217/      46 : =12H                RD	EQU	12H		; Re-DIMensioned array
     218/      46 : =14H                DZ	EQU	14H		; Division by zero (/0)
     219/      46 : =16H                ID	EQU	16H		; Illegal direct
     220/      46 : =18H                TM	EQU	18H		; Type miss-match
     221/      46 : =1AH                OS	EQU	1AH		; Out of string space
     222/      46 : =1CH                LS	EQU	1CH		; String too long
     223/      46 : =1EH                ST	EQU	1EH		; String formula too complex
     224/      46 : =20H                CN	EQU	20H		; Can't CONTinue
     225/      46 : =22H                UF	EQU	22H		; UnDEFined FN function
     226/      46 : =24H                MO	EQU	24H		; Missing operand
     227/      46 : =26H                HX	EQU	26H		; HEX error
     228/      46 : =28H                BN	EQU	28H		; BIN error
     229/      46 :                     ;
     230/      46 : C3 4D 00            STARTB: JP	CSTART		; Jump to initialise
     231/      49 :                     ;
     232/      49 : EC 08               	DW	DEINT		; Get integer -32768 to 32767
     233/      4B : 62 10               	DW	ABPASS		; Return integer in AB
     234/      4D :                     ;
     235/      4D : 21 45 1D            CSTART: LD	HL,WRKSPC	; Start of workspace RAM
     236/      50 : F9                  	LD	SP,HL		; Set up a temporary stack
     237/      51 : C3 77 1C            	JP	INITST		; Go to initialise
     238/      54 :                     ;
     239/      54 : 11 15 03            INIT:	LD	DE,INITAB	; Initialise workspace
     240/      57 : 06 63               	LD	B,INITBE-INITAB+3; Bytes to copy
     241/      59 : 21 45 1D            	LD	HL,WRKSPC	; Into workspace RAM
     242/      5C : 1A                  COPY:	LD	A,(DE)		; Get source
     243/      5D : 77                  	LD	(HL),A		; To destination
     244/      5E : 23                  	INC	HL		; Next destination
     245/      5F : 13                  	INC	DE		; Next source
     246/      60 : 05                  	DEC	B		; Count bytes
     247/      61 : C2 5C 00            	JP	NZ,COPY		; More to move
     248/      64 : F9                  	LD	SP,HL		; Temporary stack
     249/      65 : CD 16 05            	CALL	CLREG		; Clear registers and stack
     250/      68 : CD E2 0A            	CALL	PRCRLF		; Output CRLF
     251/      6B : 32 EF 1D            	LD	(BUFFER+72+1),A	; Mark end of buffer
     252/      6E : 32 3E 1E            	LD	(PROGST),A	; Initialise program area
     253/      71 :                     ;MSIZE:	LD	HL,STLOOK	; Point to start of RAM
     254/      71 :                     ;MLOOP:	INC	HL		; Next byte
     255/      71 :                     ;	LD	A,H		; Above address FFFF ?
     256/      71 :                     ;	OR	L
     257/      71 :                     ;	JP	Z,SETTOP	; Yes - 64K RAM
     258/      71 :                     ;	LD	A,(HL)		; Get contents
     259/      71 :                     ;	LD	B,A		; Save it
     260/      71 :                     ;	CPL			; Flip all bits
     261/      71 :                     ;	LD	(HL),A		; Put it back
     262/      71 :                     ;	CP	(HL)		; RAM there if same
     263/      71 :                     ;	LD	(HL),B		; Restore old contents
     264/      71 :                     ;	JP	Z,MLOOP		; If RAM - test next byte
     265/      71 :                     ;
     266/      71 :                     ;SETTOP: DEC	HL		; Back one byte
     267/      71 : 21 C0 FE            	ld	hl,STACKU
     268/      74 : 11 A1 1E            	LD	DE,STLOOK-1	; See if enough RAM
     269/      77 : CD AC 06            	CALL	CPDEHL		; Compare DE with HL
     270/      7A : DA B4 00            	JP	C,NEMEM		; If not enough RAM
     271/      7D : 11 CE FF            	LD	DE,0-50		; 50 Bytes string space
     272/      80 : 22 F4 1D            	LD	(LSTRAM),HL	; Save last available RAM
     273/      83 : 19                  	ADD	HL,DE		; Allocate string space
     274/      84 : 22 9F 1D            	LD	(STRSPC),HL	; Save string space
     275/      87 : CD F1 04            	CALL	CLRPTR		; Clear program area
     276/      8A : 2A 9F 1D            	LD	HL,(STRSPC)	; Get end of memory
     277/      8D : 11 EF FF            	LD	DE,0-17		; Offset for free bytes
     278/      90 : 19                  	ADD	HL,DE		; Adjust HL
     279/      91 : 11 3E 1E            	LD	DE,PROGST	; Start of program text
     280/      94 : 7D                  	LD	A,L		; Get LSB
     281/      95 : 93                  	SUB	E		; Adjust it
     282/      96 : 6F                  	LD	L,A		; Re-save
     283/      97 : 7C                  	LD	A,H		; Get MSB
     284/      98 : 9A                  	SBC	A,D		; Adjust it
     285/      99 : 67                  	LD	H,A		; Re-save
     286/      9A : E5                  	PUSH	HL		; Save bytes free
     287/      9B : 21 CC 00            	LD	HL,SIGNON	; Sign-on message
     288/      9E : CD 80 11            	CALL	PRS		; Output string
     289/      A1 : E1                  	POP	HL		; Get bytes free back
     290/      A2 : CD 23 18            	CALL	PRNTHL		; Output amount of free memory
     291/      A5 : 21 BD 00            	LD	HL,BFREE	; " Bytes free" message
     292/      A8 : CD 80 11            	CALL	PRS		; Output string
     293/      AB :                     ;
     294/      AB : 31 AB 1D            WARMST: LD	SP,STACK	; Temporary stack
     295/      AE : CD 16 05            BRKRET: CALL	CLREG		; Clear registers and stack
     296/      B1 : C3 2F 04            	JP	PRNTOK		; Go to get command line
     297/      B4 :                     ;
     298/      B4 : 21 03 01            NEMEM:	LD	HL,MEMMSG	; Memory size not enough
     299/      B7 : CD 80 11            	CALL	PRS		; Print it
     300/      BA : C3 BA 00            XXXXX:	JP	XXXXX		; Stop
     301/      BD :                     ;
     302/      BD : 20 42 79 74 65 73   BFREE:	DB	" Bytes free",CR,LF,0,0
               C3 : 20 66 72 65 65 0D 
               C9 : 0A 00 00          
     303/      CC :                     ;
     304/      CC : 5A 38 30 20 42 41   SIGNON: DB	"Z80 BASIC Ver 4.7b",CR,LF
               D2 : 53 49 43 20 56 65 
               D8 : 72 20 34 2E 37 62 
               DE : 0D 0A             
     305/      E0 : 43 6F 70 79 72 69   	DB	"Copyright ",40,"C",41
               E6 : 67 68 74 20 28 43 
               EC : 29                
     306/      ED : 20 31 39 37 38 20   	DB	" 1978 by Microsoft",CR,LF,0,0
               F3 : 62 79 20 4D 69 63 
               F9 : 72 6F 73 6F 66 74 
               FF : 0D 0A 00 00       
     307/     103 :                     ;
     308/     103 : 4D 65 6D 6F 72 79   MEMMSG: DB	"Memory size not enough",CR,LF
              109 : 20 73 69 7A 65 20 
              10F : 6E 6F 74 20 65 6E 
              115 : 6F 75 67 68 0D 0A 
     309/     11B : 54 68 65 20 73 79   	DB	"The system is stopped.",CR,LF,0,0
              121 : 73 74 65 6D 20 69 
              127 : 73 20 73 74 6F 70 
              12D : 70 65 64 2E 0D 0A 
              133 : 00 00             
     310/     135 :                     ;
     311/     135 :                     ; FUNCTION ADDRESS TABLE
     312/     135 :                     ;
     313/     135 : 98 16               FNCTAB: DW	SGN
     314/     137 : 5C 17               	DW	INT
     315/     139 : AE 16               	DW	ABS
     316/     13B : 48 1D               	DW	USR
     317/     13D : 40 10               	DW	FRE
     318/     13F : C5 13               	DW	INP
     319/     141 : 6E 10               	DW	POS
     320/     143 : 22 19               	DW	SQR
     321/     145 : 01 1A               	DW	RND
     322/     147 : 3D 15               	DW	LOG
     323/     149 : 70 19               	DW	EXP
     324/     14B : 76 1A               	DW	COS
     325/     14D : 7C 1A               	DW	SIN
     326/     14F : DD 1A               	DW	TAN
     327/     151 : F2 1A               	DW	ATN
     328/     153 : 19 14               	DW	PEEK
     329/     155 : 5C 1B               	DW	DEEK
     330/     157 : 96 1D               	DW	POINT
     331/     159 : F2 12               	DW	LEN
     332/     15B : 0A 11               	DW	STR
     333/     15D : 8C 13               	DW	VAL
     334/     15F : 01 13               	DW	ASC
     335/     161 : 12 13               	DW	CHR
     336/     163 : 7E 1B               	DW	HEX
     337/     165 : 11 1C               	DW	BIN
     338/     167 : 22 13               	DW	LEFT
     339/     169 : 52 13               	DW	RIGHT
     340/     16B : 5C 13               	DW	MID
     341/     16D :                     ;
     342/     16D :                     ; RESERVED WORD LIST
     343/     16D :                     ;
     344/     16D : C5 4E 44            WORDS:	DB	0C5H,"ND"
     345/     170 : C6 4F 52            	DB	0C6H,"OR"
     346/     173 : CE 45 58 54         	DB	0CEH,"EXT"
     347/     177 : C4 41 54 41         	DB	0C4H,"ATA"
     348/     17B : C9 4E 50 55 54      	DB	0C9H,"NPUT"
     349/     180 : C4 49 4D            	DB	0C4H,"IM"
     350/     183 : D2 45 41 44         	DB	0D2H,"EAD"
     351/     187 : CC 45 54            	DB	0CCH,"ET"
     352/     18A : C7 4F 54 4F         	DB	0C7H,"OTO"
     353/     18E : D2 55 4E            	DB	0D2H,"UN"
     354/     191 : C9 46               	DB	0C9H,"F"
     355/     193 : D2 45 53 54 4F 52   	DB	0D2H,"ESTORE"
              199 : 45                
     356/     19A : C7 4F 53 55 42      	DB	0C7H,"OSUB"
     357/     19F : D2 45 54 55 52 4E   	DB	0D2H,"ETURN"
     358/     1A5 : D2 45 4D            	DB	0D2H,"EM"
     359/     1A8 : D3 54 4F 50         	DB	0D3H,"TOP"
     360/     1AC : CF 55 54            	DB	0CFH,"UT"
     361/     1AF : CF 4E               	DB	0CFH,"N"
     362/     1B1 : CE 55 4C 4C         	DB	0CEH,"ULL"
     363/     1B5 : D7 41 49 54         	DB	0D7H,"AIT"
     364/     1B9 : C4 45 46            	DB	0C4H,"EF"
     365/     1BC : D0 4F 4B 45         	DB	0D0H,"OKE"
     366/     1C0 : C4 4F 4B 45         	DB	0C4H,"OKE"
     367/     1C4 : D3 43 52 45 45 4E   	DB	0D3H,"CREEN"
     368/     1CA : CC 49 4E 45 53      	DB	0CCH,"INES"
     369/     1CF : C3 4C 53            	DB	0C3H,"LS"
     370/     1D2 : D7 49 44 54 48      	DB	0D7H,"IDTH"
     371/     1D7 : CD 4F 4E 49 54 4F   	DB	0CDH,"ONITOR"
              1DD : 52                
     372/     1DE : D3 45 54            	DB	0D3H,"ET"
     373/     1E1 : D2 45 53 45 54      	DB	0D2H,"ESET"
     374/     1E6 : D0 52 49 4E 54      	DB	0D0H,"RINT"
     375/     1EB : C3 4F 4E 54         	DB	0C3H,"ONT"
     376/     1EF : CC 49 53 54         	DB	0CCH,"IST"
     377/     1F3 : C3 4C 45 41 52      	DB	0C3H,"LEAR"
     378/     1F8 : C3 4C 4F 41 44      	DB	0C3H,"LOAD"
     379/     1FD : C3 53 41 56 45      	DB	0C3H,"SAVE"
     380/     202 : CE 45 57            	DB	0CEH,"EW"
     381/     205 :                     ;
     382/     205 : D4 41 42 28         	DB	0D4H,"AB("
     383/     209 : D4 4F               	DB	0D4H,"O"
     384/     20B : C6 4E               	DB	0C6H,"N"
     385/     20D : D3 50 43 28         	DB	0D3H,"PC("
     386/     211 : D4 48 45 4E         	DB	0D4H,"HEN"
     387/     215 : CE 4F 54            	DB	0CEH,"OT"
     388/     218 : D3 54 45 50         	DB	0D3H,"TEP"
     389/     21C :                     ;
     390/     21C : AB                  	DB	0ABH
     391/     21D : AD                  	DB	0ADH
     392/     21E : AA                  	DB	0AAH
     393/     21F : AF                  	DB	0AFH
     394/     220 : DE                  	DB	0DEH
     395/     221 : C1 4E 44            	DB	0C1H,"ND"
     396/     224 : CF 52               	DB	0CFH,"R"
     397/     226 : BE                  	DB	0BEH
     398/     227 : BD                  	DB	0BDH
     399/     228 : BC                  	DB	0BCH
     400/     229 :                     ;
     401/     229 : D3 47 4E            	DB	0D3H,"GN"
     402/     22C : C9 4E 54            	DB	0C9H,"NT"
     403/     22F : C1 42 53            	DB	0C1H,"BS"
     404/     232 : D5 53 52            	DB	0D5H,"SR"
     405/     235 : C6 52 45            	DB	0C6H,"RE"
     406/     238 : C9 4E 50            	DB	0C9H,"NP"
     407/     23B : D0 4F 53            	DB	0D0H,"OS"
     408/     23E : D3 51 52            	DB	0D3H,"QR"
     409/     241 : D2 4E 44            	DB	0D2H,"ND"
     410/     244 : CC 4F 47            	DB	0CCH,"OG"
     411/     247 : C5 58 50            	DB	0C5H,"XP"
     412/     24A : C3 4F 53            	DB	0C3H,"OS"
     413/     24D : D3 49 4E            	DB	0D3H,"IN"
     414/     250 : D4 41 4E            	DB	0D4H,"AN"
     415/     253 : C1 54 4E            	DB	0C1H,"TN"
     416/     256 : D0 45 45 4B         	DB	0D0H,"EEK"
     417/     25A : C4 45 45 4B         	DB	0C4H,"EEK"
     418/     25E : D0 4F 49 4E 54      	DB	0D0H,"OINT"
     419/     263 : CC 45 4E            	DB	0CCH,"EN"
     420/     266 : D3 54 52 24         	DB	0D3H,"TR$"
     421/     26A : D6 41 4C            	DB	0D6H,"AL"
     422/     26D : C1 53 43            	DB	0C1H,"SC"
     423/     270 : C3 48 52 24         	DB	0C3H,"HR$"
     424/     274 : C8 45 58 24         	DB	0C8H,"EX$"
     425/     278 : C2 49 4E 24         	DB	0C2H,"IN$"
     426/     27C : CC 45 46 54 24      	DB	0CCH,"EFT$"
     427/     281 : D2 49 47 48 54 24   	DB	0D2H,"IGHT$"
     428/     287 : CD 49 44 24         	DB	0CDH,"ID$"
     429/     28B : 80                  	DB	80H		; End of list marker
     430/     28C :                     ;
     431/     28C :                     ; KEYWORD ADDRESS TABLE
     432/     28C :                     ;
     433/     28C : 84 08               WORDTB: DW	PEND
     434/     28E : 81 07               	DW	FOR
     435/     290 : 5C 0C               	DW	NEXT
     436/     292 : D1 09               	DW	DATA
     437/     294 : 63 0B               	DW	INPUT
     438/     296 : 98 0E               	DW	DIM
     439/     298 : 92 0B               	DW	READ
     440/     29A : E8 09               	DW	LET
     441/     29C : 8E 09               	DW	GOTO
     442/     29E : 71 09               	DW	RUN
     443/     2A0 : 60 0A               	DW	IF_
     444/     2A2 : 4A 08               	DW	RESTOR
     445/     2A4 : 7D 09               	DW	GOSUB
     446/     2A6 : AC 09               	DW	RETURN
     447/     2A8 : D3 09               	DW	REM
     448/     2AA : 82 08               	DW	STOP
     449/     2AC : D1 13               	DW	POUT
     450/     2AE : 42 0A               	DW	ON
     451/     2B0 : C3 08               	DW	NULL
     452/     2B2 : D7 13               	DW	WAIT
     453/     2B4 : 76 10               	DW	DEF
     454/     2B6 : 20 14               	DW	POKE
     455/     2B8 : 67 1B               	DW	DOKE
     456/     2BA : D3 09               	DW	REM
     457/     2BC : 4D 1B               	DW	LINES
     458/     2BE : 41 1B               	DW	CLS
     459/     2C0 : 45 1B               	DW	WIDTH
     460/     2C2 : 73 1C               	DW	MONITR
     461/     2C4 : 99 1D               	DW	PSET
     462/     2C6 : 9C 1D               	DW	RESET
     463/     2C8 : 84 0A               	DW	PRINT
     464/     2CA : B0 08               	DW	CONT
     465/     2CC : F6 06               	DW	LIST
     466/     2CE : 2B 09               	DW	CLEAR
     467/     2D0 : D3 09               	DW	REM
     468/     2D2 : D3 09               	DW	REM
     469/     2D4 : F0 04               	DW	NEW
     470/     2D6 :                     ;
     471/     2D6 :                     ; RESERVED WORD TOKEN VALUES
     472/     2D6 :                     ;
     473/     2D6 : =80H                ZEND	EQU	080H		; END
     474/     2D6 : =81H                ZFOR	EQU	081H		; FOR
     475/     2D6 : =83H                ZDATA	EQU	083H		; DATA
     476/     2D6 : =88H                ZGOTO	EQU	088H		; GOTO
     477/     2D6 : =8CH                ZGOSUB	EQU	08CH		; GOSUB
     478/     2D6 : =8EH                ZREM	EQU	08EH		; REM
     479/     2D6 : =9EH                ZPRINT	EQU	09EH		; PRINT
     480/     2D6 : =0A4H               ZNEW	EQU	0A4H		; NEW
     481/     2D6 :                     ;
     482/     2D6 : =0A5H               ZTAB	EQU	0A5H		; TAB
     483/     2D6 : =0A6H               ZTO	EQU	0A6H		; TO
     484/     2D6 : =0A7H               ZFN	EQU	0A7H		; FN
     485/     2D6 : =0A8H               ZSPC	EQU	0A8H		; SPC
     486/     2D6 : =0A9H               ZTHEN	EQU	0A9H		; THEN
     487/     2D6 : =0AAH               ZNOT	EQU	0AAH		; NOT
     488/     2D6 : =0ABH               ZSTEP	EQU	0ABH		; STEP
     489/     2D6 :                     ;
     490/     2D6 : =0ACH               ZPLUS	EQU	0ACH		; +
     491/     2D6 : =0ADH               ZMINUS	EQU	0ADH		; -
     492/     2D6 : =0AEH               ZTIMES	EQU	0AEH		; *
     493/     2D6 : =0AFH               ZDIV	EQU	0AFH		; /
     494/     2D6 : =0B2H               ZOR	EQU	0B2H		; OR
     495/     2D6 : =0B3H               ZGTR	EQU	0B3H		; >
     496/     2D6 : =0B4H               ZEQUAL	EQU	0B4H		; M
     497/     2D6 : =0B5H               ZLTH	EQU	0B5H		; <
     498/     2D6 : =0B6H               ZSGN	EQU	0B6H		; SGN
     499/     2D6 : =0C7H               ZPOINT	EQU	0C7H		; POINT
     500/     2D6 : =0CFH               ZLEFT	EQU	0CDH +2		; LEFT$
     501/     2D6 :                     ;
     502/     2D6 :                     ; ARITHMETIC PRECEDENCE TABLE
     503/     2D6 :                     ;
     504/     2D6 : 79                  PRITAB: DB	79H		; Precedence value
     505/     2D7 : 0A 18               	DW	PADD		; FPREG = <last> + FPREG
     506/     2D9 :                     ;
     507/     2D9 : 79                  	DB	79H		; Precedence value
     508/     2DA : 3E 14               	DW	PSUB		; FPREG = <last> - FPREG
     509/     2DC :                     ;
     510/     2DC : 7C                  	DB	7CH		; Precedence value
     511/     2DD : 7C 15               	DW	MULT		; PPREG = <last> * FPREG
     512/     2DF :                     ;
     513/     2DF : 7C                  	DB	7CH		; Precedence value
     514/     2E0 : DD 15               	DW	DIV		; FPREG = <last> / FPREG
     515/     2E2 :                     ;
     516/     2E2 : 7F                  	DB	7FH		; Precedence value
     517/     2E3 : 2B 19               	DW	POWER		; FPREG = <last> ^ FPREG
     518/     2E5 :                     ;
     519/     2E5 : 50                  	DB	50H		; Precedence value
     520/     2E6 : F1 0D               	DW	PAND		; FPREG = <last> AND FPREG
     521/     2E8 :                     ;
     522/     2E8 : 46                  	DB	46H		; Precedence value
     523/     2E9 : F0 0D               	DW	POR		; FPREG = <last> OR FPREG
     524/     2EB :                     ;
     525/     2EB :                     ; BASIC ERROR CODE LIST
     526/     2EB :                     ;
     527/     2EB : 4E 46               ERRORS: DB	"NF"		; NEXT without FOR
     528/     2ED : 53 4E               	DB	"SN"		; Syntax error
     529/     2EF : 52 47               	DB	"RG"		; RETURN without GOSUB
     530/     2F1 : 4F 44               	DB	"OD"		; Out of DATA
     531/     2F3 : 46 43               	DB	"FC"		; Illegal function call
     532/     2F5 : 4F 56               	DB	"OV"		; Overflow error
     533/     2F7 : 4F 4D               	DB	"OM"		; Out of memory
     534/     2F9 : 55 4C               	DB	"UL"		; Undefined line
     535/     2FB : 42 53               	DB	"BS"		; Bad subscript
     536/     2FD : 44 44               	DB	"DD"		; Re-DIMensioned array
     537/     2FF : 2F 30               	DB	"/0"		; Division by zero
     538/     301 : 49 44               	DB	"ID"		; Illegal direct
     539/     303 : 54 4D               	DB	"TM"		; Type mis-match
     540/     305 : 4F 53               	DB	"OS"		; Out of string space
     541/     307 : 4C 53               	DB	"LS"		; String too long
     542/     309 : 53 54               	DB	"ST"		; String formula too complex
     543/     30B : 43 4E               	DB	"CN"		; Can't CONTinue
     544/     30D : 55 46               	DB	"UF"		; Undefined FN function
     545/     30F : 4D 4F               	DB	"MO"		; Missing operand
     546/     311 : 48 58               	DB	"HX"		; HEX error
     547/     313 : 42 4E               	DB	"BN"		; BIN error
     548/     315 :                     ;
     549/     315 :                     ; INITIALISATION TABLE -------------------------------------------------------
     550/     315 :                     ;
     551/     315 : C3 AB 00            INITAB: JP	WARMST		; Warm start jump
     552/     318 : C3 01 09            	JP	FCERR		; "USR (X)" jump (Set to Error)
     553/     31B : D3 00               	OUT	(0),A		; "OUT p,n" skeleton
     554/     31D : C9                  	RET
     555/     31E : D6 00               	SUB	0		; Division support routine
     556/     320 : 6F                  	LD	L,A
     557/     321 : 7C                  	LD	A,H
     558/     322 : DE 00               	SBC	A,0
     559/     324 : 67                  	LD	H,A
     560/     325 : 78                  	LD	A,B
     561/     326 : DE 00               	SBC	A,0
     562/     328 : 47                  	LD	B,A
     563/     329 : 3E 00               	LD	A,0
     564/     32B : C9                  	RET
     565/     32C : 00 00 00            	DB	0,0,0			; Random number seed table used by RND
     566/     32F : 35 4A CA 99         	DB	035H,04AH,0CAH,099H	;-2.65145E+07
     567/     333 : 39 1C 76 98         	DB	039H,01CH,076H,098H	; 1.61291E+07
     568/     337 : 22 95 B3 98         	DB	022H,095H,0B3H,098H	;-1.17691E+07
     569/     33B : 0A DD 47 98         	DB	00AH,0DDH,047H,098H	; 1.30983E+07
     570/     33F : 53 D1 99 99         	DB	053H,0D1H,099H,099H	;-2-01612E+07
     571/     343 : 0A 1A 9F 98         	DB	00AH,01AH,09FH,098H	;-1.04269E+07
     572/     347 : 65 BC CD 98         	DB	065H,0BCH,0CDH,098H	;-1.34831E+07
     573/     34B : D6 77 3E 98         	DB	0D6H,077H,03EH,098H	; 1.24825E+07
     574/     34F : 52 C7 4F 80         	DB	052H,0C7H,04FH,080H	; Last random number
     575/     353 : DB 00               	IN	A,(0)		; INP (x) skeleton
     576/     355 : C9                  	RET
     577/     356 : 01                  	DB	1		; POS (x) number (1)
     578/     357 : FF                  	DB	255		; Terminal width (255 = no auto CRLF)
     579/     358 : 1C                  	DB	28		; Width for commas (3 columns)
     580/     359 : 00                  	DB	0		; No nulls after input bytes
     581/     35A : 00                  	DB	0		; Output enabled (^O off)
     582/     35B : 14 00               	DW	20		; Initial lines counter
     583/     35D : 14 00               	DW	20		; Initial lines number
     584/     35F : 00 00               	DW	0		; Array load/save check sum
     585/     361 : 00                  	DB	0		; Break not by NMI
     586/     362 : 00                  	DB	0		; Break flag
     587/     363 : C3 29 06            	JP	TTYLIN		; Input reflection (set to TTY)
     588/     366 : C3 00 00            	JP	0000H		; POINT reflection unused
     589/     369 : C3 00 00            	JP	0000H		; SET reflection
     590/     36C : C3 00 00            	JP	0000H			; RESET reflection
     591/     36F : A2 1E               	DW	STLOOK		; Temp string space
     592/     371 : FE FF               	DW	-2		; Current line number (cold)
     593/     373 : 3F 1E               	DW	PROGST+1	; Start of program text
     594/     375 :                     INITBE:			 
     595/     375 :                     ;
     596/     375 :                     ; END OF INITIALISATION TABLE ---------------------------------------------------
     597/     375 :                     ;
     598/     375 : 20 45 72 72 6F 72   ERRMSG: DB	" Error",0
              37B : 00                
     599/     37C : 20 69 6E 20 00      INMSG:	DB	" in ",0
     600/     381 : =380H               ZERBYT	EQU	$-1		; A zero byte
     601/     381 : 4F 6B 0D 0A 00 00   OKMSG:	DB	"Ok",CR,LF,0,0
     602/     387 : 42 72 65 61 6B 00   BRKMSG: DB	"Break",0
     603/     38D :                     ;
     604/     38D : 21 04 00            BAKSTK: LD	HL,4		; Look for "FOR" block with
     605/     390 : 39                  	ADD	HL,SP		; same index as specified
     606/     391 : 7E                  LOKFOR: LD	A,(HL)		; Get block ID
     607/     392 : 23                  	INC	HL		; Point to index address
     608/     393 : FE 81               	CP	ZFOR		; Is it a "FOR" token
     609/     395 : C0                  	RET	NZ		; No - exit
     610/     396 : 4E                  	LD	C,(HL)		; BC = Address of "FOR" index
     611/     397 : 23                  	INC	HL
     612/     398 : 46                  	LD	B,(HL)
     613/     399 : 23                  	INC	HL		; Point to sign of STEP
     614/     39A : E5                  	PUSH	HL		; Save pointer to sign
     615/     39B : 69                  	LD	L,C		; HL = address of "FOR" index
     616/     39C : 60                  	LD	H,B
     617/     39D : 7A                  	LD	A,D		; See if an index was specified
     618/     39E : B3                  	OR	E		; DE = 0 if no index specified
     619/     39F : EB                  	EX	DE,HL		; Specified index into HL
     620/     3A0 : CA A7 03            	JP	Z,INDFND	; Skip if no index given
     621/     3A3 : EB                  	EX	DE,HL		; Index back into DE
     622/     3A4 : CD AC 06            	CALL	CPDEHL		; Compare index with one given
     623/     3A7 : 01 0D 00            INDFND: LD	BC,16-3		; Offset to next block
     624/     3AA : E1                  	POP	HL		; Restore pointer to sign
     625/     3AB : C8                  	RET	Z		; Return if block found
     626/     3AC : 09                  	ADD	HL,BC		; Point to next block
     627/     3AD : C3 91 03            	JP	LOKFOR		; Keep on looking
     628/     3B0 :                     ;
     629/     3B0 : CD CA 03            MOVUP:	CALL	ENFMEM		; See if enough memory
     630/     3B3 : C5                  MOVSTR: PUSH	BC		; Save end of source
     631/     3B4 : E3                  	EX	(SP),HL		; Swap source and dest" end
     632/     3B5 : C1                  	POP	BC		; Get end of destination
     633/     3B6 : CD AC 06            MOVLP:	CALL	CPDEHL		; See if list moved
     634/     3B9 : 7E                  	LD	A,(HL)		; Get byte
     635/     3BA : 02                  	LD	(BC),A		; Move it
     636/     3BB : C8                  	RET	Z		; Exit if all done
     637/     3BC : 0B                  	DEC	BC		; Next byte to move to
     638/     3BD : 2B                  	DEC	HL		; Next byte to move
     639/     3BE : C3 B6 03            	JP	MOVLP		; Loop until all bytes moved
     640/     3C1 :                     ;
     641/     3C1 : E5                  CHKSTK: PUSH	HL		; Save code string address
     642/     3C2 : 2A 1F 1E            	LD	HL,(ARREND)	; Lowest free memory
     643/     3C5 : 06 00               	LD	B,0		; BC = Number of levels to test
     644/     3C7 : 09                  	ADD	HL,BC		; 2 Bytes for each level
     645/     3C8 : 09                  	ADD	HL,BC
     646/     3C9 : 3E                  	DB	3EH		; Skip "PUSH HL"
     647/     3CA : E5                  ENFMEM: PUSH	HL		; Save code string address
     648/     3CB : 3E D0               	LD	A,0D0H		; LOW -48; 48 Bytes minimum RAM
     649/     3CD : 95                  	SUB	L
     650/     3CE : 6F                  	LD	L,A
     651/     3CF : 3E FF               	LD	A,0FFH		; HIGH (-48); 48 Bytes minimum RAM
     652/     3D1 : 9C                  	SBC	A,H
     653/     3D2 : DA D9 03            	JP	C,OMERR		; Not enough - ?OM Error
     654/     3D5 : 67                  	LD	H,A
     655/     3D6 : 39                  	ADD	HL,SP		; Test if stack is overflowed
     656/     3D7 : E1                  	POP	HL		; Restore code string address
     657/     3D8 : D8                  	RET	C		; Return if enough mmory
     658/     3D9 : 1E 0C               OMERR:	LD	E,OM		; ?OM Error
     659/     3DB : C3 F8 03            	JP	ERROR_
     660/     3DE :                     ;
     661/     3DE : 2A 0E 1E            DATSNR: LD	HL,(DATLIN)	; Get line of current DATA item
     662/     3E1 : 22 A1 1D            	LD	(LINEAT),HL	; Save as current line
     663/     3E4 : 1E 02               SNERR:	LD	E,SN		; ?SN Error
     664/     3E6 : 01                  	DB	01H		; Skip "LD E,DZ"
     665/     3E7 : 1E 14               DZERR:	LD	E,DZ		; ?/0 Error
     666/     3E9 : 01                  	DB	01H		; Skip "LD E,NF"
     667/     3EA : 1E 00               NFERR:	LD	E,NF		; ?NF Error
     668/     3EC : 01                  	DB	01H		; Skip "LD E,RD"
     669/     3ED : 1E 12               DDERR:	LD	E,RD		; ?DD Error
     670/     3EF : 01                  	DB	01H		; Skip "LD E,UF"
     671/     3F0 : 1E 22               UFERR:	LD	E,UF		; ?UF Error
     672/     3F2 : 01                  	DB	01H		; Skip "LD E,OV
     673/     3F3 : 1E 0A               OVERR:	LD	E,OV		; ?OV Error
     674/     3F5 : 01                  	DB	01H		; Skip "LD E,TM"
     675/     3F6 : 1E 18               TMERR:	LD	E,TM		; ?TM Error
     676/     3F8 :                     ;
     677/     3F8 : CD 16 05            ERROR_:	CALL	CLREG		; Clear registers and stack
     678/     3FB : 32 8A 1D            	LD	(CTLOFG),A	; Enable output (A is 0)
     679/     3FE : CD D5 0A            	CALL	STTLIN		; Start new line
     680/     401 : 21 EB 02            	LD	HL,ERRORS	; Point to error codes
     681/     404 : 57                  	LD	D,A		; D = 0 (A is 0)
     682/     405 : 3E 3F               	LD	A,'?'
     683/     407 : CD BD 06            	CALL	OUTC		; Output '?'
     684/     40A : 19                  	ADD	HL,DE		; Offset to correct error code
     685/     40B : 7E                  	LD	A,(HL)		; First character
     686/     40C : CD BD 06            	CALL	OUTC		; Output it
     687/     40F : CD 3A 08            	CALL	GETCHR		; Get next character
     688/     412 : CD BD 06            	CALL	OUTC		; Output it
     689/     415 : 21 75 03            	LD	HL,ERRMSG	; "Error" message
     690/     418 : CD 80 11            ERRIN:	CALL	PRS		; Output message
     691/     41B : 2A A1 1D            	LD	HL,(LINEAT)	; Get line of error
     692/     41E : 11 FE FF            	LD	DE,-2		; Cold start error if -2
     693/     421 : CD AC 06            	CALL	CPDEHL		; See if cold start error
     694/     424 : CA 4D 00            	JP	Z,CSTART	; Cold start error - Restart
     695/     427 : 7C                  	LD	A,H		; Was it a direct error?
     696/     428 : A5                  	AND	L		; Line = -1 if direct error
     697/     429 : 3C                  	INC	A
     698/     42A : C4 1B 18            	CALL	NZ,LINEIN	; No - output line of error
     699/     42D : 3E                  	DB	3EH		; Skip "POP BC"
     700/     42E : C1                  POPNOK: POP	BC		; Drop address in input buffer
     701/     42F :                     ;
     702/     42F : AF                  PRNTOK: XOR	A		; Output "Ok" and get command
     703/     430 : 32 8A 1D            	LD	(CTLOFG),A	; Enable output
     704/     433 : CD D5 0A            	CALL	STTLIN		; Start new line
     705/     436 : 21 81 03            	LD	HL,OKMSG	; "Ok" message
     706/     439 : CD 80 11            	CALL	PRS		; Output "Ok"
     707/     43C : 21 FF FF            GETCMD: LD	HL,-1		; Flag direct mode
     708/     43F : 22 A1 1D            	LD	(LINEAT),HL	; Save as current line
     709/     442 : CD 29 06            	CALL	GETLIN		; Get an input line
     710/     445 : DA 3C 04            	JP	C,GETCMD	; Get line again if break
     711/     448 : CD 3A 08            	CALL	GETCHR		; Get first character
     712/     44B : 3C                  	INC	A		; Test if end of line
     713/     44C : 3D                  	DEC	A		; Without affecting Carry
     714/     44D : CA 3C 04            	JP	Z,GETCMD	; Nothing entered - Get another
     715/     450 : F5                  	PUSH	AF		; Save Carry status
     716/     451 : CD 06 09            	CALL	ATOH		; Get line number into DE
     717/     454 : D5                  	PUSH	DE		; Save line number
     718/     455 : CD 40 05            	CALL	CRUNCH		; Tokenise rest of line
     719/     458 : 47                  	LD	B,A		; Length of tokenised line
     720/     459 : D1                  	POP	DE		; Restore line number
     721/     45A : F1                  	POP	AF		; Restore Carry
     722/     45B : D2 1A 08            	JP	NC,EXCUTE	; No line number - Direct mode
     723/     45E : D5                  	PUSH	DE		; Save line number
     724/     45F : C5                  	PUSH	BC		; Save length of tokenised line
     725/     460 : AF                  	XOR	A
     726/     461 : 32 11 1E            	LD	(LSTBIN),A	; Clear last byte input
     727/     464 : CD 3A 08            	CALL	GETCHR		; Get next character
     728/     467 : B7                  	OR	A		; Set flags
     729/     468 : F5                  	PUSH	AF		; And save them
     730/     469 : CD D0 04            	CALL	SRCHLN		; Search for line number in DE
     731/     46C : DA 75 04            	JP	C,LINFND	; Jump if line found
     732/     46F : F1                  	POP	AF		; Get status
     733/     470 : F5                  	PUSH	AF		; And re-save
     734/     471 : CA A7 09            	JP	Z,ULERR	; Nothing after number - Error
     735/     474 : B7                  	OR	A		; Clear Carry
     736/     475 : C5                  LINFND: PUSH	BC		; Save address of line in prog
     737/     476 : D2 8C 04            	JP	NC,INEWLN	; Line not found - Insert new
     738/     479 : EB                  	EX	DE,HL		; Next line address in DE
     739/     47A : 2A 1B 1E            	LD	HL,(PROGND)	; End of program
     740/     47D : 1A                  SFTPRG: LD	A,(DE)		; Shift rest of program down
     741/     47E : 02                  	LD	(BC),A
     742/     47F : 03                  	INC	BC		; Next destination
     743/     480 : 13                  	INC	DE		; Next source
     744/     481 : CD AC 06            	CALL	CPDEHL		; All done?
     745/     484 : C2 7D 04            	JP	NZ,SFTPRG	; More to do
     746/     487 : 60                  	LD	H,B		; HL - New end of program
     747/     488 : 69                  	LD	L,C
     748/     489 : 22 1B 1E            	LD	(PROGND),HL	; Update end of program
     749/     48C :                     ;
     750/     48C : D1                  INEWLN: POP	DE		; Get address of line,
     751/     48D : F1                  	POP	AF		; Get status
     752/     48E : CA B3 04            	JP	Z,SETPTR	; No text - Set up pointers
     753/     491 : 2A 1B 1E            	LD	HL,(PROGND)	; Get end of program
     754/     494 : E3                  	EX	(SP),HL		; Get length of input line
     755/     495 : C1                  	POP	BC		; End of program to BC
     756/     496 : 09                  	ADD	HL,BC		; Find new end
     757/     497 : E5                  	PUSH	HL		; Save new end
     758/     498 : CD B0 03            	CALL	MOVUP		; Make space for line
     759/     49B : E1                  	POP	HL		; Restore new end
     760/     49C : 22 1B 1E            	LD	(PROGND),HL	; Update end of program pointer
     761/     49F : EB                  	EX	DE,HL		; Get line to move up in HL
     762/     4A0 : 74                  	LD	(HL),H		; Save MSB
     763/     4A1 : D1                  	POP	DE		; Get new line number
     764/     4A2 : 23                  	INC	HL		; Skip pointer
     765/     4A3 : 23                  	INC	HL
     766/     4A4 : 73                  	LD	(HL),E		; Save LSB of line number
     767/     4A5 : 23                  	INC	HL
     768/     4A6 : 72                  	LD	(HL),D		; Save MSB of line number
     769/     4A7 : 23                  	INC	HL		; To first byte in line
     770/     4A8 : 11 A6 1D            	LD	DE,BUFFER	; Copy buffer to program
     771/     4AB : 1A                  MOVBUF: LD	A,(DE)		; Get source
     772/     4AC : 77                  	LD	(HL),A		; Save destinations
     773/     4AD : 23                  	INC	HL		; Next source
     774/     4AE : 13                  	INC	DE		; Next destination
     775/     4AF : B7                  	OR	A		; Done?
     776/     4B0 : C2 AB 04            	JP	NZ,MOVBUF	; No - Repeat
     777/     4B3 : CD FC 04            SETPTR: CALL	RUNFST		; Set line pointers
     778/     4B6 : 23                  	INC	HL		; To LSB of pointer
     779/     4B7 : EB                  	EX	DE,HL		; Address to DE
     780/     4B8 : 62                  PTRLP:	LD	H,D		; Address to HL
     781/     4B9 : 6B                  	LD	L,E
     782/     4BA : 7E                  	LD	A,(HL)		; Get LSB of pointer
     783/     4BB : 23                  	INC	HL		; To MSB of pointer
     784/     4BC : B6                  	OR	(HL)		; Compare with MSB pointer
     785/     4BD : CA 3C 04            	JP	Z,GETCMD	; Get command line if end
     786/     4C0 : 23                  	INC	HL		; To LSB of line number
     787/     4C1 : 23                  	INC	HL		; Skip line number
     788/     4C2 : 23                  	INC	HL		; Point to first byte in line
     789/     4C3 : AF                  	XOR	A		; Looking for 00 byte
     790/     4C4 : BE                  FNDEND: CP	(HL)		; Found end of line?
     791/     4C5 : 23                  	INC	HL		; Move to next byte
     792/     4C6 : C2 C4 04            	JP	NZ,FNDEND	; No - Keep looking
     793/     4C9 : EB                  	EX	DE,HL		; Next line address to HL
     794/     4CA : 73                  	LD	(HL),E		; Save LSB of pointer
     795/     4CB : 23                  	INC	HL
     796/     4CC : 72                  	LD	(HL),D		; Save MSB of pointer
     797/     4CD : C3 B8 04            	JP	PTRLP		; Do next line
     798/     4D0 :                     ;
     799/     4D0 : 2A A3 1D            SRCHLN: LD	HL,(BASTXT)	; Start of program text
     800/     4D3 : 44                  SRCHLP: LD	B,H		; BC = Address to look at
     801/     4D4 : 4D                  	LD	C,L
     802/     4D5 : 7E                  	LD	A,(HL)		; Get address of next line
     803/     4D6 : 23                  	INC	HL
     804/     4D7 : B6                  	OR	(HL)		; End of program found?
     805/     4D8 : 2B                  	DEC	HL
     806/     4D9 : C8                  	RET	Z		; Yes - Line not found
     807/     4DA : 23                  	INC	HL
     808/     4DB : 23                  	INC	HL
     809/     4DC : 7E                  	LD	A,(HL)		; Get LSB of line number
     810/     4DD : 23                  	INC	HL
     811/     4DE : 66                  	LD	H,(HL)		; Get MSB of line number
     812/     4DF : 6F                  	LD	L,A
     813/     4E0 : CD AC 06            	CALL	CPDEHL		; Compare with line in DE
     814/     4E3 : 60                  	LD	H,B		; HL = Start of this line
     815/     4E4 : 69                  	LD	L,C
     816/     4E5 : 7E                  	LD	A,(HL)		; Get LSB of next line address
     817/     4E6 : 23                  	INC	HL
     818/     4E7 : 66                  	LD	H,(HL)		; Get MSB of next line address
     819/     4E8 : 6F                  	LD	L,A		; Next line to HL
     820/     4E9 : 3F                  	CCF
     821/     4EA : C8                  	RET	Z		; Lines found - Exit
     822/     4EB : 3F                  	CCF
     823/     4EC : D0                  	RET	NC		; Line not found,at line after
     824/     4ED : C3 D3 04            	JP	SRCHLP		; Keep looking
     825/     4F0 :                     ;
     826/     4F0 : C0                  NEW:	RET	NZ		; Return if any more on line
     827/     4F1 : 2A A3 1D            CLRPTR: LD	HL,(BASTXT)	; Point to start of program
     828/     4F4 : AF                  	XOR	A		; Set program area to empty
     829/     4F5 : 77                  	LD	(HL),A		; Save LSB = 00
     830/     4F6 : 23                  	INC	HL
     831/     4F7 : 77                  	LD	(HL),A		; Save MSB = 00
     832/     4F8 : 23                  	INC	HL
     833/     4F9 : 22 1B 1E            	LD	(PROGND),HL	; Set program end
     834/     4FC :                     ;
     835/     4FC : 2A A3 1D            RUNFST: LD	HL,(BASTXT)	; Clear all variables
     836/     4FF : 2B                  	DEC	HL
     837/     500 :                     ;
     838/     500 : 22 13 1E            INTVAR: LD	(BRKLIN),HL	; Initialise RUN variables
     839/     503 : 2A F4 1D            	LD	HL,(LSTRAM)	; Get end of RAM
     840/     506 : 22 08 1E            	LD	(STRBOT),HL	; Clear string space
     841/     509 : AF                  	XOR	A
     842/     50A : CD 4A 08            	CALL	RESTOR		; Reset DATA pointers
     843/     50D : 2A 1B 1E            	LD	HL,(PROGND)	; Get end of program
     844/     510 : 22 1D 1E            	LD	(VAREND),HL	; Clear variables
     845/     513 : 22 1F 1E            	LD	(ARREND),HL	; Clear arrays
     846/     516 :                     ;
     847/     516 : C1                  CLREG:	POP	BC		; Save return address
     848/     517 : 2A 9F 1D            	LD	HL,(STRSPC)	; Get end of working RAN
     849/     51A : F9                  	LD	SP,HL		; Set stack
     850/     51B : 21 F8 1D            	LD	HL,TMSTPL	; Temporary string pool
     851/     51E : 22 F6 1D            	LD	(TMSTPT),HL	; Reset temporary string ptr
     852/     521 : AF                  	XOR	A		; A = 00
     853/     522 : 6F                  	LD	L,A		; HL = 0000
     854/     523 : 67                  	LD	H,A
     855/     524 : 22 19 1E            	LD	(CONTAD),HL	; No CONTinue
     856/     527 : 32 10 1E            	LD	(FORFLG),A	; Clear FOR flag
     857/     52A : 22 23 1E            	LD	(FNRGNM),HL	; Clear FN argument
     858/     52D : E5                  	PUSH	HL		; HL = 0000
     859/     52E : C5                  	PUSH	BC		; Put back return
     860/     52F : 2A 13 1E            DOAGN:	LD	HL,(BRKLIN)	; Get address of code to RUN
     861/     532 : C9                  	RET			; Return to execution driver
     862/     533 :                     ;
     863/     533 : 3E 3F               PROMPT: LD	A,'?'		; '?'
     864/     535 : CD BD 06            	CALL	OUTC		; Output character
     865/     538 : 3E 20               	LD	A,' '		; Space
     866/     53A : CD BD 06            	CALL	OUTC		; Output character
     867/     53D : C3 93 1D            	JP	RINPUT		; Get input line
     868/     540 :                     ;
     869/     540 : AF                  CRUNCH: XOR	A		; Tokenise line @ HL to BUFFER
     870/     541 : 32 F3 1D            	LD	(DATFLG),A	; Reset literal flag
     871/     544 : 0E 05               	LD	C,2+3		; 2 byte number and 3 nulls
     872/     546 : 11 A6 1D            	LD	DE,BUFFER	; Start of input buffer
     873/     549 : 7E                  CRNCLP: LD	A,(HL)		; Get byte
     874/     54A : FE 20               	CP	' '		; Is it a space?
     875/     54C : CA C8 05            	JP	Z,MOVDIR	; Yes - Copy direct
     876/     54F : 47                  	LD	B,A		; Save character
     877/     550 : FE 22               	CP	'"'		; Is it a quote?
     878/     552 : CA E8 05            	JP	Z,CPYLIT	; Yes - Copy literal string
     879/     555 : B7                  	OR	A		; Is it end of buffer?
     880/     556 : CA EF 05            	JP	Z,ENDBUF	; Yes - End buffer
     881/     559 : 3A F3 1D            	LD	A,(DATFLG)	; Get data type
     882/     55C : B7                  	OR	A		; Literal?
     883/     55D : 7E                  	LD	A,(HL)		; Get byte to copy
     884/     55E : C2 C8 05            	JP	NZ,MOVDIR	; Literal - Copy direct
     885/     561 : FE 3F               	CP	'?'		; Is it '?' short for PRINT
     886/     563 : 3E 9E               	LD	A,ZPRINT	; "PRINT" token
     887/     565 : CA C8 05            	JP	Z,MOVDIR	; Yes - replace it
     888/     568 : 7E                  	LD	A,(HL)		; Get byte again
     889/     569 : FE 30               	CP	'0'		; Is it less than '0'
     890/     56B : DA 73 05            	JP	C,FNDWRD	; Yes - Look for reserved words
     891/     56E : FE 3C               	CP	60		; ";"+1; Is it "0123456789:;" ?
     892/     570 : DA C8 05            	JP	C,MOVDIR	; Yes - copy it direct
     893/     573 : D5                  FNDWRD: PUSH	DE		; Look for reserved words
     894/     574 : 11 6C 01            	LD	DE,WORDS-1	; Point to table
     895/     577 : C5                  	PUSH	BC		; Save count
     896/     578 : 01 C4 05            	LD	BC,RETNAD	; Where to return to
     897/     57B : C5                  	PUSH	BC		; Save return address
     898/     57C : 06 7F               	LD	B,ZEND-1	; First token value -1
     899/     57E : 7E                  	LD	A,(HL)		; Get byte
     900/     57F : FE 61               	CP	'a'		; Less than 'a' ?
     901/     581 : DA 8C 05            	JP	C,SEARCH	; Yes - search for words
     902/     584 : FE 7B               	CP	'z'+1		; Greater than 'z' ?
     903/     586 : D2 8C 05            	JP	NC,SEARCH	; Yes - search for words
     904/     589 : E6 5F               	AND	01011111B	; Force upper case
     905/     58B : 77                  	LD	(HL),A		; Replace byte
     906/     58C : 4E                  SEARCH: LD	C,(HL)		; Search for a word
     907/     58D : EB                  	EX	DE,HL
     908/     58E : 23                  GETNXT: INC	HL		; Get next reserved word
     909/     58F : B6                  	OR	(HL)		; Start of word?
     910/     590 : F2 8E 05            	JP	P,GETNXT	; No - move on
     911/     593 : 04                  	INC	B		; Increment token value
     912/     594 : 7E                  	LD	A, (HL)		; Get byte from table
     913/     595 : E6 7F               	AND	01111111B	; Strip bit 7
     914/     597 : C8                  	RET	Z		; Return if end of list
     915/     598 : B9                  	CP	C		; Same character as in buffer?
     916/     599 : C2 8E 05            	JP	NZ,GETNXT	; No - get next word
     917/     59C : EB                  	EX	DE,HL
     918/     59D : E5                  	PUSH	HL		; Save start of word
     919/     59E :                     ;
     920/     59E : 13                  NXTBYT: INC	DE		; Look through rest of word
     921/     59F : 1A                  	LD	A,(DE)		; Get byte from table
     922/     5A0 : B7                  	OR	A		; End of word ?
     923/     5A1 : FA C0 05            	JP	M,MATCH		; Yes - Match found
     924/     5A4 : 4F                  	LD	C,A		; Save it
     925/     5A5 : 78                  	LD	A,B		; Get token value
     926/     5A6 : FE 88               	CP	ZGOTO		; Is it "GOTO" token ?
     927/     5A8 : C2 AF 05            	JP	NZ,NOSPC	; No - Don't allow spaces
     928/     5AB : CD 3A 08            	CALL	GETCHR		; Get next character
     929/     5AE : 2B                  	DEC	HL		; Cancel increment from GETCHR
     930/     5AF : 23                  NOSPC:	INC	HL		; Next byte
     931/     5B0 : 7E                  	LD	A,(HL)		; Get byte
     932/     5B1 : FE 61               	CP	'a'		; Less than 'a' ?
     933/     5B3 : DA B8 05            	JP	C,NOCHNG	; Yes - don't change
     934/     5B6 : E6 5F               	AND	01011111B	; Make upper case
     935/     5B8 : B9                  NOCHNG: CP	C		; Same as in buffer ?
     936/     5B9 : CA 9E 05            	JP	Z,NXTBYT	; Yes - keep testing
     937/     5BC : E1                  	POP	HL		; Get back start of word
     938/     5BD : C3 8C 05            	JP	SEARCH		; Look at next word
     939/     5C0 :                     ;
     940/     5C0 : 48                  MATCH:	LD	C,B		; Word found - Save token value
     941/     5C1 : F1                  	POP	AF		; Throw away return
     942/     5C2 : EB                  	EX	DE,HL
     943/     5C3 : C9                  	RET			; Return to "RETNAD"
     944/     5C4 : EB                  RETNAD: EX	DE,HL		; Get address in string
     945/     5C5 : 79                  	LD	A,C		; Get token value
     946/     5C6 : C1                  	POP	BC		; Restore buffer length
     947/     5C7 : D1                  	POP	DE		; Get destination address
     948/     5C8 : 23                  MOVDIR: INC	HL		; Next source in buffer
     949/     5C9 : 12                  	LD	(DE),A		; Put byte in buffer
     950/     5CA : 13                  	INC	DE		; Move up buffer
     951/     5CB : 0C                  	INC	C		; Increment length of buffer
     952/     5CC : D6 3A               	SUB	':'		; End of statement?
     953/     5CE : CA D6 05            	JP	Z,SETLIT	; Jump if multi-statement line
     954/     5D1 : FE 49               	CP	ZDATA-3AH	; Is it DATA statement ?
     955/     5D3 : C2 D9 05            	JP	NZ,TSTREM	; No - see if REM
     956/     5D6 : 32 F3 1D            SETLIT: LD	(DATFLG),A	; Set literal flag
     957/     5D9 : D6 54               TSTREM: SUB	ZREM-3AH	; Is it REM?
     958/     5DB : C2 49 05            	JP	NZ,CRNCLP	; No - Leave flag
     959/     5DE : 47                  	LD	B,A		; Copy rest of buffer
     960/     5DF : 7E                  NXTCHR: LD	A,(HL)		; Get byte
     961/     5E0 : B7                  	OR	A		; End of line ?
     962/     5E1 : CA EF 05            	JP	Z,ENDBUF	; Yes - Terminate buffer
     963/     5E4 : B8                  	CP	B		; End of statement ?
     964/     5E5 : CA C8 05            	JP	Z,MOVDIR	; Yes - Get next one
     965/     5E8 : 23                  CPYLIT: INC	HL		; Move up source string
     966/     5E9 : 12                  	LD	(DE),A		; Save in destination
     967/     5EA : 0C                  	INC	C		; Increment length
     968/     5EB : 13                  	INC	DE		; Move up destination
     969/     5EC : C3 DF 05            	JP	NXTCHR		; Repeat
     970/     5EF :                     ;
     971/     5EF : 21 A5 1D            ENDBUF: LD	HL,BUFFER-1	; Point to start of buffer
     972/     5F2 : 12                  	LD	(DE),A		; Mark end of buffer (A = 00)
     973/     5F3 : 13                  	INC	DE
     974/     5F4 : 12                  	LD	(DE),A		; A = 00
     975/     5F5 : 13                  	INC	DE
     976/     5F6 : 12                  	LD	(DE),A		; A = 00
     977/     5F7 : C9                  	RET
     978/     5F8 :                     ;
     979/     5F8 : 3A 89 1D            DODEL:	LD	A,(NULFLG)	; Get null flag status
     980/     5FB : B7                  	OR	A		; Is it zero?
     981/     5FC : 3E 00               	LD	A,0		; Zero A - Leave flags
     982/     5FE : 32 89 1D            	LD	(NULFLG),A	; Zero null flag
     983/     601 : C2 0C 06            	JP	NZ,ECHDEL	; Set - Echo it
     984/     604 : 05                  	DEC	B		; Decrement length
     985/     605 : CA 29 06            	JP	Z,GETLIN	; Get line again if empty
     986/     608 : CD BD 06            	CALL	OUTC		; Output null character
     987/     60B : 3E                  	DB	3EH		; Skip "DEC B"
     988/     60C : 05                  ECHDEL: DEC	B		; Count bytes in buffer
     989/     60D : 2B                  	DEC	HL		; Back space buffer
     990/     60E : CA 20 06            	JP	Z,OTKLN		; No buffer - Try again
     991/     611 : 7E                  	LD	A,(HL)		; Get deleted byte
     992/     612 : CD BD 06            	CALL	OUTC		; Echo it
     993/     615 : C3 32 06            	JP	MORINP		; Get more input
     994/     618 :                     ;
     995/     618 : 05                  DELCHR: DEC	B		; Count bytes in buffer
     996/     619 : 2B                  	DEC	HL		; Back space buffer
     997/     61A : CD BD 06            	CALL	OUTC		; Output character in A
     998/     61D : C2 32 06            	JP	NZ,MORINP	; Not end - Get more
     999/     620 : CD BD 06            OTKLN:	CALL	OUTC		; Output character in A
    1000/     623 : CD E2 0A            KILIN:	CALL	PRCRLF		; Output CRLF
    1001/     626 : C3 29 06            	JP	TTYLIN		; Get line again
    1002/     629 :                     ;
    1003/     629 :                     GETLIN:
    1004/     629 : 21 A6 1D            TTYLIN: LD	HL,BUFFER	; Get a line by character
    1005/     62C : 06 01               	LD	B,1		; Set buffer as empty
    1006/     62E : AF                  	XOR	A
    1007/     62F : 32 89 1D            	LD	(NULFLG),A	; Clear null flag
    1008/     632 : CD E5 06            MORINP: CALL	CLOTST		; Get character and test ^O
    1009/     635 : 4F                  	LD	C,A		; Save character in C
    1010/     636 : FE 7F               	CP	DEL		; Delete character?
    1011/     638 : CA F8 05            	JP	Z,DODEL	; Yes - Process it
    1012/     63B : 3A 89 1D            	LD	A,(NULFLG)	; Get null flag
    1013/     63E : B7                  	OR	A		; Test null flag status
    1014/     63F : CA 4B 06            	JP	Z,PROCES	; Reset - Process character
    1015/     642 : 3E 00               	LD	A,0		; Set a null
    1016/     644 : CD BD 06            	CALL	OUTC		; Output null
    1017/     647 : AF                  	XOR	A		; Clear A
    1018/     648 : 32 89 1D            	LD	(NULFLG),A	; Reset null flag
    1019/     64B : 79                  PROCES: LD	A,C		; Get character
    1020/     64C : FE 07               	CP	CTRLG		; Bell?
    1021/     64E : CA 8F 06            	JP	Z,PUTCTL	; Yes - Save it
    1022/     651 : FE 03               	CP	CTRLC		; Is it control "C"?
    1023/     653 : CC E2 0A            	CALL	Z,PRCRLF	; Yes - Output CRLF
    1024/     656 : 37                  	SCF			; Flag break
    1025/     657 : C8                  	RET	Z		; Return if control "C"
    1026/     658 : FE 0D               	CP	CR		; Is it enter?
    1027/     65A : CA DD 0A            	JP	Z,ENDINP	; Yes - Terminate input
    1028/     65D : FE 15               	CP	CTRLU		; Is it control "U"?
    1029/     65F : CA 23 06            	JP	Z,KILIN		; Yes - Get another line
    1030/     662 : FE 40               	CP	'@'		; Is it "kill line"?
    1031/     664 : CA 20 06            	JP	Z,OTKLN		; Yes - Kill line
    1032/     667 : FE 5F               	CP	'_'		; Is it delete?
    1033/     669 : CA 18 06            	JP	Z,DELCHR	; Yes - Delete character
    1034/     66C : FE 08               	CP	BKSP		; Is it backspace?
    1035/     66E : CA 18 06            	JP	Z,DELCHR	; Yes - Delete character
    1036/     671 : FE 12               	CP	CTRLR		; Is it control "R"?
    1037/     673 : C2 8A 06            	JP	NZ,PUTBUF	; No - Put in buffer
    1038/     676 : C5                  	PUSH	BC		; Save buffer length
    1039/     677 : D5                  	PUSH	DE		; Save DE
    1040/     678 : E5                  	PUSH	HL		; Save buffer address
    1041/     679 : 36 00               	LD	(HL),0		; Mark end of buffer
    1042/     67B : CD 86 1C            	CALL	OUTNCR		; Output and do CRLF
    1043/     67E : 21 A6 1D            	LD	HL,BUFFER	; Point to buffer start
    1044/     681 : CD 80 11            	CALL	PRS		; Output buffer
    1045/     684 : E1                  	POP	HL		; Restore buffer address
    1046/     685 : D1                  	POP	DE		; Restore DE
    1047/     686 : C1                  	POP	BC		; Restore buffer length
    1048/     687 : C3 32 06            	JP	MORINP		; Get another character
    1049/     68A :                     ;
    1050/     68A : FE 20               PUTBUF: CP	' '		; Is it a control code?
    1051/     68C : DA 32 06            	JP	C,MORINP	; Yes - Ignore
    1052/     68F : 78                  PUTCTL: LD	A,B		; Get number of bytes in buffer
    1053/     690 : FE 49               	CP	72+1		; Test for line overflow
    1054/     692 : 3E 07               	LD	A,CTRLG		; Set a bell
    1055/     694 : D2 A4 06            	JP	NC,OUTNBS	; Ring bell if buffer full
    1056/     697 : 79                  	LD	A,C		; Get character
    1057/     698 : 71                  	LD	(HL),C		; Save in buffer
    1058/     699 : 32 11 1E            	LD	(LSTBIN),A	; Save last input byte
    1059/     69C : 23                  	INC	HL		; Move up buffer
    1060/     69D : 04                  	INC	B		; Increment length
    1061/     69E : CD BD 06            OUTIT:	CALL	OUTC		; Output the character entered
    1062/     6A1 : C3 32 06            	JP	MORINP		; Get another character
    1063/     6A4 :                     ;
    1064/     6A4 : CD BD 06            OUTNBS: CALL	OUTC		; Output bell and back over it
    1065/     6A7 : 3E 08               	LD	A,BKSP		; Set back space
    1066/     6A9 : C3 9E 06            	JP	OUTIT		; Output it and get more
    1067/     6AC :                     ;
    1068/     6AC : 7C                  CPDEHL: LD	A,H		; Get H
    1069/     6AD : 92                  	SUB	D		; Compare with D
    1070/     6AE : C0                  	RET	NZ		; Different - Exit
    1071/     6AF : 7D                  	LD	A,L		; Get L
    1072/     6B0 : 93                  	SUB	E		; Compare with E
    1073/     6B1 : C9                  	RET			; Return status
    1074/     6B2 :                     ;
    1075/     6B2 : 7E                  CHKSYN: LD	A,(HL)		; Check syntax of character
    1076/     6B3 : E3                  	EX	(SP),HL		; Address of test byte
    1077/     6B4 : BE                  	CP	(HL)		; Same as in code string?
    1078/     6B5 : 23                  	INC	HL		; Return address
    1079/     6B6 : E3                  	EX	(SP),HL		; Put it back
    1080/     6B7 : CA 3A 08            	JP	Z,GETCHR	; Yes - Get next character
    1081/     6BA : C3 E4 03            	JP	SNERR		; Different - ?SN Error
    1082/     6BD :                     ;
    1083/     6BD : F5                  OUTC:	PUSH	AF		; Save character
    1084/     6BE : 3A 8A 1D            	LD	A,(CTLOFG)	; Get control "O" flag
    1085/     6C1 : B7                  	OR	A		; Is it set?
    1086/     6C2 : C2 B5 11            	JP	NZ,POPAF	; Yes - don't output
    1087/     6C5 : F1                  	POP	AF		; Restore character
    1088/     6C6 : C5                  	PUSH	BC		; Save buffer length
    1089/     6C7 : F5                  	PUSH	AF		; Save character
    1090/     6C8 : FE 20               	CP	' '		; Is it a control code?
    1091/     6CA : DA E1 06            	JP	C,DINPOS	; Yes - Don't INC POS(X)
    1092/     6CD : 3A 87 1D            	LD	A,(LWIDTH)	; Get line width
    1093/     6D0 : 47                  	LD	B,A		; To B
    1094/     6D1 : 3A F0 1D            	LD	A,(CURPOS)	; Get cursor position
    1095/     6D4 : 04                  	INC	B		; Width 255?
    1096/     6D5 : CA DD 06            	JP	Z,INCLEN	; Yes - No width limit
    1097/     6D8 : 05                  	DEC	B		; Restore width
    1098/     6D9 : B8                  	CP	B		; At end of line?
    1099/     6DA : CC E2 0A            	CALL	Z,PRCRLF	; Yes - output CRLF
    1100/     6DD : 3C                  INCLEN: INC	A		; Move on one character
    1101/     6DE : 32 F0 1D            	LD	(CURPOS),A	; Save new position
    1102/     6E1 : F1                  DINPOS: POP	AF		; Restore character
    1103/     6E2 : C1                  	POP	BC		; Restore buffer length
    1104/     6E3 :                     ;	CALL	MONOUT		; Send it
    1105/     6E3 : CF                  	rst	08h
    1106/     6E4 : C9                  	RET
    1107/     6E5 :                     ;
    1108/     6E5 : CD 3F 1B            CLOTST: CALL	GETINP		; Get input character
    1109/     6E8 : E6 7F               	AND	01111111B	; Strip bit 7
    1110/     6EA : FE 0F               	CP	CTRLO		; Is it control "O"?
    1111/     6EC : C0                  	RET	NZ		; No don't flip flag
    1112/     6ED : 3A 8A 1D            	LD	A,(CTLOFG)	; Get flag
    1113/     6F0 : 2F                  	CPL			; Flip it
    1114/     6F1 : 32 8A 1D            	LD	(CTLOFG),A	; Put it back
    1115/     6F4 : AF                  	XOR	A		; Null character
    1116/     6F5 : C9                  	RET
    1117/     6F6 :                     ;
    1118/     6F6 : CD 06 09            LIST:	CALL	ATOH		; ASCII number to DE
    1119/     6F9 : C0                  	RET	NZ		; Return if anything extra
    1120/     6FA : C1                  	POP	BC		; Rubbish - Not needed
    1121/     6FB : CD D0 04            	CALL	SRCHLN		; Search for line number in DE
    1122/     6FE : C5                  	PUSH	BC		; Save address of line
    1123/     6FF : CD 4C 07            	CALL	SETLIN		; Set up lines counter
    1124/     702 : E1                  LISTLP: POP	HL		; Restore address of line
    1125/     703 : 4E                  	LD	C,(HL)		; Get LSB of next line
    1126/     704 : 23                  	INC	HL
    1127/     705 : 46                  	LD	B,(HL)		; Get MSB of next line
    1128/     706 : 23                  	INC	HL
    1129/     707 : 78                  	LD	A,B		; BC = 0 (End of program)?
    1130/     708 : B1                  	OR	C
    1131/     709 : CA 2F 04            	JP	Z,PRNTOK	; Yes - Go to command mode
    1132/     70C : CD 55 07            	CALL	COUNT		; Count lines
    1133/     70F : CD 65 08            	CALL	TSTBRK		; Test for break key
    1134/     712 : C5                  	PUSH	BC		; Save address of next line
    1135/     713 : CD E2 0A            	CALL	PRCRLF		; Output CRLF
    1136/     716 : 5E                  	LD	E,(HL)		; Get LSB of line number
    1137/     717 : 23                  	INC	HL
    1138/     718 : 56                  	LD	D,(HL)		; Get MSB of line number
    1139/     719 : 23                  	INC	HL
    1140/     71A : E5                  	PUSH	HL		; Save address of line start
    1141/     71B : EB                  	EX	DE,HL		; Line number to HL
    1142/     71C : CD 23 18            	CALL	PRNTHL		; Output line number in decimal
    1143/     71F : 3E 20               	LD	A,' '		; Space after line number
    1144/     721 : E1                  	POP	HL		; Restore start of line address
    1145/     722 : CD BD 06            LSTLP2: CALL	OUTC		; Output character in A
    1146/     725 : 7E                  LSTLP3: LD	A,(HL)		; Get next byte in line
    1147/     726 : B7                  	OR	A		; End of line?
    1148/     727 : 23                  	INC	HL		; To next byte in line
    1149/     728 : CA 02 07            	JP	Z,LISTLP	; Yes - get next line
    1150/     72B : F2 22 07            	JP	P,LSTLP2	; No token - output it
    1151/     72E : D6 7F               	SUB	ZEND-1		; Find and output word
    1152/     730 : 4F                  	LD	C,A		; Token offset+1 to C
    1153/     731 : 11 6D 01            	LD	DE,WORDS	; Reserved word list
    1154/     734 : 1A                  FNDTOK: LD	A,(DE)		; Get character in list
    1155/     735 : 13                  	INC	DE		; Move on to next
    1156/     736 : B7                  	OR	A		; Is it start of word?
    1157/     737 : F2 34 07            	JP	P,FNDTOK	; No - Keep looking for word
    1158/     73A : 0D                  	DEC	C		; Count words
    1159/     73B : C2 34 07            	JP	NZ,FNDTOK	; Not there - keep looking
    1160/     73E : E6 7F               OUTWRD: AND	01111111B	; Strip bit 7
    1161/     740 : CD BD 06            	CALL	OUTC		; Output first character
    1162/     743 : 1A                  	LD	A,(DE)		; Get next character
    1163/     744 : 13                  	INC	DE		; Move on to next
    1164/     745 : B7                  	OR	A		; Is it end of word?
    1165/     746 : F2 3E 07            	JP	P,OUTWRD	; No - output the rest
    1166/     749 : C3 25 07            	JP	LSTLP3		; Next byte in line
    1167/     74C :                     ;
    1168/     74C : E5                  SETLIN: PUSH	HL		; Set up LINES counter
    1169/     74D : 2A 8D 1D            	LD	HL,(LINESN)	; Get LINES number
    1170/     750 : 22 8B 1D            	LD	(LINESC),HL	; Save in LINES counter
    1171/     753 : E1                  	POP	HL
    1172/     754 : C9                  	RET
    1173/     755 :                     ;
    1174/     755 : E5                  COUNT:	PUSH	HL		; Save code string address
    1175/     756 : D5                  	PUSH	DE
    1176/     757 : 2A 8B 1D            	LD	HL,(LINESC)	; Get LINES counter
    1177/     75A : 11 FF FF            	LD	DE,-1
    1178/     75D : ED 5A               	ADC	HL,DE		; Decrement
    1179/     75F : 22 8B 1D            	LD	(LINESC),HL	; Put it back
    1180/     762 : D1                  	POP	DE
    1181/     763 : E1                  	POP	HL		; Restore code string address
    1182/     764 : F0                  	RET	P		; Return if more lines to go
    1183/     765 : E5                  	PUSH	HL		; Save code string address
    1184/     766 : 2A 8D 1D            	LD	HL,(LINESN)	; Get LINES number
    1185/     769 : 22 8B 1D            	LD	(LINESC),HL	; Reset LINES counter
    1186/     76C : CD 3F 1B            	CALL	GETINP		; Get input character
    1187/     76F : FE 03               	CP	CTRLC		; Is it control "C"?
    1188/     771 : CA 78 07            	JP	Z,RSLNBK	; Yes - Reset LINES and break
    1189/     774 : E1                  	POP	HL		; Restore code string address
    1190/     775 : C3 55 07            	JP	COUNT		; Keep on counting
    1191/     778 :                     ;
    1192/     778 : 2A 8D 1D            RSLNBK: LD	HL,(LINESN)	; Get LINES number
    1193/     77B : 22 8B 1D            	LD	(LINESC),HL	; Reset LINES counter
    1194/     77E : C3 AE 00            	JP	BRKRET		; Go and output "Break"
    1195/     781 :                     ;
    1196/     781 : 3E 64               FOR:	LD	A,64H		; Flag "FOR" assignment
    1197/     783 : 32 10 1E            	LD	(FORFLG),A	; Save "FOR" flag
    1198/     786 : CD E8 09            	CALL	LET		; Set up initial index
    1199/     789 : C1                  	POP	BC		; Drop RETurn address
    1200/     78A : E5                  	PUSH	HL		; Save code string address
    1201/     78B : CD D1 09            	CALL	DATA		; Get next statement address
    1202/     78E : 22 0C 1E            	LD	(LOOPST),HL	; Save it for start of loop
    1203/     791 : 21 02 00            	LD	HL,2		; Offset for "FOR" block
    1204/     794 : 39                  	ADD	HL,SP		; Point to it
    1205/     795 : CD 91 03            FORSLP: CALL	LOKFOR		; Look for existing "FOR" block
    1206/     798 : D1                  	POP	DE		; Get code string address
    1207/     799 : C2 B1 07            	JP	NZ,FORFND	; No nesting found
    1208/     79C : 09                  	ADD	HL,BC		; Move into "FOR" block
    1209/     79D : D5                  	PUSH	DE		; Save code string address
    1210/     79E : 2B                  	DEC	HL
    1211/     79F : 56                  	LD	D,(HL)		; Get MSB of loop statement
    1212/     7A0 : 2B                  	DEC	HL
    1213/     7A1 : 5E                  	LD	E,(HL)		; Get LSB of loop statement
    1214/     7A2 : 23                  	INC	HL
    1215/     7A3 : 23                  	INC	HL
    1216/     7A4 : E5                  	PUSH	HL		; Save block address
    1217/     7A5 : 2A 0C 1E            	LD	HL,(LOOPST)	; Get address of loop statement
    1218/     7A8 : CD AC 06            	CALL	CPDEHL		; Compare the FOR loops
    1219/     7AB : E1                  	POP	HL		; Restore block address
    1220/     7AC : C2 95 07            	JP	NZ,FORSLP	; Different FORs - Find another
    1221/     7AF : D1                  	POP	DE		; Restore code string address
    1222/     7B0 : F9                  	LD	SP,HL		; Remove all nested loops
    1223/     7B1 :                     ;
    1224/     7B1 : EB                  FORFND: EX	DE,HL		; Code string address to HL
    1225/     7B2 : 0E 08               	LD	C,8
    1226/     7B4 : CD C1 03            	CALL	CHKSTK		; Check for 8 levels of stack
    1227/     7B7 : E5                  	PUSH	HL		; Save code string address
    1228/     7B8 : 2A 0C 1E            	LD	HL,(LOOPST)	; Get first statement of loop
    1229/     7BB : E3                  	EX	(SP),HL		; Save and restore code string
    1230/     7BC : E5                  	PUSH	HL		; Re-save code string address
    1231/     7BD : 2A A1 1D            	LD	HL,(LINEAT)	; Get current line number
    1232/     7C0 : E3                  	EX	(SP),HL		; Save and restore code string
    1233/     7C1 : CD AA 0C            	CALL	TSTNUM		; Make sure it's a number
    1234/     7C4 : CD B2 06            	CALL	CHKSYN		; Make sure "TO" is next
    1235/     7C7 : A6                  	DB	ZTO		; "TO" token
    1236/     7C8 : CD A7 0C            	CALL	GETNUM		; Get "TO" expression value
    1237/     7CB : E5                  	PUSH	HL		; Save code string address
    1238/     7CC : CD D5 16            	CALL	BCDEFP		; Move "TO" value to BCDE
    1239/     7CF : E1                  	POP	HL		; Restore code string address
    1240/     7D0 : C5                  	PUSH	BC		; Save "TO" value in block
    1241/     7D1 : D5                  	PUSH	DE
    1242/     7D2 : 01 00 81            	LD	BC,8100H	; BCDE - 1 (default STEP)
    1243/     7D5 : 51                  	LD	D,C		; C=0
    1244/     7D6 : 5A                  	LD	E,D		; D=0
    1245/     7D7 : 7E                  	LD	A,(HL)		; Get next byte in code string
    1246/     7D8 : FE AB               	CP	ZSTEP		; See if "STEP" is stated
    1247/     7DA : 3E 01               	LD	A,1		; Sign of step = 1
    1248/     7DC : C2 ED 07            	JP	NZ,SAVSTP	; No STEP given - Default to 1
    1249/     7DF : CD 3A 08            	CALL	GETCHR		; Jump over "STEP" token
    1250/     7E2 : CD A7 0C            	CALL	GETNUM		; Get step value
    1251/     7E5 : E5                  	PUSH	HL		; Save code string address
    1252/     7E6 : CD D5 16            	CALL	BCDEFP		; Move STEP to BCDE
    1253/     7E9 : CD 89 16            	CALL	TSTSGN		; Test sign of FPREG
    1254/     7EC : E1                  	POP	HL		; Restore code string address
    1255/     7ED : C5                  SAVSTP: PUSH	BC		; Save the STEP value in block
    1256/     7EE : D5                  	PUSH	DE
    1257/     7EF : F5                  	PUSH	AF		; Save sign of STEP
    1258/     7F0 : 33                  	INC	SP		; Don't save flags
    1259/     7F1 : E5                  	PUSH	HL		; Save code string address
    1260/     7F2 : 2A 13 1E            	LD	HL,(BRKLIN)	; Get address of index variable
    1261/     7F5 : E3                  	EX	(SP),HL		; Save and restore code string
    1262/     7F6 : 06 81               PUTFID: LD	B,ZFOR		; "FOR" block marker
    1263/     7F8 : C5                  	PUSH	BC		; Save it
    1264/     7F9 : 33                  	INC	SP		; Don't save C
    1265/     7FA :                     ;
    1266/     7FA : CD 65 08            RUNCNT: CALL	TSTBRK		; Execution driver - Test break
    1267/     7FD : 22 13 1E            	LD	(BRKLIN),HL	; Save code address for break
    1268/     800 : 7E                  	LD	A,(HL)		; Get next byte in code string
    1269/     801 : FE 3A               	CP	':'		; Multi statement line?
    1270/     803 : CA 1A 08            	JP	Z,EXCUTE	; Yes - Execute it
    1271/     806 : B7                  	OR	A		; End of line?
    1272/     807 : C2 E4 03            	JP	NZ,SNERR	; No - Syntax error
    1273/     80A : 23                  	INC	HL		; Point to address of next line
    1274/     80B : 7E                  	LD	A,(HL)		; Get LSB of line pointer
    1275/     80C : 23                  	INC	HL
    1276/     80D : B6                  	OR	(HL)		; Is it zero (End of prog)?
    1277/     80E : CA 8C 08            	JP	Z,ENDPRG	; Yes - Terminate execution
    1278/     811 : 23                  	INC	HL		; Point to line number
    1279/     812 : 5E                  	LD	E,(HL)		; Get LSB of line number
    1280/     813 : 23                  	INC	HL
    1281/     814 : 56                  	LD	D,(HL)		; Get MSB of line number
    1282/     815 : EB                  	EX	DE,HL		; Line number to HL
    1283/     816 : 22 A1 1D            	LD	(LINEAT),HL	; Save as current line number
    1284/     819 : EB                  	EX	DE,HL		; Line number back to DE
    1285/     81A : CD 3A 08            EXCUTE: CALL	GETCHR		; Get key word
    1286/     81D : 11 FA 07            	LD	DE,RUNCNT	; Where to RETurn to
    1287/     820 : D5                  	PUSH	DE		; Save for RETurn
    1288/     821 : C8                  IFJMP:	RET	Z		; Go to RUNCNT if end of STMT
    1289/     822 : D6 80               ONJMP:	SUB	ZEND		; Is it a token?
    1290/     824 : DA E8 09            	JP	C,LET		; No - try to assign it
    1291/     827 : FE 25               	CP	ZNEW+1-ZEND	; END to NEW ?
    1292/     829 : D2 E4 03            	JP	NC,SNERR	; Not a key word - ?SN Error
    1293/     82C : 07                  	RLCA			; Double it
    1294/     82D : 4F                  	LD	C,A		; BC = Offset into table
    1295/     82E : 06 00               	LD	B,0
    1296/     830 : EB                  	EX	DE,HL		; Save code string address
    1297/     831 : 21 8C 02            	LD	HL,WORDTB	; Keyword address table
    1298/     834 : 09                  	ADD	HL,BC		; Point to routine address
    1299/     835 : 4E                  	LD	C,(HL)		; Get LSB of routine address
    1300/     836 : 23                  	INC	HL
    1301/     837 : 46                  	LD	B,(HL)		; Get MSB of routine address
    1302/     838 : C5                  	PUSH	BC		; Save routine address
    1303/     839 : EB                  	EX	DE,HL		; Restore code string address
    1304/     83A :                     ;
    1305/     83A : 23                  GETCHR: INC	HL		; Point to next character
    1306/     83B : 7E                  	LD	A,(HL)		; Get next code string byte
    1307/     83C : FE 3A               	CP	':'		; Z if ':'
    1308/     83E : D0                  	RET	NC		; NC if > "9"
    1309/     83F : FE 20               	CP	' '
    1310/     841 : CA 3A 08            	JP	Z,GETCHR	; Skip over spaces
    1311/     844 : FE 30               	CP	'0'
    1312/     846 : 3F                  	CCF			; NC if < '0'
    1313/     847 : 3C                  	INC	A		; Test for zero - Leave carry
    1314/     848 : 3D                  	DEC	A		; Z if Null
    1315/     849 : C9                  	RET
    1316/     84A :                     ;
    1317/     84A : EB                  RESTOR: EX	DE,HL		; Save code string address
    1318/     84B : 2A A3 1D            	LD	HL,(BASTXT)	; Point to start of program
    1319/     84E : CA 5F 08            	JP	Z,RESTNL	; Just RESTORE - reset pointer
    1320/     851 : EB                  	EX	DE,HL		; Restore code string address
    1321/     852 : CD 06 09            	CALL	ATOH		; Get line number to DE
    1322/     855 : E5                  	PUSH	HL		; Save code string address
    1323/     856 : CD D0 04            	CALL	SRCHLN		; Search for line number in DE
    1324/     859 : 60                  	LD	H,B		; HL = Address of line
    1325/     85A : 69                  	LD	L,C
    1326/     85B : D1                  	POP	DE		; Restore code string address
    1327/     85C : D2 A7 09            	JP	NC,ULERR	; ?UL Error if not found
    1328/     85F : 2B                  RESTNL: DEC	HL		; Byte before DATA statement
    1329/     860 : 22 21 1E            UPDATA: LD	(NXTDAT),HL	; Update DATA pointer
    1330/     863 : EB                  	EX	DE,HL		; Restore code string address
    1331/     864 : C9                  	RET
    1332/     865 :                     ;
    1333/     865 :                     
    1334/     865 : DF                  TSTBRK: RST	18H		; Check input status
    1335/     866 : C8                  	RET	Z		; No key, go back
    1336/     867 : D7                  	RST	10H		; Get the key into A
    1337/     868 : FE 1B               	CP	ESC		; Escape key?
    1338/     86A : 28 11               	JR	Z,BRK		; Yes, break
    1339/     86C : FE 03               	CP	CTRLC		; <Ctrl-C>
    1340/     86E : 28 0D               	JR	Z,BRK		; Yes, break
    1341/     870 : FE 13               	CP	CTRLS		; Stop scrolling?
    1342/     872 : C0                  	RET	NZ		; Other key, ignore
    1343/     873 :                     ;
    1344/     873 :                     
    1345/     873 : D7                  STALL:	RST	10H		; Wait for key
    1346/     874 : FE 11               	CP	CTRLQ		; Resume scrolling?
    1347/     876 : C8                  	RET	Z		; Release the chokehold
    1348/     877 : FE 03               	CP	CTRLC		; Second break?
    1349/     879 : 28 07               	JR	Z,STOP		; Break during hold exits prog
    1350/     87B : 18 F6               	JR	STALL		; Loop until <Ctrl-Q> or <brk>
    1351/     87D :                     ;
    1352/     87D : 3E FF               BRK:	LD	A,0FFH		; Set BRKFLG
    1353/     87F : 32 92 1D            	LD	(BRKFLG),A	; Store it
    1354/     882 :                     ;
    1355/     882 :                     
    1356/     882 : C0                  STOP:	RET	NZ		; Exit if anything else
    1357/     883 : F6                  	DB	0F6H		; Flag "STOP"
    1358/     884 : C0                  PEND:	RET	NZ		; Exit if anything else
    1359/     885 : 22 13 1E            	LD	(BRKLIN),HL	; Save point of break
    1360/     888 : 21                  	DB	21H		; Skip "OR 11111111B"
    1361/     889 : F6 FF               INPBRK: OR	11111111B	; Flag "Break" wanted
    1362/     88B : C1                  	POP	BC		; Return not needed and more
    1363/     88C : 2A A1 1D            ENDPRG: LD	HL,(LINEAT)	; Get current line number
    1364/     88F : F5                  	PUSH	AF		; Save STOP / END status
    1365/     890 : 7D                  	LD	A,L		; Is it direct break?
    1366/     891 : A4                  	AND	H
    1367/     892 : 3C                  	INC	A		; Line is -1 if direct break
    1368/     893 : CA 9F 08            	JP	Z,NOLIN		; Yes - No line number
    1369/     896 : 22 17 1E            	LD	(ERRLIN),HL	; Save line of break
    1370/     899 : 2A 13 1E            	LD	HL,(BRKLIN)	; Get point of break
    1371/     89C : 22 19 1E            	LD	(CONTAD),HL	; Save point to CONTinue
    1372/     89F : AF                  NOLIN:	XOR	A
    1373/     8A0 : 32 8A 1D            	LD	(CTLOFG),A	; Enable output
    1374/     8A3 : CD D5 0A            	CALL	STTLIN		; Start a new line
    1375/     8A6 : F1                  	POP	AF		; Restore STOP / END status
    1376/     8A7 : 21 87 03            	LD	HL,BRKMSG	; "Break" message
    1377/     8AA : C2 18 04            	JP	NZ,ERRIN	; "in line" wanted?
    1378/     8AD : C3 2F 04            	JP	PRNTOK		; Go to command mode
    1379/     8B0 :                     ;
    1380/     8B0 : 2A 19 1E            CONT:	LD	HL,(CONTAD)	; Get CONTinue address
    1381/     8B3 : 7C                  	LD	A,H		; Is it zero?
    1382/     8B4 : B5                  	OR	L
    1383/     8B5 : 1E 20               	LD	E,CN		; ?CN Error
    1384/     8B7 : CA F8 03            	JP	Z,ERROR_	; Yes - output "?CN Error"
    1385/     8BA : EB                  	EX	DE,HL		; Save code string address
    1386/     8BB : 2A 17 1E            	LD	HL,(ERRLIN)	; Get line of last break
    1387/     8BE : 22 A1 1D            	LD	(LINEAT),HL	; Set up current line number
    1388/     8C1 : EB                  	EX	DE,HL		; Restore code string address
    1389/     8C2 : C9                  	RET			; CONTinue where left off
    1390/     8C3 :                     ;
    1391/     8C3 : CD 08 14            NULL:	CALL	GETINT		; Get integer 0-255
    1392/     8C6 : C0                  	RET	NZ		; Return if bad value
    1393/     8C7 : 32 86 1D            	LD	(NULLS),A	; Set nulls number
    1394/     8CA : C9                  	RET
    1395/     8CB :                     ;
    1396/     8CB :                     
    1397/     8CB : E5                  ACCSUM: PUSH	HL		; Save address in array
    1398/     8CC : 2A 8F 1D            	LD	HL,(CHKSUM)	; Get check sum
    1399/     8CF : 06 00               	LD	B,0		; BC - Value of byte
    1400/     8D1 : 4F                  	LD	C,A
    1401/     8D2 : 09                  	ADD	HL,BC		; Add byte to check sum
    1402/     8D3 : 22 8F 1D            	LD	(CHKSUM),HL	; Re-save check sum
    1403/     8D6 : E1                  	POP	HL		; Restore address in array
    1404/     8D7 : C9                  	RET
    1405/     8D8 :                     ;
    1406/     8D8 : 7E                  CHKLTR: LD	A,(HL)		; Get byte
    1407/     8D9 : FE 41               	CP	'A'		; < 'a' ?
    1408/     8DB : D8                  	RET	C		; Carry set if not letter
    1409/     8DC : FE 5B               	CP	'Z'+1		; > 'z' ?
    1410/     8DE : 3F                  	CCF
    1411/     8DF : C9                  	RET			; Carry set if not letter
    1412/     8E0 :                     ;
    1413/     8E0 : CD 3A 08            FPSINT: CALL	GETCHR		; Get next character
    1414/     8E3 : CD A7 0C            POSINT: CALL	GETNUM		; Get integer 0 to 32767
    1415/     8E6 : CD 89 16            DEPINT: CALL	TSTSGN		; Test sign of FPREG
    1416/     8E9 : FA 01 09            	JP	M,FCERR		; Negative - ?FC Error
    1417/     8EC : 3A 2C 1E            DEINT:	LD	A,(FPEXP)	; Get integer value to DE
    1418/     8EF : FE 90               	CP	80H+16		; Exponent in range (16 bits)?
    1419/     8F1 : DA 31 17            	JP	C,FPINT		; Yes - convert it
    1420/     8F4 : 01 80 90            	LD	BC,9080H	; BCDE = -32768
    1421/     8F7 : 11 00 00            	LD	DE,0000
    1422/     8FA : E5                  	PUSH	HL		; Save code string address
    1423/     8FB : CD 04 17            	CALL	CMPNUM		; Compare FPREG with BCDE
    1424/     8FE : E1                  	POP	HL		; Restore code string address
    1425/     8FF : 51                  	LD	D,C		; MSB to D
    1426/     900 : C8                  	RET	Z		; Return if in range
    1427/     901 : 1E 08               FCERR:	LD	E,FC		; ?FC Error
    1428/     903 : C3 F8 03            	JP	ERROR_		; Output error-
    1429/     906 :                     ;
    1430/     906 : 2B                  ATOH:	DEC	HL		; ASCII number to DE binary
    1431/     907 : 11 00 00            GETLN:	LD	DE,0		; Get number to DE
    1432/     90A : CD 3A 08            GTLNLP: CALL	GETCHR		; Get next character
    1433/     90D : D0                  	RET	NC		; Exit if not a digit
    1434/     90E : E5                  	PUSH	HL		; Save code string address
    1435/     90F : F5                  	PUSH	AF		; Save digit
    1436/     910 : 21 98 19            	LD	HL,65529/10	; Largest number 65529
    1437/     913 : CD AC 06            	CALL	CPDEHL		; Number in range?
    1438/     916 : DA E4 03            	JP	C,SNERR		; No - ?SN Error
    1439/     919 : 62                  	LD	H,D		; HL = Number
    1440/     91A : 6B                  	LD	L,E
    1441/     91B : 19                  	ADD	HL,DE		; Times 2
    1442/     91C : 29                  	ADD	HL,HL		; Times 4
    1443/     91D : 19                  	ADD	HL,DE		; Times 5
    1444/     91E : 29                  	ADD	HL,HL		; Times 10
    1445/     91F : F1                  	POP	AF		; Restore digit
    1446/     920 : D6 30               	SUB	'0'		; Make it 0 to 9
    1447/     922 : 5F                  	LD	E,A		; DE = Value of digit
    1448/     923 : 16 00               	LD	D,0
    1449/     925 : 19                  	ADD	HL,DE		; Add to number
    1450/     926 : EB                  	EX	DE,HL		; Number to DE
    1451/     927 : E1                  	POP	HL		; Restore code string address
    1452/     928 : C3 0A 09            	JP	GTLNLP		; Go to next character
    1453/     92B :                     ;
    1454/     92B : CA 00 05            CLEAR:	JP	Z,INTVAR	; Just "CLEAR" Keep parameters
    1455/     92E : CD E3 08            	CALL	POSINT		; Get integer 0 to 32767 to DE
    1456/     931 : 2B                  	DEC	HL		; Cancel increment
    1457/     932 : CD 3A 08            	CALL	GETCHR		; Get next character
    1458/     935 : E5                  	PUSH	HL		; Save code string address
    1459/     936 : 2A F4 1D            	LD	HL,(LSTRAM)	; Get end of RAM
    1460/     939 : CA 4E 09            	JP	Z,STORED	; No value given - Use stored
    1461/     93C : E1                  	POP	HL		; Restore code string address
    1462/     93D : CD B2 06            	CALL	CHKSYN		; Check for comma
    1463/     940 : 2C                  	DB	','
    1464/     941 : D5                  	PUSH	DE		; Save number
    1465/     942 : CD E3 08            	CALL	POSINT		; Get integer 0 to 32767
    1466/     945 : 2B                  	DEC	HL		; Cancel increment
    1467/     946 : CD 3A 08            	CALL	GETCHR		; Get next character
    1468/     949 : C2 E4 03            	JP	NZ,SNERR	; ?SN Error if more on line
    1469/     94C : E3                  	EX	(SP),HL		; Save code string address
    1470/     94D : EB                  	EX	DE,HL		; Number to DE
    1471/     94E : 7D                  STORED: LD	A,L		; Get LSB of new RAM top
    1472/     94F : 93                  	SUB	E		; Subtract LSB of string space
    1473/     950 : 5F                  	LD	E,A		; Save LSB
    1474/     951 : 7C                  	LD	A,H		; Get MSB of new RAM top
    1475/     952 : 9A                  	SBC	A,D		; Subtract MSB of string space
    1476/     953 : 57                  	LD	D,A		; Save MSB
    1477/     954 : DA D9 03            	JP	C,OMERR		; ?OM Error if not enough mem
    1478/     957 : E5                  	PUSH	HL		; Save RAM top
    1479/     958 : 2A 1B 1E            	LD	HL,(PROGND)	; Get program end
    1480/     95B : 01 28 00            	LD	BC,40		; 40 Bytes minimum working RAM
    1481/     95E : 09                  	ADD	HL,BC		; Get lowest address
    1482/     95F : CD AC 06            	CALL	CPDEHL		; Enough memory?
    1483/     962 : D2 D9 03            	JP	NC,OMERR	; No - ?OM Error
    1484/     965 : EB                  	EX	DE,HL		; RAM top to HL
    1485/     966 : 22 9F 1D            	LD	(STRSPC),HL	; Set new string space
    1486/     969 : E1                  	POP	HL		; End of memory to use
    1487/     96A : 22 F4 1D            	LD	(LSTRAM),HL	; Set new top of RAM
    1488/     96D : E1                  	POP	HL		; Restore code string address
    1489/     96E : C3 00 05            	JP	INTVAR		; Initialise variables
    1490/     971 :                     ;
    1491/     971 : CA FC 04            RUN:	JP	Z,RUNFST	; RUN from start if just RUN
    1492/     974 : CD 00 05            	CALL	INTVAR		; Initialise variables
    1493/     977 : 01 FA 07            	LD	BC,RUNCNT	; Execution driver loop
    1494/     97A : C3 8D 09            	JP	RUNLIN		; RUN from line number
    1495/     97D :                     ;
    1496/     97D : 0E 03               GOSUB:	LD	C,3		; 3 Levels of stack needed
    1497/     97F : CD C1 03            	CALL	CHKSTK		; Check for 3 levels of stack
    1498/     982 : C1                  	POP	BC		; Get return address
    1499/     983 : E5                  	PUSH	HL		; Save code string for RETURN
    1500/     984 : E5                  	PUSH	HL		; And for GOSUB routine
    1501/     985 : 2A A1 1D            	LD	HL,(LINEAT)	; Get current line
    1502/     988 : E3                  	EX	(SP),HL		; Into stack - Code string out
    1503/     989 : 3E 8C               	LD	A,ZGOSUB	; "GOSUB" token
    1504/     98B : F5                  	PUSH	AF		; Save token
    1505/     98C : 33                  	INC	SP		; Don't save flags
    1506/     98D :                     ;
    1507/     98D : C5                  RUNLIN: PUSH	BC		; Save return address
    1508/     98E : CD 06 09            GOTO:	CALL	ATOH		; ASCII number to DE binary
    1509/     991 : CD D3 09            	CALL	REM		; Get end of line
    1510/     994 : E5                  	PUSH	HL		; Save end of line
    1511/     995 : 2A A1 1D            	LD	HL,(LINEAT)	; Get current line
    1512/     998 : CD AC 06            	CALL	CPDEHL		; Line after current?
    1513/     99B : E1                  	POP	HL		; Restore end of line
    1514/     99C : 23                  	INC	HL		; Start of next line
    1515/     99D : DC D3 04            	CALL	C,SRCHLP	; Line is after current line
    1516/     9A0 : D4 D0 04            	CALL	NC,SRCHLN	; Line is before current line
    1517/     9A3 : 60                  	LD	H,B		; Set up code string address
    1518/     9A4 : 69                  	LD	L,C
    1519/     9A5 : 2B                  	DEC	HL		; Incremented after
    1520/     9A6 : D8                  	RET	C		; Line found
    1521/     9A7 : 1E 0E               ULERR:	LD	E,UL		; ?UL Error
    1522/     9A9 : C3 F8 03            	JP	ERROR_		; Output error message
    1523/     9AC :                     ;
    1524/     9AC : C0                  RETURN: RET	NZ		; Return if not just RETURN
    1525/     9AD : 16 FF               	LD	D,-1		; Flag "GOSUB" search
    1526/     9AF : CD 8D 03            	CALL	BAKSTK		; Look "GOSUB" block
    1527/     9B2 : F9                  	LD	SP,HL		; Kill all FORs in subroutine
    1528/     9B3 : FE 8C               	CP	ZGOSUB		; Test for "GOSUB" token
    1529/     9B5 : 1E 04               	LD	E,RG		; ?RG Error
    1530/     9B7 : C2 F8 03            	JP	NZ,ERROR_	; Error if no "GOSUB" found
    1531/     9BA : E1                  	POP	HL		; Get RETURN line number
    1532/     9BB : 22 A1 1D            	LD	(LINEAT),HL	; Save as current
    1533/     9BE : 23                  	INC	HL		; Was it from direct statement?
    1534/     9BF : 7C                  	LD	A,H
    1535/     9C0 : B5                  	OR	L		; Return to line
    1536/     9C1 : C2 CB 09            	JP	NZ,RETLIN	; No - Return to line
    1537/     9C4 : 3A 11 1E            	LD	A,(LSTBIN)	; Any INPUT in subroutine?
    1538/     9C7 : B7                  	OR	A		; If so buffer is corrupted
    1539/     9C8 : C2 2E 04            	JP	NZ,POPNOK	; Yes - Go to command mode
    1540/     9CB : 21 FA 07            RETLIN: LD	HL,RUNCNT	; Execution driver loop
    1541/     9CE : E3                  	EX	(SP),HL		; Into stack - Code string out
    1542/     9CF : 3E                  	DB	3EH		; Skip "POP HL"
    1543/     9D0 : E1                  NXTDTA: POP	HL		; Restore code string address
    1544/     9D1 :                     ;
    1545/     9D1 : 01 3A               DATA:	DB	01H,3AH		; ':' End of statement
    1546/     9D3 : 0E 00               REM:	LD	C,0		; 00	End of statement
    1547/     9D5 : 06 00               	LD	B,0
    1548/     9D7 : 79                  NXTSTL: LD	A,C		; Statement and byte
    1549/     9D8 : 48                  	LD	C,B
    1550/     9D9 : 47                  	LD	B,A		; Statement end byte
    1551/     9DA : 7E                  NXTSTT: LD	A,(HL)		; Get byte
    1552/     9DB : B7                  	OR	A		; End of line?
    1553/     9DC : C8                  	RET	Z		; Yes - Exit
    1554/     9DD : B8                  	CP	B		; End of statement?
    1555/     9DE : C8                  	RET	Z		; Yes - Exit
    1556/     9DF : 23                  	INC	HL		; Next byte
    1557/     9E0 : FE 22               	CP	'"'		; Literal string?
    1558/     9E2 : CA D7 09            	JP	Z,NXTSTL	; Yes - Look for another '"'
    1559/     9E5 : C3 DA 09            	JP	NXTSTT		; Keep looking
    1560/     9E8 :                     ;
    1561/     9E8 : CD 9D 0E            LET:	CALL	GETVAR		; Get variable name
    1562/     9EB : CD B2 06            	CALL	CHKSYN		; Make sure "=" follows
    1563/     9EE : B4                  	DB	ZEQUAL		; "=" token
    1564/     9EF : D5                  	PUSH	DE		; Save address of variable
    1565/     9F0 : 3A F2 1D            	LD	A,(TYPE)	; Get data type
    1566/     9F3 : F5                  	PUSH	AF		; Save type
    1567/     9F4 : CD B9 0C            	CALL	EVAL		; Evaluate expression
    1568/     9F7 : F1                  	POP	AF		; Restore type
    1569/     9F8 : E3                  	EX	(SP),HL		; Save code - Get var addr
    1570/     9F9 : 22 13 1E            	LD	(BRKLIN),HL	; Save address of variable
    1571/     9FC : 1F                  	RRA			; Adjust type
    1572/     9FD : CD AC 0C            	CALL	CHKTYP		; Check types are the same
    1573/     A00 : CA 3B 0A            	JP	Z,LETNUM	; Numeric - Move value
    1574/     A03 : E5                  LETSTR: PUSH	HL		; Save address of string var
    1575/     A04 : 2A 29 1E            	LD	HL,(FPREG)	; Pointer to string entry
    1576/     A07 : E5                  	PUSH	HL		; Save it on stack
    1577/     A08 : 23                  	INC	HL		; Skip over length
    1578/     A09 : 23                  	INC	HL
    1579/     A0A : 5E                  	LD	E,(HL)		; LSB of string address
    1580/     A0B : 23                  	INC	HL
    1581/     A0C : 56                  	LD	D,(HL)		; MSB of string address
    1582/     A0D : 2A A3 1D            	LD	HL,(BASTXT)	; Point to start of program
    1583/     A10 : CD AC 06            	CALL	CPDEHL		; Is string before program?
    1584/     A13 : D2 2A 0A            	JP	NC,CRESTR	; Yes - Create string entry
    1585/     A16 : 2A 9F 1D            	LD	HL,(STRSPC)	; Point to string space
    1586/     A19 : CD AC 06            	CALL	CPDEHL		; Is string literal in program?
    1587/     A1C : D1                  	POP	DE		; Restore address of string
    1588/     A1D : D2 32 0A            	JP	NC,MVSTPT	; Yes - Set up pointer
    1589/     A20 : 21 04 1E            	LD	HL,TMPSTR	; Temporary string pool
    1590/     A23 : CD AC 06            	CALL	CPDEHL		; Is string in temporary pool?
    1591/     A26 : D2 32 0A            	JP	NC,MVSTPT	; No - Set up pointer
    1592/     A29 : 3E                  	DB	3EH		; Skip "POP DE"
    1593/     A2A : D1                  CRESTR: POP	DE		; Restore address of string
    1594/     A2B : CD E1 12            	CALL	BAKTMP		; Back to last tmp-str entry
    1595/     A2E : EB                  	EX	DE,HL		; Address of string entry
    1596/     A2F : CD 1A 11            	CALL	SAVSTR		; Save string in string area
    1597/     A32 : CD E1 12            MVSTPT: CALL	BAKTMP		; Back to last tmp-str entry
    1598/     A35 : E1                  	POP	HL		; Get string pointer
    1599/     A36 : CD E4 16            	CALL	DETHL4		; Move string pointer to var
    1600/     A39 : E1                  	POP	HL		; Restore code string address
    1601/     A3A : C9                  	RET
    1602/     A3B :                     ;
    1603/     A3B : E5                  LETNUM: PUSH	HL		; Save address of variable
    1604/     A3C : CD E1 16            	CALL	FPTHL		; Move value to variable
    1605/     A3F : D1                  	POP	DE		; Restore address of variable
    1606/     A40 : E1                  	POP	HL		; Restore code string address
    1607/     A41 : C9                  	RET
    1608/     A42 :                     ;
    1609/     A42 : CD 08 14            ON:	CALL	GETINT		; Get integer 0-255
    1610/     A45 : 7E                  	LD	A,(HL)		; Get "GOTO" or "GOSUB" token
    1611/     A46 : 47                  	LD	B,A		; Save in B
    1612/     A47 : FE 8C               	CP	ZGOSUB		; "GOSUB" token?
    1613/     A49 : CA 51 0A            	JP	Z,ONGO		; Yes - Find line number
    1614/     A4C : CD B2 06            	CALL	CHKSYN		; Make sure it's "GOTO"
    1615/     A4F : 88                  	DB	ZGOTO		; "GOTO" token
    1616/     A50 : 2B                  	DEC	HL		; Cancel increment
    1617/     A51 : 4B                  ONGO:	LD	C,E		; Integer of branch value
    1618/     A52 : 0D                  ONGOLP: DEC	C		; Count branches
    1619/     A53 : 78                  	LD	A,B		; Get "GOTO" or "GOSUB" token
    1620/     A54 : CA 22 08            	JP	Z,ONJMP		; Go to that line if right one
    1621/     A57 : CD 07 09            	CALL	GETLN		; Get line number to DE
    1622/     A5A : FE 2C               	CP	','		; Another line number?
    1623/     A5C : C0                  	RET	NZ		; No - Drop through
    1624/     A5D : C3 52 0A            	JP	ONGOLP		; Yes - loop
    1625/     A60 :                     ;
    1626/     A60 : CD B9 0C            IF_:	CALL	EVAL		; Evaluate expression
    1627/     A63 : 7E                  	LD	A,(HL)		; Get token
    1628/     A64 : FE 88               	CP	ZGOTO		; "GOTO" token?
    1629/     A66 : CA 6E 0A            	JP	Z,IFGO		; Yes - Get line
    1630/     A69 : CD B2 06            	CALL	CHKSYN		; Make sure it's "THEN"
    1631/     A6C : A9                  	DB	ZTHEN		; "THEN" token
    1632/     A6D : 2B                  	DEC	HL		; Cancel increment
    1633/     A6E : CD AA 0C            IFGO:	CALL	TSTNUM		; Make sure it's numeric
    1634/     A71 : CD 89 16            	CALL	TSTSGN		; Test state of expression
    1635/     A74 : CA D3 09            	JP	Z,REM		; False - Drop through
    1636/     A77 : CD 3A 08            	CALL	GETCHR		; Get next character
    1637/     A7A : DA 8E 09            	JP	C,GOTO		; Number - GOTO that line
    1638/     A7D : C3 21 08            	JP	IFJMP		; Otherwise do statement
    1639/     A80 :                     ;
    1640/     A80 : 2B                  MRPRNT: DEC	HL		; DEC 'cos GETCHR INCs
    1641/     A81 : CD 3A 08            	CALL	GETCHR		; Get next character
    1642/     A84 : CA E2 0A            PRINT:	JP	Z,PRCRLF	; CRLF if just PRINT
    1643/     A87 : C8                  PRNTLP: RET	Z		; End of list - Exit
    1644/     A88 : FE A5               	CP	ZTAB		; "TAB(" token?
    1645/     A8A : CA 15 0B            	JP	Z,DOTAB		; Yes - Do TAB routine
    1646/     A8D : FE A8               	CP	ZSPC		; "SPC(" token?
    1647/     A8F : CA 15 0B            	JP	Z,DOTAB		; Yes - Do SPC routine
    1648/     A92 : E5                  	PUSH	HL		; Save code string address
    1649/     A93 : FE 2C               	CP	','		; Comma?
    1650/     A95 : CA FE 0A            	JP	Z,DOCOM		; Yes - Move to next zone
    1651/     A98 : FE 3B               	CP	59;";"		; Semi-colon?
    1652/     A9A : CA 38 0B            	JP	Z,NEXITM	; Do semi-colon routine
    1653/     A9D : C1                  	POP	BC		; Code string address to BC
    1654/     A9E : CD B9 0C            	CALL	EVAL		; Evaluate expression
    1655/     AA1 : E5                  	PUSH	HL		; Save code string address
    1656/     AA2 : 3A F2 1D            	LD	A,(TYPE)	; Get variable type
    1657/     AA5 : B7                  	OR	A		; Is it a string variable?
    1658/     AA6 : C2 CE 0A            	JP	NZ,PRNTST	; Yes - Output string contents
    1659/     AA9 : CD 2E 18            	CALL	NUMASC		; Convert number to text
    1660/     AAC : CD 3E 11            	CALL	CRTST		; Create temporary string
    1661/     AAF : 36 20               	LD	(HL),' '	; Followed by a space
    1662/     AB1 : 2A 29 1E            	LD	HL,(FPREG)	; Get length of output
    1663/     AB4 : 34                  	INC	(HL)		; Plus 1 for the space
    1664/     AB5 : 2A 29 1E            	LD	HL,(FPREG)	; < Not needed >
    1665/     AB8 : 3A 87 1D            	LD	A,(LWIDTH)	; Get width of line
    1666/     ABB : 47                  	LD	B,A		; To B
    1667/     ABC : 04                  	INC	B		; Width 255 (No limit)?
    1668/     ABD : CA CA 0A            	JP	Z,PRNTNB	; Yes - Output number string
    1669/     AC0 : 04                  	INC	B		; Adjust it
    1670/     AC1 : 3A F0 1D            	LD	A,(CURPOS)	; Get cursor position
    1671/     AC4 : 86                  	ADD	A,(HL)		; Add length of string
    1672/     AC5 : 3D                  	DEC	A		; Adjust it
    1673/     AC6 : B8                  	CP	B		; Will output fit on this line?
    1674/     AC7 : D4 E2 0A            	CALL	NC,PRCRLF	; No - CRLF first
    1675/     ACA : CD 83 11            PRNTNB: CALL	PRS1		; Output string at (HL)
    1676/     ACD : AF                  	XOR	A		; Skip CALL by setting 'z' flag
    1677/     ACE : C4 83 11            PRNTST: CALL	NZ,PRS1		; Output string at (HL)
    1678/     AD1 : E1                  	POP	HL		; Restore code string address
    1679/     AD2 : C3 80 0A            	JP	MRPRNT		; See if more to PRINT
    1680/     AD5 :                     ;
    1681/     AD5 : 3A F0 1D            STTLIN: LD	A,(CURPOS)	; Make sure on new line
    1682/     AD8 : B7                  	OR	A		; Already at start?
    1683/     AD9 : C8                  	RET	Z		; Yes - Do nothing
    1684/     ADA : C3 E2 0A            	JP	PRCRLF		; Start a new line
    1685/     ADD :                     ;
    1686/     ADD : 36 00               ENDINP: LD	(HL),0		; Mark end of buffer
    1687/     ADF : 21 A5 1D            	LD	HL,BUFFER-1	; Point to buffer
    1688/     AE2 : 3E 0D               PRCRLF: LD	A,CR		; Load a CR
    1689/     AE4 : CD BD 06            	CALL	OUTC		; Output character
    1690/     AE7 : 3E 0A               	LD	A,LF		; Load a LF
    1691/     AE9 : CD BD 06            	CALL	OUTC		; Output character
    1692/     AEC : AF                  DONULL: XOR	A		; Set to position 0
    1693/     AED : 32 F0 1D            	LD	(CURPOS),A	; Store it
    1694/     AF0 : 3A 86 1D            	LD	A,(NULLS)	; Get number of nulls
    1695/     AF3 : 3D                  NULLP:	DEC	A		; Count them
    1696/     AF4 : C8                  	RET	Z		; Return if done
    1697/     AF5 : F5                  	PUSH	AF		; Save count
    1698/     AF6 : AF                  	XOR	A		; Load a null
    1699/     AF7 : CD BD 06            	CALL	OUTC		; Output it
    1700/     AFA : F1                  	POP	AF		; Restore count
    1701/     AFB : C3 F3 0A            	JP	NULLP		; Keep counting
    1702/     AFE :                     ;
    1703/     AFE : 3A 88 1D            DOCOM:	LD	A,(COMMAN)	; Get comma width
    1704/     B01 : 47                  	LD	B,A		; Save in B
    1705/     B02 : 3A F0 1D            	LD	A,(CURPOS)	; Get current position
    1706/     B05 : B8                  	CP	B		; Within the limit?
    1707/     B06 : D4 E2 0A            	CALL	NC,PRCRLF	; No - output CRLF
    1708/     B09 : D2 38 0B            	JP	NC,NEXITM	; Get next item
    1709/     B0C : D6 0E               ZONELP: SUB	14		; Next zone of 14 characters
    1710/     B0E : D2 0C 0B            	JP	NC,ZONELP	; Repeat if more zones
    1711/     B11 : 2F                  	CPL			; Number of spaces to output
    1712/     B12 : C3 2D 0B            	JP	ASPCS		; Output them
    1713/     B15 :                     ;
    1714/     B15 : F5                  DOTAB:	PUSH	AF		; Save token
    1715/     B16 : CD 05 14            	CALL	FNDNUM		; Evaluate expression
    1716/     B19 : CD B2 06            	CALL	CHKSYN		; Make sure ")" follows
    1717/     B1C : 29                  	DB	")"
    1718/     B1D : 2B                  	DEC	HL		; Back space on to ")"
    1719/     B1E : F1                  	POP	AF		; Restore token
    1720/     B1F : D6 A8               	SUB	ZSPC		; Was it "SPC(" ?
    1721/     B21 : E5                  	PUSH	HL		; Save code string address
    1722/     B22 : CA 28 0B            	JP	Z,DOSPC	; Yes - Do 'E' spaces
    1723/     B25 : 3A F0 1D            	LD	A,(CURPOS)	; Get current position
    1724/     B28 : 2F                  DOSPC:	CPL			; Number of spaces to print to
    1725/     B29 : 83                  	ADD	A,E		; Total number to print
    1726/     B2A : D2 38 0B            	JP	NC,NEXITM	; TAB < Current POS(X)
    1727/     B2D : 3C                  ASPCS:	INC	A		; Output A spaces
    1728/     B2E : 47                  	LD	B,A		; Save number to print
    1729/     B2F : 3E 20               	LD	A,' '		; Space
    1730/     B31 : CD BD 06            SPCLP:	CALL	OUTC		; Output character in A
    1731/     B34 : 05                  	DEC	B		; Count them
    1732/     B35 : C2 31 0B            	JP	NZ,SPCLP	; Repeat if more
    1733/     B38 : E1                  NEXITM: POP	HL		; Restore code string address
    1734/     B39 : CD 3A 08            	CALL	GETCHR		; Get next character
    1735/     B3C : C3 87 0A            	JP	PRNTLP		; More to print
    1736/     B3F :                     ;
    1737/     B3F : 3F 52 65 64 6F 20   REDO:	DB	"?Redo from start",CR,LF,0
              B45 : 66 72 6F 6D 20 73 
              B4B : 74 61 72 74 0D 0A 
              B51 : 00                
    1738/     B52 :                     ;
    1739/     B52 : 3A 12 1E            BADINP: LD	A,(READFG)	; READ or INPUT?
    1740/     B55 : B7                  	OR	A
    1741/     B56 : C2 DE 03            	JP	NZ,DATSNR	; READ - ?SN Error
    1742/     B59 : C1                  	POP	BC		; Throw away code string addr
    1743/     B5A : 21 3F 0B            	LD	HL,REDO		; "Redo from start" message
    1744/     B5D : CD 80 11            	CALL	PRS		; Output string
    1745/     B60 : C3 2F 05            	JP	DOAGN		; Do last INPUT again
    1746/     B63 :                     ;
    1747/     B63 : CD EB 10            INPUT:	CALL	IDTEST		; Test for illegal direct
    1748/     B66 : 7E                  	LD	A,(HL)		; Get character after "INPUT"
    1749/     B67 : FE 22               	CP	'"'		; Is there a prompt string?
    1750/     B69 : 3E 00               	LD	A,0		; Clear A and leave flags
    1751/     B6B : 32 8A 1D            	LD	(CTLOFG),A	; Enable output
    1752/     B6E : C2 7D 0B            	JP	NZ,NOPMPT	; No prompt - get input
    1753/     B71 : CD 3F 11            	CALL	QTSTR		; Get string terminated by '"'
    1754/     B74 : CD B2 06            	CALL	CHKSYN		; Check for ';' after prompt
    1755/     B77 : 3B                  	DB	';'
    1756/     B78 : E5                  	PUSH	HL		; Save code string address
    1757/     B79 : CD 83 11            	CALL	PRS1		; Output prompt string
    1758/     B7C : 3E                  	DB	3EH		; Skip "PUSH HL"
    1759/     B7D : E5                  NOPMPT: PUSH	HL		; Save code string address
    1760/     B7E : CD 33 05            	CALL	PROMPT		; Get input with "? " prompt
    1761/     B81 : C1                  	POP	BC		; Restore code string address
    1762/     B82 : DA 89 08            	JP	C,INPBRK	; Break pressed - Exit
    1763/     B85 : 23                  	INC	HL		; Next byte
    1764/     B86 : 7E                  	LD	A,(HL)		; Get it
    1765/     B87 : B7                  	OR	A		; End of line?
    1766/     B88 : 2B                  	DEC	HL		; Back again
    1767/     B89 : C5                  	PUSH	BC		; Re-save code string address
    1768/     B8A : CA D0 09            	JP	Z,NXTDTA	; Yes - Find next DATA stmt
    1769/     B8D : 36 2C               	LD	(HL),','	; Store comma as separator
    1770/     B8F : C3 97 0B            	JP	NXTITM		; Get next item
    1771/     B92 :                     ;
    1772/     B92 : E5                  READ:	PUSH	HL		; Save code string address
    1773/     B93 : 2A 21 1E            	LD	HL,(NXTDAT)	; Next DATA statement
    1774/     B96 : F6                  	DB	0F6H		; Flag "READ"
    1775/     B97 : AF                  NXTITM: XOR	A		; Flag "INPUT"
    1776/     B98 : 32 12 1E            	LD	(READFG),A	; Save "READ"/"INPUT" flag
    1777/     B9B : E3                  	EX	(SP),HL		; Get code str' , Save pointer
    1778/     B9C : C3 A3 0B            	JP	GTVLUS		; Get values
    1779/     B9F :                     ;
    1780/     B9F : CD B2 06            NEDMOR: CALL	CHKSYN		; Check for comma between items
    1781/     BA2 : 2C                  	DB	','
    1782/     BA3 : CD 9D 0E            GTVLUS: CALL	GETVAR		; Get variable name
    1783/     BA6 : E3                  	EX	(SP),HL		; Save code str" , Get pointer
    1784/     BA7 : D5                  	PUSH	DE		; Save variable address
    1785/     BA8 : 7E                  	LD	A,(HL)		; Get next "INPUT"/"DATA" byte
    1786/     BA9 : FE 2C               	CP	','		; Comma?
    1787/     BAB : CA CB 0B            	JP	Z,ANTVLU	; Yes - Get another value
    1788/     BAE : 3A 12 1E            	LD	A,(READFG)	; Is it READ?
    1789/     BB1 : B7                  	OR	A
    1790/     BB2 : C2 38 0C            	JP	NZ,FDTLP	; Yes - Find next DATA stmt
    1791/     BB5 : 3E 3F               	LD	A,'?'		; More INPUT needed
    1792/     BB7 : CD BD 06            	CALL	OUTC		; Output character
    1793/     BBA : CD 33 05            	CALL	PROMPT		; Get INPUT with prompt
    1794/     BBD : D1                  	POP	DE		; Variable address
    1795/     BBE : C1                  	POP	BC		; Code string address
    1796/     BBF : DA 89 08            	JP	C,INPBRK	; Break pressed
    1797/     BC2 : 23                  	INC	HL		; Point to next DATA byte
    1798/     BC3 : 7E                  	LD	A,(HL)		; Get byte
    1799/     BC4 : B7                  	OR	A		; Is it zero (No input) ?
    1800/     BC5 : 2B                  	DEC	HL		; Back space INPUT pointer
    1801/     BC6 : C5                  	PUSH	BC		; Save code string address
    1802/     BC7 : CA D0 09            	JP	Z,NXTDTA	; Find end of buffer
    1803/     BCA : D5                  	PUSH	DE		; Save variable address
    1804/     BCB : 3A F2 1D            ANTVLU: LD	A,(TYPE)	; Check data type
    1805/     BCE : B7                  	OR	A		; Is it numeric?
    1806/     BCF : CA F5 0B            	JP	Z,INPBIN	; Yes - Convert to binary
    1807/     BD2 : CD 3A 08            	CALL	GETCHR		; Get next character
    1808/     BD5 : 57                  	LD	D,A		; Save input character
    1809/     BD6 : 47                  	LD	B,A		; Again
    1810/     BD7 : FE 22               	CP	'"'		; Start of literal sting?
    1811/     BD9 : CA E9 0B            	JP	Z,STRENT	; Yes - Create string entry
    1812/     BDC : 3A 12 1E            	LD	A,(READFG)	; "READ" or "INPUT" ?
    1813/     BDF : B7                  	OR	A
    1814/     BE0 : 57                  	LD	D,A		; Save 00 if "INPUT"
    1815/     BE1 : CA E6 0B            	JP	Z,ITMSEP	; "INPUT" - End with 00
    1816/     BE4 : 16 3A               	LD	D,':'		; "DATA" - End with 00 or ':'
    1817/     BE6 : 06 2C               ITMSEP: LD	B,','		; Item separator
    1818/     BE8 : 2B                  	DEC	HL		; Back space for DTSTR
    1819/     BE9 : CD 42 11            STRENT: CALL	DTSTR		; Get string terminated by D
    1820/     BEC : EB                  	EX	DE,HL		; String address to DE
    1821/     BED : 21 00 0C            	LD	HL,LTSTND	; Where to go after LETSTR
    1822/     BF0 : E3                  	EX	(SP),HL		; Save HL , get input pointer
    1823/     BF1 : D5                  	PUSH	DE		; Save address of string
    1824/     BF2 : C3 03 0A            	JP	LETSTR		; Assign string to variable
    1825/     BF5 :                     ;
    1826/     BF5 : CD 3A 08            INPBIN: CALL	GETCHR		; Get next character
    1827/     BF8 : CD 90 17            	CALL	ASCTFP		; Convert ASCII to FP number
    1828/     BFB : E3                  	EX	(SP),HL		; Save input ptr, Get var addr
    1829/     BFC : CD E1 16            	CALL	FPTHL		; Move FPREG to variable
    1830/     BFF : E1                  	POP	HL		; Restore input pointer
    1831/     C00 : 2B                  LTSTND: DEC	HL		; DEC 'cos GETCHR INCs
    1832/     C01 : CD 3A 08            	CALL	GETCHR		; Get next character
    1833/     C04 : CA 0C 0C            	JP	Z,MORDT		; End of line - More needed?
    1834/     C07 : FE 2C               	CP	','		; Another value?
    1835/     C09 : C2 52 0B            	JP	NZ,BADINP	; No - Bad input
    1836/     C0C : E3                  MORDT:	EX	(SP),HL		; Get code string address
    1837/     C0D : 2B                  	DEC	HL		; DEC 'cos GETCHR INCs
    1838/     C0E : CD 3A 08            	CALL	GETCHR		; Get next character
    1839/     C11 : C2 9F 0B            	JP	NZ,NEDMOR	; More needed - Get it
    1840/     C14 : D1                  	POP	DE		; Restore DATA pointer
    1841/     C15 : 3A 12 1E            	LD	A,(READFG)	; "READ" or "INPUT" ?
    1842/     C18 : B7                  	OR	A
    1843/     C19 : EB                  	EX	DE,HL		; DATA pointer to HL
    1844/     C1A : C2 60 08            	JP	NZ,UPDATA	; Update DATA pointer if "READ"
    1845/     C1D : D5                  	PUSH	DE		; Save code string address
    1846/     C1E : B6                  	OR	(HL)		; More input given?
    1847/     C1F : 21 27 0C            	LD	HL,EXTIG	; "?Extra ignored" message
    1848/     C22 : C4 80 11            	CALL	NZ,PRS		; Output string if extra given
    1849/     C25 : E1                  	POP	HL		; Restore code string address
    1850/     C26 : C9                  	RET
    1851/     C27 :                     ;
    1852/     C27 : 3F 45 78 74 72 61   EXTIG:	DB	"?Extra ignored",CR,LF,0
              C2D : 20 69 67 6E 6F 72 
              C33 : 65 64 0D 0A 00    
    1853/     C38 :                     ;
    1854/     C38 : CD D1 09            FDTLP:	CALL	DATA		; Get next statement
    1855/     C3B : B7                  	OR	A		; End of line?
    1856/     C3C : C2 51 0C            	JP	NZ,FANDT	; No - See if DATA statement
    1857/     C3F : 23                  	INC	HL
    1858/     C40 : 7E                  	LD	A,(HL)		; End of program?
    1859/     C41 : 23                  	INC	HL
    1860/     C42 : B6                  	OR	(HL)		; 00 00 Ends program
    1861/     C43 : 1E 06               	LD	E,OD		; ?OD Error
    1862/     C45 : CA F8 03            	JP	Z,ERROR_	; Yes - Out of DATA
    1863/     C48 : 23                  	INC	HL
    1864/     C49 : 5E                  	LD	E,(HL)		; LSB of line number
    1865/     C4A : 23                  	INC	HL
    1866/     C4B : 56                  	LD	D,(HL)		; MSB of line number
    1867/     C4C : EB                  	EX	DE,HL
    1868/     C4D : 22 0E 1E            	LD	(DATLIN),HL	; Set line of current DATA item
    1869/     C50 : EB                  	EX	DE,HL
    1870/     C51 : CD 3A 08            FANDT:	CALL	GETCHR		; Get next character
    1871/     C54 : FE 83               	CP	ZDATA		; "DATA" token
    1872/     C56 : C2 38 0C            	JP	NZ,FDTLP	; No "DATA" - Keep looking
    1873/     C59 : C3 CB 0B            	JP	ANTVLU		; Found - Convert input
    1874/     C5C :                     ;
    1875/     C5C : 11 00 00            NEXT:	LD	DE,0		; In case no index given
    1876/     C5F : C4 9D 0E            NEXT1:	CALL	NZ,GETVAR	; Get index address
    1877/     C62 : 22 13 1E            	LD	(BRKLIN),HL	; Save code string address
    1878/     C65 : CD 8D 03            	CALL	BAKSTK		; Look for "FOR" block
    1879/     C68 : C2 EA 03            	JP	NZ,NFERR	; No "FOR" - ?NF Error
    1880/     C6B : F9                  	LD	SP,HL		; Clear nested loops
    1881/     C6C : D5                  	PUSH	DE		; Save index address
    1882/     C6D : 7E                  	LD	A,(HL)		; Get sign of STEP
    1883/     C6E : 23                  	INC	HL
    1884/     C6F : F5                  	PUSH	AF		; Save sign of STEP
    1885/     C70 : D5                  	PUSH	DE		; Save index address
    1886/     C71 : CD C7 16            	CALL	PHLTFP		; Move index value to FPREG
    1887/     C74 : E3                  	EX	(SP),HL		; Save address of TO value
    1888/     C75 : E5                  	PUSH	HL		; Save address of index
    1889/     C76 : CD 34 14            	CALL	ADDPHL		; Add STEP to index value
    1890/     C79 : E1                  	POP	HL		; Restore address of index
    1891/     C7A : CD E1 16            	CALL	FPTHL		; Move value to index variable
    1892/     C7D : E1                  	POP	HL		; Restore address of TO value
    1893/     C7E : CD D8 16            	CALL	LOADFP		; Move TO value to BCDE
    1894/     C81 : E5                  	PUSH	HL		; Save address of line of FOR
    1895/     C82 : CD 04 17            	CALL	CMPNUM		; Compare index with TO value
    1896/     C85 : E1                  	POP	HL		; Restore address of line num
    1897/     C86 : C1                  	POP	BC		; Address of sign of STEP
    1898/     C87 : 90                  	SUB	B		; Compare with expected sign
    1899/     C88 : CD D8 16            	CALL	LOADFP		; BC = Loop stmt,DE = Line num
    1900/     C8B : CA 97 0C            	JP	Z,KILFOR	; Loop finished - Terminate it
    1901/     C8E : EB                  	EX	DE,HL		; Loop statement line number
    1902/     C8F : 22 A1 1D            	LD	(LINEAT),HL	; Set loop line number
    1903/     C92 : 69                  	LD	L,C		; Set code string to loop
    1904/     C93 : 60                  	LD	H,B
    1905/     C94 : C3 F6 07            	JP	PUTFID		; Put back "FOR" and continue
    1906/     C97 :                     ;
    1907/     C97 : F9                  KILFOR: LD	SP,HL		; Remove "FOR" block
    1908/     C98 : 2A 13 1E            	LD	HL,(BRKLIN)	; Code string after "NEXT"
    1909/     C9B : 7E                  	LD	A,(HL)		; Get next byte in code string
    1910/     C9C : FE 2C               	CP	','		; More NEXTs ?
    1911/     C9E : C2 FA 07            	JP	NZ,RUNCNT	; No - Do next statement
    1912/     CA1 : CD 3A 08            	CALL	GETCHR		; Position to index name
    1913/     CA4 : CD 5F 0C            	CALL	NEXT1		; Re-enter NEXT routine
    1914/     CA7 :                     ; < will not RETurn to here , Exit to RUNCNT or Loop >
    1915/     CA7 :                     ;
    1916/     CA7 : CD B9 0C            GETNUM: CALL	EVAL		; Get a numeric expression
    1917/     CAA : F6                  TSTNUM: DB	0F6H		; Clear carry (numeric)
    1918/     CAB : 37                  TSTSTR: SCF			; Set carry (string)
    1919/     CAC : 3A F2 1D            CHKTYP: LD	A,(TYPE)	; Check types match
    1920/     CAF : 8F                  	ADC	A,A		; Expected + actual
    1921/     CB0 : B7                  	OR	A		; Clear carry , set parity
    1922/     CB1 : E8                  	RET	PE		; Even parity - Types match
    1923/     CB2 : C3 F6 03            	JP	TMERR		; Different types - Error
    1924/     CB5 :                     ;
    1925/     CB5 : CD B2 06            OPNPAR: CALL	CHKSYN		; Make sure "(" follows
    1926/     CB8 : 28                  	DB	"("
    1927/     CB9 : 2B                  EVAL:	DEC	HL		; Evaluate expression & save
    1928/     CBA : 16 00               	LD	D,0		; Precedence value
    1929/     CBC : D5                  EVAL1:	PUSH	DE		; Save precedence
    1930/     CBD : 0E 01               	LD	C,1
    1931/     CBF : CD C1 03            	CALL	CHKSTK		; Check for 1 level of stack
    1932/     CC2 : CD 30 0D            	CALL	OPRND		; Get next expression value
    1933/     CC5 : 22 15 1E            EVAL2:	LD	(NXTOPR),HL	; Save address of next operator
    1934/     CC8 : 2A 15 1E            EVAL3:	LD	HL,(NXTOPR)	; Restore address of next opr
    1935/     CCB : C1                  	POP	BC		; Precedence value and operator
    1936/     CCC : 78                  	LD	A,B		; Get precedence value
    1937/     CCD : FE 78               	CP	78H		; "AND" or "OR" ?
    1938/     CCF : D4 AA 0C            	CALL	NC,TSTNUM	; No - Make sure it's a number
    1939/     CD2 : 7E                  	LD	A,(HL)		; Get next operator / function
    1940/     CD3 : 16 00               	LD	D,0		; Clear Last relation
    1941/     CD5 : D6 B3               RLTLP:	SUB	ZGTR		; ">" Token
    1942/     CD7 : DA F1 0C            	JP	C,FOPRND	; + - * / ^ AND OR - Test it
    1943/     CDA : FE 03               	CP	ZLTH+1-ZGTR	; < = >
    1944/     CDC : D2 F1 0C            	JP	NC,FOPRND	; Function - Call it
    1945/     CDF : FE 01               	CP	ZEQUAL-ZGTR	; "="
    1946/     CE1 : 17                  	RLA			; <- Test for legal
    1947/     CE2 : AA                  	XOR	D		; <- combinations of < = >
    1948/     CE3 : BA                  	CP	D		; <- by combining last token
    1949/     CE4 : 57                  	LD	D,A		; <- with current one
    1950/     CE5 : DA E4 03            	JP	C,SNERR		; Error if "<<' '==" or ">>"
    1951/     CE8 : 22 0A 1E            	LD	(CUROPR),HL	; Save address of current token
    1952/     CEB : CD 3A 08            	CALL	GETCHR		; Get next character
    1953/     CEE : C3 D5 0C            	JP	RLTLP		; Treat the two as one
    1954/     CF1 :                     ;
    1955/     CF1 : 7A                  FOPRND: LD	A,D		; < = > found ?
    1956/     CF2 : B7                  	OR	A
    1957/     CF3 : C2 18 0E            	JP	NZ,TSTRED	; Yes - Test for reduction
    1958/     CF6 : 7E                  	LD	A,(HL)		; Get operator token
    1959/     CF7 : 22 0A 1E            	LD	(CUROPR),HL	; Save operator address
    1960/     CFA : D6 AC               	SUB	ZPLUS		; Operator or function?
    1961/     CFC : D8                  	RET	C		; Neither - Exit
    1962/     CFD : FE 07               	CP	ZOR+1-ZPLUS	; Is it + - * / ^ AND OR ?
    1963/     CFF : D0                  	RET	NC		; No - Exit
    1964/     D00 : 5F                  	LD	E,A		; Coded operator
    1965/     D01 : 3A F2 1D            	LD	A,(TYPE)	; Get data type
    1966/     D04 : 3D                  	DEC	A		; FF = numeric , 00 = string
    1967/     D05 : B3                  	OR	E		; Combine with coded operator
    1968/     D06 : 7B                  	LD	A,E		; Get coded operator
    1969/     D07 : CA 76 12            	JP	Z,CONCAT	; String concatenation
    1970/     D0A : 07                  	RLCA			; Times 2
    1971/     D0B : 83                  	ADD	A,E		; Times 3
    1972/     D0C : 5F                  	LD	E,A		; To DE (D is 0)
    1973/     D0D : 21 D6 02            	LD	HL,PRITAB	; Precedence table
    1974/     D10 : 19                  	ADD	HL,DE		; To the operator concerned
    1975/     D11 : 78                  	LD	A,B		; Last operator precedence
    1976/     D12 : 56                  	LD	D,(HL)		; Get evaluation precedence
    1977/     D13 : BA                  	CP	D		; Compare with eval precedence
    1978/     D14 : D0                  	RET	NC		; Exit if higher precedence
    1979/     D15 : 23                  	INC	HL		; Point to routine address
    1980/     D16 : CD AA 0C            	CALL	TSTNUM		; Make sure it's a number
    1981/     D19 :                     ;
    1982/     D19 : C5                  STKTHS: PUSH	BC		; Save last precedence & token
    1983/     D1A : 01 C8 0C            	LD	BC,EVAL3	; Where to go on prec' break
    1984/     D1D : C5                  	PUSH	BC		; Save on stack for return
    1985/     D1E : 43                  	LD	B,E		; Save operator
    1986/     D1F : 4A                  	LD	C,D		; Save precedence
    1987/     D20 : CD BA 16            	CALL	STAKFP		; Move value to stack
    1988/     D23 : 58                  	LD	E,B		; Restore operator
    1989/     D24 : 51                  	LD	D,C		; Restore precedence
    1990/     D25 : 4E                  	LD	C,(HL)		; Get LSB of routine address
    1991/     D26 : 23                  	INC	HL
    1992/     D27 : 46                  	LD	B,(HL)		; Get MSB of routine address
    1993/     D28 : 23                  	INC	HL
    1994/     D29 : C5                  	PUSH	BC		; Save routine address
    1995/     D2A : 2A 0A 1E            	LD	HL,(CUROPR)	; Address of current operator
    1996/     D2D : C3 BC 0C            	JP	EVAL1		; Loop until prec' break
    1997/     D30 :                     ;
    1998/     D30 : AF                  OPRND:	XOR	A		; Get operand routine
    1999/     D31 : 32 F2 1D            	LD	(TYPE),A	; Set numeric expected
    2000/     D34 : CD 3A 08            	CALL	GETCHR		; Get next character
    2001/     D37 : 1E 24               	LD	E,MO		; ?MO Error
    2002/     D39 : CA F8 03            	JP	Z,ERROR_	; No operand - Error
    2003/     D3C : DA 90 17            	JP	C,ASCTFP	; Number - Get value
    2004/     D3F : CD D8 08            	CALL	CHKLTR		; See if a letter
    2005/     D42 : D2 97 0D            	JP	NC,CONVAR	; Letter - Find variable
    2006/     D45 : FE 26               	CP	'&'		; &H = HEX, &B = BINARY
    2007/     D47 : 20 12               	JR	NZ, NOTAMP
    2008/     D49 : CD 3A 08            	CALL	GETCHR		; Get next character
    2009/     D4C : FE 48               	CP	'H'		; Hex number indicated? [function added]
    2010/     D4E : CA D3 1B            	JP	Z,HEXTFP	; Convert Hex to FPREG
    2011/     D51 : FE 42               	CP	'B'		; Binary number indicated? [function added]
    2012/     D53 : CA 43 1C            	JP	Z,BINTFP	; Convert Bin to FPREG
    2013/     D56 : 1E 02               	LD	E,SN		; If neither then a ?SN Error
    2014/     D58 : CA F8 03            	JP	Z,ERROR_
    2015/     D5B : FE AC               NOTAMP: CP	ZPLUS		; '+' Token ?
    2016/     D5D : CA 30 0D            	JP	Z,OPRND		; Yes - Look for operand
    2017/     D60 : FE 2E               	CP	'.'		; '.' ?
    2018/     D62 : CA 90 17            	JP	Z,ASCTFP	; Yes - Create FP number
    2019/     D65 : FE AD               	CP	ZMINUS		; '-' Token ?
    2020/     D67 : CA 86 0D            	JP	Z,MINUS		; Yes - Do minus
    2021/     D6A : FE 22               	CP	'"'		; Literal string ?
    2022/     D6C : CA 3F 11            	JP	Z,QTSTR		; Get string terminated by '"'
    2023/     D6F : FE AA               	CP	ZNOT		; "NOT" Token ?
    2024/     D71 : CA 78 0E            	JP	Z,EVNOT		; Yes - Eval NOT expression
    2025/     D74 : FE A7               	CP	ZFN		; "FN" Token ?
    2026/     D76 : CA A3 10            	JP	Z,DOFN		; Yes - Do FN routine
    2027/     D79 : D6 B6               	SUB	ZSGN		; Is it a function?
    2028/     D7B : D2 A8 0D            	JP	NC,FNOFST	; Yes - Evaluate function
    2029/     D7E : CD B5 0C            EVLPAR: CALL	OPNPAR		; Evaluate expression in "()"
    2030/     D81 : CD B2 06            	CALL	CHKSYN		; Make sure ")" follows
    2031/     D84 : 29                  	DB	")"
    2032/     D85 : C9                  	RET
    2033/     D86 :                     ;
    2034/     D86 : 16 7D               MINUS:	LD	D,7DH		; '-' precedence
    2035/     D88 : CD BC 0C            	CALL	EVAL1		; Evaluate until prec' break
    2036/     D8B : 2A 15 1E            	LD	HL,(NXTOPR)	; Get next operator address
    2037/     D8E : E5                  	PUSH	HL		; Save next operator address
    2038/     D8F : CD B2 16            	CALL	INVSGN		; Negate value
    2039/     D92 : CD AA 0C            RETNUM: CALL	TSTNUM		; Make sure it's a number
    2040/     D95 : E1                  	POP	HL		; Restore next operator address
    2041/     D96 : C9                  	RET
    2042/     D97 :                     ;
    2043/     D97 : CD 9D 0E            CONVAR: CALL	GETVAR		; Get variable address to DE
    2044/     D9A : E5                  FRMEVL: PUSH	HL		; Save code string address
    2045/     D9B : EB                  	EX	DE,HL		; Variable address to HL
    2046/     D9C : 22 29 1E            	LD	(FPREG),HL	; Save address of variable
    2047/     D9F : 3A F2 1D            	LD	A,(TYPE)	; Get type
    2048/     DA2 : B7                  	OR	A		; Numeric?
    2049/     DA3 : CC C7 16            	CALL	Z,PHLTFP	; Yes - Move contents to FPREG
    2050/     DA6 : E1                  	POP	HL		; Restore code string address
    2051/     DA7 : C9                  	RET
    2052/     DA8 :                     ;
    2053/     DA8 : 06 00               FNOFST: LD	B,0		; Get address of function
    2054/     DAA : 07                  	RLCA			; Double function offset
    2055/     DAB : 4F                  	LD	C,A		; BC = Offset in function table
    2056/     DAC : C5                  	PUSH	BC		; Save adjusted token value
    2057/     DAD : CD 3A 08            	CALL	GETCHR		; Get next character
    2058/     DB0 : 79                  	LD	A,C		; Get adjusted token value
    2059/     DB1 : FE 31               	CP	2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
    2060/     DB3 : DA CF 0D            	JP	C,FNVAL		; No - Do function
    2061/     DB6 : CD B5 0C            	CALL	OPNPAR		; Evaluate expression	(X,...
    2062/     DB9 : CD B2 06            	CALL	CHKSYN		; Make sure ',' follows
    2063/     DBC : 2C                  	DB	','
    2064/     DBD : CD AB 0C            	CALL	TSTSTR		; Make sure it's a string
    2065/     DC0 : EB                  	EX	DE,HL		; Save code string address
    2066/     DC1 : 2A 29 1E            	LD	HL,(FPREG)	; Get address of string
    2067/     DC4 : E3                  	EX	(SP),HL		; Save address of string
    2068/     DC5 : E5                  	PUSH	HL		; Save adjusted token value
    2069/     DC6 : EB                  	EX	DE,HL		; Restore code string address
    2070/     DC7 : CD 08 14            	CALL	GETINT		; Get integer 0-255
    2071/     DCA : EB                  	EX	DE,HL		; Save code string address
    2072/     DCB : E3                  	EX	(SP),HL		; Save integer,HL = adj' token
    2073/     DCC : C3 D7 0D            	JP	GOFUNC		; Jump to string function
    2074/     DCF :                     ;
    2075/     DCF : CD 7E 0D            FNVAL:	CALL	EVLPAR		; Evaluate expression
    2076/     DD2 : E3                  	EX	(SP),HL		; HL = Adjusted token value
    2077/     DD3 : 11 92 0D            	LD	DE,RETNUM	; Return number from function
    2078/     DD6 : D5                  	PUSH	DE		; Save on stack
    2079/     DD7 : 01 35 01            GOFUNC: LD	BC,FNCTAB	; Function routine addresses
    2080/     DDA : 09                  	ADD	HL,BC		; Point to right address
    2081/     DDB : 4E                  	LD	C,(HL)		; Get LSB of address
    2082/     DDC : 23                  	INC	HL		;
    2083/     DDD : 66                  	LD	H,(HL)		; Get MSB of address
    2084/     DDE : 69                  	LD	L,C		; Address to HL
    2085/     DDF : E9                  	JP	(HL)		; Jump to function
    2086/     DE0 :                     ;
    2087/     DE0 : 15                  SGNEXP: DEC	D		; Dee to flag negative exponent
    2088/     DE1 : FE AD               	CP	ZMINUS		; '-' token ?
    2089/     DE3 : C8                  	RET	Z		; Yes - Return
    2090/     DE4 : FE 2D               	CP	'-'		; '-' ASCII ?
    2091/     DE6 : C8                  	RET	Z		; Yes - Return
    2092/     DE7 : 14                  	INC	D		; Inc to flag positive exponent
    2093/     DE8 : FE 2B               	CP	'+'		; '+' ASCII ?
    2094/     DEA : C8                  	RET	Z		; Yes - Return
    2095/     DEB : FE AC               	CP	ZPLUS		; '+' token ?
    2096/     DED : C8                  	RET	Z		; Yes - Return
    2097/     DEE : 2B                  	DEC	HL		; DEC 'cos GETCHR INCs
    2098/     DEF : C9                  	RET			; Return "NZ"
    2099/     DF0 :                     ;
    2100/     DF0 : F6                  POR:	DB	0F6H		; Flag "OR"
    2101/     DF1 : AF                  PAND:	XOR	A		; Flag "AND"
    2102/     DF2 : F5                  	PUSH	AF		; Save "AND" / "OR" flag
    2103/     DF3 : CD AA 0C            	CALL	TSTNUM		; Make sure it's a number
    2104/     DF6 : CD EC 08            	CALL	DEINT		; Get integer -32768 to 32767
    2105/     DF9 : F1                  	POP	AF		; Restore "AND" / "OR" flag
    2106/     DFA : EB                  	EX	DE,HL		; <- Get last
    2107/     DFB : C1                  	POP	BC		; <- value
    2108/     DFC : E3                  	EX	(SP),HL		; <- from
    2109/     DFD : EB                  	EX	DE,HL		; <- stack
    2110/     DFE : CD CA 16            	CALL	FPBCDE		; Move last value to FPREG
    2111/     E01 : F5                  	PUSH	AF		; Save "AND" / "OR" flag
    2112/     E02 : CD EC 08            	CALL	DEINT		; Get integer -32768 to 32767
    2113/     E05 : F1                  	POP	AF		; Restore "AND" / "OR" flag
    2114/     E06 : C1                  	POP	BC		; Get value
    2115/     E07 : 79                  	LD	A,C		; Get LSB
    2116/     E08 : 21 61 10            	LD	HL,ACPASS	; Address of save AC as current
    2117/     E0B : C2 13 0E            	JP	NZ,POR1		; Jump if OR
    2118/     E0E : A3                  	AND	E		; "AND" LSBs
    2119/     E0F : 4F                  	LD	C,A		; Save LSB
    2120/     E10 : 78                  	LD	A,B		; Get MBS
    2121/     E11 : A2                  	AND	D		; "AND" MSBs
    2122/     E12 : E9                  	JP	(HL)		; Save AC as current (ACPASS)
    2123/     E13 :                     ;
    2124/     E13 : B3                  POR1:	OR	E		; "OR" LSBs
    2125/     E14 : 4F                  	LD	C,A		; Save LSB
    2126/     E15 : 78                  	LD	A,B		; Get MSB
    2127/     E16 : B2                  	OR	D		; "OR" MSBs
    2128/     E17 : E9                  	JP	(HL)		; Save AC as current (ACPASS)
    2129/     E18 :                     ;
    2130/     E18 : 21 2A 0E            TSTRED: LD	HL,CMPLOG	; Logical compare routine
    2131/     E1B : 3A F2 1D            	LD	A,(TYPE)	; Get data type
    2132/     E1E : 1F                  	RRA			; Carry set = string
    2133/     E1F : 7A                  	LD	A,D		; Get last precedence value
    2134/     E20 : 17                  	RLA			; Times 2 plus carry
    2135/     E21 : 5F                  	LD	E,A		; To E
    2136/     E22 : 16 64               	LD	D,64H		; Relational precedence
    2137/     E24 : 78                  	LD	A,B		; Get current precedence
    2138/     E25 : BA                  	CP	D		; Compare with last
    2139/     E26 : D0                  	RET	NC		; Eval if last was rel' or log'
    2140/     E27 : C3 19 0D            	JP	STKTHS		; Stack this one and get next
    2141/     E2A :                     ;
    2142/     E2A : 2C 0E               CMPLOG: DW	CMPLG1		; Compare two values / strings
    2143/     E2C : 79                  CMPLG1: LD	A,C		; Get data type
    2144/     E2D : B7                  	OR	A
    2145/     E2E : 1F                  	RRA
    2146/     E2F : C1                  	POP	BC		; Get last expression to BCDE
    2147/     E30 : D1                  	POP	DE
    2148/     E31 : F5                  	PUSH	AF		; Save status
    2149/     E32 : CD AC 0C            	CALL	CHKTYP		; Check that types match
    2150/     E35 : 21 6E 0E            	LD	HL,CMPRES	; Result to comparison
    2151/     E38 : E5                  	PUSH	HL		; Save for RETurn
    2152/     E39 : CA 04 17            	JP	Z,CMPNUM	; Compare values if numeric
    2153/     E3C : AF                  	XOR	A		; Compare two strings
    2154/     E3D : 32 F2 1D            	LD	(TYPE),A	; Set type to numeric
    2155/     E40 : D5                  	PUSH	DE		; Save string name
    2156/     E41 : CD C3 12            	CALL	GSTRCU		; Get current string
    2157/     E44 : 7E                  	LD	A,(HL)		; Get length of string
    2158/     E45 : 23                  	INC	HL
    2159/     E46 : 23                  	INC	HL
    2160/     E47 : 4E                  	LD	C,(HL)		; Get LSB of address
    2161/     E48 : 23                  	INC	HL
    2162/     E49 : 46                  	LD	B,(HL)		; Get MSB of address
    2163/     E4A : D1                  	POP	DE		; Restore string name
    2164/     E4B : C5                  	PUSH	BC		; Save address of string
    2165/     E4C : F5                  	PUSH	AF		; Save length of string
    2166/     E4D : CD C7 12            	CALL	GSTRDE		; Get second string
    2167/     E50 : CD D8 16            	CALL	LOADFP		; Get address of second string
    2168/     E53 : F1                  	POP	AF		; Restore length of string 1
    2169/     E54 : 57                  	LD	D,A		; Length to D
    2170/     E55 : E1                  	POP	HL		; Restore address of string 1
    2171/     E56 : 7B                  CMPSTR: LD	A,E		; Bytes of string 2 to do
    2172/     E57 : B2                  	OR	D		; Bytes of string 1 to do
    2173/     E58 : C8                  	RET	Z		; Exit if all bytes compared
    2174/     E59 : 7A                  	LD	A,D		; Get bytes of string 1 to do
    2175/     E5A : D6 01               	SUB	1
    2176/     E5C : D8                  	RET	C		; Exit if end of string 1
    2177/     E5D : AF                  	XOR	A
    2178/     E5E : BB                  	CP	E		; Bytes of string 2 to do
    2179/     E5F : 3C                  	INC	A
    2180/     E60 : D0                  	RET	NC		; Exit if end of string 2
    2181/     E61 : 15                  	DEC	D		; Count bytes in string 1
    2182/     E62 : 1D                  	DEC	E		; Count bytes in string 2
    2183/     E63 : 0A                  	LD	A,(BC)		; Byte in string 2
    2184/     E64 : BE                  	CP	(HL)		; Compare to byte in string 1
    2185/     E65 : 23                  	INC	HL		; Move up string 1
    2186/     E66 : 03                  	INC	BC		; Move up string 2
    2187/     E67 : CA 56 0E            	JP	Z,CMPSTR	; Same - Try next bytes
    2188/     E6A : 3F                  	CCF			; Flag difference (">" or "<")
    2189/     E6B : C3 94 16            	JP	FLGDIF		; "<" gives -1 , ">" gives +1
    2190/     E6E :                     ;
    2191/     E6E : 3C                  CMPRES: INC	A		; Increment current value
    2192/     E6F : 8F                  	ADC	A,A		; Double plus carry
    2193/     E70 : C1                  	POP	BC		; Get other value
    2194/     E71 : A0                  	AND	B		; Combine them
    2195/     E72 : C6 FF               	ADD	A,-1		; Carry set if different
    2196/     E74 : 9F                  	SBC	A,A		; 00 - Equal , FF - Different
    2197/     E75 : C3 9B 16            	JP	FLGREL		; Set current value & continue
    2198/     E78 :                     ;
    2199/     E78 : 16 5A               EVNOT:	LD	D,5AH		; Precedence value for "NOT"
    2200/     E7A : CD BC 0C            	CALL	EVAL1		; Eval until precedence break
    2201/     E7D : CD AA 0C            	CALL	TSTNUM		; Make sure it's a number
    2202/     E80 : CD EC 08            	CALL	DEINT		; Get integer -32768 - 32767
    2203/     E83 : 7B                  	LD	A,E		; Get LSB
    2204/     E84 : 2F                  	CPL			; Invert LSB
    2205/     E85 : 4F                  	LD	C,A		; Save "NOT" of LSB
    2206/     E86 : 7A                  	LD	A,D		; Get MSB
    2207/     E87 : 2F                  	CPL			; Invert MSB
    2208/     E88 : CD 61 10            	CALL	ACPASS		; Save AC as current
    2209/     E8B : C1                  	POP	BC		; Clean up stack
    2210/     E8C : C3 C8 0C            	JP	EVAL3		; Continue evaluation
    2211/     E8F :                     ;
    2212/     E8F : 2B                  DIMRET: DEC	HL		; DEC 'cos GETCHR INCs
    2213/     E90 : CD 3A 08            	CALL	GETCHR		; Get next character
    2214/     E93 : C8                  	RET	Z		; End of DIM statement
    2215/     E94 : CD B2 06            	CALL	CHKSYN		; Make sure ',' follows
    2216/     E97 : 2C                  	DB	','
    2217/     E98 : 01 8F 0E            DIM:	LD	BC,DIMRET	; Return to "DIMRET"
    2218/     E9B : C5                  	PUSH	BC		; Save on stack
    2219/     E9C : F6                  	DB	0F6H		; Flag "Create" variable
    2220/     E9D : AF                  GETVAR: XOR	A		; Find variable address,to DE
    2221/     E9E : 32 F1 1D            	LD	(LCRFLG),A	; Set locate / create flag
    2222/     EA1 : 46                  	LD	B,(HL)		; Get First byte of name
    2223/     EA2 : CD D8 08            GTFNAM: CALL	CHKLTR		; See if a letter
    2224/     EA5 : DA E4 03            	JP	C,SNERR		; ?SN Error if not a letter
    2225/     EA8 : AF                  	XOR	A
    2226/     EA9 : 4F                  	LD	C,A		; Clear second byte of name
    2227/     EAA : 32 F2 1D            	LD	(TYPE),A	; Set type to numeric
    2228/     EAD : CD 3A 08            	CALL	GETCHR		; Get next character
    2229/     EB0 : DA B9 0E            	JP	C,SVNAM2	; Numeric - Save in name
    2230/     EB3 : CD D8 08            	CALL	CHKLTR		; See if a letter
    2231/     EB6 : DA C6 0E            	JP	C,CHARTY	; Not a letter - Check type
    2232/     EB9 : 4F                  SVNAM2: LD	C,A		; Save second byte of name
    2233/     EBA : CD 3A 08            ENDNAM: CALL	GETCHR		; Get next character
    2234/     EBD : DA BA 0E            	JP	C,ENDNAM	; Numeric - Get another
    2235/     EC0 : CD D8 08            	CALL	CHKLTR		; See if a letter
    2236/     EC3 : D2 BA 0E            	JP	NC,ENDNAM	; Letter - Get another
    2237/     EC6 : D6 24               CHARTY: SUB	'$'		; String variable?
    2238/     EC8 : C2 D5 0E            	JP	NZ,NOTSTR	; No - Numeric variable
    2239/     ECB : 3C                  	INC	A		; A = 1 (string type)
    2240/     ECC : 32 F2 1D            	LD	(TYPE),A	; Set type to string
    2241/     ECF : 0F                  	RRCA			; A = 80H , Flag for string
    2242/     ED0 : 81                  	ADD	A,C		; 2nd byte of name has bit 7 on
    2243/     ED1 : 4F                  	LD	C,A		; Resave second byte on name
    2244/     ED2 : CD 3A 08            	CALL	GETCHR		; Get next character
    2245/     ED5 : 3A 10 1E            NOTSTR: LD	A,(FORFLG)	; Array name needed ?
    2246/     ED8 : 3D                  	DEC	A
    2247/     ED9 : CA 82 0F            	JP	Z,ARLDSV	; Yes - Get array name
    2248/     EDC : F2 E5 0E            	JP	P,NSCFOR	; No array with "FOR" or "FN"
    2249/     EDF : 7E                  	LD	A,(HL)		; Get byte again
    2250/     EE0 : D6 28               	SUB	'('		; Subscripted variable?
    2251/     EE2 : CA 5A 0F            	JP	Z,SBSCPT	; Yes - Sort out subscript
    2252/     EE5 :                     ;
    2253/     EE5 : AF                  NSCFOR: XOR	A		; Simple variable
    2254/     EE6 : 32 10 1E            	LD	(FORFLG),A	; Clear "FOR" flag
    2255/     EE9 : E5                  	PUSH	HL		; Save code string address
    2256/     EEA : 50                  	LD	D,B		; DE = Variable name to find
    2257/     EEB : 59                  	LD	E,C
    2258/     EEC : 2A 23 1E            	LD	HL,(FNRGNM)	; FN argument name
    2259/     EEF : CD AC 06            	CALL	CPDEHL		; Is it the FN argument?
    2260/     EF2 : 11 25 1E            	LD	DE,FNARG	; Point to argument value
    2261/     EF5 : CA CA 15            	JP	Z,POPHRT	; Yes - Return FN argument value
    2262/     EF8 : 2A 1D 1E            	LD	HL,(VAREND)	; End of variables
    2263/     EFB : EB                  	EX	DE,HL		; Address of end of search
    2264/     EFC : 2A 1B 1E            	LD	HL,(PROGND)	; Start of variables address
    2265/     EFF : CD AC 06            FNDVAR: CALL	CPDEHL		; End of variable list table?
    2266/     F02 : CA 18 0F            	JP	Z,CFEVAL	; Yes - Called from EVAL?
    2267/     F05 : 79                  	LD	A,C		; Get second byte of name
    2268/     F06 : 96                  	SUB	(HL)		; Compare with name in list
    2269/     F07 : 23                  	INC	HL		; Move on to first byte
    2270/     F08 : C2 0D 0F            	JP	NZ,FNTHR	; Different - Find another
    2271/     F0B : 78                  	LD	A,B		; Get first byte of name
    2272/     F0C : 96                  	SUB	(HL)		; Compare with name in list
    2273/     F0D : 23                  FNTHR:	INC	HL		; Move on to LSB of value
    2274/     F0E : CA 4C 0F            	JP	Z,RETADR	; Found - Return address
    2275/     F11 : 23                  	INC	HL		; <- Skip
    2276/     F12 : 23                  	INC	HL		; <- over
    2277/     F13 : 23                  	INC	HL		; <- F.P.
    2278/     F14 : 23                  	INC	HL		; <- value
    2279/     F15 : C3 FF 0E            	JP	FNDVAR		; Keep looking
    2280/     F18 :                     ;
    2281/     F18 : E1                  CFEVAL: POP	HL		; Restore code string address
    2282/     F19 : E3                  	EX	(SP),HL		; Get return address
    2283/     F1A : D5                  	PUSH	DE		; Save address of variable
    2284/     F1B : 11 9A 0D            	LD	DE,FRMEVL	; Return address in EVAL
    2285/     F1E : CD AC 06            	CALL	CPDEHL		; Called from EVAL ?
    2286/     F21 : D1                  	POP	DE		; Restore address of variable
    2287/     F22 : CA 4F 0F            	JP	Z,RETNUL	; Yes - Return null variable
    2288/     F25 : E3                  	EX	(SP),HL		; Put back return
    2289/     F26 : E5                  	PUSH	HL		; Save code string address
    2290/     F27 : C5                  	PUSH	BC		; Save variable name
    2291/     F28 : 01 06 00            	LD	BC,6		; 2 byte name plus 4 byte data
    2292/     F2B : 2A 1F 1E            	LD	HL,(ARREND)	; End of arrays
    2293/     F2E : E5                  	PUSH	HL		; Save end of arrays
    2294/     F2F : 09                  	ADD	HL,BC		; Move up 6 bytes
    2295/     F30 : C1                  	POP	BC		; Source address in BC
    2296/     F31 : E5                  	PUSH	HL		; Save new end address
    2297/     F32 : CD B0 03            	CALL	MOVUP		; Move arrays up
    2298/     F35 : E1                  	POP	HL		; Restore new end address
    2299/     F36 : 22 1F 1E            	LD	(ARREND),HL	; Set new end address
    2300/     F39 : 60                  	LD	H,B		; End of variables to HL
    2301/     F3A : 69                  	LD	L,C
    2302/     F3B : 22 1D 1E            	LD	(VAREND),HL	; Set new end address
    2303/     F3E :                     ;
    2304/     F3E : 2B                  ZEROLP: DEC	HL		; Back through to zero variable
    2305/     F3F : 36 00               	LD	(HL),0		; Zero byte in variable
    2306/     F41 : CD AC 06            	CALL	CPDEHL		; Done them all?
    2307/     F44 : C2 3E 0F            	JP	NZ,ZEROLP	; No - Keep on going
    2308/     F47 : D1                  	POP	DE		; Get variable name
    2309/     F48 : 73                  	LD	(HL),E		; Store second character
    2310/     F49 : 23                  	INC	HL
    2311/     F4A : 72                  	LD	(HL),D		; Store first character
    2312/     F4B : 23                  	INC	HL
    2313/     F4C : EB                  RETADR: EX	DE,HL		; Address of variable in DE
    2314/     F4D : E1                  	POP	HL		; Restore code string address
    2315/     F4E : C9                  	RET
    2316/     F4F :                     ;
    2317/     F4F : 32 2C 1E            RETNUL: LD	(FPEXP),A	; Set result to zero
    2318/     F52 : 21 80 03            	LD	HL,ZERBYT	; Also set a null string
    2319/     F55 : 22 29 1E            	LD	(FPREG),HL	; Save for EVAL
    2320/     F58 : E1                  	POP	HL		; Restore code string address
    2321/     F59 : C9                  	RET
    2322/     F5A :                     ;
    2323/     F5A : E5                  SBSCPT: PUSH	HL		; Save code string address
    2324/     F5B : 2A F1 1D            	LD	HL,(LCRFLG)	; Locate/Create and Type
    2325/     F5E : E3                  	EX	(SP),HL		; Save and get code string
    2326/     F5F : 57                  	LD	D,A		; Zero number of dimensions
    2327/     F60 : D5                  SCPTLP: PUSH	DE		; Save number of dimensions
    2328/     F61 : C5                  	PUSH	BC		; Save array name
    2329/     F62 : CD E0 08            	CALL	FPSINT		; Get subscript (0-32767)
    2330/     F65 : C1                  	POP	BC		; Restore array name
    2331/     F66 : F1                  	POP	AF		; Get number of dimensions
    2332/     F67 : EB                  	EX	DE,HL
    2333/     F68 : E3                  	EX	(SP),HL		; Save subscript value
    2334/     F69 : E5                  	PUSH	HL		; Save LCRFLG and TYPE
    2335/     F6A : EB                  	EX	DE,HL
    2336/     F6B : 3C                  	INC	A		; Count dimensions
    2337/     F6C : 57                  	LD	D,A		; Save in D
    2338/     F6D : 7E                  	LD	A,(HL)		; Get next byte in code string
    2339/     F6E : FE 2C               	CP	','		; Comma (more to come)?
    2340/     F70 : CA 60 0F            	JP	Z,SCPTLP	; Yes - More subscripts
    2341/     F73 : CD B2 06            	CALL	CHKSYN		; Make sure ")" follows
    2342/     F76 : 29                  	DB	")"
    2343/     F77 : 22 15 1E            	LD	(NXTOPR),HL	; Save code string address
    2344/     F7A : E1                  	POP	HL		; Get LCRFLG and TYPE
    2345/     F7B : 22 F1 1D            	LD	(LCRFLG),HL	; Restore Locate/create & type
    2346/     F7E : 1E 00               	LD	E,0		; Flag not CSAVE* or CLOAD*
    2347/     F80 : D5                  	PUSH	DE		; Save number of dimensions (D)
    2348/     F81 : 11                  	DB	11H		; Skip "PUSH HL" and "PUSH AF'
    2349/     F82 :                     ;
    2350/     F82 : E5                  ARLDSV: PUSH	HL		; Save code string address
    2351/     F83 : F5                  	PUSH	AF		; A = 00 , Flags set = Z,N
    2352/     F84 : 2A 1D 1E            	LD	HL,(VAREND)	; Start of arrays
    2353/     F87 : 3E                  	DB	3EH		; Skip "ADD HL,DE"
    2354/     F88 : 19                  FNDARY: ADD	HL,DE		; Move to next array start
    2355/     F89 : EB                  	EX	DE,HL
    2356/     F8A : 2A 1F 1E            	LD	HL,(ARREND)	; End of arrays
    2357/     F8D : EB                  	EX	DE,HL		; Current array pointer
    2358/     F8E : CD AC 06            	CALL	CPDEHL		; End of arrays found?
    2359/     F91 : CA BA 0F            	JP	Z,CREARY	; Yes - Create array
    2360/     F94 : 7E                  	LD	A,(HL)		; Get second byte of name
    2361/     F95 : B9                  	CP	C		; Compare with name given
    2362/     F96 : 23                  	INC	HL		; Move on
    2363/     F97 : C2 9C 0F            	JP	NZ,NXTARY	; Different - Find next array
    2364/     F9A : 7E                  	LD	A,(HL)		; Get first byte of name
    2365/     F9B : B8                  	CP	B		; Compare with name given
    2366/     F9C : 23                  NXTARY: INC	HL		; Move on
    2367/     F9D : 5E                  	LD	E,(HL)		; Get LSB of next array address
    2368/     F9E : 23                  	INC	HL
    2369/     F9F : 56                  	LD	D,(HL)		; Get MSB of next array address
    2370/     FA0 : 23                  	INC	HL
    2371/     FA1 : C2 88 0F            	JP	NZ,FNDARY	; Not found - Keep looking
    2372/     FA4 : 3A F1 1D            	LD	A,(LCRFLG)	; Found Locate or Create it?
    2373/     FA7 : B7                  	OR	A
    2374/     FA8 : C2 ED 03            	JP	NZ,DDERR	; Create - ?DD Error
    2375/     FAB : F1                  	POP	AF		; Locate - Get number of dim'ns
    2376/     FAC : 44                  	LD	B,H		; BC Points to array dim'ns
    2377/     FAD : 4D                  	LD	C,L
    2378/     FAE : CA CA 15            	JP	Z,POPHRT	; Jump if array load/save
    2379/     FB1 : 96                  	SUB	(HL)		; Same number of dimensions?
    2380/     FB2 : CA 18 10            	JP	Z,FINDEL	; Yes - Find element
    2381/     FB5 : 1E 10               BSERR:	LD	E,BS		; ?BS Error
    2382/     FB7 : C3 F8 03            	JP	ERROR_		; Output error
    2383/     FBA :                     ;
    2384/     FBA : 11 04 00            CREARY: LD	DE,4		; 4 Bytes per entry
    2385/     FBD : F1                  	POP	AF		; Array to save or 0 dim'ns?
    2386/     FBE : CA 01 09            	JP	Z,FCERR		; Yes - ?FC Error
    2387/     FC1 : 71                  	LD	(HL),C		; Save second byte of name
    2388/     FC2 : 23                  	INC	HL
    2389/     FC3 : 70                  	LD	(HL),B		; Save first byte of name
    2390/     FC4 : 23                  	INC	HL
    2391/     FC5 : 4F                  	LD	C,A		; Number of dimensions to C
    2392/     FC6 : CD C1 03            	CALL	CHKSTK		; Check if enough memory
    2393/     FC9 : 23                  	INC	HL		; Point to number of dimensions
    2394/     FCA : 23                  	INC	HL
    2395/     FCB : 22 0A 1E            	LD	(CUROPR),HL	; Save address of pointer
    2396/     FCE : 71                  	LD	(HL),C		; Set number of dimensions
    2397/     FCF : 23                  	INC	HL
    2398/     FD0 : 3A F1 1D            	LD	A,(LCRFLG)	; Locate of Create?
    2399/     FD3 : 17                  	RLA			; Carry set = Create
    2400/     FD4 : 79                  	LD	A,C		; Get number of dimensions
    2401/     FD5 : 01 0B 00            CRARLP: LD	BC,10+1		; Default dimension size 10
    2402/     FD8 : D2 DD 0F            	JP	NC,DEFSIZ	; Locate - Set default size
    2403/     FDB : C1                  	POP	BC		; Get specified dimension size
    2404/     FDC : 03                  	INC	BC		; Include zero element
    2405/     FDD : 71                  DEFSIZ: LD	(HL),C		; Save LSB of dimension size
    2406/     FDE : 23                  	INC	HL
    2407/     FDF : 70                  	LD	(HL),B		; Save MSB of dimension size
    2408/     FE0 : 23                  	INC	HL
    2409/     FE1 : F5                  	PUSH	AF		; Save num' of dim'ns an status
    2410/     FE2 : E5                  	PUSH	HL		; Save address of dim'n size
    2411/     FE3 : CD 75 17            	CALL	MLDEBC		; Multiply DE by BC to find
    2412/     FE6 : EB                  	EX	DE,HL		; amount of mem needed (to DE)
    2413/     FE7 : E1                  	POP	HL		; Restore address of dimension
    2414/     FE8 : F1                  	POP	AF		; Restore number of dimensions
    2415/     FE9 : 3D                  	DEC	A		; Count them
    2416/     FEA : C2 D5 0F            	JP	NZ,CRARLP	; Do next dimension if more
    2417/     FED : F5                  	PUSH	AF		; Save locate/create flag
    2418/     FEE : 42                  	LD	B,D		; MSB of memory needed
    2419/     FEF : 4B                  	LD	C,E		; LSB of memory needed
    2420/     FF0 : EB                  	EX	DE,HL
    2421/     FF1 : 19                  	ADD	HL,DE		; Add bytes to array start
    2422/     FF2 : DA D9 03            	JP	C,OMERR		; Too big - Error
    2423/     FF5 : CD CA 03            	CALL	ENFMEM		; See if enough memory
    2424/     FF8 : 22 1F 1E            	LD	(ARREND),HL	; Save new end of array
    2425/     FFB :                     ;
    2426/     FFB : 2B                  ZERARY: DEC	HL		; Back through array data
    2427/     FFC : 36 00               	LD	(HL),0		; Set array element to zero
    2428/     FFE : CD AC 06            	CALL	CPDEHL		; All elements zeroed?
    2429/    1001 : C2 FB 0F            	JP	NZ,ZERARY	; No - Keep on going
    2430/    1004 : 03                  	INC	BC		; Number of bytes + 1
    2431/    1005 : 57                  	LD	D,A		; A=0
    2432/    1006 : 2A 0A 1E            	LD	HL,(CUROPR)	; Get address of array
    2433/    1009 : 5E                  	LD	E,(HL)		; Number of dimensions
    2434/    100A : EB                  	EX	DE,HL		; To HL
    2435/    100B : 29                  	ADD	HL,HL		; Two bytes per dimension size
    2436/    100C : 09                  	ADD	HL,BC		; Add number of bytes
    2437/    100D : EB                  	EX	DE,HL		; Bytes needed to DE
    2438/    100E : 2B                  	DEC	HL
    2439/    100F : 2B                  	DEC	HL
    2440/    1010 : 73                  	LD	(HL),E		; Save LSB of bytes needed
    2441/    1011 : 23                  	INC	HL
    2442/    1012 : 72                  	LD	(HL),D		; Save MSB of bytes needed
    2443/    1013 : 23                  	INC	HL
    2444/    1014 : F1                  	POP	AF		; Locate / Create?
    2445/    1015 : DA 3C 10            	JP	C,ENDDIM	; A is 0 , End if create
    2446/    1018 : 47                  FINDEL: LD	B,A		; Find array element
    2447/    1019 : 4F                  	LD	C,A
    2448/    101A : 7E                  	LD	A,(HL)		; Number of dimensions
    2449/    101B : 23                  	INC	HL
    2450/    101C : 16                  	DB	16H		; Skip "POP HL"
    2451/    101D : E1                  FNDELP: POP	HL		; Address of next dim' size
    2452/    101E : 5E                  	LD	E,(HL)		; Get LSB of dim'n size
    2453/    101F : 23                  	INC	HL
    2454/    1020 : 56                  	LD	D,(HL)		; Get MSB of dim'n size
    2455/    1021 : 23                  	INC	HL
    2456/    1022 : E3                  	EX	(SP),HL		; Save address - Get index
    2457/    1023 : F5                  	PUSH	AF		; Save number of dim'ns
    2458/    1024 : CD AC 06            	CALL	CPDEHL		; Dimension too large?
    2459/    1027 : D2 B5 0F            	JP	NC,BSERR	; Yes - ?BS Error
    2460/    102A : E5                  	PUSH	HL		; Save index
    2461/    102B : CD 75 17            	CALL	MLDEBC		; Multiply previous by size
    2462/    102E : D1                  	POP	DE		; Index supplied to DE
    2463/    102F : 19                  	ADD	HL,DE		; Add index to pointer
    2464/    1030 : F1                  	POP	AF		; Number of dimensions
    2465/    1031 : 3D                  	DEC	A		; Count them
    2466/    1032 : 44                  	LD	B,H		; MSB of pointer
    2467/    1033 : 4D                  	LD	C,L		; LSB of pointer
    2468/    1034 : C2 1D 10            	JP	NZ,FNDELP	; More - Keep going
    2469/    1037 : 29                  	ADD	HL,HL		; 4 Bytes per element
    2470/    1038 : 29                  	ADD	HL,HL
    2471/    1039 : C1                  	POP	BC		; Start of array
    2472/    103A : 09                  	ADD	HL,BC		; Point to element
    2473/    103B : EB                  	EX	DE,HL		; Address of element to DE
    2474/    103C : 2A 15 1E            ENDDIM: LD	HL,(NXTOPR)	; Got code string address
    2475/    103F : C9                  	RET
    2476/    1040 :                     ;
    2477/    1040 : 2A 1F 1E            FRE:	LD	HL,(ARREND)	; Start of free memory
    2478/    1043 : EB                  	EX	DE,HL		; To DE
    2479/    1044 : 21 00 00            	LD	HL,0		; End of free memory
    2480/    1047 : 39                  	ADD	HL,SP		; Current stack value
    2481/    1048 : 3A F2 1D            	LD	A,(TYPE)	; Dummy argument type
    2482/    104B : B7                  	OR	A
    2483/    104C : CA 5C 10            	JP	Z,FRENUM	; Numeric - Free variable space
    2484/    104F : CD C3 12            	CALL	GSTRCU		; Current string to pool
    2485/    1052 : CD C3 11            	CALL	GARBGE		; Garbage collection
    2486/    1055 : 2A 9F 1D            	LD	HL,(STRSPC)	; Bottom of string space in use
    2487/    1058 : EB                  	EX	DE,HL		; To DE
    2488/    1059 : 2A 08 1E            	LD	HL,(STRBOT)	; Bottom of string space
    2489/    105C : 7D                  FRENUM: LD	A,L		; Get LSB of end
    2490/    105D : 93                  	SUB	E		; Subtract LSB of beginning
    2491/    105E : 4F                  	LD	C,A		; Save difference if C
    2492/    105F : 7C                  	LD	A,H		; Get MSB of end
    2493/    1060 : 9A                  	SBC	A,D		; Subtract MSB of beginning
    2494/    1061 : 41                  ACPASS: LD	B,C		; Return integer AC
    2495/    1062 : 50                  ABPASS: LD	D,B		; Return integer AB
    2496/    1063 : 1E 00               	LD	E,0
    2497/    1065 : 21 F2 1D            	LD	HL,TYPE		; Point to type
    2498/    1068 : 73                  	LD	(HL),E		; Set type to numeric
    2499/    1069 : 06 90               	LD	B,80H+16	; 16 bit integer
    2500/    106B : C3 A0 16            	JP	RETINT		; Return the integr
    2501/    106E :                     ;
    2502/    106E : 3A F0 1D            POS:	LD	A,(CURPOS)	; Get cursor position
    2503/    1071 : 47                  PASSA:	LD	B,A		; Put A into AB
    2504/    1072 : AF                  	XOR	A		; Zero A
    2505/    1073 : C3 62 10            	JP	ABPASS		; Return integer AB
    2506/    1076 :                     ;
    2507/    1076 : CD F9 10            DEF:	CALL	CHEKFN		; Get "FN" and name
    2508/    1079 : CD EB 10            	CALL	IDTEST		; Test for illegal direct
    2509/    107C : 01 D1 09            	LD	BC,DATA		; To get next statement
    2510/    107F : C5                  	PUSH	BC		; Save address for RETurn
    2511/    1080 : D5                  	PUSH	DE		; Save address of function ptr
    2512/    1081 : CD B2 06            	CALL	CHKSYN		; Make sure "(" follows
    2513/    1084 : 28                  	DB	"("
    2514/    1085 : CD 9D 0E            	CALL	GETVAR		; Get argument variable name
    2515/    1088 : E5                  	PUSH	HL		; Save code string address
    2516/    1089 : EB                  	EX	DE,HL		; Argument address to HL
    2517/    108A : 2B                  	DEC	HL
    2518/    108B : 56                  	LD	D,(HL)		; Get first byte of arg name
    2519/    108C : 2B                  	DEC	HL
    2520/    108D : 5E                  	LD	E,(HL)		; Get second byte of arg name
    2521/    108E : E1                  	POP	HL		; Restore code string address
    2522/    108F : CD AA 0C            	CALL	TSTNUM		; Make sure numeric argument
    2523/    1092 : CD B2 06            	CALL	CHKSYN		; Make sure ")" follows
    2524/    1095 : 29                  	DB	")"
    2525/    1096 : CD B2 06            	CALL	CHKSYN		; Make sure "=" follows
    2526/    1099 : B4                  	DB	ZEQUAL		; "=" token
    2527/    109A : 44                  	LD	B,H		; Code string address to BC
    2528/    109B : 4D                  	LD	C,L
    2529/    109C : E3                  	EX	(SP),HL		; Save code str , Get FN ptr
    2530/    109D : 71                  	LD	(HL),C		; Save LSB of FN code string
    2531/    109E : 23                  	INC	HL
    2532/    109F : 70                  	LD	(HL),B		; Save MSB of FN code string
    2533/    10A0 : C3 38 11            	JP	SVSTAD		; Save address and do function
    2534/    10A3 :                     ;
    2535/    10A3 : CD F9 10            DOFN:	CALL	CHEKFN		; Make sure FN follows
    2536/    10A6 : D5                  	PUSH	DE		; Save function pointer address
    2537/    10A7 : CD 7E 0D            	CALL	EVLPAR		; Evaluate expression in "()"
    2538/    10AA : CD AA 0C            	CALL	TSTNUM		; Make sure numeric result
    2539/    10AD : E3                  	EX	(SP),HL		; Save code str , Get FN ptr
    2540/    10AE : 5E                  	LD	E,(HL)		; Get LSB of FN code string
    2541/    10AF : 23                  	INC	HL
    2542/    10B0 : 56                  	LD	D,(HL)		; Get MSB of FN code string
    2543/    10B1 : 23                  	INC	HL
    2544/    10B2 : 7A                  	LD	A,D		; And function DEFined?
    2545/    10B3 : B3                  	OR	E
    2546/    10B4 : CA F0 03            	JP	Z,UFERR		; No - ?UF Error
    2547/    10B7 : 7E                  	LD	A,(HL)		; Get LSB of argument address
    2548/    10B8 : 23                  	INC	HL
    2549/    10B9 : 66                  	LD	H,(HL)		; Get MSB of argument address
    2550/    10BA : 6F                  	LD	L,A		; HL = Arg variable address
    2551/    10BB : E5                  	PUSH	HL		; Save it
    2552/    10BC : 2A 23 1E            	LD	HL,(FNRGNM)	; Get old argument name
    2553/    10BF : E3                  	EX	(SP),HL;	; Save old , Get new
    2554/    10C0 : 22 23 1E            	LD	(FNRGNM),HL	; Set new argument name
    2555/    10C3 : 2A 27 1E            	LD	HL,(FNARG+2)	; Get LSB,NLSB of old arg value
    2556/    10C6 : E5                  	PUSH	HL		; Save it
    2557/    10C7 : 2A 25 1E            	LD	HL,(FNARG)	; Get MSB,EXP of old arg value
    2558/    10CA : E5                  	PUSH	HL		; Save it
    2559/    10CB : 21 25 1E            	LD	HL,FNARG	; HL = Value of argument
    2560/    10CE : D5                  	PUSH	DE		; Save FN code string address
    2561/    10CF : CD E1 16            	CALL	FPTHL		; Move FPREG to argument
    2562/    10D2 : E1                  	POP	HL		; Get FN code string address
    2563/    10D3 : CD A7 0C            	CALL	GETNUM		; Get value from function
    2564/    10D6 : 2B                  	DEC	HL		; DEC 'cos GETCHR INCs
    2565/    10D7 : CD 3A 08            	CALL	GETCHR		; Get next character
    2566/    10DA : C2 E4 03            	JP	NZ,SNERR	; Bad character in FN - Error
    2567/    10DD : E1                  	POP	HL		; Get MSB,EXP of old arg
    2568/    10DE : 22 25 1E            	LD	(FNARG),HL	; Restore it
    2569/    10E1 : E1                  	POP	HL		; Get LSB,NLSB of old arg
    2570/    10E2 : 22 27 1E            	LD	(FNARG+2),HL	; Restore it
    2571/    10E5 : E1                  	POP	HL		; Get name of old arg
    2572/    10E6 : 22 23 1E            	LD	(FNRGNM),HL	; Restore it
    2573/    10E9 : E1                  	POP	HL		; Restore code string address
    2574/    10EA : C9                  	RET
    2575/    10EB :                     ;
    2576/    10EB : E5                  IDTEST: PUSH	HL		; Save code string address
    2577/    10EC : 2A A1 1D            	LD	HL,(LINEAT)	; Get current line number
    2578/    10EF : 23                  	INC	HL		; -1 means direct statement
    2579/    10F0 : 7C                  	LD	A,H
    2580/    10F1 : B5                  	OR	L
    2581/    10F2 : E1                  	POP	HL		; Restore code string address
    2582/    10F3 : C0                  	RET	NZ		; Return if in program
    2583/    10F4 : 1E 16               	LD	E,ID		; ?ID Error
    2584/    10F6 : C3 F8 03            	JP	ERROR_
    2585/    10F9 :                     ;
    2586/    10F9 : CD B2 06            CHEKFN: CALL	CHKSYN		; Make sure FN follows
    2587/    10FC : A7                  	DB	ZFN		; "FN" token
    2588/    10FD : 3E 80               	LD	A,80H
    2589/    10FF : 32 10 1E            	LD	(FORFLG),A	; Flag FN name to find
    2590/    1102 : B6                  	OR	(HL)		; FN name has bit 7 set
    2591/    1103 : 47                  	LD	B,A		; in first byte of name
    2592/    1104 : CD A2 0E            	CALL	GTFNAM		; Get FN name
    2593/    1107 : C3 AA 0C            	JP	TSTNUM		; Make sure numeric function
    2594/    110A :                     ;
    2595/    110A : CD AA 0C            STR:	CALL	TSTNUM		; Make sure it's a number
    2596/    110D : CD 2E 18            	CALL	NUMASC		; Turn number into text
    2597/    1110 : CD 3E 11            STR1:	CALL	CRTST		; Create string entry for it
    2598/    1113 : CD C3 12            	CALL	GSTRCU		; Current string to pool
    2599/    1116 : 01 1E 13            	LD	BC,TOPOOL	; Save in string pool
    2600/    1119 : C5                  	PUSH	BC		; Save address on stack
    2601/    111A :                     ;
    2602/    111A : 7E                  SAVSTR: LD	A,(HL)		; Get string length
    2603/    111B : 23                  	INC	HL
    2604/    111C : 23                  	INC	HL
    2605/    111D : E5                  	PUSH	HL		; Save pointer to string
    2606/    111E : CD 99 11            	CALL	TESTR		; See if enough string space
    2607/    1121 : E1                  	POP	HL		; Restore pointer to string
    2608/    1122 : 4E                  	LD	C,(HL)		; Get LSB of address
    2609/    1123 : 23                  	INC	HL
    2610/    1124 : 46                  	LD	B,(HL)		; Get MSB of address
    2611/    1125 : CD 32 11            	CALL	CRTMST		; Create string entry
    2612/    1128 : E5                  	PUSH	HL		; Save pointer to MSB of addr
    2613/    1129 : 6F                  	LD	L,A		; Length of string
    2614/    112A : CD B6 12            	CALL	TOSTRA		; Move to string area
    2615/    112D : D1                  	POP	DE		; Restore pointer to MSB
    2616/    112E : C9                  	RET
    2617/    112F :                     ;
    2618/    112F : CD 99 11            MKTMST: CALL	TESTR		; See if enough string space
    2619/    1132 : 21 04 1E            CRTMST: LD	HL,TMPSTR	; Temporary string
    2620/    1135 : E5                  	PUSH	HL		; Save it
    2621/    1136 : 77                  	LD	(HL),A		; Save length of string
    2622/    1137 : 23                  	INC	HL
    2623/    1138 : 23                  SVSTAD: INC	HL
    2624/    1139 : 73                  	LD	(HL),E		; Save LSB of address
    2625/    113A : 23                  	INC	HL
    2626/    113B : 72                  	LD	(HL),D		; Save MSB of address
    2627/    113C : E1                  	POP	HL		; Restore pointer
    2628/    113D : C9                  	RET
    2629/    113E :                     ;
    2630/    113E : 2B                  CRTST:	DEC	HL		; DEC - INCed after
    2631/    113F : 06 22               QTSTR:	LD	B,'"'		; Terminating quote
    2632/    1141 : 50                  	LD	D,B		; Quote to D
    2633/    1142 : E5                  DTSTR:	PUSH	HL		; Save start
    2634/    1143 : 0E FF               	LD	C,-1		; Set counter to -1
    2635/    1145 : 23                  QTSTLP: INC	HL		; Move on
    2636/    1146 : 7E                  	LD	A,(HL)		; Get byte
    2637/    1147 : 0C                  	INC	C		; Count bytes
    2638/    1148 : B7                  	OR	A		; End of line?
    2639/    1149 : CA 54 11            	JP	Z,CRTSTE	; Yes - Create string entry
    2640/    114C : BA                  	CP	D		; Terminator D found?
    2641/    114D : CA 54 11            	JP	Z,CRTSTE	; Yes - Create string entry
    2642/    1150 : B8                  	CP	B		; Terminator B found?
    2643/    1151 : C2 45 11            	JP	NZ,QTSTLP	; No - Keep looking
    2644/    1154 : FE 22               CRTSTE: CP	'"'		; End with '"'?
    2645/    1156 : CC 3A 08            	CALL	Z,GETCHR	; Yes - Get next character
    2646/    1159 : E3                  	EX	(SP),HL		; Starting quote
    2647/    115A : 23                  	INC	HL		; First byte of string
    2648/    115B : EB                  	EX	DE,HL		; To DE
    2649/    115C : 79                  	LD	A,C		; Get length
    2650/    115D : CD 32 11            	CALL	CRTMST		; Create string entry
    2651/    1160 : 11 04 1E            TSTOPL: LD	DE,TMPSTR	; Temporary string
    2652/    1163 : 2A F6 1D            	LD	HL,(TMSTPT)	; Temporary string pool pointer
    2653/    1166 : 22 29 1E            	LD	(FPREG),HL	; Save address of string ptr
    2654/    1169 : 3E 01               	LD	A,1
    2655/    116B : 32 F2 1D            	LD	(TYPE),A	; Set type to string
    2656/    116E : CD E4 16            	CALL	DETHL4		; Move string to pool
    2657/    1171 : CD AC 06            	CALL	CPDEHL		; Out of string pool?
    2658/    1174 : 22 F6 1D            	LD	(TMSTPT),HL	; Save new pointer
    2659/    1177 : E1                  	POP	HL		; Restore code string address
    2660/    1178 : 7E                  	LD	A,(HL)		; Get next code byte
    2661/    1179 : C0                  	RET	NZ		; Return if pool OK
    2662/    117A : 1E 1E               	LD	E,ST		; ?ST Error
    2663/    117C : C3 F8 03            	JP	ERROR_		; String pool overflow
    2664/    117F :                     ;
    2665/    117F : 23                  PRNUMS: INC	HL		; Skip leading space
    2666/    1180 : CD 3E 11            PRS:	CALL	CRTST		; Create string entry for it
    2667/    1183 : CD C3 12            PRS1:	CALL	GSTRCU		; Current string to pool
    2668/    1186 : CD D8 16            	CALL	LOADFP		; Move string block to BCDE
    2669/    1189 : 1C                  	INC	E		; Length + 1
    2670/    118A : 1D                  PRSLP:	DEC	E		; Count characters
    2671/    118B : C8                  	RET	Z		; End of string
    2672/    118C : 0A                  	LD	A,(BC)		; Get byte to output
    2673/    118D : CD BD 06            	CALL	OUTC		; Output character in A
    2674/    1190 : FE 0D               	CP	CR		; Return?
    2675/    1192 : CC EC 0A            	CALL	Z,DONULL	; Yes - Do nulls
    2676/    1195 : 03                  	INC	BC		; Next byte in string
    2677/    1196 : C3 8A 11            	JP	PRSLP		; More characters to output
    2678/    1199 :                     ;
    2679/    1199 : B7                  TESTR:	OR	A		; Test if enough room
    2680/    119A : 0E                  	DB	0EH		; No garbage collection done
    2681/    119B : F1                  GRBDON: POP	AF		; Garbage collection done
    2682/    119C : F5                  	PUSH	AF		; Save status
    2683/    119D : 2A 9F 1D            	LD	HL,(STRSPC)	; Bottom of string space in use
    2684/    11A0 : EB                  	EX	DE,HL		; To DE
    2685/    11A1 : 2A 08 1E            	LD	HL,(STRBOT)	; Bottom of string area
    2686/    11A4 : 2F                  	CPL			; Negate length (Top down)
    2687/    11A5 : 4F                  	LD	C,A		; -Length to BC
    2688/    11A6 : 06 FF               	LD	B,-1		; BC = -ve length of string
    2689/    11A8 : 09                  	ADD	HL,BC		; Add to bottom of space in use
    2690/    11A9 : 23                  	INC	HL		; Plus one for 2's complement
    2691/    11AA : CD AC 06            	CALL	CPDEHL		; Below string RAM area?
    2692/    11AD : DA B7 11            	JP	C,TESTOS	; Tidy up if not done else err
    2693/    11B0 : 22 08 1E            	LD	(STRBOT),HL	; Save new bottom of area
    2694/    11B3 : 23                  	INC	HL		; Point to first byte of string
    2695/    11B4 : EB                  	EX	DE,HL		; Address to DE
    2696/    11B5 : F1                  POPAF:	POP	AF		; Throw away status push
    2697/    11B6 : C9                  	RET
    2698/    11B7 :                     ;
    2699/    11B7 : F1                  TESTOS: POP	AF		; Garbage collect been done?
    2700/    11B8 : 1E 1A               	LD	E,OS		; ?OS Error
    2701/    11BA : CA F8 03            	JP	Z,ERROR_	; Yes - Not enough string apace
    2702/    11BD : BF                  	CP	A		; Flag garbage collect done
    2703/    11BE : F5                  	PUSH	AF		; Save status
    2704/    11BF : 01 9B 11            	LD	BC,GRBDON	; Garbage collection done
    2705/    11C2 : C5                  	PUSH	BC		; Save for RETurn
    2706/    11C3 : 2A F4 1D            GARBGE: LD	HL,(LSTRAM)	; Get end of RAM pointer
    2707/    11C6 : 22 08 1E            GARBLP: LD	(STRBOT),HL	; Reset string pointer
    2708/    11C9 : 21 00 00            	LD	HL,0
    2709/    11CC : E5                  	PUSH	HL		; Flag no string found
    2710/    11CD : 2A 9F 1D            	LD	HL,(STRSPC)	; Get bottom of string space
    2711/    11D0 : E5                  	PUSH	HL		; Save bottom of string space
    2712/    11D1 : 21 F8 1D            	LD	HL,TMSTPL	; Temporary string pool
    2713/    11D4 : EB                  GRBLP:	EX	DE,HL
    2714/    11D5 : 2A F6 1D            	LD	HL,(TMSTPT)	; Temporary string pool pointer
    2715/    11D8 : EB                  	EX	DE,HL
    2716/    11D9 : CD AC 06            	CALL	CPDEHL		; Temporary string pool done?
    2717/    11DC : 01 D4 11            	LD	BC,GRBLP	; Loop until string pool done
    2718/    11DF : C2 28 12            	JP	NZ,STPOOL	; No - See if in string area
    2719/    11E2 : 2A 1B 1E            	LD	HL,(PROGND)	; Start of simple variables
    2720/    11E5 : EB                  SMPVAR: EX	DE,HL
    2721/    11E6 : 2A 1D 1E            	LD	HL,(VAREND)	; End of simple variables
    2722/    11E9 : EB                  	EX	DE,HL
    2723/    11EA : CD AC 06            	CALL	CPDEHL		; All simple strings done?
    2724/    11ED : CA FB 11            	JP	Z,ARRLP		; Yes - Do string arrays
    2725/    11F0 : 7E                  	LD	A,(HL)		; Get type of variable
    2726/    11F1 : 23                  	INC	HL
    2727/    11F2 : 23                  	INC	HL
    2728/    11F3 : B7                  	OR	A		; "S" flag set if string
    2729/    11F4 : CD 2B 12            	CALL	STRADD		; See if string in string area
    2730/    11F7 : C3 E5 11            	JP	SMPVAR		; Loop until simple ones done
    2731/    11FA :                     ;
    2732/    11FA : C1                  GNXARY: POP	BC		; Scrap address of this array
    2733/    11FB : EB                  ARRLP:	EX	DE,HL
    2734/    11FC : 2A 1F 1E            	LD	HL,(ARREND)	; End of string arrays
    2735/    11FF : EB                  	EX	DE,HL
    2736/    1200 : CD AC 06            	CALL	CPDEHL		; All string arrays done?
    2737/    1203 : CA 51 12            	JP	Z,SCNEND	; Yes - Move string if found
    2738/    1206 : CD D8 16            	CALL	LOADFP		; Get array name to BCDE
    2739/    1209 : 7B                  	LD	A,E		; Get type of array	
    2740/    120A : E5                  	PUSH	HL		; Save address of num of dim'ns
    2741/    120B : 09                  	ADD	HL,BC		; Start of next array
    2742/    120C : B7                  	OR	A		; Test type of array
    2743/    120D : F2 FA 11            	JP	P,GNXARY	; Numeric array - Ignore it
    2744/    1210 : 22 0A 1E            	LD	(CUROPR),HL	; Save address of next array
    2745/    1213 : E1                  	POP	HL		; Get address of num of dim'ns
    2746/    1214 : 4E                  	LD	C,(HL)		; BC = Number of dimensions
    2747/    1215 : 06 00               	LD	B,0
    2748/    1217 : 09                  	ADD	HL,BC		; Two bytes per dimension size
    2749/    1218 : 09                  	ADD	HL,BC
    2750/    1219 : 23                  	INC	HL		; Plus one for number of dim'ns
    2751/    121A : EB                  GRBARY: EX	DE,HL
    2752/    121B : 2A 0A 1E            	LD	HL,(CUROPR)	; Get address of next array
    2753/    121E : EB                  	EX	DE,HL
    2754/    121F : CD AC 06            	CALL	CPDEHL		; Is this array finished?
    2755/    1222 : CA FB 11            	JP	Z,ARRLP		; Yes - Get next one
    2756/    1225 : 01 1A 12            	LD	BC,GRBARY	; Loop until array all done
    2757/    1228 : C5                  STPOOL: PUSH	BC		; Save return address
    2758/    1229 : F6 80               	OR	80H		; Flag string type
    2759/    122B : 7E                  STRADD: LD	A,(HL)		; Get string length
    2760/    122C : 23                  	INC	HL
    2761/    122D : 23                  	INC	HL
    2762/    122E : 5E                  	LD	E,(HL)		; Get LSB of string address
    2763/    122F : 23                  	INC	HL
    2764/    1230 : 56                  	LD	D,(HL)		; Get MSB of string address
    2765/    1231 : 23                  	INC	HL
    2766/    1232 : F0                  	RET	P		; Not a string - Return
    2767/    1233 : B7                  	OR	A		; Set flags on string length
    2768/    1234 : C8                  	RET	Z		; Null string - Return
    2769/    1235 : 44                  	LD	B,H		; Save variable pointer
    2770/    1236 : 4D                  	LD	C,L
    2771/    1237 : 2A 08 1E            	LD	HL,(STRBOT)	; Bottom of new area
    2772/    123A : CD AC 06            	CALL	CPDEHL		; String been done?
    2773/    123D : 60                  	LD	H,B		; Restore variable pointer
    2774/    123E : 69                  	LD	L,C
    2775/    123F : D8                  	RET	C		; String done - Ignore
    2776/    1240 : E1                  	POP	HL		; Return address
    2777/    1241 : E3                  	EX	(SP),HL		; Lowest available string area
    2778/    1242 : CD AC 06            	CALL	CPDEHL		; String within string area?
    2779/    1245 : E3                  	EX	(SP),HL		; Lowest available string area
    2780/    1246 : E5                  	PUSH	HL		; Re-save return address
    2781/    1247 : 60                  	LD	H,B		; Restore variable pointer
    2782/    1248 : 69                  	LD	L,C
    2783/    1249 : D0                  	RET	NC		; Outside string area - Ignore
    2784/    124A : C1                  	POP	BC		; Get return , Throw 2 away
    2785/    124B : F1                  	POP	AF		; 
    2786/    124C : F1                  	POP	AF		; 
    2787/    124D : E5                  	PUSH	HL		; Save variable pointer
    2788/    124E : D5                  	PUSH	DE		; Save address of current
    2789/    124F : C5                  	PUSH	BC		; Put back return address
    2790/    1250 : C9                  	RET			; Go to it
    2791/    1251 :                     ;
    2792/    1251 : D1                  SCNEND: POP	DE		; Addresses of strings
    2793/    1252 : E1                  	POP	HL		; 
    2794/    1253 : 7D                  	LD	A,L		; HL = 0 if no more to do
    2795/    1254 : B4                  	OR	H
    2796/    1255 : C8                  	RET	Z		; No more to do - Return
    2797/    1256 : 2B                  	DEC	HL
    2798/    1257 : 46                  	LD	B,(HL)		; MSB of address of string
    2799/    1258 : 2B                  	DEC	HL
    2800/    1259 : 4E                  	LD	C,(HL)		; LSB of address of string
    2801/    125A : E5                  	PUSH	HL		; Save variable address
    2802/    125B : 2B                  	DEC	HL
    2803/    125C : 2B                  	DEC	HL
    2804/    125D : 6E                  	LD	L,(HL)		; HL = Length of string
    2805/    125E : 26 00               	LD	H,0
    2806/    1260 : 09                  	ADD	HL,BC		; Address of end of string+1
    2807/    1261 : 50                  	LD	D,B		; String address to DE
    2808/    1262 : 59                  	LD	E,C
    2809/    1263 : 2B                  	DEC	HL		; Last byte in string
    2810/    1264 : 44                  	LD	B,H		; Address to BC
    2811/    1265 : 4D                  	LD	C,L
    2812/    1266 : 2A 08 1E            	LD	HL,(STRBOT)	; Current bottom of string area
    2813/    1269 : CD B3 03            	CALL	MOVSTR		; Move string to new address
    2814/    126C : E1                  	POP	HL		; Restore variable address
    2815/    126D : 71                  	LD	(HL),C		; Save new LSB of address
    2816/    126E : 23                  	INC	HL
    2817/    126F : 70                  	LD	(HL),B		; Save new MSB of address
    2818/    1270 : 69                  	LD	L,C		; Next string area+1 to HL
    2819/    1271 : 60                  	LD	H,B
    2820/    1272 : 2B                  	DEC	HL		; Next string area address
    2821/    1273 : C3 C6 11            	JP	GARBLP		; Look for more strings
    2822/    1276 :                     ;
    2823/    1276 : C5                  CONCAT: PUSH	BC		; Save prec' opr & code string
    2824/    1277 : E5                  	PUSH	HL		; 
    2825/    1278 : 2A 29 1E            	LD	HL,(FPREG)	; Get first string
    2826/    127B : E3                  	EX	(SP),HL		; Save first string
    2827/    127C : CD 30 0D            	CALL	OPRND		; Get second string
    2828/    127F : E3                  	EX	(SP),HL		; Restore first string
    2829/    1280 : CD AB 0C            	CALL	TSTSTR		; Make sure it's a string
    2830/    1283 : 7E                  	LD	A,(HL)		; Get length of second string
    2831/    1284 : E5                  	PUSH	HL		; Save first string
    2832/    1285 : 2A 29 1E            	LD	HL,(FPREG)	; Get second string
    2833/    1288 : E5                  	PUSH	HL		; Save second string
    2834/    1289 : 86                  	ADD	A,(HL)		; Add length of second string
    2835/    128A : 1E 1C               	LD	E,LS		; ?LS Error
    2836/    128C : DA F8 03            	JP	C,ERROR_	; String too long - Error
    2837/    128F : CD 2F 11            	CALL	MKTMST		; Make temporary string
    2838/    1292 : D1                  	POP	DE		; Get second string to DE
    2839/    1293 : CD C7 12            	CALL	GSTRDE		; Move to string pool if needed
    2840/    1296 : E3                  	EX	(SP),HL		; Get first string
    2841/    1297 : CD C6 12            	CALL	GSTRHL		; Move to string pool if needed
    2842/    129A : E5                  	PUSH	HL		; Save first string
    2843/    129B : 2A 06 1E            	LD	HL,(TMPSTR+2)	; Temporary string address
    2844/    129E : EB                  	EX	DE,HL		; To DE
    2845/    129F : CD AD 12            	CALL	SSTSA		; First string to string area
    2846/    12A2 : CD AD 12            	CALL	SSTSA		; Second string to string area
    2847/    12A5 : 21 C5 0C            	LD	HL,EVAL2	; Return to evaluation loop
    2848/    12A8 : E3                  	EX	(SP),HL		; Save return,get code string
    2849/    12A9 : E5                  	PUSH	HL		; Save code string address
    2850/    12AA : C3 60 11            	JP	TSTOPL		; To temporary string to pool
    2851/    12AD :                     ;
    2852/    12AD : E1                  SSTSA:	POP	HL		; Return address
    2853/    12AE : E3                  	EX	(SP),HL		; Get string block,save return
    2854/    12AF : 7E                  	LD	A,(HL)		; Get length of string
    2855/    12B0 : 23                  	INC	HL
    2856/    12B1 : 23                  	INC	HL
    2857/    12B2 : 4E                  	LD	C,(HL)		; Get LSB of string address
    2858/    12B3 : 23                  	INC	HL
    2859/    12B4 : 46                  	LD	B,(HL)		; Get MSB of string address
    2860/    12B5 : 6F                  	LD	L,A		; Length to L
    2861/    12B6 : 2C                  TOSTRA: INC	L		; INC - DECed after
    2862/    12B7 : 2D                  TSALP:	DEC	L		; Count bytes moved
    2863/    12B8 : C8                  	RET	Z		; End of string - Return
    2864/    12B9 : 0A                  	LD	A,(BC)		; Get source
    2865/    12BA : 12                  	LD	(DE),A		; Save destination
    2866/    12BB : 03                  	INC	BC		; Next source
    2867/    12BC : 13                  	INC	DE		; Next destination
    2868/    12BD : C3 B7 12            	JP	TSALP		; Loop until string moved
    2869/    12C0 :                     ;
    2870/    12C0 : CD AB 0C            GETSTR: CALL	TSTSTR		; Make sure it's a string
    2871/    12C3 : 2A 29 1E            GSTRCU: LD	HL,(FPREG)	; Get current string
    2872/    12C6 : EB                  GSTRHL: EX	DE,HL		; Save DE
    2873/    12C7 : CD E1 12            GSTRDE: CALL	BAKTMP		; Was it last tmp-str?
    2874/    12CA : EB                  	EX	DE,HL		; Restore DE
    2875/    12CB : C0                  	RET	NZ		; No - Return
    2876/    12CC : D5                  	PUSH	DE		; Save string
    2877/    12CD : 50                  	LD	D,B		; String block address to DE
    2878/    12CE : 59                  	LD	E,C
    2879/    12CF : 1B                  	DEC	DE		; Point to length
    2880/    12D0 : 4E                  	LD	C,(HL)		; Get string length
    2881/    12D1 : 2A 08 1E            	LD	HL,(STRBOT)	; Current bottom of string area
    2882/    12D4 : CD AC 06            	CALL	CPDEHL		; Last one in string area?
    2883/    12D7 : C2 DF 12            	JP	NZ,POPHL	; No - Return
    2884/    12DA : 47                  	LD	B,A		; Clear B (A=0)
    2885/    12DB : 09                  	ADD	HL,BC		; Remove string from str' area
    2886/    12DC : 22 08 1E            	LD	(STRBOT),HL	; Save new bottom of str' area
    2887/    12DF : E1                  POPHL:	POP	HL		; Restore string
    2888/    12E0 : C9                  	RET
    2889/    12E1 :                     ;
    2890/    12E1 : 2A F6 1D            BAKTMP: LD	HL,(TMSTPT)	; Get temporary string pool top
    2891/    12E4 : 2B                  	DEC	HL		; Back
    2892/    12E5 : 46                  	LD	B,(HL)		; Get MSB of address
    2893/    12E6 : 2B                  	DEC	HL		; Back
    2894/    12E7 : 4E                  	LD	C,(HL)		; Get LSB of address
    2895/    12E8 : 2B                  	DEC	HL		; Back
    2896/    12E9 : 2B                  	DEC	HL		; Back
    2897/    12EA : CD AC 06            	CALL	CPDEHL		; String last in string pool?
    2898/    12ED : C0                  	RET	NZ		; Yes - Leave it
    2899/    12EE : 22 F6 1D            	LD	(TMSTPT),HL	; Save new string pool top
    2900/    12F1 : C9                  	RET
    2901/    12F2 :                     ;
    2902/    12F2 : 01 71 10            LEN:	LD	BC,PASSA	; To return integer A
    2903/    12F5 : C5                  	PUSH	BC		; Save address
    2904/    12F6 : CD C0 12            GETLEN: CALL	GETSTR		; Get string and its length
    2905/    12F9 : AF                  	XOR	A
    2906/    12FA : 57                  	LD	D,A		; Clear D
    2907/    12FB : 32 F2 1D            	LD	(TYPE),A	; Set type to numeric
    2908/    12FE : 7E                  	LD	A,(HL)		; Get length of string
    2909/    12FF : B7                  	OR	A		; Set status flags
    2910/    1300 : C9                  	RET
    2911/    1301 :                     ;
    2912/    1301 : 01 71 10            ASC:	LD	BC,PASSA	; To return integer A
    2913/    1304 : C5                  	PUSH	BC		; Save address
    2914/    1305 : CD F6 12            GTFLNM: CALL	GETLEN		; Get length of string
    2915/    1308 : CA 01 09            	JP	Z,FCERR		; Null string - Error
    2916/    130B : 23                  	INC	HL
    2917/    130C : 23                  	INC	HL
    2918/    130D : 5E                  	LD	E,(HL)		; Get LSB of address
    2919/    130E : 23                  	INC	HL
    2920/    130F : 56                  	LD	D,(HL)		; Get MSB of address
    2921/    1310 : 1A                  	LD	A,(DE)		; Get first byte of string
    2922/    1311 : C9                  	RET
    2923/    1312 :                     ;
    2924/    1312 : 3E 01               CHR:	LD	A,1		; One character string
    2925/    1314 : CD 2F 11            	CALL	MKTMST		; Make a temporary string
    2926/    1317 : CD 0B 14            	CALL	MAKINT		; Make it integer A
    2927/    131A : 2A 06 1E            	LD	HL,(TMPSTR+2)	; Get address of string
    2928/    131D : 73                  	LD	(HL),E		; Save character
    2929/    131E : C1                  TOPOOL: POP	BC		; Clean up stack
    2930/    131F : C3 60 11            	JP	TSTOPL		; Temporary string to pool
    2931/    1322 :                     ;
    2932/    1322 : CD BB 13            LEFT:	CALL	LFRGNM		; Get number and ending ")"
    2933/    1325 : AF                  	XOR	A		; Start at first byte in string
    2934/    1326 : E3                  RIGHT1: EX	(SP),HL		; Save code string,Get string
    2935/    1327 : 4F                  	LD	C,A		; Starting position in string
    2936/    1328 : E5                  MID1:	PUSH	HL		; Save string block address
    2937/    1329 : 7E                  	LD	A,(HL)		; Get length of string
    2938/    132A : B8                  	CP	B		; Compare with number given
    2939/    132B : DA 30 13            	JP	C,ALLFOL	; All following bytes required
    2940/    132E : 78                  	LD	A,B		; Get new length
    2941/    132F : 11                  	DB	11H		; Skip "LD C,0"
    2942/    1330 : 0E 00               ALLFOL: LD	C,0		; First byte of string
    2943/    1332 : C5                  	PUSH	BC		; Save position in string
    2944/    1333 : CD 99 11            	CALL	TESTR		; See if enough string space
    2945/    1336 : C1                  	POP	BC		; Get position in string
    2946/    1337 : E1                  	POP	HL		; Restore string block address
    2947/    1338 : E5                  	PUSH	HL		; And re-save it
    2948/    1339 : 23                  	INC	HL
    2949/    133A : 23                  	INC	HL
    2950/    133B : 46                  	LD	B,(HL)		; Get LSB of address
    2951/    133C : 23                  	INC	HL
    2952/    133D : 66                  	LD	H,(HL)		; Get MSB of address
    2953/    133E : 68                  	LD	L,B		; HL = address of string
    2954/    133F : 06 00               	LD	B,0		; BC = starting address
    2955/    1341 : 09                  	ADD	HL,BC		; Point to that byte
    2956/    1342 : 44                  	LD	B,H		; BC = source string
    2957/    1343 : 4D                  	LD	C,L
    2958/    1344 : CD 32 11            	CALL	CRTMST		; Create a string entry
    2959/    1347 : 6F                  	LD	L,A		; Length of new string
    2960/    1348 : CD B6 12            	CALL	TOSTRA		; Move string to string area
    2961/    134B : D1                  	POP	DE		; Clear stack
    2962/    134C : CD C7 12            	CALL	GSTRDE		; Move to string pool if needed
    2963/    134F : C3 60 11            	JP	TSTOPL		; Temporary string to pool
    2964/    1352 :                     ;
    2965/    1352 : CD BB 13            RIGHT:	CALL	LFRGNM		; Get number and ending ")"
    2966/    1355 : D1                  	POP	DE		; Get string length
    2967/    1356 : D5                  	PUSH	DE		; And re-save
    2968/    1357 : 1A                  	LD	A,(DE)		; Get length
    2969/    1358 : 90                  	SUB	B		; Move back N bytes
    2970/    1359 : C3 26 13            	JP	RIGHT1		; Go and get sub-string
    2971/    135C :                     ;
    2972/    135C : EB                  MID:	EX	DE,HL		; Get code string address
    2973/    135D : 7E                  	LD	A,(HL)		; Get next byte ',' or ")"
    2974/    135E : CD C0 13            	CALL	MIDNUM		; Get number supplied
    2975/    1361 : 04                  	INC	B		; Is it character zero?
    2976/    1362 : 05                  	DEC	B
    2977/    1363 : CA 01 09            	JP	Z,FCERR		; Yes - Error
    2978/    1366 : C5                  	PUSH	BC		; Save starting position
    2979/    1367 : 1E FF               	LD	E,255		; All of string
    2980/    1369 : FE 29               	CP	')'		; Any length given?
    2981/    136B : CA 75 13            	JP	Z,RSTSTR	; No - Rest of string
    2982/    136E : CD B2 06            	CALL	CHKSYN		; Make sure ',' follows
    2983/    1371 : 2C                  	DB	','
    2984/    1372 : CD 08 14            	CALL	GETINT		; Get integer 0-255
    2985/    1375 : CD B2 06            RSTSTR: CALL	CHKSYN		; Make sure ")" follows
    2986/    1378 : 29                  	DB	")"
    2987/    1379 : F1                  	POP	AF		; Restore starting position
    2988/    137A : E3                  	EX	(SP),HL		; Get string,8ave code string
    2989/    137B : 01 28 13            	LD	BC,MID1		; Continuation of MID$ routine
    2990/    137E : C5                  	PUSH	BC		; Save for return
    2991/    137F : 3D                  	DEC	A		; Starting position-1
    2992/    1380 : BE                  	CP	(HL)		; Compare with length
    2993/    1381 : 06 00               	LD	B,0		; Zero bytes length
    2994/    1383 : D0                  	RET	NC		; Null string if start past end
    2995/    1384 : 4F                  	LD	C,A		; Save starting position-1
    2996/    1385 : 7E                  	LD	A,(HL)		; Get length of string
    2997/    1386 : 91                  	SUB	C		; Subtract start
    2998/    1387 : BB                  	CP	E		; Enough string for it?
    2999/    1388 : 47                  	LD	B,A		; Save maximum length available
    3000/    1389 : D8                  	RET	C		; Truncate string if needed
    3001/    138A : 43                  	LD	B,E		; Set specified length
    3002/    138B : C9                  	RET			; Go and create string
    3003/    138C :                     ;
    3004/    138C : CD F6 12            VAL:	CALL	GETLEN		; Get length of string
    3005/    138F : CA A9 14            	JP	Z,RESZER	; Result zero
    3006/    1392 : 5F                  	LD	E,A		; Save length
    3007/    1393 : 23                  	INC	HL
    3008/    1394 : 23                  	INC	HL
    3009/    1395 : 7E                  	LD	A,(HL)		; Get LSB of address
    3010/    1396 : 23                  	INC	HL
    3011/    1397 : 66                  	LD	H,(HL)		; Get MSB of address
    3012/    1398 : 6F                  	LD	L,A		; HL = String address
    3013/    1399 : E5                  	PUSH	HL		; Save string address
    3014/    139A : 19                  	ADD	HL,DE
    3015/    139B : 46                  	LD	B,(HL)		; Get end of string+1 byte
    3016/    139C : 72                  	LD	(HL),D		; Zero it to terminate
    3017/    139D : E3                  	EX	(SP),HL		; Save string end,get start
    3018/    139E : C5                  	PUSH	BC		; Save end+1 byte
    3019/    139F : 7E                  	LD	A,(HL)		; Get starting byte
    3020/    13A0 : FE 24               	CP	'$'		; Hex number indicated? [function added]
    3021/    13A2 : C2 AA 13            	JP	NZ,VAL1
    3022/    13A5 : CD D3 1B            	CALL	HEXTFP		; Convert Hex to FPREG
    3023/    13A8 : 18 0D               	JR	VAL3
    3024/    13AA : FE 25               VAL1:	CP	'%'		; Binary number indicated? [function added]
    3025/    13AC : C2 B4 13            	JP	NZ,VAL2
    3026/    13AF : CD 43 1C            	CALL	BINTFP		; Convert Bin to FPREG
    3027/    13B2 : 18 03               	JR	VAL3
    3028/    13B4 : CD 90 17            VAL2:	CALL	ASCTFP		; Convert ASCII string to FP
    3029/    13B7 : C1                  VAL3:	POP	BC		; Restore end+1 byte
    3030/    13B8 : E1                  	POP	HL		; Restore end+1 address
    3031/    13B9 : 70                  	LD	(HL),B		; Put back original byte
    3032/    13BA : C9                  	RET
    3033/    13BB :                     ;
    3034/    13BB : EB                  LFRGNM: EX	DE,HL		; Code string address to HL
    3035/    13BC : CD B2 06            	CALL	CHKSYN		; Make sure ")" follows
    3036/    13BF : 29                  	DB	")"
    3037/    13C0 : C1                  MIDNUM: POP	BC		; Get return address
    3038/    13C1 : D1                  	POP	DE		; Get number supplied
    3039/    13C2 : C5                  	PUSH	BC		; Re-save return address
    3040/    13C3 : 43                  	LD	B,E		; Number to B
    3041/    13C4 : C9                  	RET
    3042/    13C5 :                     ;
    3043/    13C5 : CD 0B 14            INP:	CALL	MAKINT		; Make it integer A
    3044/    13C8 : 32 84 1D            	LD	(INPORT),A	; Set input port
    3045/    13CB : CD 83 1D            	CALL	INPSUB		; Get input from port
    3046/    13CE : C3 71 10            	JP	PASSA		; Return integer A
    3047/    13D1 :                     ;
    3048/    13D1 : CD F5 13            POUT:	CALL	SETIO		; Set up port number
    3049/    13D4 : C3 4B 1D            	JP	OUTSUB		; Output data and return
    3050/    13D7 :                     ;
    3051/    13D7 : CD F5 13            WAIT:	CALL	SETIO		; Set up port number
    3052/    13DA : F5                  	PUSH	AF		; Save AND mask
    3053/    13DB : 1E 00               	LD	E,0		; Assume zero if none given
    3054/    13DD : 2B                  	DEC	HL		; DEC 'cos GETCHR INCs
    3055/    13DE : CD 3A 08            	CALL	GETCHR		; Get next character
    3056/    13E1 : CA EB 13            	JP	Z,NOXOR		; No XOR byte given
    3057/    13E4 : CD B2 06            	CALL	CHKSYN		; Make sure ',' follows
    3058/    13E7 : 2C                  	DB	','
    3059/    13E8 : CD 08 14            	CALL	GETINT		; Get integer 0-255 to XOR with
    3060/    13EB : C1                  NOXOR:	POP	BC		; Restore AND mask
    3061/    13EC : CD 83 1D            WAITLP: CALL	INPSUB		; Get input
    3062/    13EF : AB                  	XOR	E		; Flip selected bits
    3063/    13F0 : A0                  	AND	B		; Result non-zero?
    3064/    13F1 : CA EC 13            	JP	Z,WAITLP	; No = keep waiting
    3065/    13F4 : C9                  	RET
    3066/    13F5 :                     ;
    3067/    13F5 : CD 08 14            SETIO:	CALL	GETINT		; Get integer 0-255
    3068/    13F8 : 32 84 1D            	LD	(INPORT),A	; Set input port
    3069/    13FB : 32 4C 1D            	LD	(OTPORT),A	; Set output port
    3070/    13FE : CD B2 06            	CALL	CHKSYN		; Make sure ',' follows
    3071/    1401 : 2C                  	DB	','
    3072/    1402 : C3 08 14            	JP	GETINT		; Get integer 0-255 and return
    3073/    1405 :                     ;
    3074/    1405 : CD 3A 08            FNDNUM: CALL	GETCHR		; Get next character
    3075/    1408 : CD A7 0C            GETINT: CALL	GETNUM		; Get a number from 0 to 255
    3076/    140B : CD E6 08            MAKINT: CALL	DEPINT		; Make sure value 0 - 255
    3077/    140E : 7A                  	LD	A,D		; Get MSB of number
    3078/    140F : B7                  	OR	A		; Zero?
    3079/    1410 : C2 01 09            	JP	NZ,FCERR	; No - Error
    3080/    1413 : 2B                  	DEC	HL		; DEC 'cos GETCHR INCs
    3081/    1414 : CD 3A 08            	CALL	GETCHR		; Get next character
    3082/    1417 : 7B                  	LD	A,E		; Get number to A
    3083/    1418 : C9                  	RET
    3084/    1419 :                     ;
    3085/    1419 : CD EC 08            PEEK:	CALL	DEINT		; Get memory address
    3086/    141C : 1A                  	LD	A,(DE)		; Get byte in memory
    3087/    141D : C3 71 10            	JP	PASSA		; Return integer A
    3088/    1420 :                     ;
    3089/    1420 : CD A7 0C            POKE:	CALL	GETNUM		; Get memory address
    3090/    1423 : CD EC 08            	CALL	DEINT		; Get integer -32768 to 3276
    3091/    1426 : D5                  	PUSH	DE		; Save memory address
    3092/    1427 : CD B2 06            	CALL	CHKSYN		; Make sure ',' follows
    3093/    142A : 2C                  	DB	','
    3094/    142B : CD 08 14            	CALL	GETINT		; Get integer 0-255
    3095/    142E : D1                  	POP	DE		; Restore memory address
    3096/    142F : 12                  	LD	(DE),A		; Load it into memory
    3097/    1430 : C9                  	RET
    3098/    1431 :                     ;
    3099/    1431 : 21 07 19            ROUND:	LD	HL,HALF		; Add 0.5 to FPREG
    3100/    1434 : CD D8 16            ADDPHL: CALL	LOADFP		; Load FP at (HL) to BCDE
    3101/    1437 : C3 43 14            	JP	FPADD		; Add BCDE to FPREG
    3102/    143A :                     ;
    3103/    143A : CD D8 16            SUBPHL: CALL	LOADFP		; FPREG = -FPREG + number at HL
    3104/    143D : 21                  	DB	21H		; Skip "POP BC" and "POP DE"
    3105/    143E : C1                  PSUB:	POP	BC		; Get FP number from stack
    3106/    143F : D1                  	POP	DE
    3107/    1440 : CD B2 16            SUBCDE: CALL	INVSGN		; Negate FPREG
    3108/    1443 : 78                  FPADD:	LD	A,B		; Get FP exponent
    3109/    1444 : B7                  	OR	A		; Is number zero?
    3110/    1445 : C8                  	RET	Z		; Yes - Nothing to add
    3111/    1446 : 3A 2C 1E            	LD	A,(FPEXP)	; Get FPREG exponent
    3112/    1449 : B7                  	OR	A		; Is this number zero?
    3113/    144A : CA CA 16            	JP	Z,FPBCDE	; Yes - Move BCDE to FPREG
    3114/    144D : 90                  	SUB	B		; BCDE number larger?
    3115/    144E : D2 5D 14            	JP	NC,NOSWAP	; No - Don't swap them
    3116/    1451 : 2F                  	CPL			; Two's complement
    3117/    1452 : 3C                  	INC	A		;	FP exponent
    3118/    1453 : EB                  	EX	DE,HL
    3119/    1454 : CD BA 16            	CALL	STAKFP		; Put FPREG on stack
    3120/    1457 : EB                  	EX	DE,HL
    3121/    1458 : CD CA 16            	CALL	FPBCDE		; Move BCDE to FPREG
    3122/    145B : C1                  	POP	BC		; Restore number from stack
    3123/    145C : D1                  	POP	DE
    3124/    145D : FE 19               NOSWAP: CP	24+1		; Second number insignificant?
    3125/    145F : D0                  	RET	NC		; Yes - First number is result
    3126/    1460 : F5                  	PUSH	AF		; Save number of bits to scale
    3127/    1461 : CD EF 16            	CALL	SIGNS		; Set MSBs & sign of result
    3128/    1464 : 67                  	LD	H,A		; Save sign of result
    3129/    1465 : F1                  	POP	AF		; Restore scaling factor
    3130/    1466 : CD 08 15            	CALL	SCALE		; Scale BCDE to same exponent
    3131/    1469 : B4                  	OR	H		; Result to be positive?
    3132/    146A : 21 29 1E            	LD	HL,FPREG	; Point to FPREG
    3133/    146D : F2 83 14            	JP	P,MINCDE	; No - Subtract FPREG from CDE
    3134/    1470 : CD E8 14            	CALL	PLUCDE		; Add FPREG to CDE
    3135/    1473 : D2 C9 14            	JP	NC,RONDUP	; No overflow - Round it up
    3136/    1476 : 23                  	INC	HL		; Point to exponent
    3137/    1477 : 34                  	INC	(HL)		; Increment it
    3138/    1478 : CA F3 03            	JP	Z,OVERR		; Number overflowed - Error
    3139/    147B : 2E 01               	LD	L,1		; 1 bit to shift right
    3140/    147D : CD 1E 15            	CALL	SHRT1		; Shift result right
    3141/    1480 : C3 C9 14            	JP	RONDUP		; Round it up
    3142/    1483 :                     ;
    3143/    1483 : AF                  MINCDE: XOR	A		; Clear A and carry
    3144/    1484 : 90                  	SUB	B		; Negate exponent
    3145/    1485 : 47                  	LD	B,A		; Re-save exponent
    3146/    1486 : 7E                  	LD	A,(HL)		; Get LSB of FPREG
    3147/    1487 : 9B                  	SBC	A, E		; Subtract LSB of BCDE
    3148/    1488 : 5F                  	LD	E,A		; Save LSB of BCDE
    3149/    1489 : 23                  	INC	HL
    3150/    148A : 7E                  	LD	A,(HL)		; Get NMSB of FPREG
    3151/    148B : 9A                  	SBC	A,D		; Subtract NMSB of BCDE
    3152/    148C : 57                  	LD	D,A		; Save NMSB of BCDE
    3153/    148D : 23                  	INC	HL
    3154/    148E : 7E                  	LD	A,(HL)		; Get MSB of FPREG
    3155/    148F : 99                  	SBC	A,C		; Subtract MSB of BCDE
    3156/    1490 : 4F                  	LD	C,A		; Save MSB of BCDE
    3157/    1491 : DC F4 14            CONPOS: CALL	C,COMPL		; Overflow - Make it positive
    3158/    1494 :                     ;
    3159/    1494 : 68                  BNORM:	LD	L,B		; L = Exponent
    3160/    1495 : 63                  	LD	H,E		; H = LSB
    3161/    1496 : AF                  	XOR	A
    3162/    1497 : 47                  BNRMLP: LD	B,A		; Save bit count
    3163/    1498 : 79                  	LD	A,C		; Get MSB
    3164/    1499 : B7                  	OR	A		; Is it zero?
    3165/    149A : C2 B6 14            	JP	NZ,PNORM	; No - Do it bit at a time
    3166/    149D : 4A                  	LD	C,D		; MSB = NMSB
    3167/    149E : 54                  	LD	D,H		; NMSB= LSB
    3168/    149F : 65                  	LD	H,L		; LSB = VLSB
    3169/    14A0 : 6F                  	LD	L,A		; VLSB= 0
    3170/    14A1 : 78                  	LD	A,B		; Get exponent
    3171/    14A2 : D6 08               	SUB	8		; Count 8 bits
    3172/    14A4 : FE E0               	CP	0E0H		; -24-8 Was number zero?
    3173/    14A6 : C2 97 14            	JP	NZ,BNRMLP	; No - Keep normalising
    3174/    14A9 : AF                  RESZER: XOR	A		; Result is zero
    3175/    14AA : 32 2C 1E            SAVEXP: LD	(FPEXP),A	; Save result as zero
    3176/    14AD : C9                  	RET
    3177/    14AE :                     ;
    3178/    14AE : 05                  NORMAL: DEC	B		; Count bits
    3179/    14AF : 29                  	ADD	HL,HL		; Shift HL left
    3180/    14B0 : 7A                  	LD	A,D		; Get NMSB
    3181/    14B1 : 17                  	RLA			; Shift left with last bit
    3182/    14B2 : 57                  	LD	D,A		; Save NMSB
    3183/    14B3 : 79                  	LD	A,C		; Get MSB
    3184/    14B4 : 8F                  	ADC	A,A		; Shift left with last bit
    3185/    14B5 : 4F                  	LD	C,A		; Save MSB
    3186/    14B6 : F2 AE 14            PNORM:	JP	P,NORMAL	; Not done - Keep going
    3187/    14B9 : 78                  	LD	A,B		; Number of bits shifted
    3188/    14BA : 5C                  	LD	E,H		; Save HL in EB
    3189/    14BB : 45                  	LD	B,L
    3190/    14BC : B7                  	OR	A		; Any shifting done?
    3191/    14BD : CA C9 14            	JP	Z,RONDUP	; No - Round it up
    3192/    14C0 : 21 2C 1E            	LD	HL,FPEXP	; Point to exponent
    3193/    14C3 : 86                  	ADD	A,(HL)		; Add shifted bits
    3194/    14C4 : 77                  	LD	(HL),A		; Re-save exponent
    3195/    14C5 : D2 A9 14            	JP	NC,RESZER	; Underflow - Result is zero
    3196/    14C8 : C8                  	RET	Z		; Result is zero
    3197/    14C9 : 78                  RONDUP: LD	A,B		; Get VLSB of number
    3198/    14CA : 21 2C 1E            RONDB:	LD	HL,FPEXP	; Point to exponent
    3199/    14CD : B7                  	OR	A		; Any rounding?
    3200/    14CE : FC DB 14            	CALL	M,FPROND	; Yes - Round number up
    3201/    14D1 : 46                  	LD	B,(HL)		; B = Exponent
    3202/    14D2 : 23                  	INC	HL
    3203/    14D3 : 7E                  	LD	A,(HL)		; Get sign of result
    3204/    14D4 : E6 80               	AND	10000000B	; Only bit 7 needed
    3205/    14D6 : A9                  	XOR	C		; Set correct sign
    3206/    14D7 : 4F                  	LD	C,A		; Save correct sign in number
    3207/    14D8 : C3 CA 16            	JP	FPBCDE		; Move BCDE to FPREG
    3208/    14DB :                     ;
    3209/    14DB : 1C                  FPROND: INC	E		; Round LSB
    3210/    14DC : C0                  	RET	NZ		; Return if ok
    3211/    14DD : 14                  	INC	D		; Round NMSB
    3212/    14DE : C0                  	RET	NZ		; Return if ok
    3213/    14DF : 0C                  	INC	C		; Round MSB
    3214/    14E0 : C0                  	RET	NZ		; Return if ok
    3215/    14E1 : 0E 80               	LD	C,80H		; Set normal value
    3216/    14E3 : 34                  	INC	(HL)		; Increment exponent
    3217/    14E4 : C0                  	RET	NZ		; Return if ok
    3218/    14E5 : C3 F3 03            	JP	OVERR		; Overflow error
    3219/    14E8 :                     ;
    3220/    14E8 : 7E                  PLUCDE: LD	A,(HL)		; Get LSB of FPREG
    3221/    14E9 : 83                  	ADD	A,E		; Add LSB of BCDE
    3222/    14EA : 5F                  	LD	E,A		; Save LSB of BCDE
    3223/    14EB : 23                  	INC	HL
    3224/    14EC : 7E                  	LD	A,(HL)		; Get NMSB of FPREG
    3225/    14ED : 8A                  	ADC	A,D		; Add NMSB of BCDE
    3226/    14EE : 57                  	LD	D,A		; Save NMSB of BCDE
    3227/    14EF : 23                  	INC	HL
    3228/    14F0 : 7E                  	LD	A,(HL)		; Get MSB of FPREG
    3229/    14F1 : 89                  	ADC	A,C		; Add MSB of BCDE
    3230/    14F2 : 4F                  	LD	C,A		; Save MSB of BCDE
    3231/    14F3 : C9                  	RET
    3232/    14F4 :                     ;
    3233/    14F4 : 21 2D 1E            COMPL:	LD	HL,SGNRES	; Sign of result
    3234/    14F7 : 7E                  	LD	A,(HL)		; Get sign of result
    3235/    14F8 : 2F                  	CPL			; Negate it
    3236/    14F9 : 77                  	LD	(HL),A		; Put it back
    3237/    14FA : AF                  	XOR	A
    3238/    14FB : 6F                  	LD	L,A		; Set L to zero
    3239/    14FC : 90                  	SUB	B		; Negate exponent,set carry
    3240/    14FD : 47                  	LD	B,A		; Re-save exponent
    3241/    14FE : 7D                  	LD	A,L		; Load zero
    3242/    14FF : 9B                  	SBC	A,E		; Negate LSB
    3243/    1500 : 5F                  	LD	E,A		; Re-save LSB
    3244/    1501 : 7D                  	LD	A,L		; Load zero
    3245/    1502 : 9A                  	SBC	A,D		; Negate NMSB
    3246/    1503 : 57                  	LD	D,A		; Re-save NMSB
    3247/    1504 : 7D                  	LD	A,L		; Load zero
    3248/    1505 : 99                  	SBC	A,C		; Negate MSB
    3249/    1506 : 4F                  	LD	C,A		; Re-save MSB
    3250/    1507 : C9                  	RET
    3251/    1508 :                     ;
    3252/    1508 : 06 00               SCALE:	LD	B,0		; Clear underflow
    3253/    150A : D6 08               SCALLP: SUB	8		; 8 bits (a whole byte)?
    3254/    150C : DA 17 15            	JP	C,SHRITE	; No - Shift right A bits
    3255/    150F : 43                  	LD	B,E		; <- Shift
    3256/    1510 : 5A                  	LD	E,D		; <- right
    3257/    1511 : 51                  	LD	D,C		; <- eight
    3258/    1512 : 0E 00               	LD	C,0		; <- bits
    3259/    1514 : C3 0A 15            	JP	SCALLP		; More bits to shift
    3260/    1517 :                     ;
    3261/    1517 : C6 09               SHRITE: ADD	A,8+1		; Adjust count
    3262/    1519 : 6F                  	LD	L,A		; Save bits to shift
    3263/    151A : AF                  SHRLP:	XOR	A		; Flag for all done
    3264/    151B : 2D                  	DEC	L		; All shifting done?
    3265/    151C : C8                  	RET	Z		; Yes - Return
    3266/    151D : 79                  	LD	A,C		; Get MSB
    3267/    151E : 1F                  SHRT1:	RRA			; Shift it right
    3268/    151F : 4F                  	LD	C,A		; Re-save
    3269/    1520 : 7A                  	LD	A,D		; Get NMSB
    3270/    1521 : 1F                  	RRA			; Shift right with last bit
    3271/    1522 : 57                  	LD	D,A		; Re-save it
    3272/    1523 : 7B                  	LD	A,E		; Get LSB
    3273/    1524 : 1F                  	RRA			; Shift right with last bit
    3274/    1525 : 5F                  	LD	E,A		; Re-save it
    3275/    1526 : 78                  	LD	A,B		; Get underflow
    3276/    1527 : 1F                  	RRA			; Shift right with last bit
    3277/    1528 : 47                  	LD	B,A		; Re-save underflow
    3278/    1529 : C3 1A 15            	JP	SHRLP		; More bits to do
    3279/    152C :                     ;
    3280/    152C : 00 00 00 81         UNITY:	DB	 000H,000H,000H,081H	; 1.00000
    3281/    1530 :                     ;
    3282/    1530 : 03                  LOGTAB: DB	3			; Table used by LOG
    3283/    1531 : AA 56 19 80         	DB	0AAH,056H,019H,080H	; 0.59898
    3284/    1535 : F1 22 76 80         	DB	0F1H,022H,076H,080H	; 0.96147
    3285/    1539 : 45 AA 38 82         	DB	045H,0AAH,038H,082H	; 2.88539
    3286/    153D :                     ;
    3287/    153D : CD 89 16            LOG:	CALL	TSTSGN		; Test sign of value
    3288/    1540 : B7                  	OR	A
    3289/    1541 : EA 01 09            	JP	PE,FCERR	; ?FC Error if <= zero
    3290/    1544 : 21 2C 1E            	LD	HL,FPEXP	; Point to exponent
    3291/    1547 : 7E                  	LD	A,(HL)		; Get exponent
    3292/    1548 : 01 35 80            	LD	BC,8035H	; BCDE = SQR(1/2)
    3293/    154B : 11 F3 04            	LD	DE,04F3H
    3294/    154E : 90                  	SUB	B		; Scale value to be < 1
    3295/    154F : F5                  	PUSH	AF		; Save scale factor
    3296/    1550 : 70                  	LD	(HL),B		; Save new exponent
    3297/    1551 : D5                  	PUSH	DE		; Save SQR(1/2)
    3298/    1552 : C5                  	PUSH	BC
    3299/    1553 : CD 43 14            	CALL	FPADD		; Add SQR(1/2) to value
    3300/    1556 : C1                  	POP	BC		; Restore SQR(1/2)
    3301/    1557 : D1                  	POP	DE
    3302/    1558 : 04                  	INC	B		; Make it SQR(2)
    3303/    1559 : CD DF 15            	CALL	DVBCDE		; Divide by SQR(2)
    3304/    155C : 21 2C 15            	LD	HL,UNITY	; Point to 1.
    3305/    155F : CD 3A 14            	CALL	SUBPHL		; Subtract FPREG from 1
    3306/    1562 : 21 30 15            	LD	HL,LOGTAB	; Coefficient table
    3307/    1565 : CD D1 19            	CALL	SUMSER		; Evaluate sum of series
    3308/    1568 : 01 80 80            	LD	BC,8080H	; BCDE = -0.5
    3309/    156B : 11 00 00            	LD	DE,0000H
    3310/    156E : CD 43 14            	CALL	FPADD		; Subtract 0.5 from FPREG
    3311/    1571 : F1                  	POP	AF		; Restore scale factor
    3312/    1572 : CD 04 18            	CALL	RSCALE		; Re-scale number
    3313/    1575 : 01 31 80            MULLN2: LD	BC,8031H	; BCDE = Ln(2)
    3314/    1578 : 11 18 72            	LD	DE,7218H
    3315/    157B : 21                  	DB	21H		; Skip "POP BC" and "POP DE"
    3316/    157C :                     ;
    3317/    157C : C1                  MULT:	POP	BC		; Get number from stack
    3318/    157D : D1                  	POP	DE
    3319/    157E : CD 89 16            FPMULT: CALL	TSTSGN		; Test sign of FPREG
    3320/    1581 : C8                  	RET	Z		; Return zero if zero
    3321/    1582 : 2E 00               	LD	L,0		; Flag add exponents
    3322/    1584 : CD 47 16            	CALL	ADDEXP		; Add exponents
    3323/    1587 : 79                  	LD	A,C		; Get MSB of multiplier
    3324/    1588 : 32 3B 1E            	LD	(MULVAL),A	; Save MSB of multiplier
    3325/    158B : EB                  	EX	DE,HL
    3326/    158C : 22 3C 1E            	LD	(MULVAL+1),HL	; Save rest of multiplier
    3327/    158F : 01 00 00            	LD	BC,0		; Partial product (BCDE) = zero
    3328/    1592 : 50                  	LD	D,B
    3329/    1593 : 58                  	LD	E,B
    3330/    1594 : 21 94 14            	LD	HL,BNORM	; Address of normalise
    3331/    1597 : E5                  	PUSH	HL		; Save for return
    3332/    1598 : 21 A0 15            	LD	HL,MULT8	; Address of 8 bit multiply
    3333/    159B : E5                  	PUSH	HL		; Save for NMSB,MSB
    3334/    159C : E5                  	PUSH	HL		; 
    3335/    159D : 21 29 1E            	LD	HL,FPREG	; Point to number
    3336/    15A0 : 7E                  MULT8:	LD	A,(HL)		; Get LSB of number
    3337/    15A1 : 23                  	INC	HL		; Point to NMSB
    3338/    15A2 : B7                  	OR	A		; Test LSB
    3339/    15A3 : CA CC 15            	JP	Z,BYTSFT	; Zero - shift to next byte
    3340/    15A6 : E5                  	PUSH	HL		; Save address of number
    3341/    15A7 : 2E 08               	LD	L,8		; 8 bits to multiply by
    3342/    15A9 : 1F                  MUL8LP: RRA			; Shift LSB right
    3343/    15AA : 67                  	LD	H,A		; Save LSB
    3344/    15AB : 79                  	LD	A,C		; Get MSB
    3345/    15AC : D2 BA 15            	JP	NC,NOMADD	; Bit was zero - Don't add
    3346/    15AF : E5                  	PUSH	HL		; Save LSB and count
    3347/    15B0 : 2A 3C 1E            	LD	HL,(MULVAL+1)	; Get LSB and NMSB
    3348/    15B3 : 19                  	ADD	HL,DE		; Add NMSB and LSB
    3349/    15B4 : EB                  	EX	DE,HL		; Leave sum in DE
    3350/    15B5 : E1                  	POP	HL		; Restore MSB and count
    3351/    15B6 : 3A 3B 1E            	LD	A,(MULVAL)	; Get MSB of multiplier
    3352/    15B9 : 89                  	ADC	A,C		; Add MSB
    3353/    15BA : 1F                  NOMADD: RRA			; Shift MSB right
    3354/    15BB : 4F                  	LD	C,A		; Re-save MSB
    3355/    15BC : 7A                  	LD	A,D		; Get NMSB
    3356/    15BD : 1F                  	RRA			; Shift NMSB right
    3357/    15BE : 57                  	LD	D,A		; Re-save NMSB
    3358/    15BF : 7B                  	LD	A,E		; Get LSB
    3359/    15C0 : 1F                  	RRA			; Shift LSB right
    3360/    15C1 : 5F                  	LD	E,A		; Re-save LSB
    3361/    15C2 : 78                  	LD	A,B		; Get VLSB
    3362/    15C3 : 1F                  	RRA			; Shift VLSB right
    3363/    15C4 : 47                  	LD	B,A		; Re-save VLSB
    3364/    15C5 : 2D                  	DEC	L		; Count bits multiplied
    3365/    15C6 : 7C                  	LD	A,H		; Get LSB of multiplier
    3366/    15C7 : C2 A9 15            	JP	NZ,MUL8LP	; More - Do it
    3367/    15CA : E1                  POPHRT: POP	HL		; Restore address of number
    3368/    15CB : C9                  	RET
    3369/    15CC :                     ;
    3370/    15CC : 43                  BYTSFT: LD	B,E		; Shift partial product left
    3371/    15CD : 5A                  	LD	E,D
    3372/    15CE : 51                  	LD	D,C
    3373/    15CF : 4F                  	LD	C,A
    3374/    15D0 : C9                  	RET
    3375/    15D1 :                     ;
    3376/    15D1 : CD BA 16            DIV10:	CALL	STAKFP		; Save FPREG on stack
    3377/    15D4 : 01 20 84            	LD	BC,8420H	; BCDE = 10.
    3378/    15D7 : 11 00 00            	LD	DE,0000H
    3379/    15DA : CD CA 16            	CALL	FPBCDE		; Move 10 to FPREG
    3380/    15DD :                     ;
    3381/    15DD : C1                  DIV:	POP	BC		; Get number from stack
    3382/    15DE : D1                  	POP	DE
    3383/    15DF : CD 89 16            DVBCDE: CALL	TSTSGN		; Test sign of FPREG
    3384/    15E2 : CA E7 03            	JP	Z,DZERR		; Error if division by zero
    3385/    15E5 : 2E FF               	LD	L,-1		; Flag subtract exponents
    3386/    15E7 : CD 47 16            	CALL	ADDEXP		; Subtract exponents
    3387/    15EA : 34                  	INC	(HL)		; Add 2 to exponent to adjust
    3388/    15EB : 34                  	INC	(HL)
    3389/    15EC : 2B                  	DEC	HL		; Point to MSB
    3390/    15ED : 7E                  	LD	A,(HL)		; Get MSB of dividend
    3391/    15EE : 32 57 1D            	LD	(DIV3),A	; Save for subtraction
    3392/    15F1 : 2B                  	DEC	HL
    3393/    15F2 : 7E                  	LD	A,(HL)		; Get NMSB of dividend
    3394/    15F3 : 32 53 1D            	LD	(DIV2),A	; Save for subtraction
    3395/    15F6 : 2B                  	DEC	HL
    3396/    15F7 : 7E                  	LD	A,(HL)		; Get MSB of dividend
    3397/    15F8 : 32 4F 1D            	LD	(DIV1),A	; Save for subtraction
    3398/    15FB : 41                  	LD	B,C		; Get MSB
    3399/    15FC : EB                  	EX	DE,HL		; NMSB,LSB to HL
    3400/    15FD : AF                  	XOR	A
    3401/    15FE : 4F                  	LD	C,A		; Clear MSB of quotient
    3402/    15FF : 57                  	LD	D,A		; Clear NMSB of quotient
    3403/    1600 : 5F                  	LD	E,A		; Clear LSB of quotient
    3404/    1601 : 32 5A 1D            	LD	(DIV4),A	; Clear overflow count
    3405/    1604 : E5                  DIVLP:	PUSH	HL		; Save divisor
    3406/    1605 : C5                  	PUSH	BC
    3407/    1606 : 7D                  	LD	A,L		; Get LSB of number
    3408/    1607 : CD 4E 1D            	CALL	DIVSUP		; Subt' divisor from dividend
    3409/    160A : DE 00               	SBC	A,0		; Count for overflows
    3410/    160C : 3F                  	CCF
    3411/    160D : D2 17 16            	JP	NC,RESDIV	; Restore divisor if borrow
    3412/    1610 : 32 5A 1D            	LD	(DIV4),A	; Re-save overflow count
    3413/    1613 : F1                  	POP	AF		; Scrap divisor
    3414/    1614 : F1                  	POP	AF
    3415/    1615 : 37                  	SCF			; Set carry to
    3416/    1616 : D2                  	DB	0D2H		; Skip "POP BC" and "POP HL"
    3417/    1617 :                     ;
    3418/    1617 : C1                  RESDIV: POP	BC		; Restore divisor
    3419/    1618 : E1                  	POP	HL
    3420/    1619 : 79                  	LD	A,C		; Get MSB of quotient
    3421/    161A : 3C                  	INC	A
    3422/    161B : 3D                  	DEC	A
    3423/    161C : 1F                  	RRA			; Bit 0 to bit 7
    3424/    161D : FA CA 14            	JP	M,RONDB		; Done - Normalise result
    3425/    1620 : 17                  	RLA			; Restore carry
    3426/    1621 : 7B                  	LD	A,E		; Get LSB of quotient
    3427/    1622 : 17                  	RLA			; Double it
    3428/    1623 : 5F                  	LD	E,A		; Put it back
    3429/    1624 : 7A                  	LD	A,D		; Get NMSB of quotient
    3430/    1625 : 17                  	RLA			; Double it
    3431/    1626 : 57                  	LD	D,A		; Put it back
    3432/    1627 : 79                  	LD	A,C		; Get MSB of quotient
    3433/    1628 : 17                  	RLA			; Double it
    3434/    1629 : 4F                  	LD	C,A		; Put it back
    3435/    162A : 29                  	ADD	HL,HL		; Double NMSB,LSB of divisor
    3436/    162B : 78                  	LD	A,B		; Get MSB of divisor
    3437/    162C : 17                  	RLA			; Double it
    3438/    162D : 47                  	LD	B,A		; Put it back
    3439/    162E : 3A 5A 1D            	LD	A,(DIV4)	; Get VLSB of quotient
    3440/    1631 : 17                  	RLA			; Double it
    3441/    1632 : 32 5A 1D            	LD	(DIV4),A	; Put it back
    3442/    1635 : 79                  	LD	A,C		; Get MSB of quotient
    3443/    1636 : B2                  	OR	D		; Merge NMSB
    3444/    1637 : B3                  	OR	E		; Merge LSB
    3445/    1638 : C2 04 16            	JP	NZ,DIVLP	; Not done - Keep dividing
    3446/    163B : E5                  	PUSH	HL		; Save divisor
    3447/    163C : 21 2C 1E            	LD	HL,FPEXP	; Point to exponent
    3448/    163F : 35                  	DEC	(HL)		; Divide by 2
    3449/    1640 : E1                  	POP	HL		; Restore divisor
    3450/    1641 : C2 04 16            	JP	NZ,DIVLP	; Ok - Keep going
    3451/    1644 : C3 F3 03            	JP	OVERR		; Overflow error
    3452/    1647 :                     ;
    3453/    1647 : 78                  ADDEXP: LD	A,B		; Get exponent of dividend
    3454/    1648 : B7                  	OR	A		; Test it
    3455/    1649 : CA 6B 16            	JP	Z,OVTST3	; Zero - Result zero
    3456/    164C : 7D                  	LD	A,L		; Get add/subtract flag
    3457/    164D : 21 2C 1E            	LD	HL,FPEXP	; Point to exponent
    3458/    1650 : AE                  	XOR	(HL)		; Add or subtract it
    3459/    1651 : 80                  	ADD	A,B		; Add the other exponent
    3460/    1652 : 47                  	LD	B,A		; Save new exponent
    3461/    1653 : 1F                  	RRA			; Test exponent for overflow
    3462/    1654 : A8                  	XOR	B
    3463/    1655 : 78                  	LD	A,B		; Get exponent
    3464/    1656 : F2 6A 16            	JP	P,OVTST2	; Positive - Test for overflow
    3465/    1659 : C6 80               	ADD	A,80H		; Add excess 128
    3466/    165B : 77                  	LD	(HL),A		; Save new exponent
    3467/    165C : CA CA 15            	JP	Z,POPHRT	; Zero - Result zero
    3468/    165F : CD EF 16            	CALL	SIGNS		; Set MSBs and sign of result
    3469/    1662 : 77                  	LD	(HL),A		; Save new exponent
    3470/    1663 : 2B                  	DEC	HL		; Point to MSB
    3471/    1664 : C9                  	RET
    3472/    1665 :                     ;
    3473/    1665 : CD 89 16            OVTST1: CALL	TSTSGN		; Test sign of FPREG
    3474/    1668 : 2F                  	CPL			; Invert sign
    3475/    1669 : E1                  	POP	HL		; Clean up stack
    3476/    166A : B7                  OVTST2: OR	A		; Test if new exponent zero
    3477/    166B : E1                  OVTST3: POP	HL		; Clear off return address
    3478/    166C : F2 A9 14            	JP	P,RESZER	; Result zero
    3479/    166F : C3 F3 03            	JP	OVERR		; Overflow error
    3480/    1672 :                     ;
    3481/    1672 : CD D5 16            MLSP10: CALL	BCDEFP		; Move FPREG to BCDE
    3482/    1675 : 78                  	LD	A,B		; Get exponent
    3483/    1676 : B7                  	OR	A		; Is it zero?
    3484/    1677 : C8                  	RET	Z		; Yes - Result is zero
    3485/    1678 : C6 02               	ADD	A,2		; Multiply by 4
    3486/    167A : DA F3 03            	JP	C,OVERR		; Overflow - ?OV Error
    3487/    167D : 47                  	LD	B,A		; Re-save exponent
    3488/    167E : CD 43 14            	CALL	FPADD		; Add BCDE to FPREG (Times 5)
    3489/    1681 : 21 2C 1E            	LD	HL,FPEXP	; Point to exponent
    3490/    1684 : 34                  	INC	(HL)		; Double number (Times 10)
    3491/    1685 : C0                  	RET	NZ		; Ok - Return
    3492/    1686 : C3 F3 03            	JP	OVERR		; Overflow error
    3493/    1689 :                     ;
    3494/    1689 : 3A 2C 1E            TSTSGN: LD	A,(FPEXP)	; Get sign of FPREG
    3495/    168C : B7                  	OR	A
    3496/    168D : C8                  	RET	Z		; RETurn if number is zero
    3497/    168E : 3A 2B 1E            	LD	A,(FPREG+2)	; Get MSB of FPREG
    3498/    1691 : FE                  	DB	0FEH		; Test sign
    3499/    1692 : 2F                  RETREL: CPL			; Invert sign
    3500/    1693 : 17                  	RLA			; Sign bit to carry
    3501/    1694 : 9F                  FLGDIF: SBC	A,A		; Carry to all bits of A
    3502/    1695 : C0                  	RET	NZ		; Return -1 if negative
    3503/    1696 : 3C                  	INC	A		; Bump to +1
    3504/    1697 : C9                  	RET			; Positive - Return +1
    3505/    1698 :                     ;
    3506/    1698 : CD 89 16            SGN:	CALL	TSTSGN		; Test sign of FPREG
    3507/    169B : 06 88               FLGREL: LD	B,80H+8		; 8 bit integer in exponent
    3508/    169D : 11 00 00            	LD	DE,0		; Zero NMSB and LSB
    3509/    16A0 : 21 2C 1E            RETINT: LD	HL,FPEXP	; Point to exponent
    3510/    16A3 : 4F                  	LD	C,A		; CDE = MSB,NMSB and LSB
    3511/    16A4 : 70                  	LD	(HL),B		; Save exponent
    3512/    16A5 : 06 00               	LD	B,0		; CDE = integer to normalise
    3513/    16A7 : 23                  	INC	HL		; Point to sign of result
    3514/    16A8 : 36 80               	LD	(HL),80H	; Set sign of result
    3515/    16AA : 17                  	RLA			; Carry = sign of integer
    3516/    16AB : C3 91 14            	JP	CONPOS		; Set sign of result
    3517/    16AE :                     ;
    3518/    16AE : CD 89 16            ABS:	CALL	TSTSGN		; Test sign of FPREG
    3519/    16B1 : F0                  	RET	P		; Return if positive
    3520/    16B2 : 21 2B 1E            INVSGN: LD	HL,FPREG+2	; Point to MSB
    3521/    16B5 : 7E                  	LD	A,(HL)		; Get sign of mantissa
    3522/    16B6 : EE 80               	XOR	80H		; Invert sign of mantissa
    3523/    16B8 : 77                  	LD	(HL),A		; Re-save sign of mantissa
    3524/    16B9 : C9                  	RET
    3525/    16BA :                     ;
    3526/    16BA : EB                  STAKFP: EX	DE,HL		; Save code string address
    3527/    16BB : 2A 29 1E            	LD	HL,(FPREG)	; LSB,NLSB of FPREG
    3528/    16BE : E3                  	EX	(SP),HL		; Stack them,get return
    3529/    16BF : E5                  	PUSH	HL		; Re-save return
    3530/    16C0 : 2A 2B 1E            	LD	HL,(FPREG+2)	; MSB and exponent of FPREG
    3531/    16C3 : E3                  	EX	(SP),HL		; Stack them,get return
    3532/    16C4 : E5                  	PUSH	HL		; Re-save return
    3533/    16C5 : EB                  	EX	DE,HL		; Restore code string address
    3534/    16C6 : C9                  	RET
    3535/    16C7 :                     ;
    3536/    16C7 : CD D8 16            PHLTFP: CALL	LOADFP		; Number at HL to BCDE
    3537/    16CA : EB                  FPBCDE: EX	DE,HL		; Save code string address
    3538/    16CB : 22 29 1E            	LD	(FPREG),HL	; Save LSB,NLSB of number
    3539/    16CE : 60                  	LD	H,B		; Exponent of number
    3540/    16CF : 69                  	LD	L,C		; MSB of number
    3541/    16D0 : 22 2B 1E            	LD	(FPREG+2),HL	; Save MSB and exponent
    3542/    16D3 : EB                  	EX	DE,HL		; Restore code string address
    3543/    16D4 : C9                  	RET
    3544/    16D5 :                     ;
    3545/    16D5 : 21 29 1E            BCDEFP: LD	HL,FPREG	; Point to FPREG
    3546/    16D8 : 5E                  LOADFP: LD	E,(HL)		; Get LSB of number
    3547/    16D9 : 23                  	INC	HL
    3548/    16DA : 56                  	LD	D,(HL)		; Get NMSB of number
    3549/    16DB : 23                  	INC	HL
    3550/    16DC : 4E                  	LD	C,(HL)		; Get MSB of number
    3551/    16DD : 23                  	INC	HL
    3552/    16DE : 46                  	LD	B,(HL)		; Get exponent of number
    3553/    16DF : 23                  INCHL:	INC	HL		; Used for conditional "INC HL"
    3554/    16E0 : C9                  	RET
    3555/    16E1 :                     ;
    3556/    16E1 : 11 29 1E            FPTHL:	LD	DE,FPREG	; Point to FPREG
    3557/    16E4 : 06 04               DETHL4: LD	B,4		; 4 bytes to move
    3558/    16E6 : 1A                  DETHLB: LD	A,(DE)		; Get source
    3559/    16E7 : 77                  	LD	(HL),A		; Save destination
    3560/    16E8 : 13                  	INC	DE		; Next source
    3561/    16E9 : 23                  	INC	HL		; Next destination
    3562/    16EA : 05                  	DEC	B		; Count bytes
    3563/    16EB : C2 E6 16            	JP	NZ,DETHLB	; Loop if more
    3564/    16EE : C9                  	RET
    3565/    16EF :                     ;
    3566/    16EF : 21 2B 1E            SIGNS:	LD	HL,FPREG+2	; Point to MSB of FPREG
    3567/    16F2 : 7E                  	LD	A,(HL)		; Get MSB
    3568/    16F3 : 07                  	RLCA			; Old sign to carry
    3569/    16F4 : 37                  	SCF			; Set MSBit
    3570/    16F5 : 1F                  	RRA			; Set MSBit of MSB
    3571/    16F6 : 77                  	LD	(HL),A		; Save new MSB
    3572/    16F7 : 3F                  	CCF			; Complement sign
    3573/    16F8 : 1F                  	RRA			; Old sign to carry
    3574/    16F9 : 23                  	INC	HL
    3575/    16FA : 23                  	INC	HL
    3576/    16FB : 77                  	LD	(HL),A		; Set sign of result
    3577/    16FC : 79                  	LD	A,C		; Get MSB
    3578/    16FD : 07                  	RLCA			; Old sign to carry
    3579/    16FE : 37                  	SCF			; Set MSBit
    3580/    16FF : 1F                  	RRA			; Set MSBit of MSB
    3581/    1700 : 4F                  	LD	C,A		; Save MSB
    3582/    1701 : 1F                  	RRA
    3583/    1702 : AE                  	XOR	(HL)		; New sign of result
    3584/    1703 : C9                  	RET
    3585/    1704 :                     ;
    3586/    1704 : 78                  CMPNUM: LD	A,B		; Get exponent of number
    3587/    1705 : B7                  	OR	A
    3588/    1706 : CA 89 16            	JP	Z,TSTSGN	; Zero - Test sign of FPREG
    3589/    1709 : 21 92 16            	LD	HL,RETREL	; Return relation routine
    3590/    170C : E5                  	PUSH	HL		; Save for return
    3591/    170D : CD 89 16            	CALL	TSTSGN		; Test sign of FPREG
    3592/    1710 : 79                  	LD	A,C		; Get MSB of number
    3593/    1711 : C8                  	RET	Z		; FPREG zero - Number's MSB
    3594/    1712 : 21 2B 1E            	LD	HL,FPREG+2	; MSB of FPREG
    3595/    1715 : AE                  	XOR	(HL)		; Combine signs
    3596/    1716 : 79                  	LD	A,C		; Get MSB of number
    3597/    1717 : F8                  	RET	M		; Exit if signs different
    3598/    1718 : CD 1E 17            	CALL	CMPFP		; Compare FP numbers
    3599/    171B : 1F                  	RRA			; Get carry to sign
    3600/    171C : A9                  	XOR	C		; Combine with MSB of number
    3601/    171D : C9                  	RET
    3602/    171E :                     ;
    3603/    171E : 23                  CMPFP:	INC	HL		; Point to exponent
    3604/    171F : 78                  	LD	A,B		; Get exponent
    3605/    1720 : BE                  	CP	(HL)		; Compare exponents
    3606/    1721 : C0                  	RET	NZ		; Different
    3607/    1722 : 2B                  	DEC	HL		; Point to MBS
    3608/    1723 : 79                  	LD	A,C		; Get MSB
    3609/    1724 : BE                  	CP	(HL)		; Compare MSBs
    3610/    1725 : C0                  	RET	NZ		; Different
    3611/    1726 : 2B                  	DEC	HL		; Point to NMSB
    3612/    1727 : 7A                  	LD	A,D		; Get NMSB
    3613/    1728 : BE                  	CP	(HL)		; Compare NMSBs
    3614/    1729 : C0                  	RET	NZ		; Different
    3615/    172A : 2B                  	DEC	HL		; Point to LSB
    3616/    172B : 7B                  	LD	A,E		; Get LSB
    3617/    172C : 96                  	SUB	(HL)		; Compare LSBs
    3618/    172D : C0                  	RET	NZ		; Different
    3619/    172E : E1                  	POP	HL		; Drop RETurn
    3620/    172F : E1                  	POP	HL		; Drop another RETurn
    3621/    1730 : C9                  	RET
    3622/    1731 :                     ;
    3623/    1731 : 47                  FPINT:	LD	B,A		; <- Move
    3624/    1732 : 4F                  	LD	C,A		; <- exponent
    3625/    1733 : 57                  	LD	D,A		; <- to all
    3626/    1734 : 5F                  	LD	E,A		; <- bits
    3627/    1735 : B7                  	OR	A		; Test exponent
    3628/    1736 : C8                  	RET	Z		; Zero - Return zero
    3629/    1737 : E5                  	PUSH	HL		; Save pointer to number
    3630/    1738 : CD D5 16            	CALL	BCDEFP		; Move FPREG to BCDE
    3631/    173B : CD EF 16            	CALL	SIGNS		; Set MSBs & sign of result
    3632/    173E : AE                  	XOR	(HL)		; Combine with sign of FPREG
    3633/    173F : 67                  	LD	H,A		; Save combined signs
    3634/    1740 : FC 55 17            	CALL	M,DCBCDE	; Negative - Decrement BCDE
    3635/    1743 : 3E 98               	LD	A,80H+24	; 24 bits
    3636/    1745 : 90                  	SUB	B		; Bits to shift
    3637/    1746 : CD 08 15            	CALL	SCALE		; Shift BCDE
    3638/    1749 : 7C                  	LD	A,H		; Get combined sign
    3639/    174A : 17                  	RLA			; Sign to carry
    3640/    174B : DC DB 14            	CALL	C,FPROND	; Negative - Round number up
    3641/    174E : 06 00               	LD	B,0		; Zero exponent
    3642/    1750 : DC F4 14            	CALL	C,COMPL		; If negative make positive
    3643/    1753 : E1                  	POP	HL		; Restore pointer to number
    3644/    1754 : C9                  	RET
    3645/    1755 :                     ;
    3646/    1755 : 1B                  DCBCDE: DEC	DE		; Decrement BCDE
    3647/    1756 : 7A                  	LD	A,D		; Test LSBs
    3648/    1757 : A3                  	AND	E
    3649/    1758 : 3C                  	INC	A
    3650/    1759 : C0                  	RET	NZ		; Exit if LSBs not FFFF
    3651/    175A : 0B                  	DEC	BC		; Decrement MSBs
    3652/    175B : C9                  	RET
    3653/    175C :                     ;
    3654/    175C : 21 2C 1E            INT:	LD	HL,FPEXP	; Point to exponent
    3655/    175F : 7E                  	LD	A,(HL)		; Get exponent
    3656/    1760 : FE 98               	CP	80H+24		; Integer accuracy only?
    3657/    1762 : 3A 29 1E            	LD	A,(FPREG)	; Get LSB
    3658/    1765 : D0                  	RET	NC		; Yes - Already integer
    3659/    1766 : 7E                  	LD	A,(HL)		; Get exponent
    3660/    1767 : CD 31 17            	CALL	FPINT		; F.P to integer
    3661/    176A : 36 98               	LD	(HL),80H+24	; Save 24 bit integer
    3662/    176C : 7B                  	LD	A,E		; Get LSB of number
    3663/    176D : F5                  	PUSH	AF		; Save LSB
    3664/    176E : 79                  	LD	A,C		; Get MSB of number
    3665/    176F : 17                  	RLA			; Sign to carry
    3666/    1770 : CD 91 14            	CALL	CONPOS		; Set sign of result
    3667/    1773 : F1                  	POP	AF		; Restore LSB of number
    3668/    1774 : C9                  	RET
    3669/    1775 :                     ;
    3670/    1775 : 21 00 00            MLDEBC: LD	HL,0		; Clear partial product
    3671/    1778 : 78                  	LD	A,B		; Test multiplier
    3672/    1779 : B1                  	OR	C
    3673/    177A : C8                  	RET	Z		; Return zero if zero
    3674/    177B : 3E 10               	LD	A,16		; 16 bits
    3675/    177D : 29                  MLDBLP: ADD	HL,HL		; Shift P.P left
    3676/    177E : DA B5 0F            	JP	C,BSERR		; ?BS Error if overflow
    3677/    1781 : EB                  	EX	DE,HL
    3678/    1782 : 29                  	ADD	HL,HL		; Shift multiplier left
    3679/    1783 : EB                  	EX	DE,HL
    3680/    1784 : D2 8B 17            	JP	NC,NOMLAD	; Bit was zero - No add
    3681/    1787 : 09                  	ADD	HL,BC		; Add multiplicand
    3682/    1788 : DA B5 0F            	JP	C,BSERR		; ?BS Error if overflow
    3683/    178B : 3D                  NOMLAD: DEC	A		; Count bits
    3684/    178C : C2 7D 17            	JP	NZ,MLDBLP	; More
    3685/    178F : C9                  	RET
    3686/    1790 :                     ;
    3687/    1790 : FE 2D               ASCTFP: CP	'-'		; Negative?
    3688/    1792 : F5                  	PUSH	AF		; Save it and flags
    3689/    1793 : CA 9C 17            	JP	Z,CNVNUM	; Yes - Convert number
    3690/    1796 : FE 2B               	CP	'+'		; Positive?
    3691/    1798 : CA 9C 17            	JP	Z,CNVNUM	; Yes - Convert number
    3692/    179B : 2B                  	DEC	HL		; DEC 'cos GETCHR INCs
    3693/    179C : CD A9 14            CNVNUM: CALL	RESZER		; Set result to zero
    3694/    179F : 47                  	LD	B,A		; Digits after point counter
    3695/    17A0 : 57                  	LD	D,A		; Sign of exponent
    3696/    17A1 : 5F                  	LD	E,A		; Exponent of ten
    3697/    17A2 : 2F                  	CPL
    3698/    17A3 : 4F                  	LD	C,A		; Before or after point flag
    3699/    17A4 : CD 3A 08            MANLP:	CALL	GETCHR		; Get next character
    3700/    17A7 : DA ED 17            	JP	C,ADDIG		; Digit - Add to number
    3701/    17AA : FE 2E               	CP	'.'
    3702/    17AC : CA C8 17            	JP	Z,DPOINT	; '.' - Flag point
    3703/    17AF : FE 45               	CP	'E'
    3704/    17B1 : C2 CC 17            	JP	NZ,CONEXP	; Not 'E' - Scale number
    3705/    17B4 : CD 3A 08            	CALL	GETCHR		; Get next character
    3706/    17B7 : CD E0 0D            	CALL	SGNEXP		; Get sign of exponent
    3707/    17BA : CD 3A 08            EXPLP:	CALL	GETCHR		; Get next character
    3708/    17BD : DA 0F 18            	JP	C,EDIGIT	; Digit - Add to exponent
    3709/    17C0 : 14                  	INC	D		; Is sign negative?
    3710/    17C1 : C2 CC 17            	JP	NZ,CONEXP	; No - Scale number
    3711/    17C4 : AF                  	XOR	A
    3712/    17C5 : 93                  	SUB	E		; Negate exponent
    3713/    17C6 : 5F                  	LD	E,A		; And re-save it
    3714/    17C7 : 0C                  	INC	C		; Flag end of number
    3715/    17C8 : 0C                  DPOINT: INC	C		; Flag point passed
    3716/    17C9 : CA A4 17            	JP	Z,MANLP		; Zero - Get another digit
    3717/    17CC : E5                  CONEXP: PUSH	HL		; Save code string address
    3718/    17CD : 7B                  	LD	A,E		; Get exponent
    3719/    17CE : 90                  	SUB	B		; Subtract digits after point
    3720/    17CF : F4 E5 17            SCALMI: CALL	P,SCALPL	; Positive - Multiply number
    3721/    17D2 : F2 DB 17            	JP	P,ENDCON	; Positive - All done
    3722/    17D5 : F5                  	PUSH	AF		; Save number of times to /10
    3723/    17D6 : CD D1 15            	CALL	DIV10		; Divide by 10
    3724/    17D9 : F1                  	POP	AF		; Restore count
    3725/    17DA : 3C                  	INC	A		; Count divides
    3726/    17DB :                     ;
    3727/    17DB : C2 CF 17            ENDCON: JP	NZ,SCALMI	; More to do
    3728/    17DE : D1                  	POP	DE		; Restore code string address
    3729/    17DF : F1                  	POP	AF		; Restore sign of number
    3730/    17E0 : CC B2 16            	CALL	Z,INVSGN	; Negative - Negate number
    3731/    17E3 : EB                  	EX	DE,HL		; Code string address to HL
    3732/    17E4 : C9                  	RET
    3733/    17E5 :                     ;
    3734/    17E5 : C8                  SCALPL: RET	Z		; Exit if no scaling needed
    3735/    17E6 : F5                  MULTEN: PUSH	AF		; Save count
    3736/    17E7 : CD 72 16            	CALL	MLSP10		; Multiply number by 10
    3737/    17EA : F1                  	POP	AF		; Restore count
    3738/    17EB : 3D                  	DEC	A		; Count multiplies
    3739/    17EC : C9                  	RET
    3740/    17ED :                     ;
    3741/    17ED : D5                  ADDIG:	PUSH	DE		; Save sign of exponent
    3742/    17EE : 57                  	LD	D,A		; Save digit
    3743/    17EF : 78                  	LD	A,B		; Get digits after point
    3744/    17F0 : 89                  	ADC	A,C		; Add one if after point
    3745/    17F1 : 47                  	LD	B,A		; Re-save counter
    3746/    17F2 : C5                  	PUSH	BC		; Save point flags
    3747/    17F3 : E5                  	PUSH	HL		; Save code string address
    3748/    17F4 : D5                  	PUSH	DE		; Save digit
    3749/    17F5 : CD 72 16            	CALL	MLSP10		; Multiply number by 10
    3750/    17F8 : F1                  	POP	AF		; Restore digit
    3751/    17F9 : D6 30               	SUB	'0'		; Make it absolute
    3752/    17FB : CD 04 18            	CALL	RSCALE		; Re-scale number
    3753/    17FE : E1                  	POP	HL		; Restore code string address
    3754/    17FF : C1                  	POP	BC		; Restore point flags
    3755/    1800 : D1                  	POP	DE		; Restore sign of exponent
    3756/    1801 : C3 A4 17            	JP	MANLP		; Get another digit
    3757/    1804 :                     ;
    3758/    1804 : CD BA 16            RSCALE: CALL	STAKFP		; Put number on stack
    3759/    1807 : CD 9B 16            	CALL	FLGREL		; Digit to add to FPREG
    3760/    180A : C1                  PADD:	POP	BC		; Restore number
    3761/    180B : D1                  	POP	DE
    3762/    180C : C3 43 14            	JP	FPADD		; Add BCDE to FPREG and return
    3763/    180F :                     ;
    3764/    180F : 7B                  EDIGIT: LD	A,E		; Get digit
    3765/    1810 : 07                  	RLCA			; Times 2
    3766/    1811 : 07                  	RLCA			; Times 4
    3767/    1812 : 83                  	ADD	A,E		; Times 5
    3768/    1813 : 07                  	RLCA			; Times 10
    3769/    1814 : 86                  	ADD	A,(HL)		; Add next digit
    3770/    1815 : D6 30               	SUB	'0'		; Make it absolute
    3771/    1817 : 5F                  	LD	E,A		; Save new digit
    3772/    1818 : C3 BA 17            	JP	EXPLP		; Look for another digit
    3773/    181B :                     ;
    3774/    181B : E5                  LINEIN: PUSH	HL		; Save code string address
    3775/    181C : 21 7C 03            	LD	HL,INMSG	; Output " in "
    3776/    181F : CD 80 11            	CALL	PRS		; Output string at HL
    3777/    1822 : E1                  	POP	HL		; Restore code string address
    3778/    1823 : EB                  PRNTHL: EX	DE,HL		; Code string address to DE
    3779/    1824 : AF                  	XOR	A
    3780/    1825 : 06 98               	LD	B,80H+24	; 24 bits
    3781/    1827 : CD A0 16            	CALL	RETINT		; Return the integer
    3782/    182A : 21 7F 11            	LD	HL,PRNUMS	; Print number string
    3783/    182D : E5                  	PUSH	HL		; Save for return
    3784/    182E : 21 2E 1E            NUMASC: LD	HL,PBUFF	; Convert number to ASCII
    3785/    1831 : E5                  	PUSH	HL		; Save for return
    3786/    1832 : CD 89 16            	CALL	TSTSGN		; Test sign of FPREG
    3787/    1835 : 36 20               	LD	(HL),' '	; Space at start
    3788/    1837 : F2 3C 18            	JP	P,SPCFST	; Positive - Space to start
    3789/    183A : 36 2D               	LD	(HL),'-'	; '-' sign at start
    3790/    183C : 23                  SPCFST: INC	HL		; First byte of number
    3791/    183D : 36 30               	LD	(HL),'0'	; '0' if zero
    3792/    183F : CA F2 18            	JP	Z,JSTZER	; Return '0' if zero
    3793/    1842 : E5                  	PUSH	HL		; Save buffer address
    3794/    1843 : FC B2 16            	CALL	M,INVSGN	; Negate FPREG if negative
    3795/    1846 : AF                  	XOR	A		; Zero A
    3796/    1847 : F5                  	PUSH	AF		; Save it
    3797/    1848 : CD F8 18            	CALL	RNGTST		; Test number is in range
    3798/    184B : 01 43 91            SIXDIG: LD	BC,9143H	; BCDE - 99999.9
    3799/    184E : 11 F8 4F            	LD	DE,4FF8H
    3800/    1851 : CD 04 17            	CALL	CMPNUM		; Compare numbers
    3801/    1854 : B7                  	OR	A
    3802/    1855 : E2 69 18            	JP	PO,INRNG	; > 99999.9 - Sort it out
    3803/    1858 : F1                  	POP	AF		; Restore count
    3804/    1859 : CD E6 17            	CALL	MULTEN		; Multiply by ten
    3805/    185C : F5                  	PUSH	AF		; Re-save count
    3806/    185D : C3 4B 18            	JP	SIXDIG		; Test it again
    3807/    1860 :                     ;
    3808/    1860 : CD D1 15            GTSIXD: CALL	DIV10		; Divide by 10
    3809/    1863 : F1                  	POP	AF		; Get count
    3810/    1864 : 3C                  	INC	A		; Count divides
    3811/    1865 : F5                  	PUSH	AF		; Re-save count
    3812/    1866 : CD F8 18            	CALL	RNGTST		; Test number is in range
    3813/    1869 : CD 31 14            INRNG:	CALL	ROUND		; Add 0.5 to FPREG
    3814/    186C : 3C                  	INC	A
    3815/    186D : CD 31 17            	CALL	FPINT		; F.P to integer
    3816/    1870 : CD CA 16            	CALL	FPBCDE		; Move BCDE to FPREG
    3817/    1873 : 01 06 03            	LD	BC,0306H	; 1E+06 to 1E-03 range
    3818/    1876 : F1                  	POP	AF		; Restore count
    3819/    1877 : 81                  	ADD	A,C		; 6 digits before point
    3820/    1878 : 3C                  	INC	A		; Add one
    3821/    1879 : FA 85 18            	JP	M,MAKNUM	; Do it in 'E' form if < 1E-02
    3822/    187C : FE 08               	CP	6+1+1		; More than 999999 ?
    3823/    187E : D2 85 18            	JP	NC,MAKNUM	; Yes - Do it in 'E' form
    3824/    1881 : 3C                  	INC	A		; Adjust for exponent
    3825/    1882 : 47                  	LD	B,A		; Exponent of number
    3826/    1883 : 3E 02               	LD	A,2		; Make it zero after
    3827/    1885 :                     ;
    3828/    1885 : 3D                  MAKNUM: DEC	A		; Adjust for digits to do
    3829/    1886 : 3D                  	DEC	A
    3830/    1887 : E1                  	POP	HL		; Restore buffer address
    3831/    1888 : F5                  	PUSH	AF		; Save count
    3832/    1889 : 11 0B 19            	LD	DE,POWERS	; Powers of ten
    3833/    188C : 05                  	DEC	B		; Count digits before point
    3834/    188D : C2 96 18            	JP	NZ,DIGTXT	; Not zero - Do number
    3835/    1890 : 36 2E               	LD	(HL),'.'	; Save point
    3836/    1892 : 23                  	INC	HL		; Move on
    3837/    1893 : 36 30               	LD	(HL),'0'	; Save zero
    3838/    1895 : 23                  	INC	HL		; Move on
    3839/    1896 : 05                  DIGTXT: DEC	B		; Count digits before point
    3840/    1897 : 36 2E               	LD	(HL),'.'	; Save point in case
    3841/    1899 : CC DF 16            	CALL	Z,INCHL		; Last digit - move on
    3842/    189C : C5                  	PUSH	BC		; Save digits before point
    3843/    189D : E5                  	PUSH	HL		; Save buffer address
    3844/    189E : D5                  	PUSH	DE		; Save powers of ten
    3845/    189F : CD D5 16            	CALL	BCDEFP		; Move FPREG to BCDE
    3846/    18A2 : E1                  	POP	HL		; Powers of ten table
    3847/    18A3 : 06 2F               	LD	B, '0'-1	; ASCII '0' - 1
    3848/    18A5 : 04                  TRYAGN: INC	B		; Count subtractions
    3849/    18A6 : 7B                  	LD	A,E		; Get LSB
    3850/    18A7 : 96                  	SUB	(HL)		; Subtract LSB
    3851/    18A8 : 5F                  	LD	E,A		; Save LSB
    3852/    18A9 : 23                  	INC	HL
    3853/    18AA : 7A                  	LD	A,D		; Get NMSB
    3854/    18AB : 9E                  	SBC	A,(HL)		; Subtract NMSB
    3855/    18AC : 57                  	LD	D,A		; Save NMSB
    3856/    18AD : 23                  	INC	HL
    3857/    18AE : 79                  	LD	A,C		; Get MSB
    3858/    18AF : 9E                  	SBC	A,(HL)		; Subtract MSB
    3859/    18B0 : 4F                  	LD	C,A		; Save MSB
    3860/    18B1 : 2B                  	DEC	HL		; Point back to start
    3861/    18B2 : 2B                  	DEC	HL
    3862/    18B3 : D2 A5 18            	JP	NC,TRYAGN	; No overflow - Try again
    3863/    18B6 : CD E8 14            	CALL	PLUCDE		; Restore number
    3864/    18B9 : 23                  	INC	HL		; Start of next number
    3865/    18BA : CD CA 16            	CALL	FPBCDE		; Move BCDE to FPREG
    3866/    18BD : EB                  	EX	DE,HL		; Save point in table
    3867/    18BE : E1                  	POP	HL		; Restore buffer address
    3868/    18BF : 70                  	LD	(HL),B		; Save digit in buffer
    3869/    18C0 : 23                  	INC	HL		; And move on
    3870/    18C1 : C1                  	POP	BC		; Restore digit count
    3871/    18C2 : 0D                  	DEC	C		; Count digits
    3872/    18C3 : C2 96 18            	JP	NZ,DIGTXT	; More - Do them
    3873/    18C6 : 05                  	DEC	B		; Any decimal part?
    3874/    18C7 : CA D6 18            	JP	Z,DOEBIT	; No - Do 'E' bit
    3875/    18CA : 2B                  SUPTLZ: DEC	HL		; Move back through buffer
    3876/    18CB : 7E                  	LD	A,(HL)		; Get character
    3877/    18CC : FE 30               	CP	'0'		; '0' character?
    3878/    18CE : CA CA 18            	JP	Z,SUPTLZ	; Yes - Look back for more
    3879/    18D1 : FE 2E               	CP	'.'		; A decimal point?
    3880/    18D3 : C4 DF 16            	CALL	NZ,INCHL	; Move back over digit
    3881/    18D6 :                     ;
    3882/    18D6 : F1                  DOEBIT: POP	AF		; Get 'E' flag
    3883/    18D7 : CA F5 18            	JP	Z,NOENED	; No 'E' needed - End buffer
    3884/    18DA : 36 45               	LD	(HL),'E'	; Put 'E' in buffer
    3885/    18DC : 23                  	INC	HL		; And move on
    3886/    18DD : 36 2B               	LD	(HL),'+'	; Put '+' in buffer
    3887/    18DF : F2 E6 18            	JP	P,OUTEXP	; Positive - Output exponent
    3888/    18E2 : 36 2D               	LD	(HL),'-'	; Put '-' in buffer
    3889/    18E4 : 2F                  	CPL			; Negate exponent
    3890/    18E5 : 3C                  	INC	A
    3891/    18E6 : 06 2F               OUTEXP: LD	B,'0'-1		; ASCII '0' - 1
    3892/    18E8 : 04                  EXPTEN: INC	B		; Count subtractions
    3893/    18E9 : D6 0A               	SUB	10		; Tens digit
    3894/    18EB : D2 E8 18            	JP	NC,EXPTEN	; More to do
    3895/    18EE : C6 3A               	ADD	A,'0'+10	; Restore and make ASCII
    3896/    18F0 : 23                  	INC	HL		; Move on
    3897/    18F1 : 70                  	LD	(HL),B		; Save MSB of exponent
    3898/    18F2 : 23                  JSTZER: INC	HL		;
    3899/    18F3 : 77                  	LD	(HL),A		; Save LSB of exponent
    3900/    18F4 : 23                  	INC	HL
    3901/    18F5 : 71                  NOENED: LD	(HL),C		; Mark end of buffer
    3902/    18F6 : E1                  	POP	HL		; Restore code string address
    3903/    18F7 : C9                  	RET
    3904/    18F8 :                     ;
    3905/    18F8 : 01 74 94            RNGTST: LD	BC,9474H	; BCDE = 999999.
    3906/    18FB : 11 F7 23            	LD	DE,23F7H
    3907/    18FE : CD 04 17            	CALL	CMPNUM		; Compare numbers
    3908/    1901 : B7                  	OR	A
    3909/    1902 : E1                  	POP	HL		; Return address to HL
    3910/    1903 : E2 60 18            	JP	PO,GTSIXD	; Too big - Divide by ten
    3911/    1906 : E9                  	JP	(HL)		; Otherwise return to caller
    3912/    1907 :                     ;
    3913/    1907 : 00 00 00 80         HALF:	DB	00H,00H,00H,80H	; 0.5
    3914/    190B :                     ;
    3915/    190B : A0 86 01            POWERS: DB	0A0H,086H,001H	; 100000
    3916/    190E : 10 27 00            	DB	010H,027H,000H	; 10000
    3917/    1911 : E8 03 00            	DB	0E8H,003H,000H	; 1000
    3918/    1914 : 64 00 00            	DB	064H,000H,000H	; 100
    3919/    1917 : 0A 00 00            	DB	00AH,000H,000H	; 10
    3920/    191A : 01 00 00            	DB	001H,000H,000H	; 1
    3921/    191D :                     ;
    3922/    191D : 21 B2 16            NEGAFT: LD	HL,INVSGN	; Negate result
    3923/    1920 : E3                  	EX	(SP),HL		; To be done after caller
    3924/    1921 : E9                  	JP	(HL)		; Return to caller
    3925/    1922 :                     ;
    3926/    1922 : CD BA 16            SQR:	CALL	STAKFP		; Put value on stack
    3927/    1925 : 21 07 19            	LD	HL,HALF		; Set power to 1/2
    3928/    1928 : CD C7 16            	CALL	PHLTFP		; Move 1/2 to FPREG
    3929/    192B :                     ;
    3930/    192B : C1                  POWER:	POP	BC		; Get base
    3931/    192C : D1                  	POP	DE
    3932/    192D : CD 89 16            	CALL	TSTSGN		; Test sign of power
    3933/    1930 : 78                  	LD	A,B		; Get exponent of base
    3934/    1931 : CA 70 19            	JP	Z,EXP		; Make result 1 if zero
    3935/    1934 : F2 3B 19            	JP	P,POWER1	; Positive base - Ok
    3936/    1937 : B7                  	OR	A		; Zero to negative power?
    3937/    1938 : CA E7 03            	JP	Z,DZERR		; Yes - ?/0 Error
    3938/    193B : B7                  POWER1: OR	A		; Base zero?
    3939/    193C : CA AA 14            	JP	Z,SAVEXP	; Yes - Return zero
    3940/    193F : D5                  	PUSH	DE		; Save base
    3941/    1940 : C5                  	PUSH	BC
    3942/    1941 : 79                  	LD	A,C		; Get MSB of base
    3943/    1942 : F6 7F               	OR	01111111B	; Get sign status
    3944/    1944 : CD D5 16            	CALL	BCDEFP		; Move power to BCDE
    3945/    1947 : F2 58 19            	JP	P,POWER2	; Positive base - Ok
    3946/    194A : D5                  	PUSH	DE		; Save power
    3947/    194B : C5                  	PUSH	BC
    3948/    194C : CD 5C 17            	CALL	INT		; Get integer of power
    3949/    194F : C1                  	POP	BC		; Restore power
    3950/    1950 : D1                  	POP	DE
    3951/    1951 : F5                  	PUSH	AF		; MSB of base
    3952/    1952 : CD 04 17            	CALL	CMPNUM		; Power an integer?
    3953/    1955 : E1                  	POP	HL		; Restore MSB of base
    3954/    1956 : 7C                  	LD	A,H		; but don't affect flags
    3955/    1957 : 1F                  	RRA			; Exponent odd or even?
    3956/    1958 : E1                  POWER2: POP	HL		; Restore MSB and exponent
    3957/    1959 : 22 2B 1E            	LD	(FPREG+2),HL	; Save base in FPREG
    3958/    195C : E1                  	POP	HL		; LSBs of base
    3959/    195D : 22 29 1E            	LD	(FPREG),HL	; Save in FPREG
    3960/    1960 : DC 1D 19            	CALL	C,NEGAFT	; Odd power - Negate result
    3961/    1963 : CC B2 16            	CALL	Z,INVSGN	; Negative base - Negate it
    3962/    1966 : D5                  	PUSH	DE		; Save power
    3963/    1967 : C5                  	PUSH	BC
    3964/    1968 : CD 3D 15            	CALL	LOG		; Get LOG of base
    3965/    196B : C1                  	POP	BC		; Restore power
    3966/    196C : D1                  	POP	DE
    3967/    196D : CD 7E 15            	CALL	FPMULT		; Multiply LOG by power
    3968/    1970 :                     ;
    3969/    1970 : CD BA 16            EXP:	CALL	STAKFP		; Put value on stack
    3970/    1973 : 01 38 81            	LD	BC,08138H	; BCDE = 1/Ln(2)
    3971/    1976 : 11 3B AA            	LD	DE,0AA3BH
    3972/    1979 : CD 7E 15            	CALL	FPMULT		; Multiply value by 1/LN(2)
    3973/    197C : 3A 2C 1E            	LD	A,(FPEXP)	; Get exponent
    3974/    197F : FE 88               	CP	80H+8		; Is it in range?
    3975/    1981 : D2 65 16            	JP	NC,OVTST1	; No - Test for overflow
    3976/    1984 : CD 5C 17            	CALL	INT		; Get INT of FPREG
    3977/    1987 : C6 80               	ADD	A,80H		; For excess 128
    3978/    1989 : C6 02               	ADD	A,2		; Exponent > 126?
    3979/    198B : DA 65 16            	JP	C,OVTST1	; Yes - Test for overflow
    3980/    198E : F5                  	PUSH	AF		; Save scaling factor
    3981/    198F : 21 2C 15            	LD	HL,UNITY	; Point to 1.
    3982/    1992 : CD 34 14            	CALL	ADDPHL		; Add 1 to FPREG
    3983/    1995 : CD 75 15            	CALL	MULLN2		; Multiply by LN(2)
    3984/    1998 : F1                  	POP	AF		; Restore scaling factor
    3985/    1999 : C1                  	POP	BC		; Restore exponent
    3986/    199A : D1                  	POP	DE
    3987/    199B : F5                  	PUSH	AF		; Save scaling factor
    3988/    199C : CD 40 14            	CALL	SUBCDE		; Subtract exponent from FPREG
    3989/    199F : CD B2 16            	CALL	INVSGN		; Negate result
    3990/    19A2 : 21 B0 19            	LD	HL,EXPTAB	; Coefficient table
    3991/    19A5 : CD E0 19            	CALL	SMSER1		; Sum the series
    3992/    19A8 : 11 00 00            	LD	DE,0		; Zero LSBs
    3993/    19AB : C1                  	POP	BC		; Scaling factor
    3994/    19AC : 4A                  	LD	C,D		; Zero MSB
    3995/    19AD : C3 7E 15            	JP	FPMULT		; Scale result to correct value
    3996/    19B0 :                     ;
    3997/    19B0 : 08                  EXPTAB: DB	8			; Table used by EXP
    3998/    19B1 : 40 2E 94 74         	DB	040H,02EH,094H,074H	; -1/7! (-1/5040)
    3999/    19B5 : 70 4F 2E 77         	DB	070H,04FH,02EH,077H	;  1/6! ( 1/720)
    4000/    19B9 : 6E 02 88 7A         	DB	06EH,002H,088H,07AH	; -1/5! (-1/120)
    4001/    19BD : E6 A0 2A 7C         	DB	0E6H,0A0H,02AH,07CH	;  1/4! ( 1/24)
    4002/    19C1 : 50 AA AA 7E         	DB	050H,0AAH,0AAH,07EH	; -1/3! (-1/6)
    4003/    19C5 : FF FF 7F 7F         	DB	0FFH,0FFH,07FH,07FH	;  1/2! ( 1/2)
    4004/    19C9 : 00 00 80 81         	DB	000H,000H,080H,081H	; -1/1! (-1/1)
    4005/    19CD : 00 00 00 81         	DB	000H,000H,000H,081H	;  1/0! ( 1/1)
    4006/    19D1 :                     ;
    4007/    19D1 : CD BA 16            SUMSER: CALL	STAKFP		; Put FPREG on stack
    4008/    19D4 : 11 7C 15            	LD	DE,MULT		; Multiply by "X"
    4009/    19D7 : D5                  	PUSH	DE		; To be done after
    4010/    19D8 : E5                  	PUSH	HL		; Save address of table
    4011/    19D9 : CD D5 16            	CALL	BCDEFP		; Move FPREG to BCDE
    4012/    19DC : CD 7E 15            	CALL	FPMULT		; Square the value
    4013/    19DF : E1                  	POP	HL		; Restore address of table
    4014/    19E0 : CD BA 16            SMSER1: CALL	STAKFP		; Put value on stack
    4015/    19E3 : 7E                  	LD	A,(HL)		; Get number of coefficients
    4016/    19E4 : 23                  	INC	HL		; Point to start of table
    4017/    19E5 : CD C7 16            	CALL	PHLTFP		; Move coefficient to FPREG
    4018/    19E8 : 06                  	DB	06H		; Skip "POP AF"
    4019/    19E9 : F1                  SUMLP:	POP	AF		; Restore count
    4020/    19EA : C1                  	POP	BC		; Restore number
    4021/    19EB : D1                  	POP	DE
    4022/    19EC : 3D                  	DEC	A		; Cont coefficients
    4023/    19ED : C8                  	RET	Z		; All done
    4024/    19EE : D5                  	PUSH	DE		; Save number
    4025/    19EF : C5                  	PUSH	BC
    4026/    19F0 : F5                  	PUSH	AF		; Save count
    4027/    19F1 : E5                  	PUSH	HL		; Save address in table
    4028/    19F2 : CD 7E 15            	CALL	FPMULT		; Multiply FPREG by BCDE
    4029/    19F5 : E1                  	POP	HL		; Restore address in table
    4030/    19F6 : CD D8 16            	CALL	LOADFP		; Number at HL to BCDE
    4031/    19F9 : E5                  	PUSH	HL		; Save address in table
    4032/    19FA : CD 43 14            	CALL	FPADD		; Add coefficient to FPREG
    4033/    19FD : E1                  	POP	HL		; Restore address in table
    4034/    19FE : C3 E9 19            	JP	SUMLP		; More coefficients
    4035/    1A01 :                     ;
    4036/    1A01 : CD 89 16            RND:	CALL	TSTSGN		; Test sign of FPREG
    4037/    1A04 : 21 5E 1D            	LD	HL,SEED+2	; Random number seed
    4038/    1A07 : FA 62 1A            	JP	M,RESEED	; Negative - Re-seed
    4039/    1A0A : 21 7F 1D            	LD	HL,LSTRND	; Last random number
    4040/    1A0D : CD C7 16            	CALL	PHLTFP		; Move last RND to FPREG
    4041/    1A10 : 21 5E 1D            	LD	HL,SEED+2	; Random number seed
    4042/    1A13 : C8                  	RET	Z		; Return if RND(0)
    4043/    1A14 : 86                  	ADD	A,(HL)		; Add (SEED)+2)
    4044/    1A15 : E6 07               	AND	00000111B	; 0 to 7
    4045/    1A17 : 06 00               	LD	B,0
    4046/    1A19 : 77                  	LD	(HL),A		; Re-save seed
    4047/    1A1A : 23                  	INC	HL		; Move to coefficient table
    4048/    1A1B : 87                  	ADD	A,A		; 4 bytes
    4049/    1A1C : 87                  	ADD	A,A		; per entry
    4050/    1A1D : 4F                  	LD	C,A		; BC = Offset into table
    4051/    1A1E : 09                  	ADD	HL,BC		; Point to coefficient
    4052/    1A1F : CD D8 16            	CALL	LOADFP		; Coefficient to BCDE
    4053/    1A22 : CD 7E 15            	CALL	FPMULT	;	; Multiply FPREG by coefficient
    4054/    1A25 : 3A 5D 1D            	LD	A,(SEED+1)	; Get (SEED+1)
    4055/    1A28 : 3C                  	INC	A		; Add 1
    4056/    1A29 : E6 03               	AND	00000011B	; 0 to 3
    4057/    1A2B : 06 00               	LD	B,0
    4058/    1A2D : FE 01               	CP	1		; Is it zero?
    4059/    1A2F : 88                  	ADC	A,B		; Yes - Make it 1
    4060/    1A30 : 32 5D 1D            	LD	(SEED+1),A	; Re-save seed
    4061/    1A33 : 21 66 1A            	LD	HL,RNDTAB-4	; Addition table
    4062/    1A36 : 87                  	ADD	A,A		; 4 bytes
    4063/    1A37 : 87                  	ADD	A,A		; per entry
    4064/    1A38 : 4F                  	LD	C,A		; BC = Offset into table
    4065/    1A39 : 09                  	ADD	HL,BC		; Point to value
    4066/    1A3A : CD 34 14            	CALL	ADDPHL		; Add value to FPREG
    4067/    1A3D : CD D5 16            RND1:	CALL	BCDEFP		; Move FPREG to BCDE
    4068/    1A40 : 7B                  	LD	A,E		; Get LSB
    4069/    1A41 : 59                  	LD	E,C		; LSB = MSB
    4070/    1A42 : EE 4F               	XOR	01001111B	; Fiddle around
    4071/    1A44 : 4F                  	LD	C,A		; New MSB
    4072/    1A45 : 36 80               	LD	(HL),80H	; Set exponent
    4073/    1A47 : 2B                  	DEC	HL		; Point to MSB
    4074/    1A48 : 46                  	LD	B,(HL)		; Get MSB
    4075/    1A49 : 36 80               	LD	(HL),80H	; Make value -0.5
    4076/    1A4B : 21 5C 1D            	LD	HL,SEED		; Random number seed
    4077/    1A4E : 34                  	INC	(HL)		; Count seed
    4078/    1A4F : 7E                  	LD	A,(HL)		; Get seed
    4079/    1A50 : D6 AB               	SUB	171		; Do it modulo 171
    4080/    1A52 : C2 59 1A            	JP	NZ,RND2		; Non-zero - Ok
    4081/    1A55 : 77                  	LD	(HL),A		; Zero seed
    4082/    1A56 : 0C                  	INC	C		; Fillde about
    4083/    1A57 : 15                  	DEC	D		; with the
    4084/    1A58 : 1C                  	INC	E		; number
    4085/    1A59 : CD 94 14            RND2:	CALL	BNORM		; Normalise number
    4086/    1A5C : 21 7F 1D            	LD	HL,LSTRND	; Save random number
    4087/    1A5F : C3 E1 16            	JP	FPTHL		; Move FPREG to last and return
    4088/    1A62 :                     ;
    4089/    1A62 : 77                  RESEED: LD	(HL),A		; Re-seed random numbers
    4090/    1A63 : 2B                  	DEC	HL
    4091/    1A64 : 77                  	LD	(HL),A
    4092/    1A65 : 2B                  	DEC	HL
    4093/    1A66 : 77                  	LD	(HL),A
    4094/    1A67 : C3 3D 1A            	JP	RND1		; Return RND seed
    4095/    1A6A :                     ;
    4096/    1A6A : 68 B1 46 68         RNDTAB: DB	068H,0B1H,046H,068H	; Table used by RND
    4097/    1A6E : 99 E9 92 69         	DB	099H,0E9H,092H,069H
    4098/    1A72 : 10 D1 75 68         	DB	010H,0D1H,075H,068H
    4099/    1A76 :                     ;
    4100/    1A76 : 21 C0 1A            COS:	LD	HL,HALFPI	; Point to PI/2
    4101/    1A79 : CD 34 14            	CALL	ADDPHL		; Add it to PPREG
    4102/    1A7C : CD BA 16            SIN:	CALL	STAKFP		; Put angle on stack
    4103/    1A7F : 01 49 83            	LD	BC,8349H	; BCDE = 2 PI
    4104/    1A82 : 11 DB 0F            	LD	DE,0FDBH
    4105/    1A85 : CD CA 16            	CALL	FPBCDE		; Move 2 PI to FPREG
    4106/    1A88 : C1                  	POP	BC		; Restore angle
    4107/    1A89 : D1                  	POP	DE
    4108/    1A8A : CD DF 15            	CALL	DVBCDE		; Divide angle by 2 PI
    4109/    1A8D : CD BA 16            	CALL	STAKFP		; Put it on stack
    4110/    1A90 : CD 5C 17            	CALL	INT		; Get INT of result
    4111/    1A93 : C1                  	POP	BC		; Restore number
    4112/    1A94 : D1                  	POP	DE
    4113/    1A95 : CD 40 14            	CALL	SUBCDE		; Make it 0 <= value < 1
    4114/    1A98 : 21 C4 1A            	LD	HL,QUARTR	; Point to 0.25
    4115/    1A9B : CD 3A 14            	CALL	SUBPHL		; Subtract value from 0.25
    4116/    1A9E : CD 89 16            	CALL	TSTSGN		; Test sign of value
    4117/    1AA1 : 37                  	SCF			; Flag positive
    4118/    1AA2 : F2 AC 1A            	JP	P,SIN1		; Positive - Ok
    4119/    1AA5 : CD 31 14            	CALL	ROUND		; Add 0.5 to value
    4120/    1AA8 : CD 89 16            	CALL	TSTSGN		; Test sign of value
    4121/    1AAB : B7                  	OR	A		; Flag negative
    4122/    1AAC : F5                  SIN1:	PUSH	AF		; Save sign
    4123/    1AAD : F4 B2 16            	CALL	P,INVSGN	; Negate value if positive
    4124/    1AB0 : 21 C4 1A            	LD	HL,QUARTR	; Point to 0.25
    4125/    1AB3 : CD 34 14            	CALL	ADDPHL		; Add 0.25 to value
    4126/    1AB6 : F1                  	POP	AF		; Restore sign
    4127/    1AB7 : D4 B2 16            	CALL	NC,INVSGN	; Negative - Make positive
    4128/    1ABA : 21 C8 1A            	LD	HL,SINTAB	; Coefficient table
    4129/    1ABD : C3 D1 19            	JP	SUMSER		; Evaluate sum of series
    4130/    1AC0 :                     ;
    4131/    1AC0 : DB 0F 49 81         HALFPI: DB	0DBH,00FH,049H,081H	; 1.5708 (PI/2)
    4132/    1AC4 :                     ;
    4133/    1AC4 : 00 00 00 7F         QUARTR: DB	000H,000H,000H,07FH	; 0.25
    4134/    1AC8 :                     ;
    4135/    1AC8 : 05                  SINTAB: DB	5			; Table used by SIN
    4136/    1AC9 : BA D7 1E 86         	DB	0BAH,0D7H,01EH,086H	; 39.711
    4137/    1ACD : 64 26 99 87         	DB	064H,026H,099H,087H	;-76.575
    4138/    1AD1 : 58 34 23 87         	DB	058H,034H,023H,087H	; 81.602
    4139/    1AD5 : E0 5D A5 86         	DB	0E0H,05DH,0A5H,086H	;-41.342
    4140/    1AD9 : DA 0F 49 83         	DB	0DAH,00FH,049H,083H	; 6.2832
    4141/    1ADD :                     ;
    4142/    1ADD : CD BA 16            TAN:	CALL	STAKFP		; Put angle on stack
    4143/    1AE0 : CD 7C 1A            	CALL	SIN		; Get SIN of angle
    4144/    1AE3 : C1                  	POP	BC		; Restore angle
    4145/    1AE4 : E1                  	POP	HL
    4146/    1AE5 : CD BA 16            	CALL	STAKFP		; Save SIN of angle
    4147/    1AE8 : EB                  	EX	DE,HL		; BCDE = Angle
    4148/    1AE9 : CD CA 16            	CALL	FPBCDE		; Angle to FPREG
    4149/    1AEC : CD 76 1A            	CALL	COS		; Get COS of angle
    4150/    1AEF : C3 DD 15            	JP	DIV		; TAN = SIN / COS
    4151/    1AF2 :                     ;
    4152/    1AF2 : CD 89 16            ATN:	CALL	TSTSGN		; Test sign of value
    4153/    1AF5 : FC 1D 19            	CALL	M,NEGAFT	; Negate result after if -ve
    4154/    1AF8 : FC B2 16            	CALL	M,INVSGN	; Negate value if -ve
    4155/    1AFB : 3A 2C 1E            	LD	A,(FPEXP)	; Get exponent
    4156/    1AFE : FE 81               	CP	81H		; Number less than 1?
    4157/    1B00 : DA 0F 1B            	JP	C,ATN1		; Yes - Get arc tangnt
    4158/    1B03 : 01 00 81            	LD	BC,8100H	; BCDE = 1
    4159/    1B06 : 51                  	LD	D,C
    4160/    1B07 : 59                  	LD	E,C
    4161/    1B08 : CD DF 15            	CALL	DVBCDE		; Get reciprocal of number
    4162/    1B0B : 21 3A 14            	LD	HL,SUBPHL	; Sub angle from PI/2
    4163/    1B0E : E5                  	PUSH	HL		; Save for angle > 1
    4164/    1B0F : 21 19 1B            ATN1:	LD	HL,ATNTAB	; Coefficient table
    4165/    1B12 : CD D1 19            	CALL	SUMSER		; Evaluate sum of series
    4166/    1B15 : 21 C0 1A            	LD	HL,HALFPI	; PI/2 - angle in case > 1
    4167/    1B18 : C9                  	RET			; Number > 1 - Sub from PI/2
    4168/    1B19 :                     ;
    4169/    1B19 : 09                  ATNTAB: DB	9			; Table used by ATN
    4170/    1B1A : 4A D7 3B 78         	DB	04AH,0D7H,03BH,078H	; 1/17
    4171/    1B1E : 02 6E 84 7B         	DB	002H,06EH,084H,07BH	;-1/15
    4172/    1B22 : FE C1 2F 7C         	DB	0FEH,0C1H,02FH,07CH	; 1/13
    4173/    1B26 : 74 31 9A 7D         	DB	074H,031H,09AH,07DH	;-1/11
    4174/    1B2A : 84 3D 5A 7D         	DB	084H,03DH,05AH,07DH	; 1/9
    4175/    1B2E : C8 7F 91 7E         	DB	0C8H,07FH,091H,07EH	;-1/7
    4176/    1B32 : E4 BB 4C 7E         	DB	0E4H,0BBH,04CH,07EH	; 1/5
    4177/    1B36 : 6C AA AA 7F         	DB	06CH,0AAH,0AAH,07FH	;-1/3
    4178/    1B3A : 00 00 00 81         	DB	000H,000H,000H,081H	; 1/1
    4179/    1B3E :                     ;
    4180/    1B3E :                     
    4181/    1B3E : C9                  ARET:	RET			; A RETurn instruction
    4182/    1B3F :                     ;
    4183/    1B3F : D7                  GETINP: RST	10H		;input a character
    4184/    1B40 : C9                  	RET
    4185/    1B41 :                     ;
    4186/    1B41 :                     CLS: 
    4187/    1B41 : 3E 0C               	LD	A,CS		; ASCII Clear screen
    4188/    1B43 :                     ;	JP	MONOUT		; Output character
    4189/    1B43 : CF                  	rst	08h
    4190/    1B44 : C9                  	ret
    4191/    1B45 :                     ;
    4192/    1B45 : CD 08 14            WIDTH:	CALL	GETINT		; Get integer 0-255
    4193/    1B48 : 7B                  	LD	A,E		; Width to A
    4194/    1B49 : 32 87 1D            	LD	(LWIDTH),A	; Set width
    4195/    1B4C : C9                  	RET
    4196/    1B4D :                     ;
    4197/    1B4D : CD A7 0C            LINES:	CALL	GETNUM		; Get a number
    4198/    1B50 : CD EC 08            	CALL	DEINT		; Get integer -32768 to 32767
    4199/    1B53 : ED 53 8B 1D         	LD	(LINESC),DE	; Set lines counter
    4200/    1B57 : ED 53 8D 1D         	LD	(LINESN),DE	; Set lines number
    4201/    1B5B : C9                  	RET
    4202/    1B5C :                     ;
    4203/    1B5C : CD EC 08            DEEK:	CALL	DEINT		; Get integer -32768 to 32767
    4204/    1B5F : D5                  	PUSH	DE		; Save number
    4205/    1B60 : E1                  	POP	HL		; Number to HL
    4206/    1B61 : 46                  	LD	B,(HL)		; Get LSB of contents
    4207/    1B62 : 23                  	INC	HL
    4208/    1B63 : 7E                  	LD	A,(HL)		; Get MSB of contents
    4209/    1B64 : C3 62 10            	JP	ABPASS		; Return integer AB
    4210/    1B67 :                     ;
    4211/    1B67 : CD A7 0C            DOKE:	CALL	GETNUM		; Get a number
    4212/    1B6A : CD EC 08            	CALL	DEINT		; Get integer -32768 to 32767
    4213/    1B6D : D5                  	PUSH	DE		; Save address
    4214/    1B6E : CD B2 06            	CALL	CHKSYN		; Make sure ',' follows
    4215/    1B71 : 2C                  	DB	','
    4216/    1B72 : CD A7 0C            	CALL	GETNUM		; Get a number
    4217/    1B75 : CD EC 08            	CALL	DEINT		; Get integer -32768 to 32767
    4218/    1B78 : E3                  	EX	(SP),HL		; Save value,get address
    4219/    1B79 : 73                  	LD	(HL),E		; Save LSB of value
    4220/    1B7A : 23                  	INC	HL
    4221/    1B7B : 72                  	LD	(HL),D		; Save MSB of value
    4222/    1B7C : E1                  	POP	HL		; Restore code string address
    4223/    1B7D : C9                  	RET
    4224/    1B7E :                     ;
    4225/    1B7E :                     
    4226/    1B7E :                     ; HEX$(nn) Convert 16 bit number to Hexadecimal string
    4227/    1B7E :                     ;
    4228/    1B7E : CD AA 0C            HEX: 	CALL	TSTNUM		; Verify it's a number
    4229/    1B81 : CD EC 08            	CALL	DEINT		; Get integer -32768 to 32767
    4230/    1B84 : C5                  	PUSH	BC		; Save contents of BC
    4231/    1B85 : 21 2E 1E            	LD	HL,PBUFF
    4232/    1B88 : 7A                  	LD	A,D		; Get high order into A
    4233/    1B89 : FE 00               	CP	0
    4234/    1B8B : 28 0C               	JR	Z,HEX2		; Skip output if both high digits are zero
    4235/    1B8D : CD B6 1B            	CALL	BYT2ASC		; Convert D to ASCII
    4236/    1B90 : 78                  	LD	A,B
    4237/    1B91 : FE 30               	CP	'0'
    4238/    1B93 : 28 02               	JR	Z,HEX1		; Don't store high digit if zero
    4239/    1B95 : 70                  	LD	(HL),B		; Store it to PBUFF
    4240/    1B96 : 23                  	INC	HL		; Next location
    4241/    1B97 : 71                  HEX1:	LD	(HL),C		; Store C to PBUFF+1
    4242/    1B98 : 23                  	INC	HL		; Next location
    4243/    1B99 : 7B                  HEX2:	LD	A,E		; Get lower byte
    4244/    1B9A : CD B6 1B            	CALL	BYT2ASC		; Convert E to ASCII
    4245/    1B9D : 7A                  	LD	A,D
    4246/    1B9E : FE 00               	CP	0
    4247/    1BA0 : 20 05               	JR	NZ,HEX3		; If upper byte was not zero then always print lower byte
    4248/    1BA2 : 78                  	LD	A,B
    4249/    1BA3 : FE 30               	CP	'0'		; If high digit of lower byte is zero then don't print
    4250/    1BA5 : 28 02               	JR	Z,HEX4
    4251/    1BA7 : 70                  HEX3:	LD	(HL),B		; to PBUFF+2
    4252/    1BA8 : 23                  	INC	HL		; Next location
    4253/    1BA9 : 71                  HEX4:	LD	(HL),C		; to PBUFF+3
    4254/    1BAA : 23                  	INC	HL		; PBUFF+4 to zero
    4255/    1BAB : AF                  	XOR	A		; Terminating character
    4256/    1BAC : 77                  	LD	(HL),A		; Store zero to terminate
    4257/    1BAD : 23                  	INC	HL		; Make sure PBUFF is terminated
    4258/    1BAE : 77                  	LD	(HL),A		; Store the double zero there
    4259/    1BAF : C1                  	POP	BC		; Get BC back
    4260/    1BB0 : 21 2E 1E            	LD	HL,PBUFF	; Reset to start of PBUFF
    4261/    1BB3 : C3 10 11            	JP	STR1		; Convert the PBUFF to a string and return it
    4262/    1BB6 :                     ;
    4263/    1BB6 : 47                  BYT2ASC: LD	B,A		; Save original value
    4264/    1BB7 : E6 0F               	AND	0FH		; Strip off upper nybble
    4265/    1BB9 : FE 0A               	CP	0AH		; 0-9?
    4266/    1BBB : 38 02               	JR	C,ADD30		; If A-F, add 7 more
    4267/    1BBD : C6 07               	ADD	A,07H		; Bring value up to ASCII A-F
    4268/    1BBF : C6 30               ADD30:	ADD	A,30H		; And make ASCII
    4269/    1BC1 : 4F                  	LD	C,A		; Save converted char to C
    4270/    1BC2 : 78                  	LD	A,B		; Retrieve original value
    4271/    1BC3 : 0F                  	RRCA			; and Rotate it right
    4272/    1BC4 : 0F                  	RRCA
    4273/    1BC5 : 0F                  	RRCA
    4274/    1BC6 : 0F                  	RRCA
    4275/    1BC7 : E6 0F               	AND	0FH		; Mask off upper nybble
    4276/    1BC9 : FE 0A               	CP	0AH		; 0-9? < A hex?
    4277/    1BCB : 38 02               	JR	C,ADD301	; Skip Add 7
    4278/    1BCD : C6 07               	ADD	A,07H		; Bring it up to ASCII A-F
    4279/    1BCF : C6 30               ADD301:	ADD	A,30H		; And make it full ASCII
    4280/    1BD1 : 47                  	LD	B,A		; Store high order byte
    4281/    1BD2 : C9                  	RET	
    4282/    1BD3 :                     ;
    4283/    1BD3 :                     ; Convert "&Hnnnn" to FPREG
    4284/    1BD3 :                     ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
    4285/    1BD3 :                     ; Char is in A, NC if char is;<=>?@ A-z, CY is set if 0-9
    4286/    1BD3 : EB                  HEXTFP:	EX	DE,HL		; Move code string pointer to DE
    4287/    1BD4 : 21 00 00            	LD	HL,0000H	; Zero out the value
    4288/    1BD7 : CD EC 1B            	CALL	GETHEX		; Check the number for valid hex
    4289/    1BDA : DA 0C 1C            	JP	C,HXERR		; First value wasn't hex, HX error
    4290/    1BDD : 18 05               	JR	HEXLP1		; Convert first character
    4291/    1BDF : CD EC 1B            HEXLP:	CALL	GETHEX		; Get second and addtional characters
    4292/    1BE2 : 38 1F               	JR	C,HEXIT		; Exit if not a hex character
    4293/    1BE4 : 29                  HEXLP1:	ADD	HL,HL		; Rotate 4 bits to the left
    4294/    1BE5 : 29                  	ADD	HL,HL
    4295/    1BE6 : 29                  	ADD	HL,HL
    4296/    1BE7 : 29                  	ADD	HL,HL
    4297/    1BE8 : B5                  	OR	L		; Add in D0-D3 into L
    4298/    1BE9 : 6F                  	LD	L,A		; Save new value
    4299/    1BEA : 18 F3               	JR	HEXLP		; And continue until all hex characters are in
    4300/    1BEC :                     ;
    4301/    1BEC : 13                  GETHEX:	INC	DE		; Next location
    4302/    1BED : 1A                  	LD	A,(DE)		; Load character at pointer
    4303/    1BEE : FE 20               	CP	' '
    4304/    1BF0 : CA EC 1B            	JP	Z,GETHEX	; Skip spaces
    4305/    1BF3 : D6 30               	SUB	30H		; Get absolute value
    4306/    1BF5 : D8                  	RET	C		; < "0", error
    4307/    1BF6 : FE 0A               	CP	0AH
    4308/    1BF8 : 38 05               	JR	C,NOSUB7	; Is already in the range 0-9
    4309/    1BFA : D6 07               	SUB	07H		; Reduce to A-F
    4310/    1BFC : FE 0A               	CP	0AH		; Value should be $0A-$0F at this point
    4311/    1BFE : D8                  	RET	C		; CY set if was :		; < = > ? @
    4312/    1BFF : FE 10               NOSUB7:	CP	10H		; > Greater than "F"?
    4313/    1C01 : 3F                  	CCF
    4314/    1C02 : C9                  	RET			; CY set if it wasn't valid hex
    4315/    1C03 :                     	
    4316/    1C03 : EB                  HEXIT:	EX	DE,HL		; Value into DE, Code string into HL
    4317/    1C04 : 7A                  	LD	A,D		; Load DE into AC
    4318/    1C05 : 4B                  	LD	C,E		; For prep to 
    4319/    1C06 : E5                  	PUSH	HL
    4320/    1C07 : CD 61 10            	CALL	ACPASS		; ACPASS to set AC as integer into FPREG
    4321/    1C0A : E1                  	POP	HL
    4322/    1C0B : C9                  	RET
    4323/    1C0C :                     ;
    4324/    1C0C : 1E 26               HXERR:	LD	E,HX		; ?HEX Error
    4325/    1C0E : C3 F8 03            	JP	ERROR_
    4326/    1C11 :                     ;
    4327/    1C11 :                     ; BIN$(NN) Convert integer to a 1-16 char binary string
    4328/    1C11 : CD AA 0C            BIN:	CALL	TSTNUM		; Verify it's a number
    4329/    1C14 : CD EC 08            	CALL	DEINT		; Get integer -32768 to 32767
    4330/    1C17 : C5                  BIN2:	PUSH	BC		; Save contents of BC
    4331/    1C18 : 21 2E 1E            	LD	HL,PBUFF
    4332/    1C1B : 06 11               	LD	B,17		; One higher than max char count
    4333/    1C1D :                     ZEROSUP:			; Suppress leading zeros
    4334/    1C1D : 05                  	DEC	B		; Max 16 chars
    4335/    1C1E : 78                  	LD	A,B
    4336/    1C1F : FE 01               	CP	01H
    4337/    1C21 : 28 08               	JR	Z,BITOUT	; Always output at least one character
    4338/    1C23 : CB 13               	RL	E
    4339/    1C25 : CB 12               	RL	D
    4340/    1C27 : 30 F4               	JR	NC,ZEROSUP
    4341/    1C29 : 18 04               	JR	BITOUT2
    4342/    1C2B :                     BITOUT:	
    4343/    1C2B : CB 13               	RL	E
    4344/    1C2D : CB 12               	RL	D		; Top bit now in carry
    4345/    1C2F :                     BITOUT2:
    4346/    1C2F : 3E 30               	LD	A,'0'		; Char for '0'
    4347/    1C31 : CE 00               	ADC	A,0		; If carry set then '0' --> '1'
    4348/    1C33 : 77                  	LD	(HL),A
    4349/    1C34 : 23                  	INC	HL
    4350/    1C35 : 05                  	DEC	B
    4351/    1C36 : 20 F3               	JR	NZ,BITOUT
    4352/    1C38 : AF                  	XOR	A		; Terminating character
    4353/    1C39 : 77                  	LD	(HL),A		; Store zero to terminate
    4354/    1C3A : 23                  	INC	HL		; Make sure PBUFF is terminated
    4355/    1C3B : 77                  	LD	(HL),A		; Store the double zero there
    4356/    1C3C : C1                  	POP	BC
    4357/    1C3D : 21 2E 1E            	LD	HL,PBUFF
    4358/    1C40 : C3 10 11            	JP	STR1
    4359/    1C43 :                     ;
    4360/    1C43 :                     ; Convert "&Bnnnn" to FPREG
    4361/    1C43 :                     ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
    4362/    1C43 : EB                  BINTFP: EX	DE,HL		; Move code string pointer to DE
    4363/    1C44 : 21 00 00            	LD	HL,0000H	; Zero out the value
    4364/    1C47 : CD 60 1C            	CALL	CHKBIN		; Check the number for valid bin
    4365/    1C4A : DA 6E 1C            	JP	C,BINERR	; First value wasn't bin, HX error
    4366/    1C4D : D6 30               BINIT:	SUB	'0'
    4367/    1C4F : 29                  	ADD	HL,HL		; Rotate HL left
    4368/    1C50 : B5                  	OR	L
    4369/    1C51 : 6F                  	LD	L,A
    4370/    1C52 : CD 60 1C            	CALL	CHKBIN		; Get second and addtional characters
    4371/    1C55 : 30 F6               	JR	NC,BINIT	; Process if a bin character
    4372/    1C57 : EB                  	EX	DE,HL		; Value into DE, Code string into HL
    4373/    1C58 : 7A                  	LD	A,D		; Load DE into AC
    4374/    1C59 : 4B                  	LD	C,E		; For prep to 
    4375/    1C5A : E5                  	PUSH	HL
    4376/    1C5B : CD 61 10            	CALL	ACPASS		; ACPASS to set AC as integer into FPREG
    4377/    1C5E : E1                  	POP	HL
    4378/    1C5F : C9                  	RET
    4379/    1C60 :                     ;
    4380/    1C60 :                     ; Char is in A, NC if char is 0 or 1
    4381/    1C60 : 13                  CHKBIN: INC	DE
    4382/    1C61 : 1A                  	LD	A,(DE)
    4383/    1C62 : FE 20               	CP	' '
    4384/    1C64 : CA 60 1C            	JP	Z,CHKBIN	; Skip spaces
    4385/    1C67 : FE 30               	CP	'0'		; Set C if < '0'
    4386/    1C69 : D8                  	RET	C
    4387/    1C6A : FE 32               	CP	'2'
    4388/    1C6C : 3F                  	CCF			; Set C if > '1'
    4389/    1C6D : C9                  	RET
    4390/    1C6E :                     ;
    4391/    1C6E : 1E 28               BINERR: LD	E,BN		; ?BIN Error
    4392/    1C70 : C3 F8 03            	JP	ERROR_
    4393/    1C73 :                     ;
    4394/    1C73 :                     ;JJUMP1: JP	CSTART		; Go and initialise
    4395/    1C73 :                     ;
    4396/    1C73 :                     ;MONOUT: JP	TXA		; output a char
    4397/    1C73 :                     ;
    4398/    1C73 :                     MONITR: 
    4399/    1C73 :                     ;JP	UNI_CST		; Restart unimon
    4400/    1C73 : 0E 01               	ld	c, 1
    4401/    1C75 : F7                  	rst	30h
    4402/    1C76 : C9                  	ret
    4403/    1C77 :                     ;
    4404/    1C77 : 3E 00               INITST: LD	A,0		; Clear break flag
    4405/    1C79 : 32 92 1D            	LD	(BRKFLG),A
    4406/    1C7C : C3 54 00            	JP	INIT
    4407/    1C7F :                     ;
    4408/    1C7F : F5                  TSTBIT: PUSH	AF		; Save bit mask
    4409/    1C80 : A0                  	AND	B		; Get common bits
    4410/    1C81 : C1                  	POP	BC		; Restore bit mask
    4411/    1C82 : B8                  	CP	B		; Same bit set?
    4412/    1C83 : 3E 00               	LD	A,0		; Return 0 in A
    4413/    1C85 : C9                  	RET
    4414/    1C86 :                     ;
    4415/    1C86 : CD BD 06            OUTNCR: CALL	OUTC		; Output character in A
    4416/    1C89 : C3 E2 0A            	JP	PRCRLF		; Output CRLF
    4417/    1C8C :                     
    4418/    1C8C : FF FF FF FF FF FF   	db	($ & 0FF00H)+100H-$ dup(0FFH)
             1C92 : FF FF FF FF FF FF 
             1C98 : FF FF FF FF FF FF 
             1C9E : FF FF FF FF FF FF 
             1CA4 : FF FF FF FF FF FF 
             1CAA : FF FF FF FF FF FF 
             1CB0 : FF FF FF FF FF FF 
             1CB6 : FF FF FF FF FF FF 
             1CBC : FF FF FF FF FF FF 
             1CC2 : FF FF FF FF FF FF 
             1CC8 : FF FF FF FF FF FF 
             1CCE : FF FF FF FF FF FF 
             1CD4 : FF FF FF FF FF FF 
             1CDA : FF FF FF FF FF FF 
             1CE0 : FF FF FF FF FF FF 
             1CE6 : FF FF FF FF FF FF 
             1CEC : FF FF FF FF FF FF 
             1CF2 : FF FF FF FF FF FF 
             1CF8 : FF FF FF FF FF FF 
             1CFE : FF FF             
    4419/    1D00 :                     
    4420/    1D00 :                     	END
 AS V1.42 Beta [Bld 246] - Source File add_EMUBASIC_SMEZ.ASM - Page 2 - 9/22/2023 19:27:59


  Symbol Table (* = unused):
  --------------------------

 ABPASS :                      1062 C |  ABS :                         16AE C |
*ACCSUM :                       8CB C |  ACPASS :                      1061 C |
 ADD30 :                       1BBF C |  ADD301 :                      1BCF C |
 ADDEXP :                      1647 C |  ADDIG :                       17ED C |
 ADDPHL :                      1434 C |  AKI80 :                          0 - |
 ALLFOL :                      1330 C |  ANTVLU :                      0BCB C |
*ARCHITECTURE :                                        "i386-unknown-win32" - |
*ARET :                        1B3E C |  ARLDSV :                      0F82 C |
 ARREND :                      1E1F - |  ARRLP :                       11FB C |
 ASC :                         1301 C |  ASCTFP :                      1790 C |
 ASPCS :                       0B2D C |  ATN :                         1AF2 C |
 ATN1 :                        1B0F C |  ATNTAB :                      1B19 C |
 ATOH :                         906 C |  BADINP :                      0B52 C |
 BAKSTK :                       38D C |  BAKTMP :                      12E1 C |
 BASTXT :                      1DA3 - |  BCDEFP :                      16D5 C |
 BFREE :                        0BD C |  BIN :                         1C11 C |
*BIN2 :                        1C17 C |  BINERR :                      1C6E C |
 BINIT :                       1C4D C |  BINTFP :                      1C43 C |
 BITOUT :                      1C2B C |  BITOUT2 :                     1C2F C |
 BKSP :                           8 - |  BN :                            28 - |
 BNORM :                       1494 C |  BNRMLP :                      1497 C |
 BRK :                          87D C |  BRKFLG :                      1D92 - |
 BRKLIN :                      1E13 - |  BRKMSG :                       387 C |
 BRKRET :                       0AE C |  BS :                            10 - |
 BSERR :                       0FB5 C |  BUFFER :                      1DA6 - |
 BYT2ASC :                     1BB6 C |  BYTSFT :                      15CC C |
*CASESENSITIVE :                  0 - |  CFEVAL :                      0F18 C |
 CHARTY :                      0EC6 C |  CHEKFN :                      10F9 C |
 CHKBIN :                      1C60 C |  CHKLTR :                       8D8 C |
 CHKSTK :                       3C1 C |  CHKSUM :                      1D8F - |
 CHKSYN :                       6B2 C |  CHKTYP :                      0CAC C |
 CHR :                         1312 C |  CLEAR :                        92B C |
 CLOTST :                       6E5 C |  CLREG :                        516 C |
 CLRPTR :                       4F1 C |  CLS :                         1B41 C |
 CMPFP :                       171E C |  CMPLG1 :                      0E2C C |
 CMPLOG :                      0E2A C |  CMPNUM :                      1704 C |
 CMPRES :                      0E6E C |  CMPSTR :                      0E56 C |
 CN :                            20 - |  CNVNUM :                      179C C |
 COMMAN :                      1D88 - |  COMPL :                       14F4 C |
 CONCAT :                      1276 C |  CONEXP :                      17CC C |
 CONPOS :                      1491 C | *CONSTPI :        3.141592653589793 - |
 CONT :                         8B0 C |  CONTAD :                      1E19 - |
 CONVAR :                      0D97 C |  COPY :                          5C C |
 COS :                         1A76 C |  COUNT :                        755 C |
 CPDEHL :                       6AC C |  CPYLIT :                       5E8 C |
 CR :                            0D - |  CRARLP :                      0FD5 C |
 CREARY :                      0FBA C |  CRESTR :                      0A2A C |
 CRNCLP :                       549 C |  CRTMST :                      1132 C |
 CRTST :                       113E C |  CRTSTE :                      1154 C |
 CRUNCH :                       540 C |  CS :                            0C - |
 CSTART :                        4D C |  CTLOFG :                      1D8A - |
 CTRLC :                          3 - |  CTRLG :                          7 - |
 CTRLO :                         0F - |  CTRLQ :                         11 - |
 CTRLR :                         12 - |  CTRLS :                         13 - |
 CTRLU :                         15 - |  CUROPR :                      1E0A - |
 CURPOS :                      1DF0 - |  DATA :                         9D1 C |
*DATE :                 "9/22/2023" - |  DATFLG :                      1DF3 - |
 DATLIN :                      1E0E - |  DATSNR :                       3DE C |
 DCBCDE :                      1755 C |  DDERR :                        3ED C |
 DEEK :                        1B5C C |  DEF :                         1076 C |
 DEFSIZ :                      0FDD C |  DEINT :                        8EC C |
 DEL :                           7F - |  DELCHR :                       618 C |
 DEPINT :                       8E6 C |  DETHL4 :                      16E4 C |
 DETHLB :                      16E6 C |  DIGTXT :                      1896 C |
 DIM :                         0E98 C |  DIMRET :                      0E8F C |
 DINPOS :                       6E1 C |  DIV :                         15DD C |
 DIV1 :                        1D4F - |  DIV10 :                       15D1 C |
 DIV2 :                        1D53 - |  DIV3 :                        1D57 - |
 DIV4 :                        1D5A - |  DIVLP :                       1604 C |
 DIVSUP :                      1D4E - |  DOAGN :                        52F C |
 DOCOM :                       0AFE C |  DODEL :                        5F8 C |
 DOEBIT :                      18D6 C |  DOFN :                        10A3 C |
 DOKE :                        1B67 C |  DONULL :                      0AEC C |
 DOSPC :                       0B28 C |  DOTAB :                       0B15 C |
 DPOINT :                      17C8 C |  DTSTR :                       1142 C |
 DVBCDE :                      15DF C |  DZ :                            14 - |
 DZERR :                        3E7 C |  ECHDEL :                       60C C |
 EDIGIT :                      180F C |  ENDBUF :                       5EF C |
 ENDCON :                      17DB C |  ENDDIM :                      103C C |
 ENDINP :                      0ADD C |  ENDNAM :                      0EBA C |
 ENDPRG :                       88C C |  ENFMEM :                       3CA C |
 ERRIN :                        418 C |  ERRLIN :                      1E17 - |
 ERRMSG :                       375 C |  ERRORS :                       2EB C |
 ERROR_ :                       3F8 C |  ESC :                           1B - |
 EVAL :                        0CB9 C |  EVAL1 :                       0CBC C |
 EVAL2 :                       0CC5 C |  EVAL3 :                       0CC8 C |
 EVLPAR :                      0D7E C |  EVNOT :                       0E78 C |
 EXCUTE :                       81A C |  EXP :                         1970 C |
 EXPLP :                       17BA C |  EXPTAB :                      19B0 C |
 EXPTEN :                      18E8 C |  EXTIG :                       0C27 C |
*FALSE :                          0 - |  FANDT :                       0C51 C |
 FC :                             8 - |  FCERR :                        901 C |
 FDTLP :                       0C38 C |  FINDEL :                      1018 C |
 FLGDIF :                      1694 C |  FLGREL :                      169B C |
 FNARG :                       1E25 - |  FNCTAB :                       135 C |
 FNDARY :                      0F88 C |  FNDELP :                      101D C |
 FNDEND :                       4C4 C |  FNDNUM :                      1405 C |
 FNDTOK :                       734 C |  FNDVAR :                      0EFF C |
 FNDWRD :                       573 C |  FNOFST :                      0DA8 C |
 FNRGNM :                      1E23 - |  FNTHR :                       0F0D C |
 FNVAL :                       0DCF C |  FOPRND :                      0CF1 C |
 FOR :                          781 C |  FORFLG :                      1E10 - |
 FORFND :                       7B1 C |  FORSLP :                       795 C |
 FPADD :                       1443 C |  FPBCDE :                      16CA C |
 FPEXP :                       1E2C - |  FPINT :                       1731 C |
 FPMULT :                      157E C |  FPREG :                       1E29 - |
 FPROND :                      14DB C |  FPSINT :                       8E0 C |
 FPTHL :                       16E1 C |  FRE :                         1040 C |
 FRENUM :                      105C C |  FRMEVL :                      0D9A C |
*FULLPMMU :                       1 - |  GARBGE :                      11C3 C |
 GARBLP :                      11C6 C |  GETCHR :                       83A C |
 GETCMD :                       43C C |  GETHEX :                      1BEC C |
 GETINP :                      1B3F C |  GETINT :                      1408 C |
 GETLEN :                      12F6 C |  GETLIN :                       629 C |
 GETLN :                        907 C |  GETNUM :                      0CA7 C |
 GETNXT :                       58E C |  GETSTR :                      12C0 C |
 GETVAR :                      0E9D C |  GNXARY :                      11FA C |
 GOFUNC :                      0DD7 C |  GOSUB :                        97D C |
 GOTO :                         98E C |  GRBARY :                      121A C |
 GRBDON :                      119B C |  GRBLP :                       11D4 C |
 GSTRCU :                      12C3 C |  GSTRDE :                      12C7 C |
 GSTRHL :                      12C6 C | *GTFLNM :                      1305 C |
 GTFNAM :                      0EA2 C |  GTLNLP :                       90A C |
 GTSIXD :                      1860 C |  GTVLUS :                      0BA3 C |
 HALF :                        1907 C |  HALFPI :                      1AC0 C |
*HAS64 :                          0 - | *HASFPU :                         0 - |
*HASPMMU :                        0 - |  HEX :                         1B7E C |
 HEX1 :                        1B97 C |  HEX2 :                        1B99 C |
 HEX3 :                        1BA7 C |  HEX4 :                        1BA9 C |
 HEXIT :                       1C03 C |  HEXLP :                       1BDF C |
 HEXLP1 :                      1BE4 C |  HEXTFP :                      1BD3 C |
 HX :                            26 - |  HXERR :                       1C0C C |
 ID :                            16 - |  IDTEST :                      10EB C |
 IFGO :                        0A6E C |  IFJMP :                        821 C |
 IF_ :                         0A60 C |  INCHL :                       16DF C |
 INCLEN :                       6DD C |  INDFND :                       3A7 C |
 INEWLN :                       48C C |  INIT :                          54 C |
 INITAB :                       315 C |  INITBE :                       375 C |
 INITST :                      1C77 C |  INMSG :                        37C C |
 INP :                         13C5 C |  INPBIN :                      0BF5 C |
 INPBRK :                       889 C |  INPORT :                      1D84 - |
 INPSUB :                      1D83 - |  INPUT :                       0B63 C |
 INRNG :                       1869 C | *INSUPMODE :                      0 - |
 INT :                         175C C |  INTVAR :                       500 C |
 INVSGN :                      16B2 C |  ITMSEP :                      0BE6 C |
 JSTZER :                      18F2 C |  KILFOR :                      0C97 C |
 KILIN :                        623 C |  LCRFLG :                      1DF1 - |
 LEFT :                        1322 C |  LEN :                         12F2 C |
 LET :                          9E8 C |  LETNUM :                      0A3B C |
 LETSTR :                      0A03 C |  LF :                            0A - |
 LFRGNM :                      13BB C |  LINEAT :                      1DA1 - |
 LINEIN :                      181B C |  LINES :                       1B4D C |
 LINESC :                      1D8B - |  LINESN :                      1D8D - |
 LINFND :                       475 C |  LIST :                         6F6 C |
 LISTLP :                       702 C | *LISTON :                         1 - |
 LOADFP :                      16D8 C |  LOG :                         153D C |
 LOGTAB :                      1530 C |  LOKFOR :                       391 C |
 LOOPST :                      1E0C - |  LS :                            1C - |
 LSTBIN :                      1E11 - |  LSTLP2 :                       722 C |
 LSTLP3 :                       725 C |  LSTRAM :                      1DF4 - |
 LSTRND :                      1D7F - |  LTSTND :                      0C00 C |
 LWIDTH :                      1D87 - | *MACEXP :                         7 - |
 MAKINT :                      140B C |  MAKNUM :                      1885 C |
 MANLP :                       17A4 C |  MATCH :                        5C0 C |
 MEMMSG :                       103 C |  MID :                         135C C |
 MID1 :                        1328 C |  MIDNUM :                      13C0 C |
 MINCDE :                      1483 C |  MINUS :                       0D86 C |
 MKTMST :                      112F C |  MLDBLP :                      177D C |
 MLDEBC :                      1775 C |  MLSP10 :                      1672 C |
 MO :                            24 - | *MOMCPU :                        80 - |
*MOMCPUNAME :                 "Z80" - |  MONITR :                      1C73 C |
 MORDT :                       0C0C C |  MORINP :                       632 C |
 MOVBUF :                       4AB C |  MOVDIR :                       5C8 C |
 MOVLP :                        3B6 C |  MOVSTR :                       3B3 C |
 MOVUP :                        3B0 C |  MRPRNT :                      0A80 C |
 MUL8LP :                      15A9 C |  MULLN2 :                      1575 C |
 MULT :                        157C C |  MULT8 :                       15A0 C |
 MULTEN :                      17E6 C |  MULVAL :                      1E3B - |
 MVSTPT :                      0A32 C |  NEDMOR :                      0B9F C |
 NEGAFT :                      191D C |  NEMEM :                        0B4 C |
*NESTMAX :                      100 - |  NEW :                          4F0 C |
 NEXITM :                      0B38 C |  NEXT :                        0C5C C |
 NEXT1 :                       0C5F C |  NF :                             0 - |
 NFERR :                        3EA C | *NMIFLG :                      1D91 - |
 NOCHNG :                       5B8 C |  NOENED :                      18F5 C |
 NOLIN :                        89F C |  NOMADD :                      15BA C |
 NOMLAD :                      178B C |  NOPMPT :                      0B7D C |
 NORMAL :                      14AE C |  NOSPC :                        5AF C |
 NOSUB7 :                      1BFF C |  NOSWAP :                      145D C |
 NOTAMP :                      0D5B C |  NOTSTR :                      0ED5 C |
 NOXOR :                       13EB C |  NSCFOR :                      0EE5 C |
 NULFLG :                      1D89 - |  NULL :                         8C3 C |
 NULLP :                       0AF3 C |  NULLS :                       1D86 - |
 NUMASC :                      182E C |  NXTARY :                      0F9C C |
 NXTBYT :                       59E C |  NXTCHR :                       5DF C |
 NXTDAT :                      1E21 - |  NXTDTA :                       9D0 C |
 NXTITM :                      0B97 C |  NXTOPR :                      1E15 - |
 NXTSTL :                       9D7 C |  NXTSTT :                       9DA C |
 OD :                             6 - |  OKMSG :                        381 C |
 OM :                            0C - |  OMERR :                        3D9 C |
 ON :                          0A42 C |  ONGO :                        0A51 C |
 ONGOLP :                      0A52 C |  ONJMP :                        822 C |
 OPNPAR :                      0CB5 C |  OPRND :                       0D30 C |
 OS :                            1A - |  OTKLN :                        620 C |
 OTPORT :                      1D4C - |  OUTC :                         6BD C |
 OUTEXP :                      18E6 C |  OUTIT :                        69E C |
 OUTNBS :                       6A4 C |  OUTNCR :                      1C86 C |
 OUTSUB :                      1D4B - |  OUTWRD :                       73E C |
 OV :                            0A - |  OVERR :                        3F3 C |
 OVTST1 :                      1665 C |  OVTST2 :                      166A C |
 OVTST3 :                      166B C |  PADD :                        180A C |
*PADDING :                        1 - |  PAND :                        0DF1 C |
 PASSA :                       1071 C |  PBUFF :                       1E2E - |
 PEEK :                        1419 C |  PEND :                         884 C |
 PHLTFP :                      16C7 C |  PLUCDE :                      14E8 C |
 PNORM :                       14B6 C |  POINT :                       1D96 - |
 POKE :                        1420 C |  POPAF :                       11B5 C |
 POPHL :                       12DF C |  POPHRT :                      15CA C |
 POPNOK :                       42E C |  POR :                         0DF0 C |
 POR1 :                        0E13 C |  POS :                         106E C |
 POSINT :                       8E3 C |  POUT :                        13D1 C |
 POWER :                       192B C |  POWER1 :                      193B C |
 POWER2 :                      1958 C |  POWERS :                      190B C |
 PRCRLF :                      0AE2 C |  PRINT :                       0A84 C |
 PRITAB :                       2D6 C |  PRNTHL :                      1823 C |
 PRNTLP :                      0A87 C |  PRNTNB :                      0ACA C |
 PRNTOK :                       42F C |  PRNTST :                      0ACE C |
 PRNUMS :                      117F C |  PROCES :                       64B C |
 PROGND :                      1E1B - |  PROGST :                      1E3E - |
 PROMPT :                       533 C |  PRS :                         1180 C |
 PRS1 :                        1183 C |  PRSLP :                       118A C |
 PSET :                        1D99 - |  PSUB :                        143E C |
 PTRLP :                        4B8 C |  PUTBUF :                       68A C |
 PUTCTL :                       68F C |  PUTFID :                       7F6 C |
 QTSTLP :                      1145 C |  QTSTR :                       113F C |
 QUARTR :                      1AC4 C |  RAM12K :                         0 - |
 RAM4K :                          0 - |  RAM8K :                          0 - |
 RAMTOP :                      1D00 - |  RD :                            12 - |
 READ :                        0B92 C |  READFG :                      1E12 - |
 REDO :                        0B3F C | *RELAXED :                        0 - |
 REM :                          9D3 C |  RESDIV :                      1617 C |
 RESEED :                      1A62 C |  RESET :                       1D9C - |
 RESTNL :                       85F C |  RESTOR :                       84A C |
 RESZER :                      14A9 C |  RETADR :                      0F4C C |
 RETINT :                      16A0 C |  RETLIN :                       9CB C |
 RETNAD :                       5C4 C |  RETNUL :                      0F4F C |
 RETNUM :                      0D92 C |  RETREL :                      1692 C |
 RETURN :                       9AC C |  RG :                             4 - |
 RIGHT :                       1352 C |  RIGHT1 :                      1326 C |
 RINPUT :                      1D93 - |  RLTLP :                       0CD5 C |
 RND :                         1A01 C |  RND1 :                        1A3D C |
 RND2 :                        1A59 C |  RNDTAB :                      1A6A C |
 RNGTST :                      18F8 C |  ROMTOP :                        40 - |
 RONDB :                       14CA C |  RONDUP :                      14C9 C |
 ROUND :                       1431 C |  RSCALE :                      1804 C |
 RSLNBK :                       778 C |  RSTSTR :                      1375 C |
 RUN :                          971 C |  RUNCNT :                       7FA C |
 RUNFST :                       4FC C |  RUNLIN :                       98D C |
 SAVEXP :                      14AA C |  SAVSTP :                       7ED C |
 SAVSTR :                      111A C |  SBSCPT :                      0F5A C |
 SCALE :                       1508 C |  SCALLP :                      150A C |
 SCALMI :                      17CF C |  SCALPL :                      17E5 C |
 SCNEND :                      1251 C |  SCPTLP :                      0F60 C |
 SEARCH :                       58C C |  SEED :                        1D5C - |
 SETIO :                       13F5 C |  SETLIN :                       74C C |
 SETLIT :                       5D6 C |  SETPTR :                       4B3 C |
 SFTPRG :                       47D C |  SGN :                         1698 C |
 SGNEXP :                      0DE0 C |  SGNRES :                      1E2D - |
 SHRITE :                      1517 C |  SHRLP :                       151A C |
 SHRT1 :                       151E C |  SIGNON :                       0CC C |
 SIGNS :                       16EF C |  SIN :                         1A7C C |
 SIN1 :                        1AAC C |  SINTAB :                      1AC8 C |
 SIXDIG :                      184B C |  SMPVAR :                      11E5 C |
 SMSER1 :                      19E0 C |  SN :                             2 - |
 SNERR :                        3E4 C |  SPCFST :                      183C C |
 SPCLP :                       0B31 C |  SQR :                         1922 C |
 SRCHLN :                       4D0 C |  SRCHLP :                       4D3 C |
 SSTSA :                       12AD C |  ST :                            1E - |
 STACK :                       1DAB - |  STACKU :                     0FEC0 - |
 STAKFP :                      16BA C |  STALL :                        873 C |
 STARTB :                        46 C |  STKTHS :                      0D19 C |
 STLOOK :                      1EA2 - |  STOP :                         882 C |
 STORED :                       94E C |  STPOOL :                      1228 C |
 STR :                         110A C |  STR1 :                        1110 C |
 STRADD :                      122B C |  STRBOT :                      1E08 - |
 STRENT :                      0BE9 C |  STRSPC :                      1D9F - |
 STTLIN :                      0AD5 C |  SUBCDE :                      1440 C |
 SUBPHL :                      143A C |  SUMLP :                       19E9 C |
 SUMSER :                      19D1 C |  SUPERMEZ80 :                     1 - |
 SUPTLZ :                      18CA C |  SVNAM2 :                      0EB9 C |
 SVSTAD :                      1138 C |  TAN :                         1ADD C |
 TESTOS :                      11B7 C |  TESTR :                       1199 C |
*TIME :                  "19:27:59" - |  TM :                            18 - |
 TMERR :                        3F6 C |  TMPSTR :                      1E04 - |
 TMSTPL :                      1DF8 - |  TMSTPT :                      1DF6 - |
 TOPOOL :                      131E C |  TOSTRA :                      12B6 C |
*TRUE :                           1 - |  TRYAGN :                      18A5 C |
 TSALP :                       12B7 C | *TSTBIT :                      1C7F C |
 TSTBRK :                       865 C |  TSTNUM :                      0CAA C |
 TSTOPL :                      1160 C |  TSTRED :                      0E18 C |
 TSTREM :                       5D9 C |  TSTSGN :                      1689 C |
 TSTSTR :                      0CAB C |  TTYLIN :                       629 C |
 TYPE :                        1DF2 - |  UF :                            22 - |
 UFERR :                        3F0 C |  UL :                            0E - |
 ULERR :                        9A7 C |  UNITY :                       152C C |
 UPDATA :                       860 C |  USR :                         1D48 - |
 VAL :                         138C C |  VAL1 :                        13AA C |
 VAL2 :                        13B4 C |  VAL3 :                        13B7 C |
 VAREND :                      1E1D - | *VERSION :                     142F - |
 WAIT :                        13D7 C |  WAITLP :                      13EC C |
 WARMST :                       0AB C |  WIDTH :                       1B45 C |
 WORDS :                        16D C |  WORDTB :                       28C C |
 WRKSPC :                      1D45 - |  XXXXX :                        0BA C |
 ZDATA :                         83 - | *ZDIV :                         0AF - |
 ZEND :                          80 - |  ZEQUAL :                       0B4 - |
 ZERARY :                      0FFB C |  ZERBYT :                       380 - |
 ZEROLP :                      0F3E C |  ZEROSUP :                     1C1D C |
 ZFN :                          0A7 - |  ZFOR :                          81 - |
 ZGOSUB :                        8C - |  ZGOTO :                         88 - |
 ZGTR :                         0B3 - |  ZLEFT :                        0CF - |
 ZLTH :                         0B5 - |  ZMINUS :                       0AD - |
 ZNEW :                         0A4 - |  ZNOT :                         0AA - |
 ZONELP :                      0B0C C |  ZOR :                          0B2 - |
 ZPLUS :                        0AC - | *ZPOINT :                       0C7 - |
 ZPRINT :                        9E - |  ZREM :                          8E - |
 ZSGN :                         0B6 - |  ZSPC :                         0A8 - |
 ZSTEP :                        0AB - |  ZTAB :                         0A5 - |
 ZTHEN :                        0A9 - | *ZTIMES :                       0AE - |
 ZTO :                          0A6 - |

    656 symbols
     29 unused symbols

 AS V1.42 Beta [Bld 246] - Source File add_EMUBASIC_SMEZ.ASM - Page 3 - 9/22/2023 19:27:59


  Code Pages:
  ----------

STANDARD (0 changed characters)

1 code page

0.11 seconds assembly time

   4421 lines source file
      2 passes
      0 errors
      0 warnings
