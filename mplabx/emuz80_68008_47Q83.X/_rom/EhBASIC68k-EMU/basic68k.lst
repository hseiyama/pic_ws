 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 1 - 10/11/2023 21:18:52


       1/       0 :                     ;************************************************************************************
       2/       0 :                     ;										    										*
       3/       0 :                     ;	Enhanced BASIC for the Motorola MC680xx					    					*
       4/       0 :                     ;										    										*
       5/       0 :                     ;	This version is for the TS2 single board computer.		            			*
       6/       0 :                     ;	Jeff Tranter (tranter@pobox.com)					    						*
       7/       0 :                     ;										    										*
       8/       0 :                     ;************************************************************************************
       9/       0 :                     ;										    										*
      10/       0 :                     ;	Copyright(C) 2002-12 by Lee Davison. This program may be freely distributed 	*
      11/       0 :                     ;	for personal use only. All commercial rights are reserved.		    			*
      12/       0 :                     ;										    										*
      13/       0 :                     ;	More 68000 and other projects can be found on my website at ..		    		*
      14/       0 :                     ;										    										*
      15/       0 :                     ;	 http://mycorner.no-ip.org/index.html					    					*
      16/       0 :                     ;										    										*
      17/       0 :                     ;	mail : leeedavison@googlemail.com					    						*
      18/       0 :                     ;										    										*
      19/       0 :                     ;************************************************************************************
      20/       0 :                     
      21/       0 :                     ; Ver 3.54
      22/       0 :                     
      23/       0 :                     ; Ver 3.54 adds experimental support for LOAD/SAVE using Hobbytronics
      24/       0 :                     ; USB Flash Drive Host Board
      25/       0 :                     ; Ver 3.53 fixes math error that affected exponentiation ("^") and
      26/       0 :                     ;  EXP() function. Thanks to joelang for fix.
      27/       0 :                     ; Ver 3.52 stops USING$() from reading beyond the end of the format string
      28/       0 :                     ; Ver 3.51 fixes the UCASE$() and LCASE$() functions for null strings
      29/       0 :                     ; Ver 3.50 unary minus in concatenate generates a type mismatch error
      30/       0 :                     ; Ver 3.49 doesn't tokenise 'DEF' or 'DEC' within a hex value
      31/       0 :                     ; Ver 3.48 allows scientific notation underflow in the USING$() function
      32/       0 :                     ; Ver 3.47 traps the use of array elements as the FOR loop variable
      33/       0 :                     ; Ver 3.46 updates function and function variable handling
      34/       0 :                     
      35/       0 :                     ;************************************************************************************
      36/       0 :                     ;
      37/       0 :                     ; Ver 3.45 makes the handling of non existant variables consistent and gives the
      38/       0 :                     ; option of not returning an error for a non existant variable. If this is the
      39/       0 :                     ; behaviour you want just change novar to some non zero value
      40/       0 :                     
      41/       0 : =$0                 novar		EQU	0					; non existant variables cause errors
      42/       0 :                     
      43/       0 :                     ; Set the symbol FLASH_SUPPORT to 1 if you want to enable experimental
      44/       0 :                     ; support for LOAD/SAVE using a Hobbytronics USB Flash Drive Host
      45/       0 :                     ; Board.
      46/       0 :                     
      47/       0 : =$0                 FLASH_SUPPORT   EQU     0
      48/       0 :                     
      49/       0 :                     ;************************************************************************************
      50/       0 :                     
      51/       0 :                     ; Ver 3.44 adds overflow indication to the USING$() function
      52/       0 :                     ; Ver 3.43 removes an undocumented feature of concatenating null strings
      53/       0 :                     ; Ver 3.42 reimplements backspace so that characters are overwritten with [SPACE]
      54/       0 :                     ; Ver 3.41 removes undocumented features of the USING$() function
      55/       0 :                     ; Ver 3.40 adds the USING$() function
      56/       0 :                     ; Ver 3.33 adds the file requester to LOAD and SAVE
      57/       0 :                     ; Ver 3.32 adds the optional ELSE clause to IF .. THEN
      58/       0 :                     
      59/       0 :                     ;************************************************************************************
      60/       0 :                     ;
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 2 - 10/11/2023 21:18:52


      61/       0 :                     ; Version 3.25 adds the option to change the behaviour of INPUT so that a null
      62/       0 :                     ; response does not cause a program break. If this is the behaviour you want just
      63/       0 :                     ; change nobrk to some non zero value.
      64/       0 :                     
      65/       0 : =$0                 nobrk		EQU	0					; null response to INPUT causes a break
      66/       0 :                     
      67/       0 :                     
      68/       0 :                     ;************************************************************************************
      69/       0 :                     ;
      70/       0 :                     ; Version 3.xx replaces the fixed RAM addressing from previous versions with a RAM
      71/       0 :                     ; pointer in a3. this means that this could now be run as a task on a multitasking
      72/       0 :                     ; system where memory resources may change.
      73/       0 :                     
      74/       0 :                     
      75/       0 :                     ;************************************************************************************
      76/       0 :                     
      77/       0 :                     
      78/       0 :                     	CPU	68000
      79/       0 :                     	SUPMODE	ON
      80/       0 :                     
      81/       0 :                     	ORG	$00000000
      82/       0 :                     
      83/       0 :                     INIVEC:
      84/       0 :                     	;; 0-7
      85/       0 : 0000 8400           	DC.L	ram_addr+ram_base	; Reset: Initial SSP
      86/       4 : 0000 0106           	DC.L	code_start			; Reset: Initial PC
      87/       8 :                     
      88/       8 :                     
      89/       8 :                     	INCLUDE	"basic68k.inc"
(1)    1/       8 :                     
(1)    2/       8 :                     ; This lot is in RAM
(1)    3/       8 :                     
(1)    4/       0 :                         		ORG     $0000			; start of RAM
(1)    5/       0 :                      
(1)    6/       0 :                     ram_strt	ds.l	$100		; allow 1K for the stack, this should be plenty
(1)    7/     400 :                     								; for any BASIC program that doesn't do something
(1)    8/     400 :                     								; silly, it could even be much less.
(1)    9/     400 :                     ram_base
(1)   10/     400 :                     LAB_WARM	ds.w	1			; BASIC warm start entry point
(1)   11/     402 :                     Wrmjpv		ds.l	1			; BASIC warm start jump vector
(1)   12/     406 :                     
(1)   13/     406 :                     Usrjmp		ds.w	1			; USR function JMP address
(1)   14/     408 :                     Usrjpv		ds.l	1			; USR function JMP vector
(1)   15/     40C :                     
(1)   16/     40C :                     ; system dependant i/o vectors
(1)   17/     40C :                     ; these are in RAM and are set at start-up
(1)   18/     40C :                     
(1)   19/     40C :                     V_INPT		ds.w	1			; non halting scan input device entry point
(1)   20/     40E :                     V_INPTv		ds.l	1			; non halting scan input device jump vector
(1)   21/     412 :                     
(1)   22/     412 :                     V_OUTP		ds.w	1			; send byte to output device entry point
(1)   23/     414 :                     V_OUTPv		ds.l	1			; send byte to output device jump vector
(1)   24/     418 :                     
(1)   25/     418 :                     V_LOAD		ds.w	1			; load BASIC program entry point
(1)   26/     41A :                     V_LOADv		ds.l	1			; load BASIC program jump vector
(1)   27/     41E :                     
(1)   28/     41E :                     V_SAVE		ds.w	1			; save BASIC program entry point
(1)   29/     420 :                     V_SAVEv		ds.l	1			; save BASIC program jump vector
(1)   30/     424 :                     
(1)   31/     424 :                     V_CTLC		ds.w	1			; save CTRL-C check entry point
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm(basic68k.inc) - Page 3 - 10/11/2023 21:18:52


(1)   32/     426 :                     V_CTLCv		ds.l	1			; save CTRL-C check jump vector
(1)   33/     42A :                     
(1)   34/     42A :                     Itemp		ds.l	1			; temporary integer	(for GOTO etc)
(1)   35/     42E :                     
(1)   36/     42E :                     Smeml		ds.l	1			; start of memory		(start of program)
(1)   37/     432 :                     
(1)   38/     432 :                     ; the program is stored as a series of lines each line having the following format
(1)   39/     432 :                     ;
(1)   40/     432 :                     ;		ds.l	1			; pointer to the next line or $00000000 if [EOT]
(1)   41/     432 :                     ;		ds.l	1			; line number
(1)   42/     432 :                     ;		ds.b	n			; program bytes
(1)   43/     432 :                     ;		dc.b	$00			; [EOL] marker, there will be a second $00 byte, if
(1)   44/     432 :                     ;						; needed, to pad the line to an even number of bytes
(1)   45/     432 :                     
(1)   46/     432 :                     Sfncl		ds.l	1			; start of functions	(end of Program)
(1)   47/     436 :                     
(1)   48/     436 :                     ; the functions are stored as function name, function execute pointer and function
(1)   49/     436 :                     ; variable name
(1)   50/     436 :                     ;
(1)   51/     436 :                     ;		ds.l	1			; name
(1)   52/     436 :                     ;		ds.l	1			; execute pointer
(1)   53/     436 :                     ;		ds.l	1			; function variable
(1)   54/     436 :                     
(1)   55/     436 :                     Svarl		ds.l	1			; start of variables	(end of functions)
(1)   56/     43A :                     
(1)   57/     43A :                     ; the variables are stored as variable name, variable value
(1)   58/     43A :                     ;
(1)   59/     43A :                     ;		ds.l	1			; name
(1)   60/     43A :                     ;		ds.l	1			; packed float or integer value
(1)   61/     43A :                     
(1)   62/     43A :                     Sstrl		ds.l	1			; start of strings	(end of variables)
(1)   63/     43E :                     
(1)   64/     43E :                     ; the strings are stored as string name, string pointer and string length
(1)   65/     43E :                     ;
(1)   66/     43E :                     ;		ds.l	1			; name
(1)   67/     43E :                     ;		ds.l	1			; string pointer
(1)   68/     43E :                     ;		ds.w	1			; string length
(1)   69/     43E :                     
(1)   70/     43E :                     Sarryl		ds.l	1			; start of arrays		(end of strings)
(1)   71/     442 :                     
(1)   72/     442 :                     ; the arrays are stored as array name, array size, array dimensions count, array
(1)   73/     442 :                     ; dimensions upper bounds and array elements
(1)   74/     442 :                     ;
(1)   75/     442 :                     ;		ds.l	1			; name
(1)   76/     442 :                     ;		ds.l	1			; size including this header
(1)   77/     442 :                     ;		ds.w	1			; dimensions count
(1)   78/     442 :                     ;		ds.w	1			; 1st dimension upper bound
(1)   79/     442 :                     ;		ds.w	1			; 2nd dimension upper bound
(1)   80/     442 :                     ;		...				; ...
(1)   81/     442 :                     ;		ds.w	1			; nth dimension upper bound
(1)   82/     442 :                     ;
(1)   83/     442 :                     ; then (i1+1)*(i2+1)...*(in+1) of either ..
(1)   84/     442 :                     ;
(1)   85/     442 :                     ;		ds.l	1			; packed float or integer value
(1)   86/     442 :                     ;
(1)   87/     442 :                     ; .. if float or integer, or ..
(1)   88/     442 :                     ;
(1)   89/     442 :                     ;		ds.l	1			; string pointer
(1)   90/     442 :                     ;		ds.w	1			; string length
(1)   91/     442 :                     ;
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm(basic68k.inc) - Page 4 - 10/11/2023 21:18:52


(1)   92/     442 :                     ; .. if string
(1)   93/     442 :                     
(1)   94/     442 :                     Earryl		ds.l	1			; end of arrays		(start of free mem)
(1)   95/     446 :                     Sstorl		ds.l	1			; string storage		(moving down)
(1)   96/     44A :                     Ememl		ds.l	1			; end of memory		(upper bound of RAM)
(1)   97/     44E :                     Sutill		ds.l	1			; string utility ptr
(1)   98/     452 :                     Clinel		ds.l	1			; current line		(Basic line number)
(1)   99/     456 :                     Blinel		ds.l	1			; break line		(Basic line number)
(1)  100/     45A :                     
(1)  101/     45A :                     Cpntrl		ds.l	1			; continue pointer
(1)  102/     45E :                     Dlinel		ds.l	1			; current DATA line
(1)  103/     462 :                     Dptrl		ds.l	1			; DATA pointer
(1)  104/     466 :                     Rdptrl		ds.l	1			; read pointer
(1)  105/     46A :                     Varname		ds.l	1			; current var name
(1)  106/     46E :                     Cvaral		ds.l	1			; current var address
(1)  107/     472 :                     Lvarpl		ds.l	1			; variable pointer for LET and FOR/NEXT
(1)  108/     476 :                     
(1)  109/     476 :                     des_sk_e	ds.l	6			; descriptor stack end address
(1)  110/     48E :                     des_sk							; descriptor stack start address
(1)  111/     48E :                     								; use a4 for the descriptor pointer
(1)  112/     48E :                     			ds.w	1			
(1)  113/     490 :                     Ibuffs		ds.l	$40			; start of input buffer
(1)  114/     590 :                     Ibuffe
(1)  115/     590 :                     								; end of input buffer
(1)  116/     590 :                     
(1)  117/     590 :                     FAC1_m		ds.l	1			; FAC1 mantissa1
(1)  118/     594 :                     FAC1_e		ds.w	1			; FAC1 exponent
(1)  119/     596 : =$595               FAC1_s		EQU	FAC1_e+1		; FAC1 sign (b7)
(1)  120/     596 :                     			ds.w	1			
(1)  121/     598 :                     
(1)  122/     598 :                     FAC2_m		ds.l	1			; FAC2 mantissa1
(1)  123/     59C :                     FAC2_e		ds.l	1			; FAC2 exponent
(1)  124/     5A0 : =$59D               FAC2_s		EQU	FAC2_e+1		; FAC2 sign (b7)
(1)  125/     5A0 : =$59E               FAC_sc		EQU	FAC2_e+2		; FAC sign comparison, Acc#1 vs #2
(1)  126/     5A0 : =$59F               flag		EQU	FAC2_e+3		; flag byte for divide routine
(1)  127/     5A0 :                     
(1)  128/     5A0 :                     PRNlword	ds.l	1			; PRNG seed long word
(1)  129/     5A4 :                     
(1)  130/     5A4 :                     ut1_pl		ds.l	1			; utility pointer 1
(1)  131/     5A8 :                     
(1)  132/     5A8 :                     Asptl		ds.l	1			; array size/pointer
(1)  133/     5AC :                     Astrtl		ds.l	1			; array start pointer
(1)  134/     5B0 :                     
(1)  135/     5B0 : =$5AC               numexp		EQU	Astrtl			; string to float number exponent count
(1)  136/     5B0 : =$5AD               expcnt		EQU	Astrtl+1		; string to float exponent count
(1)  137/     5B0 :                     
(1)  138/     5B0 : =$5AF               expneg		EQU	Astrtl+3		; string to float eval exponent -ve flag
(1)  139/     5B0 :                     
(1)  140/     5B0 :                     func_l		ds.l	1			; function pointer
(1)  141/     5B4 :                     
(1)  142/     5B4 :                     
(1)  143/     5B4 :                     								; these two need to be a word aligned pair !
(1)  144/     5B4 :                     Defdim		ds.w	1			; default DIM flag
(1)  145/     5B6 : =$5B4               cosout		EQU	Defdim			; flag which CORDIC output (re-use byte)
(1)  146/     5B6 : =$5B5               Dtypef		EQU	Defdim+1		; data type flag, $80=string, $40=integer, $00=float
(1)  147/     5B6 :                     
(1)  148/     5B6 :                     
(1)  149/     5B6 :                     Binss		ds.l	4			; number to bin string start (32 chrs)
(1)  150/     5C6 :                     
(1)  151/     5C6 :                     Decss		ds.l	1			; number to decimal string start (16 chrs)
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm(basic68k.inc) - Page 5 - 10/11/2023 21:18:52


(1)  152/     5CA :                     			ds.w	1
(1)  153/     5CC :                     Usdss		ds.w	1			; unsigned decimal string start (10 chrs)
(1)  154/     5CE :                     
(1)  155/     5CE :                     Hexss		ds.l	2			; number to hex string start (8 chrs)
(1)  156/     5D6 :                     
(1)  157/     5D6 :                     BHsend		ds.w	1			; bin/decimal/hex string end
(1)  158/     5D8 :                     
(1)  159/     5D8 :                     
(1)  160/     5D8 :                     prstk		ds.b	1			; stacked function index
(1)  161/     5D9 :                     
(1)  162/     5D9 :                     tpower		ds.b	1			; remember CORDIC power
(1)  163/     5DA :                     
(1)  164/     5DA :                     Asrch		ds.b	1			; scan-between-quotes flag, alt search character
(1)  165/     5DB :                     
(1)  166/     5DB :                     Dimcnt		ds.b	1			; # of dimensions
(1)  167/     5DC :                     
(1)  168/     5DC :                     Breakf		ds.b	1			; break flag, $00=END else=break
(1)  169/     5DD :                     Oquote		ds.b	1			; open quote flag (Flag: DATA; LIST; memory)
(1)  170/     5DE :                     Gclctd		ds.b	1			; garbage collected flag
(1)  171/     5DF :                     Sufnxf		ds.b	1			; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
(1)  172/     5E0 :                     Imode		ds.b	1			; input mode flag, $00=INPUT, $98=READ
(1)  173/     5E1 :                     
(1)  174/     5E1 :                     Cflag		ds.b	1			; comparison evaluation flag
(1)  175/     5E2 :                     
(1)  176/     5E2 :                     TabSiz		ds.b	1			; TAB step size
(1)  177/     5E3 :                     
(1)  178/     5E3 :                     comp_f		ds.b	1			; compare function flag, bits 0,1 and 2 used
(1)  179/     5E4 :                     								; bit 2 set if >
(1)  180/     5E4 :                     								; bit 1 set if =
(1)  181/     5E4 :                     								; bit 0 set if <
(1)  182/     5E4 :                     
(1)  183/     5E4 :                     Nullct		ds.b	1			; nulls output after each line
(1)  184/     5E5 :                     TPos		ds.b	1			; BASIC terminal position byte
(1)  185/     5E6 :                     TWidth		ds.b	1			; BASIC terminal width byte
(1)  186/     5E7 :                     Iclim		ds.b	1			; input column limit
(1)  187/     5E8 :                     ccflag		ds.b	1			; CTRL-C check flag
(1)  188/     5E9 :                     ccbyte		ds.b	1			; CTRL-C last received byte
(1)  189/     5EA :                     ccnull		ds.b	1			; CTRL-C last received byte 'life' timer
(1)  190/     5EB :                     
(1)  191/     5EB :                     	ALIGN	2
(1)  192/     5EC :                     
(1)  193/     5EC :                     ; these variables for load/save routines
(1)  194/     5EC :                     
(1)  195/     5EC :                     ; ifne   FLASH_SUPPORT
(1)  196/     5EC :                     ;
(1)  197/     5EC :                     ;load_first      ds.b    1               ; Boolean indicating if first byte read
(1)  198/     5EC :                     ;load_filename   ds.b    13              ; Hold LOAD/SAVE filename (DOS 8.3 format plus terminating null)
(1)  199/     5EC :                     ;
(1)  200/     5EC :                     ; endc
(1)  201/     5EC :                     ;
(1)  202/     5EC :                     ;		even			; dummy even value and zero pad byte
(1)  203/     5EC :                     
(1)  204/     5EC :                     prg_strt
(1)  205/     5EC :                     
(1)  206/     5EC :                     ; Use these two lines when running from ROM
(1)  207/     5EC : =$8000              ram_addr	EQU	$08000		; RAM start address
(1)  208/     5EC : =$2000              ram_size	EQU	$02000		; RAM size
(1)  209/     5EC :                     
(1)  210/     5EC :                     ; Use these two lines when running from RAM
(1)  211/     5EC :                     ;ram_addr	EQU	$04000		; RAM start address
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm(basic68k.inc) - Page 6 - 10/11/2023 21:18:52


(1)  212/     5EC :                     ;ram_size	EQU	$04000		; RAM size
(1)  213/     5EC :                     
      90/     5EC :                     								; RAM offset definitions
      91/     5EC :                     
      92/     5EC :                     ; Use this value to run out of ROM
      93/     5EC :                     ;	ORG		$00C000				; past the vectors in a real system
      94/     5EC :                     ; Use this value to run out of RAM
      95/      C0 :                     	ORG		$0000c0				; past the vectors in a real system
      96/      C0 :                     
      97/      C0 : =$E001              ACIAC:	EQU	$0000E001
      98/      C0 : =$E000              ACIAD:	EQU	$0000E000
      99/      C0 :                     
     100/      C0 :                     ;************************************************************************************
     101/      C0 :                     ;
     102/      C0 :                     ; the following code is simulator specific, change to suit your system
     103/      C0 :                     ; Output character to the console from register d0.b
     104/      C0 :                     
     105/      C0 :                     VEC_OUT
     106/      C0 : 4840                	SWAP	D0
     107/      C2 :                     CO0:
     108/      C2 : 1039 0000 E001      	MOVE.B	ACIAC,D0
     109/      C8 : C03C 0002           	AND.B	#$02,D0
     110/      CC : 67F4                	BEQ	CO0
     111/      CE : 4840                	SWAP	D0
     112/      D0 : 13C0 0000 E000      	MOVE.B	D0,ACIAD
     113/      D6 : 4E75                	RTS
     114/      D8 :                     
     115/      D8 :                     ;************************************************************************************
     116/      D8 :                     ;
     117/      D8 :                     ; input a character from the console into register d0
     118/      D8 :                     ; else return Cb=0 if there's no character available
     119/      D8 :                     
     120/      D8 :                     VEC_IN
     121/      D8 : 1039 0000 E001      	MOVE.B	ACIAC,D0
     122/      DE : C03C 0001           	AND.B	#$01,D0
     123/      E2 : 6710                	BEQ     NOCHR
     124/      E4 : 1039 0000 E000      	MOVE.B	ACIAD,D0
     125/      EA : 0000 0000           	ORI.b	#$00,d0		; set z flag on received byte
     126/      EE : 003C 0001           	ORI.b	#1,CCR		; set carry, flag we got a byte
     127/      F2 : 4E75                	RTS
     128/      F4 :                     NOCHR
     129/      F4 : 0000 0000           	ORI.b   #$00,d0
     130/      F8 : 4E75                	RTS
     131/      FA :                     
     132/      FA :                     ;************************************************************************************
     133/      FA :                     ;
     134/      FA :                     ; LOAD routine for the TS2 computer (not implemented)
     135/      FA :                     
     136/      FA :                     VEC_LD
     137/      FA : 7E2E                       MOVEQ           #$2E,d7                        ; error code $2E "Not implemented" error
     138/      FC : 6000 0122                  BRA             LAB_XERR                       ; do error #d7, then warm start
     139/     100 :                     
     140/     100 :                     ;************************************************************************************
     141/     100 :                     ;
     142/     100 :                     ; SAVE routine for the TS2 computer (not implemented)
     143/     100 :                     
     144/     100 :                     VEC_SV
     145/     100 : 7E2E                       MOVEQ           #$2E,d7                        ; error code $2E "Not implemented" error
     146/     102 : 6000 011C                  BRA             LAB_XERR                       ; do error #d7, then warm start
     147/     106 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 7 - 10/11/2023 21:18:52


     148/     106 :                     
     149/     106 :                     ;************************************************************************************
     150/     106 :                     
     151/     106 :                     code_start
     152/     106 :                     ;                               ; Set up ACIA parameters
     153/     106 :                     ;        LEA.L   ACIA_1,A0      ; A0 points to console ACIA
     154/     106 :                     ;        MOVE.B  #$15,(A0)      ; Set up ACIA1 constants (no IRQ,
     155/     106 :                     ;                               ; RTS* low, 8 bit, no parity, 1 stop)
     156/     106 :                     ;        LEA.L   ACIA_2,A0      ; A0 points to aux. ACIA
     157/     106 :                     ;        MOVE.B  #$15,(A0)      ; Set up ACIA2 constants (no IRQ,
     158/     106 :                     ;                               ; RTS* low, 8 bit, no parity, 1 stop)
     159/     106 :                     
     160/     106 :                     ; to tell EhBASIC where and how much RAM it has pass the address in a0 and the size
     161/     106 :                     ; in d0. these values are at the end of the .inc file
     162/     106 :                     
     163/     106 : 207C 0000 8000      	MOVEA.l	#ram_addr,a0			; tell BASIC where RAM starts
     164/     10C : 203C 0000 2000      	MOVE.l	#ram_size,d0			; tell BASIC how big RAM is
     165/     112 :                     
     166/     112 :                     ; end of simulator specific code
     167/     112 :                     
     168/     112 :                     
     169/     112 :                     ;************************************************************************************
     170/     112 :                     ;************************************************************************************
     171/     112 :                     ;************************************************************************************
     172/     112 :                     ;************************************************************************************
     173/     112 :                     ;
     174/     112 :                     ; Register use :- (must improve this !!)
     175/     112 :                     ;
     176/     112 :                     ;	a6 -	temp Bpntr					; temporary BASIC execute pointer
     177/     112 :                     ;	a5 -	Bpntr						; BASIC execute (get byte) pointer
     178/     112 :                     ;	a4 -	des_sk				       ; descriptor stack pointer
     179/     112 :                     ;	a3 -	ram_strt					; start of RAM. all RAM references are offsets
     180/     112 :                     ;								; from this value
     181/     112 :                     ;
     182/     112 :                     
     183/     112 :                     ;************************************************************************************
     184/     112 :                     ;
     185/     112 :                     ; BASIC cold start entry point. assume entry with RAM address in a0 and RAM length
     186/     112 :                     ; in d0
     187/     112 :                     
     188/     112 :                     LAB_COLD
     189/     112 :                     ;	CMP.l		#$4000,d0			; compare size with 16k
     190/     112 :                     ;	BGE.s		LAB_sizok			; branch if >= 16k
     191/     112 :                     ;
     192/     112 :                     ;	MOVEQ	#5,d0					; error 5 - not enough RAM
     193/     112 :                     ;	move.b	#228,D7					; Go to TUTOR function
     194/     112 :                     ;	trap	#14						; Call TRAP14 handler
     195/     112 :                     ;
     196/     112 :                     ;LAB_sizok
     197/     112 : 2648                	MOVEA.l	a0,a3					; copy RAM base to a3
     198/     114 : D1C0                	ADDA.l	d0,a0					; a0 is top of RAM
     199/     116 : 2748 044A           	MOVE.l	a0,Ememl(a3)			; set end of mem
     200/     11A : 2E7C 0000 8400      	MOVE.l	#ram_addr+ram_base,sp	; set stack to RAM start + 1k
     201/     120 :                     
     202/     120 : 303C 4EF9           	MOVE.w	#$4EF9,d0				; JMP opcode
     203/     124 : 204F                	MOVEA.l	sp,a0					; point to start of vector table
     204/     126 :                     
     205/     126 : 30C0                	MOVE.w	d0,(a0)+				; LAB_WARM
     206/     128 : 43FA FFE8           	LEA		LAB_COLD(pc),a1			; initial warm start vector
     207/     12C : 20C9                	MOVE.l	a1,(a0)+				; set vector
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 8 - 10/11/2023 21:18:52


     208/     12E :                     
     209/     12E : 30C0                	MOVE.w	d0,(a0)+				; Usrjmp
     210/     130 : 43FA 00DC           	LEA		LAB_FCER(pc),a1			; initial user function vector
     211/     134 :                     									; "Function call" error
     212/     134 : 20C9                	MOVE.l	a1,(a0)+				; set vector
     213/     136 :                     
     214/     136 : 30C0                	MOVE.w	d0,(a0)+				; V_INPT JMP opcode
     215/     138 : 43FA FF9E           	LEA		VEC_IN(pc),a1			; get byte from input device vector
     216/     13C : 20C9                	MOVE.l	a1,(a0)+				; set vector
     217/     13E :                     
     218/     13E : 30C0                	MOVE.w	d0,(a0)+				; V_OUTP JMP opcode
     219/     140 : 43FA FF7E           	LEA		VEC_OUT(pc),a1			; send byte to output device vector
     220/     144 : 20C9                	MOVE.l	a1,(a0)+				; set vector
     221/     146 :                     
     222/     146 : 30C0                	MOVE.w	d0,(a0)+				; V_LOAD JMP opcode
     223/     148 : 43FA FFB0           	LEA		VEC_LD(pc),a1			; load BASIC program vector
     224/     14C : 20C9                	MOVE.l	a1,(a0)+				; set vector
     225/     14E :                     
     226/     14E : 30C0                	MOVE.w	d0,(a0)+				; V_SAVE JMP opcode
     227/     150 : 43FA FFAE           	LEA		VEC_SV(pc),a1			; save BASIC program vector
     228/     154 : 20C9                	MOVE.l	a1,(a0)+				; set vector
     229/     156 :                     
     230/     156 : 30C0                	MOVE.w	d0,(a0)+				; V_CTLC JMP opcode
     231/     158 : 43FA 2634           	LEA		VEC_CC(pc),a1			; save CTRL-C check vector
     232/     15C : 20C9                	MOVE.l	a1,(a0)+				; set vector
     233/     15E :                     
     234/     15E :                     ; set-up start values
     235/     15E :                     
     236/     15E :                     ;##LAB_GMEM
     237/     15E : 7000                	MOVEQ	#$00,d0					; clear d0
     238/     160 : 1740 05E4           	MOVE.b	d0,Nullct(a3)			; default NULL count
     239/     164 : 1740 05E5           	MOVE.b	d0,TPos(a3)				; clear terminal position
     240/     168 : 1740 05E8           	MOVE.b	d0,ccflag(a3)			; allow CTRL-C check
     241/     16C : 3740 05EA           	MOVE.w	d0,prg_strt-2(a3)			; clear start word
     242/     170 : 3740 05D6           	MOVE.w	d0,BHsend(a3)			; clear value to string end word
     243/     174 :                     
     244/     174 : 177C 0050 05E6      	MOVE.b	#$50,TWidth(a3)			; default terminal width byte for simulator
     245/     17A : 177C 000E 05E2      	MOVE.b	#$0E,TabSiz(a3)			; save default tab size = 14
     246/     180 :                     
     247/     180 : 177C 0038 05E7      	MOVE.b	#$38,Iclim(a3)			; default limit for TAB = 14 for simulator
     248/     186 :                     
     249/     186 : 49EB 048E           	LEA		des_sk(a3),a4			; set descriptor stack start
     250/     18A :                     
     251/     18A : 41EB 05EC           	LEA		prg_strt(a3),a0			; get start of mem
     252/     18E : 2748 042E           	MOVE.l	a0,Smeml(a3)			; save start of mem
     253/     192 :                     
     254/     192 : 6100 0322           	BSR		LAB_1463				; do "NEW" and "CLEAR"
     255/     196 : 6100 08A0           	BSR		LAB_CRLF				; print CR/LF
     256/     19A : 202B 044A           	MOVE.l	Ememl(a3),d0			; get end of mem
     257/     19E : 90AB 042E           	SUB.l		Smeml(a3),d0			; subtract start of mem
     258/     1A2 :                     
     259/     1A2 : 6100 1BDC           	BSR		LAB_295E				; print d0 as unsigned integer (bytes free)
     260/     1A6 : 41FA 3404           	LEA		LAB_SMSG(pc),a0			; point to start message
     261/     1AA : 6100 08EA           	BSR		LAB_18C3				; print null terminated string from memory
     262/     1AE :                     
     263/     1AE : 41FA 29E8           	LEA		LAB_RSED(pc),a0			; get pointer to value
     264/     1B2 : 6100 1A74           	BSR		LAB_UFAC				; unpack memory (a0) into FAC1
     265/     1B6 :                     
     266/     1B6 : 41FA 0092           	LEA		LAB_1274(pc),a0			; get warm start vector
     267/     1BA : 2748 0402           	MOVE.l	a0,Wrmjpv(a3)			; set warm start vector
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 9 - 10/11/2023 21:18:52


     268/     1BE : 6100 1FE6           	BSR		LAB_RND					; initialise
     269/     1C2 : 4EEB 0400           	JMP		LAB_WARM(a3)			; go do warm start
     270/     1C6 :                     
     271/     1C6 :                     
     272/     1C6 :                     ;************************************************************************************
     273/     1C6 :                     ;
     274/     1C6 :                     ; do format error
     275/     1C6 :                     
     276/     1C6 :                     LAB_FOER
     277/     1C6 : 7E2C                	MOVEQ		#$2C,d7				; error code $2C "Format" error
     278/     1C8 : 6056                	BRA.s		LAB_XERR				; do error #d7, then warm start
     279/     1CA :                     
     280/     1CA :                     
     281/     1CA :                     ;************************************************************************************
     282/     1CA :                     ;
     283/     1CA :                     ; do address error
     284/     1CA :                     
     285/     1CA :                     LAB_ADER
     286/     1CA : 7E2A                	MOVEQ		#$2A,d7				; error code $2A "Address" error
     287/     1CC : 6052                	BRA.s		LAB_XERR				; do error #d7, then warm start
     288/     1CE :                     
     289/     1CE :                     
     290/     1CE :                     ;************************************************************************************
     291/     1CE :                     ;
     292/     1CE :                     ; do wrong dimensions error
     293/     1CE :                     
     294/     1CE :                     LAB_WDER
     295/     1CE : 7E28                	MOVEQ		#$28,d7				; error code $28 "Wrong dimensions" error
     296/     1D0 : 604E                	BRA.s		LAB_XERR				; do error #d7, then warm start
     297/     1D2 :                     
     298/     1D2 :                     
     299/     1D2 :                     ;************************************************************************************
     300/     1D2 :                     ;
     301/     1D2 :                     ; do undimensioned array error
     302/     1D2 :                     
     303/     1D2 :                     LAB_UDER
     304/     1D2 : 7E26                	MOVEQ		#$26,d7				; error code $26 "undimensioned array" error
     305/     1D4 : 604A                	BRA.s		LAB_XERR				; do error #d7, then warm start
     306/     1D6 :                     
     307/     1D6 :                     
     308/     1D6 :                     ;************************************************************************************
     309/     1D6 :                     ;
     310/     1D6 :                     ; do undefined variable error
     311/     1D6 :                     
     312/     1D6 :                     LAB_UVER
     313/     1D6 :                     
     314/     1D6 : 7E24                	MOVEQ		#$24,d7				; error code $24 "undefined variable" error
     315/     1D8 : 6046                	BRA.s		LAB_XERR				; do error #d7, then warm start
     316/     1DA :                     
     317/     1DA :                     
     318/     1DA :                     ;************************************************************************************
     319/     1DA :                     ;
     320/     1DA :                     ; do loop without do error
     321/     1DA :                     
     322/     1DA :                     LAB_LDER
     323/     1DA : 7E22                	MOVEQ		#$22,d7				; error code $22 "LOOP without DO" error
     324/     1DC : 6042                	BRA.s		LAB_XERR				; do error #d7, then warm start
     325/     1DE :                     
     326/     1DE :                     
     327/     1DE :                     ;************************************************************************************
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 10 - 10/11/2023 21:18:52


     328/     1DE :                     ;
     329/     1DE :                     ; do undefined function error
     330/     1DE :                     
     331/     1DE :                     LAB_UFER
     332/     1DE : 7E20                	MOVEQ		#$20,d7				; error code $20 "Undefined function" error
     333/     1E0 : 603E                	BRA.s		LAB_XERR				; do error #d7, then warm start
     334/     1E2 :                     
     335/     1E2 :                     
     336/     1E2 :                     ;************************************************************************************
     337/     1E2 :                     ;
     338/     1E2 :                     ; do can't continue error
     339/     1E2 :                     
     340/     1E2 :                     LAB_CCER
     341/     1E2 : 7E1E                	MOVEQ		#$1E,d7				; error code $1E "Can't continue" error
     342/     1E4 : 603A                	BRA.s		LAB_XERR				; do error #d7, then warm start
     343/     1E6 :                     
     344/     1E6 :                     
     345/     1E6 :                     ;************************************************************************************
     346/     1E6 :                     ;
     347/     1E6 :                     ; do string too complex error
     348/     1E6 :                     
     349/     1E6 :                     LAB_SCER
     350/     1E6 : 7E1C                	MOVEQ		#$1C,d7				; error code $1C "String too complex" error
     351/     1E8 : 6036                	BRA.s		LAB_XERR				; do error #d7, then warm start
     352/     1EA :                     
     353/     1EA :                     
     354/     1EA :                     ;************************************************************************************
     355/     1EA :                     ;
     356/     1EA :                     ; do string too long error
     357/     1EA :                     
     358/     1EA :                     LAB_SLER
     359/     1EA : 7E1A                	MOVEQ		#$1A,d7				; error code $1A "String too long" error
     360/     1EC : 6032                	BRA.s		LAB_XERR				; do error #d7, then warm start
     361/     1EE :                     
     362/     1EE :                     
     363/     1EE :                     ;************************************************************************************
     364/     1EE :                     ;
     365/     1EE :                     ; do type missmatch error
     366/     1EE :                     
     367/     1EE :                     LAB_TMER
     368/     1EE : 7E18                	MOVEQ		#$18,d7				; error code $18 "Type mismatch" error
     369/     1F0 : 602E                	BRA.s		LAB_XERR				; do error #d7, then warm start
     370/     1F2 :                     
     371/     1F2 :                     
     372/     1F2 :                     ;************************************************************************************
     373/     1F2 :                     ;
     374/     1F2 :                     ; do illegal direct error
     375/     1F2 :                     
     376/     1F2 :                     LAB_IDER
     377/     1F2 : 7E16                	MOVEQ		#$16,d7				; error code $16 "Illegal direct" error
     378/     1F4 : 602A                	BRA.s		LAB_XERR				; do error #d7, then warm start
     379/     1F6 :                     
     380/     1F6 :                     
     381/     1F6 :                     ;************************************************************************************
     382/     1F6 :                     ;
     383/     1F6 :                     ; do divide by zero error
     384/     1F6 :                     
     385/     1F6 :                     LAB_DZER
     386/     1F6 : 7E14                	MOVEQ		#$14,d7				; error code $14 "Divide by zero" error
     387/     1F8 : 6026                	BRA.s		LAB_XERR				; do error #d7, then warm start
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 11 - 10/11/2023 21:18:52


     388/     1FA :                     
     389/     1FA :                     
     390/     1FA :                     ;************************************************************************************
     391/     1FA :                     ;
     392/     1FA :                     ; do double dimension error
     393/     1FA :                     
     394/     1FA :                     LAB_DDER
     395/     1FA : 7E12                	MOVEQ		#$12,d7				; error code $12 "Double dimension" error
     396/     1FC : 6022                	BRA.s		LAB_XERR				; do error #d7, then warm start
     397/     1FE :                     
     398/     1FE :                     
     399/     1FE :                     ;************************************************************************************
     400/     1FE :                     ;
     401/     1FE :                     ; do array bounds error
     402/     1FE :                     
     403/     1FE :                     LAB_ABER
     404/     1FE : 7E10                	MOVEQ		#$10,d7				; error code $10 "Array bounds" error
     405/     200 : 601E                	BRA.s		LAB_XERR				; do error #d7, then warm start
     406/     202 :                     
     407/     202 :                     
     408/     202 :                     ;************************************************************************************
     409/     202 :                     ;
     410/     202 :                     ; do undefined satement error
     411/     202 :                     
     412/     202 :                     LAB_USER
     413/     202 : 7E0E                	MOVEQ		#$0E,d7				; error code $0E "Undefined statement" error
     414/     204 : 601A                	BRA.s		LAB_XERR				; do error #d7, then warm start
     415/     206 :                     
     416/     206 :                     
     417/     206 :                     ;************************************************************************************
     418/     206 :                     ;
     419/     206 :                     ; do out of memory error
     420/     206 :                     
     421/     206 :                     LAB_OMER
     422/     206 : 7E0C                	MOVEQ		#$0C,d7				; error code $0C "Out of memory" error
     423/     208 : 6016                	BRA.s		LAB_XERR				; do error #d7, then warm start
     424/     20A :                     
     425/     20A :                     
     426/     20A :                     ;************************************************************************************
     427/     20A :                     ;
     428/     20A :                     ; do overflow error
     429/     20A :                     
     430/     20A :                     LAB_OFER
     431/     20A : 7E0A                	MOVEQ		#$0A,d7				; error code $0A "Overflow" error
     432/     20C : 6012                	BRA.s		LAB_XERR				; do error #d7, then warm start
     433/     20E :                     
     434/     20E :                     
     435/     20E :                     ;************************************************************************************
     436/     20E :                     ;
     437/     20E :                     ; do function call error
     438/     20E :                     
     439/     20E :                     LAB_FCER
     440/     20E : 7E08                	MOVEQ		#$08,d7				; error code $08 "Function call" error
     441/     210 : 600E                	BRA.s		LAB_XERR				; do error #d7, then warm start
     442/     212 :                     
     443/     212 :                     
     444/     212 :                     ;************************************************************************************
     445/     212 :                     ;
     446/     212 :                     ; do out of data error
     447/     212 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 12 - 10/11/2023 21:18:52


     448/     212 :                     LAB_ODER
     449/     212 : 7E06                	MOVEQ		#$06,d7				; error code $06 "Out of DATA" error
     450/     214 : 600A                	BRA.s		LAB_XERR				; do error #d7, then warm start
     451/     216 :                     
     452/     216 :                     
     453/     216 :                     ;************************************************************************************
     454/     216 :                     ;
     455/     216 :                     ; do return without gosub error
     456/     216 :                     
     457/     216 :                     LAB_RGER
     458/     216 : 7E04                	MOVEQ		#$04,d7				; error code $04 "RETURN without GOSUB" error
     459/     218 : 6006                	BRA.s		LAB_XERR				; do error #d7, then warm start
     460/     21A :                     
     461/     21A :                     
     462/     21A :                     ;************************************************************************************
     463/     21A :                     ;
     464/     21A :                     ; do syntax error
     465/     21A :                     
     466/     21A :                     LAB_SNER
     467/     21A : 7E02                	MOVEQ		#$02,d7				; error code $02 "Syntax" error
     468/     21C : 6002                	BRA.s		LAB_XERR				; do error #d7, then warm start
     469/     21E :                     
     470/     21E :                     
     471/     21E :                     ;************************************************************************************
     472/     21E :                     ;
     473/     21E :                     ; do next without for error
     474/     21E :                     
     475/     21E :                     LAB_NFER
     476/     21E : 7E00                	MOVEQ		#$00,d7				; error code $00 "NEXT without FOR" error
     477/     220 :                     
     478/     220 :                     
     479/     220 :                     ;************************************************************************************
     480/     220 :                     ;
     481/     220 :                     ; do error #d7, then warm start
     482/     220 :                     
     483/     220 :                     LAB_XERR
     484/     220 : 6100 02CA           	BSR		LAB_1491				; flush stack & clear continue flag
     485/     224 : 6100 0812           	BSR		LAB_CRLF				; print CR/LF
     486/     228 : 43FA 2FFA           	LEA		LAB_BAER(pc),a1			; start of error message pointer table
     487/     22C : 3E31 7000           	MOVE.w	(a1,d7.w),d7			; get error message offset
     488/     230 : 41F1 7000           	LEA		(a1,d7.w),a0			; get error message address
     489/     234 : 6100 0860           	BSR		LAB_18C3				; print null terminated string from memory
     490/     238 : 41FA 3335           	LEA		LAB_EMSG(pc),a0			; point to " Error" message
     491/     23C :                     LAB_1269
     492/     23C : 6100 0858           	BSR		LAB_18C3				; print null terminated string from memory
     493/     240 : 202B 0452           	MOVE.l	Clinel(a3),d0			; get current line
     494/     244 : 6B04                	BMI.s	LAB_1274				; go do warm start if -ve # (was immediate mode)
     495/     246 :                     
     496/     246 :                     									; else print line number
     497/     246 : 6100 1B2C           	BSR		LAB_2953				; print " in line [LINE #]"
     498/     24A :                     
     499/     24A :                     ; BASIC warm start entry point, wait for Basic command
     500/     24A :                     
     501/     24A :                     LAB_1274
     502/     24A : 41FA 3356           	LEA		LAB_RMSG(pc),a0			; point to "Ready" message
     503/     24E : 6100 0846           	BSR		LAB_18C3				; go do print string
     504/     252 :                     
     505/     252 :                     ; wait for Basic command - no "Ready"
     506/     252 :                     
     507/     252 :                     LAB_127D
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 13 - 10/11/2023 21:18:52


     508/     252 : 72FF                	MOVEQ	#-1,d1					; set to -1
     509/     254 : 2741 0452           	MOVE.l	d1,Clinel(a3)			; set current line #
     510/     258 : 1741 05DC           	MOVE.b	d1,Breakf(a3)			; set break flag
     511/     25C : 4BEB 0490           	LEA		Ibuffs(a3),a5			; set basic execute pointer ready for new line
     512/     260 :                     LAB_127E
     513/     260 : 6100 00EC           	BSR		LAB_1357				; call for BASIC input
     514/     264 : 6100 0BFC           	BSR		LAB_GBYT				; scan memory
     515/     268 : 67F6                	BEQ.s	LAB_127E				; loop while null
     516/     26A :                     
     517/     26A :                     ; got to interpret input line now ....
     518/     26A :                     
     519/     26A : 6508                	BCS.s	LAB_1295				; branch if numeric character, handle new
     520/     26C :                     								; BASIC line
     521/     26C :                     
     522/     26C :                     								; no line number so do immediate mode, a5
     523/     26C :                     								; points to the buffer start
     524/     26C : 6100 0156           	BSR		LAB_13A6				; crunch keywords into Basic tokens
     525/     270 :                     								; crunch from (a5), output to (a0)
     526/     270 :                     								; returns ..
     527/     270 :                     								; d2 is length, d1 trashed, d0 trashed,
     528/     270 :                     								; a1 trashed
     529/     270 : 6000 03C6           	BRA		LAB_15F6				; go scan & interpret code
     530/     274 :                     
     531/     274 :                     
     532/     274 :                     ;************************************************************************************
     533/     274 :                     ;
     534/     274 :                     ; handle a new BASIC line
     535/     274 :                     
     536/     274 :                     LAB_1295
     537/     274 : 6100 0640           	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
     538/     278 : 6100 014A           	BSR		LAB_13A6				; crunch keywords into Basic tokens
     539/     27C :                     								; crunch from (a5), output to (a0)
     540/     27C :                     								; returns .. d2 is length,
     541/     27C :                     								; d1 trashed, d0 trashed, a1 trashed
     542/     27C : 222B 042A           	MOVE.l	Itemp(a3),d1			; get required line #
     543/     280 : 6100 0218           	BSR		LAB_SSLN				; search BASIC for d1 line number
     544/     284 :                     								; returns pointer in a0
     545/     284 : 6532                	BCS.s		LAB_12E6				; branch if not found
     546/     286 :                     
     547/     286 :                     								; aroooogah! line # already exists! delete it
     548/     286 : 2250                	MOVEA.l	(a0),a1				; get start of block (next line pointer)
     549/     288 : 202B 0432           	MOVE.l	Sfncl(a3),d0			; get end of block (start of functions)
     550/     28C : 9089                	SUB.l		a1,d0					; subtract start of block ( = bytes to move)
     551/     28E : E288                	LSR.l		#1,d0					; /2 (word move)
     552/     290 : 5380                	SUBQ.l	#1,d0					; adjust for DBF loop
     553/     292 : 4840                	SWAP		d0					; swap high word to low word
     554/     294 : 2448                	MOVEA.l	a0,a2					; copy destination
     555/     296 :                     LAB_12AE
     556/     296 : 4840                	SWAP		d0					; swap high word to low word
     557/     298 :                     LAB_12B0
     558/     298 : 34D9                	MOVE.w	(a1)+,(a2)+				; copy word
     559/     29A : 51C8 FFFC           	DBF		d0,LAB_12B0				; decrement low count and loop until done
     560/     29E :                     
     561/     29E : 4840                	SWAP		d0					; swap high word to low word
     562/     2A0 : 51C8 FFF4           	DBF		d0,LAB_12AE				; decrement high count and loop until done
     563/     2A4 :                     
     564/     2A4 : 274A 0432           	MOVE.l	a2,Sfncl(a3)			; start of functions
     565/     2A8 : 274A 0436           	MOVE.l	a2,Svarl(a3)			; save start of variables
     566/     2AC : 274A 043A           	MOVE.l	a2,Sstrl(a3)			; start of strings
     567/     2B0 : 274A 043E           	MOVE.l	a2,Sarryl(a3)			; save start of arrays
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 14 - 10/11/2023 21:18:52


     568/     2B4 : 274A 0442           	MOVE.l	a2,Earryl(a3)			; save end of arrays
     569/     2B8 :                     
     570/     2B8 :                     								; got new line in buffer and no existing same #
     571/     2B8 :                     LAB_12E6
     572/     2B8 : 102B 0490           	MOVE.b	Ibuffs(a3),d0			; get byte from start of input buffer
     573/     2BC : 6764                	BEQ.s		LAB_1325				; if null line go do line chaining
     574/     2BE :                     
     575/     2BE :                     								; got new line and it isn't empty line
     576/     2BE : 226B 0432           	MOVEA.l	Sfncl(a3),a1			; get start of functions (end of block to move)
     577/     2C2 : 45F1 2008           	LEA		8(a1,d2),a2				; copy it, add line length and add room for
     578/     2C6 :                     								; pointer and line number
     579/     2C6 :                     
     580/     2C6 : 274A 0432           	MOVE.l	a2,Sfncl(a3)			; start of functions
     581/     2CA : 274A 0436           	MOVE.l	a2,Svarl(a3)			; save start of variables
     582/     2CE : 274A 043A           	MOVE.l	a2,Sstrl(a3)			; start of strings
     583/     2D2 : 274A 043E           	MOVE.l	a2,Sarryl(a3)			; save start of arrays
     584/     2D6 : 274A 0442           	MOVE.l	a2,Earryl(a3)			; save end of arrays
     585/     2DA : 276B 044A 0446      	MOVE.l	Ememl(a3),Sstorl(a3)		; copy end of mem to start of strings, clear
     586/     2E0 :                     								; strings
     587/     2E0 :                     
     588/     2E0 : 2209                	MOVE.l	a1,d1					; copy end of block to move
     589/     2E2 : 9288                	SUB.l		a0,d1					; subtract start of block to move
     590/     2E4 : E289                	LSR.l		#1,d1					; /2 (word copy)
     591/     2E6 : 5381                	SUBQ.l	#1,d1					; correct for loop end on -1
     592/     2E8 : 4841                	SWAP		d1					; swap high word to low word
     593/     2EA :                     LAB_12FF
     594/     2EA : 4841                	SWAP		d1					; swap high word to low word
     595/     2EC :                     LAB_1301
     596/     2EC : 3521                	MOVE.w	-(a1),-(a2)				; decrement pointers and copy word
     597/     2EE : 51C9 FFFC           	DBF		d1,LAB_1301				; decrement & loop
     598/     2F2 :                     
     599/     2F2 : 4841                	SWAP		d1					; swap high word to low word
     600/     2F4 : 51C9 FFF4           	DBF		d1,LAB_12FF				; decrement high count and loop until done
     601/     2F8 :                     
     602/     2F8 :                     ; space is opened up, now copy the crunched line from the input buffer into the space
     603/     2F8 :                     
     604/     2F8 : 43EB 0490           	LEA		Ibuffs(a3),a1			; source is input buffer
     605/     2FC : 2448                	MOVEA.l	a0,a2					; copy destination
     606/     2FE : 72FF                	MOVEQ		#-1,d1				; set to allow re-chaining
     607/     300 : 24C1                	MOVE.l	d1,(a2)+				; set next line pointer (allow re-chaining)
     608/     302 : 24EB 042A           	MOVE.l	Itemp(a3),(a2)+			; save line number
     609/     306 : E24A                	LSR.w		#1,d2					; /2 (word copy)
     610/     308 : 5342                	SUBQ.w	#1,d2					; correct for loop end on -1
     611/     30A :                     LAB_1303
     612/     30A : 34D9                	MOVE.w	(a1)+,(a2)+				; copy word
     613/     30C : 51CA FFFC           	DBF		d2,LAB_1303				; decrement & loop
     614/     310 :                     
     615/     310 : 6010                	BRA.s		LAB_1325				; go test for end of prog
     616/     312 :                     
     617/     312 :                     ; rebuild chaining of BASIC lines
     618/     312 :                     
     619/     312 :                     LAB_132E
     620/     312 : 5048                	ADDQ.w	#8,a0					; point to first code byte of line, there is
     621/     314 :                     								; always 1 byte + [EOL] as null entries are
     622/     314 :                     								; deleted
     623/     314 :                     LAB_1330
     624/     314 : 4A18                	TST.b		(a0)+					; test byte	
     625/     316 : 66FC                	BNE.s		LAB_1330				; loop if not [EOL]
     626/     318 :                     
     627/     318 :                     								; was [EOL] so get next line start
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 15 - 10/11/2023 21:18:52


     628/     318 : 3208                	MOVE.w	a0,d1					; past pad byte(s)
     629/     31A : 0241 0001           	ANDI.w	#1,d1					; mask odd bit
     630/     31E : D0C1                	ADD.w		d1,a0					; add back to ensure even
     631/     320 : 2288                	MOVE.l	a0,(a1)				; save next line pointer to current line
     632/     322 :                     LAB_1325
     633/     322 : 2248                	MOVEA.l	a0,a1					; copy pointer for this line
     634/     324 : 4A90                	TST.l		(a0)					; test pointer to next line
     635/     326 : 66EA                	BNE.s		LAB_132E				; not end of program yet so we must
     636/     328 :                     								; go and fix the pointers
     637/     328 :                     
     638/     328 : 6100 0198           	BSR		LAB_1477				; reset execution to start, clear variables
     639/     32C :                     								; and flush stack
     640/     32C : 6000 FF24           	BRA		LAB_127D				; now we just wait for Basic command, no "Ready"
     641/     330 :                     
     642/     330 :                     
     643/     330 :                     ;************************************************************************************
     644/     330 :                     ;
     645/     330 :                     ; receive a line from the keyboard
     646/     330 :                     								; character $08 as delete key, BACKSPACE on
     647/     330 :                     								; standard keyboard
     648/     330 :                     LAB_134B
     649/     330 : 6100 077E           	BSR		LAB_PRNA				; go print the character
     650/     334 : 7020                	MOVEQ		#' ',d0				; load [SPACE]
     651/     336 : 6100 0778           	BSR		LAB_PRNA				; go print
     652/     33A : 7008                	MOVEQ		#$08,d0				; load [BACKSPACE]
     653/     33C : 6100 0772           	BSR		LAB_PRNA				; go print
     654/     340 : 5341                	SUBQ.w	#$01,d1				; decrement the buffer index (delete)
     655/     342 : 6010                	BRA.s		LAB_1359				; re-enter loop
     656/     344 :                     
     657/     344 :                     ; print "? " and get BASIC input
     658/     344 :                     ; return a0 pointing to the buffer start
     659/     344 :                     
     660/     344 :                     LAB_INLN
     661/     344 : 6100 0768           	BSR		LAB_18E3				; print "?" character
     662/     348 : 7020                	MOVEQ		#' ',d0				; load " "
     663/     34A : 6100 0764           	BSR		LAB_PRNA				; go print
     664/     34E :                     
     665/     34E :                     ; call for BASIC input (main entry point)
     666/     34E :                     ; return a0 pointing to the buffer start
     667/     34E :                     
     668/     34E :                     LAB_1357
     669/     34E : 7200                	MOVEQ		#$00,d1				; clear buffer index
     670/     350 : 41EB 0490           	LEA		Ibuffs(a3),a0			; set buffer base pointer
     671/     354 :                     LAB_1359
     672/     354 : 4EAB 040C           	JSR		V_INPT(a3)				; call scan input device
     673/     358 : 64FA                	BCC.s		LAB_1359				; loop if no byte
     674/     35A :                     
     675/     35A : 67F8                	BEQ.s		LAB_1359				; loop if null byte
     676/     35C :                     
     677/     35C : B03C 0007           	CMP.b		#$07,d0				; compare with [BELL]
     678/     360 : 6718                	BEQ.s		LAB_1378				; branch if [BELL]
     679/     362 :                     
     680/     362 : B03C 000D           	CMP.b		#$0D,d0				; compare with [CR]
     681/     366 : 6700 06CA           	BEQ		LAB_1866				; do CR/LF exit if [CR]
     682/     36A :                     
     683/     36A : 4A41                	TST.w		d1					; set flags on buffer index
     684/     36C : 6606                	BNE.s		LAB_1374				; branch if not empty
     685/     36E :                     
     686/     36E :                     ; the next two lines ignore any non printing character and [SPACE] if the input buffer
     687/     36E :                     ; is empty
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 16 - 10/11/2023 21:18:52


     688/     36E :                     
     689/     36E : B03C 0020           	CMP.b		#' ',d0				; compare with [SP]+1
     690/     372 : 63E0                	BLS.s		LAB_1359				; if < ignore character
     691/     374 :                     
     692/     374 :                     ;##	CMP.b		#' '+1,d0				; compare with [SP]+1
     693/     374 :                     ;##	BCS.s		LAB_1359				; if < ignore character
     694/     374 :                     
     695/     374 :                     LAB_1374
     696/     374 : B03C 0008           	CMP.b		#$08,d0				; compare with [BACKSPACE]
     697/     378 : 67B6                	BEQ.s		LAB_134B				; go delete last character
     698/     37A :                     
     699/     37A :                     LAB_1378
     700/     37A : B27C 00FF           	CMP.w		#(Ibuffe-Ibuffs-1),d1		; compare character count with max-1
     701/     37E : 640C                	BCC.s		LAB_138E				; skip store & do [BELL] if buffer full
     702/     380 :                     
     703/     380 : 1180 1000           	MOVE.b	d0,(a0,d1.w)			; else store in buffer
     704/     384 : 5241                	ADDQ.w	#$01,d1				; increment index
     705/     386 :                     LAB_137F
     706/     386 : 6100 0728           	BSR		LAB_PRNA				; go print the character
     707/     38A : 60C8                	BRA.s		LAB_1359				; always loop for next character
     708/     38C :                     
     709/     38C :                     ; announce buffer full
     710/     38C :                     
     711/     38C :                     LAB_138E
     712/     38C : 7007                	MOVEQ		#$07,d0				; [BELL] character into d0
     713/     38E : 60F6                	BRA.s		LAB_137F				; go print the [BELL] but ignore input character
     714/     390 :                     
     715/     390 :                     
     716/     390 :                     ;************************************************************************************
     717/     390 :                     ;
     718/     390 :                     ; copy a hex value without crunching
     719/     390 :                     
     720/     390 :                     LAB_1392
     721/     390 : 1180 2000           	MOVE.b	d0,(a0,d2.w)			; save the byte to the output
     722/     394 : 5242                	ADDQ.w	#1,d2					; increment the buffer save index
     723/     396 :                     
     724/     396 : 5241                	ADDQ.w	#1,d1					; increment the buffer read index
     725/     398 : 1035 1000           	MOVE.b	(a5,d1.w),d0			; get a byte from the input buffer
     726/     39C : 6700 0094           	BEQ		LAB_13EC				; if [EOL] go save it without crunching
     727/     3A0 :                     
     728/     3A0 : B03C 0020           	CMP.b		#' ',d0				; compare the character with " "
     729/     3A4 : 67EA                	BEQ.s		LAB_1392				; if [SPACE] just go save it and get another
     730/     3A6 :                     
     731/     3A6 : B03C 0030           	CMP.b		#'0',d0				; compare the character with "0"
     732/     3AA : 654A                	BCS.s		LAB_13C6				; if < "0" quit the hex save loop
     733/     3AC :                     
     734/     3AC : B03C 0039           	CMP.b		#'9',d0				; compare with "9"
     735/     3B0 : 63DE                	BLS.s		LAB_1392				; if it is "0" to "9" save it and get another
     736/     3B2 :                     
     737/     3B2 : 7ADF                	MOVEQ		#-33,d5				; mask xx0x xxxx, ASCII upper case
     738/     3B4 : CA00                	AND.b		d0,d5					; mask the character
     739/     3B6 :                     
     740/     3B6 : BA3C 0041           	CMP.b		#'A',d5				; compare with "A"
     741/     3BA : 6540                	BCS.s		LAB_13CC				; if < "A" quit the hex save loop
     742/     3BC :                     
     743/     3BC : BA3C 0046           	CMP.b		#'F',d5				; compare with "F"
     744/     3C0 : 63CE                	BLS.s		LAB_1392				; if it is "A" to "F" save it and get another
     745/     3C2 :                     
     746/     3C2 : 6038                	BRA.s		LAB_13CC				; else continue crunching
     747/     3C4 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 17 - 10/11/2023 21:18:52


     748/     3C4 :                     ; crunch keywords into Basic tokens
     749/     3C4 :                     ; crunch from (a5), output to (a0)
     750/     3C4 :                     ; returns ..
     751/     3C4 :                     ; d4 trashed
     752/     3C4 :                     ; d3 trashed
     753/     3C4 :                     ; d2 is length
     754/     3C4 :                     ; d1 trashed
     755/     3C4 :                     ; d0 trashed
     756/     3C4 :                     ; a1 trashed
     757/     3C4 :                     
     758/     3C4 :                     ; this is the improved BASIC crunch routine and is 10 to 100 times faster than the
     759/     3C4 :                     ; old list search
     760/     3C4 :                     
     761/     3C4 :                     LAB_13A6
     762/     3C4 : 7200                	MOVEQ		#0,d1					; clear the read index
     763/     3C6 : 2401                	MOVE.l	d1,d2					; clear the save index
     764/     3C8 : 1741 05DD           	MOVE.b	d1,Oquote(a3)			; clear the open quote/DATA flag
     765/     3CC :                     LAB_13AC
     766/     3CC : 7000                	MOVEQ		#0,d0					; clear word
     767/     3CE : 1035 1000           	MOVE.b	(a5,d1.w),d0			; get byte from input buffer
     768/     3D2 : 675E                	BEQ.s		LAB_13EC				; if null save byte then continue crunching
     769/     3D4 :                     
     770/     3D4 : B03C 005F           	CMP.b		#'_',d0				; compare with "_"
     771/     3D8 : 6458                	BCC.s		LAB_13EC				; if >= "_" save byte then continue crunching
     772/     3DA :                     
     773/     3DA : B03C 003C           	CMP.b		#'<',d0				; compare with "<"
     774/     3DE : 641C                	BCC.s		LAB_13CC				; if >= "<" go crunch
     775/     3E0 :                     
     776/     3E0 : B03C 0030           	CMP.b		#'0',d0				; compare with "0"
     777/     3E4 : 644C                	BCC.s		LAB_13EC				; if >= "0" save byte then continue crunching
     778/     3E6 :                     
     779/     3E6 : 1740 05DA           	MOVE.b	d0,Asrch(a3)			; save buffer byte as search character
     780/     3EA : B03C 0022           	CMP.b		#$22,d0				; is it quote character?
     781/     3EE : 6776                	BEQ.s		LAB_1410				; branch if so (copy quoted string)
     782/     3F0 :                     
     783/     3F0 : B03C 0024           	CMP.b		#'$',d0				; is it the hex value character?
     784/     3F4 : 679A                	BEQ.s		LAB_1392				; if so go copy a hex value
     785/     3F6 :                     
     786/     3F6 :                     LAB_13C6
     787/     3F6 : B03C 002A           	CMP.b		#'*',d0				; compare with "*"
     788/     3FA : 6536                	BCS.s		LAB_13EC				; if <= "*" save byte then continue crunching
     789/     3FC :                     
     790/     3FC :                     								; crunch rest
     791/     3FC :                     LAB_13CC
     792/     3FC : 082B 0006 05DD      	BTST.b	#6,Oquote(a3)			; test open quote/DATA token flag
     793/     402 : 662E                	BNE.s		LAB_13EC				; branch if b6 of Oquote set (was DATA)
     794/     404 :                     								; go save byte then continue crunching
     795/     404 :                     
     796/     404 : 903C 002A           	SUB.b		#$2A,d0				; normalise byte
     797/     408 : D040                	ADD.w		d0,d0					; *2 makes word offset (high byte=$00)
     798/     40A : 43FA 2C1A           	LEA		TAB_CHRT(pc),a1			; get keyword offset table address
     799/     40E : 3031 0000           	MOVE.w	(a1,d0.w),d0			; get offset into keyword table
     800/     412 : 6B6E                	BMI.s		LAB_141F				; branch if no keywords for character
     801/     414 :                     
     802/     414 : 43FA 2FA6           	LEA		TAB_STAR(pc),a1			; get keyword table address
     803/     418 : D2C0                	ADDA.w	d0,a1					; add keyword offset
     804/     41A : 76FF                	MOVEQ		#-1,d3				; clear index
     805/     41C : 3801                	MOVE.w	d1,d4					; copy read index
     806/     41E :                     LAB_13D6
     807/     41E : 5243                	ADDQ.w	#1,d3					; increment table index
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 18 - 10/11/2023 21:18:52


     808/     420 : 1031 3000           	MOVE.b	(a1,d3.w),d0			; get byte from table
     809/     424 :                     LAB_13D8
     810/     424 : 6B0A                	BMI.s		LAB_13EA				; branch if token, save token and continue
     811/     426 :                     								; crunching
     812/     426 :                     
     813/     426 : 5244                	ADDQ.w	#1,d4					; increment read index
     814/     428 : B035 4000           	CMP.b		(a5,d4.w),d0			; compare byte from input buffer
     815/     42C : 67F0                	BEQ.s		LAB_13D6				; loop if character match
     816/     42E :                     
     817/     42E : 6040                	BRA.s		LAB_1417				; branch if no match
     818/     430 :                     
     819/     430 :                     LAB_13EA
     820/     430 : 3204                	MOVE.w	d4,d1					; update read index
     821/     432 :                     LAB_13EC
     822/     432 : 1180 2000           	MOVE.b	d0,(a0,d2.w)			; save byte to output
     823/     436 : 5242                	ADDQ.w	#1,d2					; increment buffer save index
     824/     438 : 5241                	ADDQ.w	#1,d1					; increment buffer read index
     825/     43A : 4A00                	TST.b		d0					; set flags
     826/     43C : 674A                	BEQ.s		LAB_142A				; branch if was null [EOL]
     827/     43E :                     
     828/     43E :                     								; d0 holds token or byte here
     829/     43E : 903C 003A           	SUB.b		#$3A,d0				; subtract ":"
     830/     442 : 6706                	BEQ.s		LAB_13FF				; branch if it was ":" (is now $00)
     831/     444 :                     
     832/     444 :                     								; d0 now holds token-$3A
     833/     444 : B03C 0049           	CMP.b		#(TK_DATA-$3A),d0			; compare with DATA token - $3A
     834/     448 : 6604                	BNE.s		LAB_1401				; branch if not DATA
     835/     44A :                     
     836/     44A :                     								; token was : or DATA
     837/     44A :                     LAB_13FF
     838/     44A : 1740 05DD           	MOVE.b	d0,Oquote(a3)			; save token-$3A ($00 for ":", TK_DATA-$3A for
     839/     44E :                     								; DATA)
     840/     44E :                     LAB_1401
     841/     44E : 903C 0055           	SUB.b		#(TK_REM-$3A),d0			; subtract REM token offset
     842/     452 : 6600 FF78           	BNE		LAB_13AC				; If wasn't REM then go crunch rest of line
     843/     456 :                     
     844/     456 : 1740 05DA           	MOVE.b	d0,Asrch(a3)			; else was REM so set search for [EOL]
     845/     45A :                     
     846/     45A :                     								; loop for REM, "..." etc.
     847/     45A :                     LAB_1408
     848/     45A : 1035 1000           	MOVE.b	(a5,d1.w),d0			; get byte from input buffer
     849/     45E : 67D2                	BEQ.s		LAB_13EC				; branch if null [EOL]
     850/     460 :                     
     851/     460 : B02B 05DA           	CMP.b		Asrch(a3),d0			; compare with stored character
     852/     464 : 67CC                	BEQ.s		LAB_13EC				; branch if match (end quote, REM, :, or DATA)
     853/     466 :                     
     854/     466 :                     								; entry for copy string in quotes, don't crunch
     855/     466 :                     LAB_1410
     856/     466 : 1180 2000           	MOVE.b	d0,(a0,d2.w)			; save byte to output
     857/     46A : 5242                	ADDQ.w	#1,d2					; increment buffer save index
     858/     46C : 5241                	ADDQ.w	#1,d1					; increment buffer read index
     859/     46E : 60EA                	BRA.s		LAB_1408				; loop
     860/     470 :                     
     861/     470 :                     ; not found keyword this go so find the end of this word in the table
     862/     470 :                     
     863/     470 :                     LAB_1417
     864/     470 : 3801                	MOVE.w	d1,d4					; reset read pointer
     865/     472 :                     LAB_141B
     866/     472 : 5243                	ADDQ.w	#1,d3					; increment keyword table pointer, flag
     867/     474 :                     								; unchanged
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 19 - 10/11/2023 21:18:52


     868/     474 : 1031 3000           	MOVE.b	(a1,d3.w),d0			; get keyword table byte
     869/     478 : 6AF8                	BPL.s		LAB_141B				; if not end of keyword go do next byte
     870/     47A :                     
     871/     47A : 5243                	ADDQ.w	#1,d3					; increment keyword table pointer flag
     872/     47C :                     								; unchanged
     873/     47C : 1031 3000           	MOVE.b	(a1,d3.w),d0			; get keyword table byte
     874/     480 : 66A2                	BNE.s		LAB_13D8				; go test next word if not zero byte (table end)
     875/     482 :                     
     876/     482 :                     								; reached end of table with no match
     877/     482 :                     LAB_141F
     878/     482 : 1035 1000           	MOVE.b	(a5,d1.w),d0			; restore byte from input buffer
     879/     486 : 60AA                	BRA.s		LAB_13EC				; go save byte in output and continue crunching
     880/     488 :                     
     881/     488 :                     								; reached [EOL]
     882/     488 :                     LAB_142A
     883/     488 : 7000                	MOVEQ		#0,d0					; ensure longword clear
     884/     48A : 0102                	BTST		d0,d2					; test odd bit (fastest)
     885/     48C : 6706                	BEQ.s		LAB_142C				; branch if no bytes to fill
     886/     48E :                     
     887/     48E : 1180 2000           	MOVE.b	d0,(a0,d2.w)			; clear next byte
     888/     492 : 5242                	ADDQ.w	#1,d2					; increment buffer save index
     889/     494 :                     LAB_142C
     890/     494 : 2180 2000           	MOVE.l	d0,(a0,d2.w)			; clear next line pointer, EOT in immediate mode
     891/     498 : 4E75                	RTS
     892/     49A :                     
     893/     49A :                     
     894/     49A :                     ;************************************************************************************
     895/     49A :                     ;
     896/     49A :                     ; search Basic for d1 line number from start of mem
     897/     49A :                     
     898/     49A :                     LAB_SSLN
     899/     49A : 206B 042E           	MOVEA.l	Smeml(a3),a0			; get start of program mem
     900/     49E : 6002                	BRA.s		LAB_SCLN				; go search for required line from a0
     901/     4A0 :                     
     902/     4A0 :                     LAB_145F
     903/     4A0 : 2040                	MOVEA.l	d0,a0					; copy next line pointer
     904/     4A2 :                     
     905/     4A2 :                     ; search Basic for d1 line number from a0
     906/     4A2 :                     ; returns Cb=0 if found
     907/     4A2 :                     ; returns a0 pointer to found or next higher (not found) line
     908/     4A2 :                     
     909/     4A2 :                     LAB_SCLN
     910/     4A2 : 2018                	MOVE.l	(a0)+,d0				; get next line pointer and point to line #
     911/     4A4 : 6708                	BEQ.s		LAB_145E				; is end marker so we're done, do 'no line' exit
     912/     4A6 :                     
     913/     4A6 : B290                	CMP.l		(a0),d1				; compare this line # with required line #
     914/     4A8 : 6EF6                	BGT.s		LAB_145F				; loop if required # > this #
     915/     4AA :                     
     916/     4AA : 5948                	SUBQ.w	#4,a0					; adjust pointer, flags not changed
     917/     4AC : 4E75                	RTS
     918/     4AE :                     
     919/     4AE :                     LAB_145E
     920/     4AE : 5948                	SUBQ.w	#4,a0					; adjust pointer, flags not changed
     921/     4B0 : 5380                	SUBQ.l	#1,d0					; make end program found = -1, set carry
     922/     4B2 : 4E75                	RTS
     923/     4B4 :                     
     924/     4B4 :                     
     925/     4B4 :                     ;************************************************************************************
     926/     4B4 :                     ;
     927/     4B4 :                     ; perform NEW
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 20 - 10/11/2023 21:18:52


     928/     4B4 :                     
     929/     4B4 :                     LAB_NEW
     930/     4B4 : 664E                	BNE.s		RTS_005				; exit if not end of statement (do syntax error)
     931/     4B6 :                     
     932/     4B6 :                     LAB_1463
     933/     4B6 : 206B 042E           	MOVEA.l	Smeml(a3),a0			; point to start of program memory
     934/     4BA : 7000                	MOVEQ		#0,d0					; clear longword
     935/     4BC : 20C0                	MOVE.l	d0,(a0)+				; clear first line, next line pointer
     936/     4BE : 2748 0432           	MOVE.l	a0,Sfncl(a3)			; set start of functions
     937/     4C2 :                     
     938/     4C2 :                     ; reset execution to start, clear variables and flush stack
     939/     4C2 :                     
     940/     4C2 :                     LAB_1477
     941/     4C2 : 2A6B 042E           	MOVEA.l	Smeml(a3),a5			; reset BASIC execute pointer
     942/     4C6 : 534D                	SUBQ.w	#1,a5					; -1 (as end of previous line)
     943/     4C8 :                     
     944/     4C8 :                     ; "CLEAR" command gets here
     945/     4C8 :                     
     946/     4C8 :                     LAB_147A
     947/     4C8 : 276B 044A 0446      	MOVE.l	Ememl(a3),Sstorl(a3)		; save end of mem as bottom of string space
     948/     4CE : 202B 0432           	MOVE.l	Sfncl(a3),d0			; get start of functions
     949/     4D2 : 2740 0436           	MOVE.l	d0,Svarl(a3)			; start of variables
     950/     4D6 : 2740 043A           	MOVE.l	d0,Sstrl(a3)			; start of strings
     951/     4DA : 2740 043E           	MOVE.l	d0,Sarryl(a3)			; set start of arrays
     952/     4DE : 2740 0442           	MOVE.l	d0,Earryl(a3)			; set end of arrays
     953/     4E2 :                     LAB_1480
     954/     4E2 : 7000                	MOVEQ		#0,d0					; set Zb
     955/     4E4 : 1740 05EA           	MOVE.b	d0,ccnull(a3)			; clear get byte countdown
     956/     4E8 : 6100 01D0           	BSR		LAB_RESTORE				; perform RESTORE command
     957/     4EC :                     
     958/     4EC :                     ; flush stack & clear continue flag
     959/     4EC :                     
     960/     4EC :                     LAB_1491
     961/     4EC : 49EB 048E           	LEA		des_sk(a3),a4			; reset descriptor stack pointer
     962/     4F0 :                     
     963/     4F0 : 201F                	MOVE.l	(sp)+,d0				; pull return address
     964/     4F2 : 2E7C 0000 8400      	MOVE.l	#ram_addr+ram_base,sp	; set stack to RAM start + 1k, flush stack
     965/     4F8 : 2F00                	MOVE.l	d0,-(sp)				; restore return address
     966/     4FA :                     
     967/     4FA : 7000                	MOVEQ		#0,d0					; clear longword
     968/     4FC : 2740 045A           	MOVE.l	d0,Cpntrl(a3)			; clear continue pointer
     969/     500 : 1740 05DF           	MOVE.b	d0,Sufnxf(a3)			; clear subscript/FNX flag
     970/     504 :                     RTS_005
     971/     504 : 4E75                	RTS
     972/     506 :                     
     973/     506 :                     
     974/     506 :                     ;************************************************************************************
     975/     506 :                     ;
     976/     506 :                     ; perform CLEAR
     977/     506 :                     
     978/     506 :                     LAB_CLEAR
     979/     506 : 67C0                	BEQ.s		LAB_147A				; if no following byte go do "CLEAR"
     980/     508 :                     
     981/     508 : 4E75                	RTS							; was following byte (go do syntax error)
     982/     50A :                     
     983/     50A :                     
     984/     50A :                     ;************************************************************************************
     985/     50A :                     ;
     986/     50A :                     ; perform LIST [n][-m]
     987/     50A :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 21 - 10/11/2023 21:18:52


     988/     50A :                     LAB_LIST
     989/     50A : 6512                	BCS.s		LAB_14BD				; branch if next character numeric (LIST n...)
     990/     50C :                     
     991/     50C : 72FF                	MOVEQ		#-1,d1				; set end to $FFFFFFFF
     992/     50E : 2741 042A           	MOVE.l	d1,Itemp(a3)			; save to Itemp
     993/     512 :                     
     994/     512 : 7200                	MOVEQ		#0,d1					; set start to $00000000
     995/     514 : 4A00                	TST.b		d0					; test next byte
     996/     516 : 670A                	BEQ.s		LAB_14C0				; branch if next character [NULL] (LIST)
     997/     518 :                     
     998/     518 : B03C 00B3           	CMP.b		#TK_MINUS,d0			; compare with token for -
     999/     51C : 66E6                	BNE.s		RTS_005				; exit if not - (LIST -m)
    1000/     51E :                     
    1001/     51E :                     								; LIST [[n]-[m]] this sets the n, if present,
    1002/     51E :                     								; as the start and end
    1003/     51E :                     LAB_14BD
    1004/     51E : 6100 0396           	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
    1005/     522 :                     LAB_14C0
    1006/     522 : 6100 FF76           	BSR		LAB_SSLN				; search BASIC for d1 line number
    1007/     526 :                     								; (pointer in a0)
    1008/     526 : 6100 093A           	BSR		LAB_GBYT				; scan memory
    1009/     52A : 6716                	BEQ.s		LAB_14D4				; branch if no more characters
    1010/     52C :                     
    1011/     52C :                     								; this bit checks the - is present
    1012/     52C : B03C 00B3           	CMP.b		#TK_MINUS,d0			; compare with token for -
    1013/     530 : 66D2                	BNE.s		RTS_005				; return if not "-" (will be Syntax error)
    1014/     532 :                     
    1015/     532 : 72FF                	MOVEQ		#-1,d1				; set end to $FFFFFFFF
    1016/     534 : 2741 042A           	MOVE.l	d1,Itemp(a3)			; save Itemp
    1017/     538 :                     
    1018/     538 :                     								; LIST [n]-[m] the - was there so see if
    1019/     538 :                     								; there is an m to set as the end value
    1020/     538 : 6100 0926           	BSR		LAB_IGBY				; increment & scan memory
    1021/     53C : 6704                	BEQ.s		LAB_14D4				; branch if was [NULL] (LIST n-)
    1022/     53E :                     
    1023/     53E : 6100 0376           	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
    1024/     542 :                     LAB_14D4
    1025/     542 : 177C 0000 05DD      	MOVE.b	#$00,Oquote(a3)			; clear open quote flag
    1026/     548 : 6100 04EE           	BSR		LAB_CRLF				; print CR/LF
    1027/     54C : 2018                	MOVE.l	(a0)+,d0				; get next line pointer
    1028/     54E : 67B4                	BEQ.s		RTS_005				; if null all done so exit
    1029/     550 :                     
    1030/     550 : 2240                	MOVEA.l	d0,a1					; copy next line pointer
    1031/     552 : 6100 012C           	BSR		LAB_1629				; do CRTL-C check vector
    1032/     556 :                     
    1033/     556 : 2018                	MOVE.l	(a0)+,d0				; get this line #
    1034/     558 : B0AB 042A           	CMP.l		Itemp(a3),d0			; compare end line # with this line #
    1035/     55C : 62A6                	BHI.s		RTS_005				; if this line greater all done so exit
    1036/     55E :                     
    1037/     55E :                     LAB_14E2
    1038/     55E : 48E7 00C0           	MOVEM.l	a0-a1,-(sp)				; save registers
    1039/     562 : 6100 181C           	BSR		LAB_295E				; print d0 as unsigned integer
    1040/     566 : 4CDF 0300           	MOVEM.l	(sp)+,a0-a1				; restore registers
    1041/     56A : 7020                	MOVEQ		#$20,d0				; space is the next character
    1042/     56C :                     LAB_150C
    1043/     56C : 6100 0542           	BSR		LAB_PRNA				; go print the character
    1044/     570 : B03C 0022           	CMP.b		#$22,d0				; was it " character
    1045/     574 : 6606                	BNE.s		LAB_1519				; branch if not
    1046/     576 :                     
    1047/     576 :                     								; we're either entering or leaving quotes
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 22 - 10/11/2023 21:18:52


    1048/     576 : 0A2B 00FF 05DD      	EOR.b		#$FF,Oquote(a3)			; toggle open quote flag
    1049/     57C :                     LAB_1519
    1050/     57C : 1018                	MOVE.b	(a0)+,d0				; get byte and increment pointer
    1051/     57E : 6608                	BNE.s		LAB_152E				; branch if not [EOL] (go print)
    1052/     580 :                     
    1053/     580 :                     								; was [EOL]
    1054/     580 : 2049                	MOVEA.l	a1,a0					; copy next line pointer
    1055/     582 : 2008                	MOVE.l	a0,d0					; copy to set flags
    1056/     584 : 66BC                	BNE.s		LAB_14D4				; go do next line if not [EOT]
    1057/     586 :                     
    1058/     586 : 4E75                	RTS
    1059/     588 :                     
    1060/     588 :                     LAB_152E
    1061/     588 : 6AE2                	BPL.s		LAB_150C				; just go print it if not token byte
    1062/     58A :                     
    1063/     58A :                     								; else it was a token byte so maybe uncrunch it
    1064/     58A : 4A2B 05DD           	TST.b		Oquote(a3)				; test the open quote flag
    1065/     58E : 6BDC                	BMI.s		LAB_150C				; just go print character if open quote set
    1066/     590 :                     
    1067/     590 :                     								; else uncrunch BASIC token
    1068/     590 : 45FA 2AFE           	LEA		LAB_KEYT(pc),a2			; get keyword table address
    1069/     594 : 727F                	MOVEQ		#$7F,d1				; mask into d1
    1070/     596 : C200                	AND.b		d0,d1					; copy and mask token
    1071/     598 : E549                	LSL.w		#2,d1					; *4
    1072/     59A : 45F2 1000           	LEA		(a2,d1.w),a2			; get keyword entry address
    1073/     59E : 101A                	MOVE.b	(a2)+,d0				; get byte from keyword table
    1074/     5A0 : 6100 050E           	BSR		LAB_PRNA				; go print the first character
    1075/     5A4 : 7200                	MOVEQ		#0,d1					; clear d1
    1076/     5A6 : 121A                	MOVE.b	(a2)+,d1				; get remaining length byte from keyword table
    1077/     5A8 : 6BD2                	BMI.s		LAB_1519				; if -ve done so go get next byte
    1078/     5AA :                     
    1079/     5AA : 3012                	MOVE.w	(a2),d0				; get offset to rest
    1080/     5AC : 45FA 2E0E           	LEA		TAB_STAR(pc),a2			; get keyword table address
    1081/     5B0 : 45F2 0000           	LEA		(a2,d0.w),a2			; get address of rest
    1082/     5B4 :                     LAB_1540
    1083/     5B4 : 101A                	MOVE.b	(a2)+,d0				; get byte from keyword table
    1084/     5B6 : 6100 04F8           	BSR		LAB_PRNA				; go print the character
    1085/     5BA : 51C9 FFF8           	DBF		d1,LAB_1540				; decrement and loop if more to do
    1086/     5BE :                     
    1087/     5BE : 60BC                	BRA.s		LAB_1519				; go get next byte
    1088/     5C0 :                     
    1089/     5C0 :                     
    1090/     5C0 :                     ;************************************************************************************
    1091/     5C0 :                     ;
    1092/     5C0 :                     ; perform FOR
    1093/     5C0 :                     
    1094/     5C0 :                     LAB_FOR
    1095/     5C0 : 6100 0396           	BSR		LAB_LET				; go do LET
    1096/     5C4 :                     
    1097/     5C4 : 202B 0472           	MOVE.l	Lvarpl(a3),d0			; get the loop variable pointer
    1098/     5C8 : B0AB 043A           	CMP.l		Sstrl(a3),d0			; compare it with the end of vars memory
    1099/     5CC : 6C00 FC20           	BGE		LAB_TMER				; if greater go do type mismatch error
    1100/     5D0 :                     
    1101/     5D0 :                     ; test for not less than the start of variables memory if needed
    1102/     5D0 :                     ;
    1103/     5D0 :                     ;	CMP.l		Svarl(a3),d0			; compare it with the start of variables memory
    1104/     5D0 :                     ;	BLT		LAB_TMER				; if not variables memory do type mismatch error
    1105/     5D0 :                     
    1106/     5D0 :                     ;	MOVEQ		#28,d0				; we need 28 bytes !
    1107/     5D0 :                     ;	BSR.s		LAB_1212				; check room on stack for d0 bytes
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 23 - 10/11/2023 21:18:52


    1108/     5D0 :                     
    1109/     5D0 : 6100 0214           	BSR		LAB_SNBS				; scan for next BASIC statement ([:] or [EOL])
    1110/     5D4 :                     								; returns a0 as pointer to [:] or [EOL]
    1111/     5D4 : 2E88                	MOVE.l	a0,(sp)				; push onto stack (and dump the return address)
    1112/     5D6 : 2F2B 0452           	MOVE.l	Clinel(a3),-(sp)			; push current line onto stack
    1113/     5DA :                     
    1114/     5DA : 70AA                	MOVEQ		#TK_TO-$100,d0			; set "TO" token
    1115/     5DC : 6100 087A           	BSR		LAB_SCCA				; scan for CHR$(d0) else syntax error/warm start
    1116/     5E0 : 6100 0708           	BSR		LAB_CTNM				; check if source is numeric, else type mismatch
    1117/     5E4 : 1F2B 05B5           	MOVE.b	Dtypef(a3),-(sp)			; push the FOR variable data type onto stack
    1118/     5E8 : 6100 06FE           	BSR		LAB_EVNM				; evaluate expression and check is numeric else
    1119/     5EC :                     								; do type mismatch
    1120/     5EC :                     
    1121/     5EC : 2F2B 0590           	MOVE.l	FAC1_m(a3),-(sp)			; push TO value mantissa
    1122/     5F0 : 3F2B 0594           	MOVE.w	FAC1_e(a3),-(sp)			; push TO value exponent and sign
    1123/     5F4 :                     
    1124/     5F4 : 277C 8000 0000      	MOVE.l	#$80000000,FAC1_m(a3)		; set default STEP size mantissa
              5FA : 0590             
    1125/     5FC : 377C 8100 0594      	MOVE.w	#$8100,FAC1_e(a3)			; set default STEP size exponent and sign
    1126/     602 :                     
    1127/     602 : 6100 085E           	BSR		LAB_GBYT				; scan memory
    1128/     606 : B03C 00AF           	CMP.b		#TK_STEP,d0				; compare with STEP token
    1129/     60A : 6608                	BNE.s		LAB_15B3				; jump if not "STEP"
    1130/     60C :                     
    1131/     60C :                     								; was STEP token so ....
    1132/     60C : 6100 0852           	BSR		LAB_IGBY				; increment & scan memory
    1133/     610 : 6100 06D6           	BSR		LAB_EVNM				; evaluate expression & check is numeric
    1134/     614 :                     								; else do type mismatch
    1135/     614 :                     LAB_15B3
    1136/     614 : 2F2B 0590           	MOVE.l	FAC1_m(a3),-(sp)			; push STEP value mantissa
    1137/     618 : 3F2B 0594           	MOVE.w	FAC1_e(a3),-(sp)			; push STEP value exponent and sign
    1138/     61C :                     
    1139/     61C : 2F2B 0472           	MOVE.l	Lvarpl(a3),-(sp)			; push variable pointer for FOR/NEXT
    1140/     620 : 3F3C 0081           	MOVE.w	#TK_FOR,-(sp)			; push FOR token on stack
    1141/     624 :                     
    1142/     624 : 6018                	BRA.s		LAB_15C2				; go do interpreter inner loop
    1143/     626 :                     
    1144/     626 :                     LAB_15DC							; have reached [EOL]+1
    1145/     626 : 300D                	MOVE.w	a5,d0					; copy BASIC execute pointer
    1146/     628 : C07C 0001           	AND.w		#1,d0					; and make line start address even
    1147/     62C : DAC0                	ADD.w		d0,a5					; add to BASIC execute pointer
    1148/     62E : 201D                	MOVE.l	(a5)+,d0				; get next line pointer
    1149/     630 : 6700 FC18           	BEQ		LAB_1274				; if null go to immediate mode, no "BREAK"
    1150/     634 :                     								; message (was immediate or [EOT] marker)
    1151/     634 :                     
    1152/     634 : 275D 0452           	MOVE.l	(a5)+,Clinel(a3)			; save (new) current line #
    1153/     638 :                     LAB_15F6
    1154/     638 : 6100 0828           	BSR		LAB_GBYT				; get BASIC byte
    1155/     63C : 611A                	BSR.s		LAB_15FF				; go interpret BASIC code from (a5)
    1156/     63E :                     
    1157/     63E :                     ; interpreter inner loop (re)entry point
    1158/     63E :                     
    1159/     63E :                     LAB_15C2
    1160/     63E : 6140                	BSR.s		LAB_1629				; do CRTL-C check vector
    1161/     640 : 4A2B 0452           	TST.b		Clinel(a3)				; test current line #, is -ve for immediate mode
    1162/     644 : 6B04                	BMI.s		LAB_15D1				; branch if immediate mode
    1163/     646 :                     
    1164/     646 : 274D 045A           	MOVE.l	a5,Cpntrl(a3)			; save BASIC execute pointer as continue pointer
    1165/     64A :                     LAB_15D1
    1166/     64A : 101D                	MOVE.b	(a5)+,d0				; get this byte & increment pointer
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 24 - 10/11/2023 21:18:52


    1167/     64C : 67D8                	BEQ.s		LAB_15DC				; loop if [EOL]
    1168/     64E :                     
    1169/     64E : B03C 003A           	CMP.b		#$3A,d0				; compare with ":"
    1170/     652 : 67E4                	BEQ.s		LAB_15F6				; loop if was statement separator
    1171/     654 :                     
    1172/     654 : 6000 FBC4           	BRA		LAB_SNER				; else syntax error, then warm start
    1173/     658 :                     
    1174/     658 :                     
    1175/     658 :                     ;************************************************************************************
    1176/     658 :                     ;
    1177/     658 :                     ; interpret BASIC code from (a5)
    1178/     658 :                     
    1179/     658 :                     LAB_15FF
    1180/     658 : 6700 008C           	BEQ		RTS_006				; exit if zero [EOL]
    1181/     65C :                     
    1182/     65C :                     LAB_1602
    1183/     65C : 0A00 0080           	EORI.b	#$80,d0				; normalise token
    1184/     660 : 6B00 02F6           	BMI		LAB_LET				; if not token, go do implied LET
    1185/     664 :                     
    1186/     664 : B03C 0028           	CMP.b		#(TK_TAB-$80),d0			; compare normalised token with TAB
    1187/     668 : 6400 FBB0           	BCC		LAB_SNER				; branch if d0>=TAB, syntax error/warm start
    1188/     66C :                     								; only tokens before TAB can start a statement
    1189/     66C :                     
    1190/     66C : 4880                	EXT.w		d0					; byte to word (clear high byte)
    1191/     66E : D040                	ADD.w		d0,d0					; *2
    1192/     670 : 41FA 287C           	LEA		LAB_CTBL(pc),a0			; get vector table base address
    1193/     674 : 3030 0000           	MOVE.w	(a0,d0.w),d0			; get offset to vector
    1194/     678 : 4870 0000           	PEA		(a0,d0.w)				; push vector
    1195/     67C : 6000 07E2           	BRA		LAB_IGBY				; get following byte & execute vector
    1196/     680 :                     
    1197/     680 :                     
    1198/     680 :                     ;************************************************************************************
    1199/     680 :                     ;
    1200/     680 :                     ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
    1201/     680 :                     ; key press is detected.
    1202/     680 :                     
    1203/     680 :                     LAB_1629
    1204/     680 : 4EEB 0424           	JMP		V_CTLC(a3)				; ctrl c check vector
    1205/     684 :                     
    1206/     684 :                     ; if there was a key press it gets back here .....
    1207/     684 :                     
    1208/     684 :                     LAB_1636
    1209/     684 : B03C 0003           	CMP.b		#$03,d0				; compare with CTRL-C
    1210/     688 : 670C                	BEQ.s		LAB_163B				; STOP if was CTRL-C
    1211/     68A :                     
    1212/     68A :                     LAB_1639
    1213/     68A : 4E75                	RTS
    1214/     68C :                     
    1215/     68C :                     
    1216/     68C :                     ;************************************************************************************
    1217/     68C :                     ;
    1218/     68C :                     ; perform END
    1219/     68C :                     
    1220/     68C :                     LAB_END
    1221/     68C : 66FC                	BNE.s		LAB_1639				; exit if something follows STOP
    1222/     68E : 177C 0000 05DC      	MOVE.b	#0,Breakf(a3)			; clear break flag, indicate program end
    1223/     694 :                     
    1224/     694 :                     
    1225/     694 :                     ;************************************************************************************
    1226/     694 :                     ;
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 25 - 10/11/2023 21:18:52


    1227/     694 :                     ; perform STOP
    1228/     694 :                     
    1229/     694 :                     LAB_STOP
    1230/     694 : 66F4                	BNE.s		LAB_1639				; exit if something follows STOP
    1231/     696 :                     
    1232/     696 :                     LAB_163B
    1233/     696 : 43EB 0590           	LEA		Ibuffe(a3),a1			; get buffer end
    1234/     69A : BBC9                	CMPA.l	a1,a5					; compare execute address with buffer end
    1235/     69C : 650A                	BCS.s		LAB_164F				; branch if BASIC pointer is in buffer
    1236/     69E :                     								; can't continue in immediate mode
    1237/     69E :                     
    1238/     69E :                     								; else...
    1239/     69E : 274D 045A           	MOVE.l	a5,Cpntrl(a3)			; save BASIC execute pointer as continue pointer
    1240/     6A2 :                     LAB_1647
    1241/     6A2 : 276B 0452 0456      	MOVE.l	Clinel(a3),Blinel(a3)		; save break line
    1242/     6A8 :                     LAB_164F
    1243/     6A8 : 584F                	ADDQ.w	#4,sp					; dump return address, don't return to execute
    1244/     6AA :                     								; loop
    1245/     6AA : 102B 05DC           	MOVE.b	Breakf(a3),d0			; get break flag
    1246/     6AE : 6700 FB9A           	BEQ		LAB_1274				; go do warm start if was program end
    1247/     6B2 :                     
    1248/     6B2 : 41FA 2EB3           	LEA		LAB_BMSG(pc),a0			; point to "Break"
    1249/     6B6 : 6000 FB84           	BRA		LAB_1269				; print "Break" and do warm start
    1250/     6BA :                     
    1251/     6BA :                     
    1252/     6BA :                     ;************************************************************************************
    1253/     6BA :                     ;
    1254/     6BA :                     ; perform RESTORE
    1255/     6BA :                     
    1256/     6BA :                     LAB_RESTORE
    1257/     6BA : 206B 042E           	MOVEA.l	Smeml(a3),a0			; copy start of memory
    1258/     6BE : 6720                	BEQ.s		LAB_1624				; branch if next character null (RESTORE)
    1259/     6C0 :                     
    1260/     6C0 : 6100 01F4           	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
    1261/     6C4 : B2AB 0452           	CMP.l		Clinel(a3),d1			; compare current line # with required line #
    1262/     6C8 : 630E                	BLS.s		LAB_GSCH				; branch if >= (start search from beginning)
    1263/     6CA :                     
    1264/     6CA : 204D                	MOVEA.l	a5,a0					; copy BASIC execute pointer
    1265/     6CC :                     LAB_RESs
    1266/     6CC : 4A18                	TST.b		(a0)+					; test next byte & increment pointer
    1267/     6CE : 66FC                	BNE.s		LAB_RESs				; loop if not EOL
    1268/     6D0 :                     
    1269/     6D0 : 3008                	MOVE.w	a0,d0					; copy pointer
    1270/     6D2 : C07C 0001           	AND.w		#1,d0					; mask odd bit
    1271/     6D6 : D0C0                	ADD.w		d0,a0					; add pointer
    1272/     6D8 :                     								; search for line in Itemp from (a0)
    1273/     6D8 :                     LAB_GSCH
    1274/     6D8 : 6100 FDC8           	BSR		LAB_SCLN				; search for d1 line number from a0
    1275/     6DC :                     								; returns Cb=0 if found
    1276/     6DC : 6500 FB24           	BCS		LAB_USER				; go do "Undefined statement" error if not found
    1277/     6E0 :                     
    1278/     6E0 :                     LAB_1624
    1279/     6E0 : 4A20                	TST.b		-(a0)					; decrement pointer (faster)
    1280/     6E2 : 2748 0462           	MOVE.l	a0,Dptrl(a3)			; save DATA pointer
    1281/     6E6 :                     RTS_006
    1282/     6E6 : 4E75                	RTS
    1283/     6E8 :                     
    1284/     6E8 :                     
    1285/     6E8 :                     ;************************************************************************************
    1286/     6E8 :                     ;
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 26 - 10/11/2023 21:18:52


    1287/     6E8 :                     ; perform NULL
    1288/     6E8 :                     
    1289/     6E8 :                     LAB_NULL
    1290/     6E8 : 6100 10E2           	BSR		LAB_GTBY				; get byte parameter, result in d0 and Itemp
    1291/     6EC : 1740 05E4           	MOVE.b	d0,Nullct(a3)			; save new NULL count
    1292/     6F0 : 4E75                	RTS
    1293/     6F2 :                     
    1294/     6F2 :                     
    1295/     6F2 :                     ;************************************************************************************
    1296/     6F2 :                     ;
    1297/     6F2 :                     ; perform CONT
    1298/     6F2 :                     
    1299/     6F2 :                     LAB_CONT
    1300/     6F2 : 6600 FB26           	BNE		LAB_SNER				; if following byte exit to do syntax error
    1301/     6F6 :                     
    1302/     6F6 : 4A2B 0452           	TST.b		Clinel(a3)				; test current line #, is -ve for immediate mode
    1303/     6FA : 6A00 FAE6           	BPL		LAB_CCER				; if running go do can't continue error
    1304/     6FE :                     
    1305/     6FE : 202B 045A           	MOVE.l	Cpntrl(a3),d0			; get continue pointer
    1306/     702 : 6700 FADE           	BEQ		LAB_CCER				; go do can't continue error if we can't
    1307/     706 :                     
    1308/     706 :                     								; we can continue so ...
    1309/     706 : 2A40                	MOVEA.l	d0,a5					; save continue pointer as BASIC execute pointer
    1310/     708 : 276B 0456 0452      	MOVE.l	Blinel(a3),Clinel(a3)		; set break line as current line
    1311/     70E : 4E75                	RTS
    1312/     710 :                     
    1313/     710 :                     
    1314/     710 :                     ;************************************************************************************
    1315/     710 :                     ;
    1316/     710 :                     ; perform RUN
    1317/     710 :                     
    1318/     710 :                     LAB_RUN
    1319/     710 : 660C                	BNE.s		LAB_RUNn				; if following byte do RUN n
    1320/     712 :                     
    1321/     712 : 6100 FDAE           	BSR		LAB_1477				; execution to start, clear vars & flush stack
    1322/     716 : 274D 045A           	MOVE.l	a5,Cpntrl(a3)			; save as continue pointer
    1323/     71A : 6000 FF22           	BRA		LAB_15C2				; go do interpreter inner loop
    1324/     71E :                     								; (can't RTS, we flushed the stack!)
    1325/     71E :                     
    1326/     71E :                     LAB_RUNn
    1327/     71E : 6100 FDA8           	BSR		LAB_147A				; go do "CLEAR"
    1328/     722 : 601C                	BRA.s		LAB_16B0				; get n and do GOTO n
    1329/     724 :                     
    1330/     724 :                     
    1331/     724 :                     ;************************************************************************************
    1332/     724 :                     ;
    1333/     724 :                     ; perform DO
    1334/     724 :                     
    1335/     724 :                     LAB_DO
    1336/     724 :                     ;	MOVE.l	#$05,d0				; need 5 bytes for DO
    1337/     724 :                     ;	BSR.s		LAB_1212				; check room on stack for A bytes
    1338/     724 : 2F0D                	MOVE.l	a5,-(sp)				; push BASIC execute pointer on stack
    1339/     726 : 2F2B 0452           	MOVE.l	Clinel(a3),-(sp)			; push current line on stack
    1340/     72A : 3F3C 009C           	MOVE.w	#TK_DO,-(sp)			; push token for DO on stack
    1341/     72E : 487A FF0E           	PEA		LAB_15C2(pc)			; set return address
    1342/     732 : 6000 072E           	BRA		LAB_GBYT				; scan memory & return to interpreter inner loop
    1343/     736 :                     
    1344/     736 :                     
    1345/     736 :                     ;************************************************************************************
    1346/     736 :                     ;
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 27 - 10/11/2023 21:18:52


    1347/     736 :                     ; perform GOSUB
    1348/     736 :                     
    1349/     736 :                     LAB_GOSUB
    1350/     736 :                     ;	MOVE.l	#10,d0				; need 10 bytes for GOSUB
    1351/     736 :                     ;	BSR.s		LAB_1212				; check room on stack for d0 bytes
    1352/     736 : 2F0D                	MOVE.l	a5,-(sp)				; push BASIC execute pointer
    1353/     738 : 2F2B 0452           	MOVE.l	Clinel(a3),-(sp)			; push current line
    1354/     73C : 3F3C 008D           	MOVE.w	#TK_GOSUB,-(sp)			; push token for GOSUB
    1355/     740 :                     LAB_16B0
    1356/     740 : 6100 0720           	BSR		LAB_GBYT				; scan memory
    1357/     744 : 487A FEF8           	PEA		LAB_15C2(pc)			; return to interpreter inner loop after GOTO n
    1358/     748 :                     
    1359/     748 :                     ; this PEA is needed because either we just cleared the stack and have nowhere to return
    1360/     748 :                     ; to or, in the case of GOSUB, we have just dropped a load on the stack and the address
    1361/     748 :                     ; we whould have returned to is buried. This burried return address will be unstacked by
    1362/     748 :                     ; the corresponding RETURN command
    1363/     748 :                     
    1364/     748 :                     
    1365/     748 :                     ;************************************************************************************
    1366/     748 :                     ;
    1367/     748 :                     ; perform GOTO
    1368/     748 :                     
    1369/     748 :                     LAB_GOTO
    1370/     748 : 6100 016C           	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
    1371/     74C : 206B 042E           	MOVEA.l	Smeml(a3),a0			; get start of memory
    1372/     750 : B2AB 0452           	CMP.l		Clinel(a3),d1			; compare current line with wanted #
    1373/     754 : 630E                	BLS.s		LAB_16D0				; branch if current # => wanted #
    1374/     756 :                     
    1375/     756 : 204D                	MOVEA.l	a5,a0					; copy BASIC execute pointer
    1376/     758 :                     LAB_GOTs
    1377/     758 : 4A18                	TST.b		(a0)+					; test next byte & increment pointer
    1378/     75A : 66FC                	BNE.s		LAB_GOTs				; loop if not EOL
    1379/     75C :                     
    1380/     75C : 3008                	MOVE.w	a0,d0					; past pad byte(s)
    1381/     75E : C07C 0001           	AND.w		#1,d0					; mask odd bit
    1382/     762 : D0C0                	ADD.w		d0,a0					; add to pointer
    1383/     764 :                     
    1384/     764 :                     LAB_16D0
    1385/     764 : 6100 FD3C           	BSR		LAB_SCLN				; search for d1 line number from a0
    1386/     768 :                     								; returns Cb=0 if found
    1387/     768 : 6500 FA98           	BCS		LAB_USER				; if carry set go do "Undefined statement" error
    1388/     76C :                     
    1389/     76C : 2A48                	MOVEA.l	a0,a5					; copy to basic execute pointer
    1390/     76E : 534D                	SUBQ.w	#1,a5					; decrement pointer
    1391/     770 : 274D 045A           	MOVE.l	a5,Cpntrl(a3)			; save as continue pointer
    1392/     774 : 4E75                	RTS
    1393/     776 :                     
    1394/     776 :                     
    1395/     776 :                     ;************************************************************************************
    1396/     776 :                     ;
    1397/     776 :                     ; perform LOOP
    1398/     776 :                     
    1399/     776 :                     LAB_LOOP
    1400/     776 : 0C6F 009C 0004      	CMP.w		#TK_DO,4(sp)			; compare token on stack with DO token
    1401/     77C : 6600 FA5C           	BNE		LAB_LDER				; branch if no matching DO
    1402/     780 :                     
    1403/     780 : 1E00                	MOVE.b	d0,d7					; copy following token (byte)
    1404/     782 : 672E                	BEQ.s		LoopAlways				; if no following token loop forever
    1405/     784 :                     
    1406/     784 : BE3C 003A           	CMP.b		#':',d7				; compare with ":"
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 28 - 10/11/2023 21:18:52


    1407/     788 : 6728                	BEQ.s		LoopAlways				; if no following token loop forever
    1408/     78A :                     
    1409/     78A : 9E3C 00B0           	SUB.b		#TK_UNTIL,d7			; subtract token for UNTIL
    1410/     78E : 6708                	BEQ.s		DoRest				; branch if was UNTIL
    1411/     790 :                     
    1412/     790 : 5307                	SUBQ.b	#1,d7					; decrement result
    1413/     792 : 6600 FA86           	BNE		LAB_SNER				; if not WHILE go do syntax error & warm start
    1414/     796 :                     								; only if the token was WHILE will this fail
    1415/     796 :                     
    1416/     796 : 7EFF                	MOVEQ		#-1,d7				; set invert result longword
    1417/     798 :                     DoRest
    1418/     798 : 6100 06C6           	BSR		LAB_IGBY				; increment & scan memory
    1419/     79C : 6100 0562           	BSR		LAB_EVEX				; evaluate expression
    1420/     7A0 : 4A2B 0594           	TST.b		FAC1_e(a3)				; test FAC1 exponent
    1421/     7A4 : 6706                	BEQ.s		DoCmp					; if = 0 go do straight compare
    1422/     7A6 :                     
    1423/     7A6 : 177C 00FF 0594      	MOVE.b	#$FF,FAC1_e(a3)			; else set all bits
    1424/     7AC :                     DoCmp
    1425/     7AC : BF2B 0594           	EOR.b		d7,FAC1_e(a3)			; EOR with invert byte
    1426/     7B0 : 6614                	BNE.s		LoopDone				; if <> 0 clear stack & back to interpreter loop
    1427/     7B2 :                     
    1428/     7B2 :                     								; loop condition wasn't met so do it again
    1429/     7B2 :                     LoopAlways
    1430/     7B2 : 276F 0006 0452      	MOVE.l	6(sp),Clinel(a3)			; copy DO current line
    1431/     7B8 : 2A6F 000A           	MOVE.l	10(sp),a5				; save BASIC execute pointer
    1432/     7BC :                     
    1433/     7BC : 41FA FE80           	LEA		LAB_15C2(pc),a0			; get return address
    1434/     7C0 : 2E88                	MOVE.l	a0,(sp)				; dump the call to this routine and set the
    1435/     7C2 :                     								; return address
    1436/     7C2 : 6000 069E           	BRA		LAB_GBYT				; scan memory and return to interpreter inner
    1437/     7C6 :                     								; loop
    1438/     7C6 :                     
    1439/     7C6 :                     								; clear stack & back to interpreter loop
    1440/     7C6 :                     LoopDone
    1441/     7C6 : 4FEF 000E           	LEA		14(sp),sp				; dump structure and call from stack
    1442/     7CA : 6014                	BRA.s		LAB_DATA				; go perform DATA (find : or [EOL])
    1443/     7CC :                     
    1444/     7CC :                     
    1445/     7CC :                     ;************************************************************************************
    1446/     7CC :                     ;
    1447/     7CC :                     ; perform RETURN
    1448/     7CC :                     
    1449/     7CC :                     LAB_RETURN
    1450/     7CC : 6616                	BNE.s		RTS_007				; exit if following token to allow syntax error
    1451/     7CE :                     
    1452/     7CE : 0C6F 008D 0004      	CMP.w		#TK_GOSUB,4(sp)			; compare token from stack with GOSUB
    1453/     7D4 : 6600 FA40           	BNE		LAB_RGER				; do RETURN without GOSUB error if no matching
    1454/     7D8 :                     								; GOSUB
    1455/     7D8 :                     
    1456/     7D8 : 5C4F                	ADDQ.w	#6,sp					; dump calling address & token
    1457/     7DA : 275F 0452           	MOVE.l	(sp)+,Clinel(a3)			; pull current line
    1458/     7DE : 2A5F                	MOVE.l	(sp)+,a5				; pull BASIC execute pointer
    1459/     7E0 :                     								; now do perform "DATA" statement as we could be
    1460/     7E0 :                     								; returning into the middle of an ON <var> GOSUB
    1461/     7E0 :                     								; n,m,p,q line (the return address used by the
    1462/     7E0 :                     								; DATA statement is the one pushed before the
    1463/     7E0 :                     								; GOSUB was executed!)
    1464/     7E0 :                     
    1465/     7E0 :                     
    1466/     7E0 :                     ;************************************************************************************
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 29 - 10/11/2023 21:18:52


    1467/     7E0 :                     ;
    1468/     7E0 :                     ; perform DATA
    1469/     7E0 :                     
    1470/     7E0 :                     LAB_DATA
    1471/     7E0 : 6104                	BSR.s		LAB_SNBS				; scan for next BASIC statement ([:] or [EOL])
    1472/     7E2 :                     								; returns a0 as pointer to [:] or [EOL]
    1473/     7E2 : 2A48                	MOVEA.l	a0,a5					; skip rest of statement
    1474/     7E4 :                     RTS_007
    1475/     7E4 : 4E75                	RTS
    1476/     7E6 :                     
    1477/     7E6 :                     
    1478/     7E6 :                     ;************************************************************************************
    1479/     7E6 :                     ;
    1480/     7E6 :                     ; scan for next BASIC statement ([:] or [EOL])
    1481/     7E6 :                     ; returns a0 as pointer to [:] or [EOL]
    1482/     7E6 :                     
    1483/     7E6 :                     LAB_SNBS
    1484/     7E6 : 204D                	MOVEA.l	a5,a0					; copy BASIC execute pointer
    1485/     7E8 : 7222                	MOVEQ		#$22,d1				; set string quote character
    1486/     7EA : 743A                	MOVEQ		#$3A,d2				; set look for character = ":"
    1487/     7EC : 6008                	BRA.s		LAB_172D				; go do search
    1488/     7EE :                     
    1489/     7EE :                     LAB_172C
    1490/     7EE : B400                	CMP.b		d0,d2					; compare with ":"
    1491/     7F0 : 6708                	BEQ.s		RTS_007a				; exit if found
    1492/     7F2 :                     
    1493/     7F2 : B200                	CMP.b		d0,d1					; compare with '"'
    1494/     7F4 : 670C                	BEQ.s		LAB_1725				; if found go search for [EOL]
    1495/     7F6 :                     
    1496/     7F6 :                     LAB_172D
    1497/     7F6 : 1018                	MOVE.b	(a0)+,d0				; get next byte
    1498/     7F8 : 66F4                	BNE.s		LAB_172C				; loop if not null [EOL]
    1499/     7FA :                     
    1500/     7FA :                     RTS_007a
    1501/     7FA : 5348                	SUBQ.w	#1,a0					; correct pointer
    1502/     7FC : 4E75                	RTS
    1503/     7FE :                     
    1504/     7FE :                     LAB_1723
    1505/     7FE : B200                	CMP.b		d0,d1					; compare with '"'
    1506/     800 : 67F4                	BEQ.s		LAB_172D				; if found go search for ":" or [EOL]
    1507/     802 :                     
    1508/     802 :                     LAB_1725
    1509/     802 : 1018                	MOVE.b	(a0)+,d0				; get next byte
    1510/     804 : 66F8                	BNE.s		LAB_1723				; loop if not null [EOL]
    1511/     806 :                     
    1512/     806 : 60F2                	BRA.s		RTS_007a				; correct pointer & return
    1513/     808 :                     
    1514/     808 :                     
    1515/     808 :                     ;************************************************************************************
    1516/     808 :                     ;
    1517/     808 :                     ; perform IF
    1518/     808 :                     
    1519/     808 :                     LAB_IF
    1520/     808 : 6100 04F6           	BSR		LAB_EVEX				; evaluate expression
    1521/     80C : 6100 0654           	BSR		LAB_GBYT				; scan memory
    1522/     810 : B03C 00AD           	CMP.b		#TK_THEN,d0				; compare with THEN token
    1523/     814 : 6714                	BEQ.s		LAB_174B				; if it was THEN then continue
    1524/     816 :                     
    1525/     816 :                     								; wasn't IF .. THEN so must be IF .. GOTO
    1526/     816 : B03C 0089           	CMP.b		#TK_GOTO,d0				; compare with GOTO token
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 30 - 10/11/2023 21:18:52


    1527/     81A : 6600 F9FE           	BNE		LAB_SNER				; if not GOTO token do syntax error/warm start
    1528/     81E :                     
    1529/     81E :                     								; was GOTO so check for GOTO <n>
    1530/     81E : 204D                	MOVE.l	a5,a0					; save the execute pointer
    1531/     820 : 6100 063E           	BSR		LAB_IGBY				; scan memory, test for a numeric character
    1532/     824 : 2A48                	MOVE.l	a0,a5					; restore the execute pointer
    1533/     826 : 6400 F9F2           	BCC		LAB_SNER				; if not numeric do syntax error/warm start
    1534/     82A :                     
    1535/     82A :                     LAB_174B
    1536/     82A : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
    1537/     82E : 671E                	BEQ.s		LAB_174E				; if result was zero go look for an ELSE
    1538/     830 :                     
    1539/     830 : 6100 062E           	BSR		LAB_IGBY				; increment & scan memory
    1540/     834 : 6500 FF12           	BCS		LAB_GOTO				; if numeric do GOTO n
    1541/     838 :                     								; a GOTO <n> will never return to the IF
    1542/     838 :                     								; statement so there is no need to return
    1543/     838 :                     								; to this code
    1544/     838 :                     
    1545/     838 : B03C 008E           	CMP.b		#TK_RETURN,d0			; compare with RETURN token
    1546/     83C : 6700 FE1E           	BEQ		LAB_1602				; if RETURN then interpret BASIC code from (a5)
    1547/     840 :                     								; and don't return here
    1548/     840 :                     
    1549/     840 : 6100 FE16           	BSR		LAB_15FF				; else interpret BASIC code from (a5)
    1550/     844 :                     
    1551/     844 :                     ; the IF was executed and there may be a following ELSE so the code needs to return
    1552/     844 :                     ; here to check and ignore the ELSE if present
    1553/     844 :                     
    1554/     844 : 1015                	MOVE.b	(a5),d0				; get the next basic byte
    1555/     846 : B03C 00A9           	CMP.b		#TK_ELSE,d0				; compare it with the token for ELSE
    1556/     84A : 6794                	BEQ		LAB_DATA				; if ELSE ignore the following statement
    1557/     84C :                     
    1558/     84C :                     ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
    1559/     84C :                     ; following ELSE will, correctly, cause a syntax error
    1560/     84C :                     
    1561/     84C : 4E75                	RTS							; else return to interpreter inner loop
    1562/     84E :                     
    1563/     84E :                     ; perform ELSE after IF
    1564/     84E :                     
    1565/     84E :                     LAB_174E
    1566/     84E : 101D                	MOVE.b	(a5)+,d0				; faster increment past THEN
    1567/     850 : 163C 00A9           	MOVE.b		#TK_ELSE,d3				; set search for ELSE token
    1568/     854 : 183C 008B           	MOVE.b		#TK_IF,d4				; set search for IF token
    1569/     858 : 7A00                	MOVEQ		#0,d5					; clear the nesting depth
    1570/     85A :                     LAB_1750
    1571/     85A : 101D                	MOVE.b	(a5)+,d0				; get next BASIC byte & increment ptr
    1572/     85C : 6720                	BEQ.s		LAB_1754				; if EOL correct the pointer and return
    1573/     85E :                     
    1574/     85E : B004                	CMP.b		d4,d0					; compare with "IF" token
    1575/     860 : 6604                	BNE.s		LAB_1752				; skip if not nested IF
    1576/     862 :                     
    1577/     862 : 5245                	ADDQ.w	#1,d5					; else increment the nesting depth ..
    1578/     864 : 60F4                	BRA.s		LAB_1750				; .. and continue looking
    1579/     866 :                     
    1580/     866 :                     LAB_1752
    1581/     866 : B003                	CMP.b		d3,d0					; compare with ELSE token
    1582/     868 : 66F0                	BNE.s		LAB_1750				; if not ELSE continue looking
    1583/     86A :                     
    1584/     86A :                     LAB_1756
    1585/     86A : 51CD FFEE           	DBF		d5,LAB_1750				; loop if still nested
    1586/     86E :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 31 - 10/11/2023 21:18:52


    1587/     86E :                     ; found the matching ELSE, now do <{n|statement}>
    1588/     86E :                     
    1589/     86E : 6100 05F2           	BSR		LAB_GBYT				; scan memory
    1590/     872 : 6500 FED4           	BCS		LAB_GOTO				; if numeric do GOTO n
    1591/     876 :                     								; code will return to the interpreter loop
    1592/     876 :                     								; at the tail end of the GOTO <n>
    1593/     876 :                     
    1594/     876 : 6000 FDE0           	BRA		LAB_15FF				; else interpret BASIC code from (a5)
    1595/     87A :                     								; code will return to the interpreter loop
    1596/     87A :                     								; at the tail end of the <statement>
    1597/     87A :                     
    1598/     87A :                     
    1599/     87A :                     ;************************************************************************************
    1600/     87A :                     ;
    1601/     87A :                     ; perform REM, skip (rest of) line
    1602/     87A :                     
    1603/     87A :                     LAB_REM
    1604/     87A : 4A1D                	TST.b		(a5)+					; test byte & increment pointer
    1605/     87C : 66FC                	BNE.s		LAB_REM				; loop if not EOL
    1606/     87E :                     
    1607/     87E :                     LAB_1754
    1608/     87E : 534D                	SUBQ.w	#1,a5					; correct the execute pointer
    1609/     880 : 4E75                	RTS
    1610/     882 :                     
    1611/     882 :                     
    1612/     882 :                     ;************************************************************************************
    1613/     882 :                     ;
    1614/     882 :                     ; perform ON
    1615/     882 :                     
    1616/     882 :                     LAB_ON
    1617/     882 : 6100 0F48           	BSR		LAB_GTBY				; get byte parameter, result in d0 and Itemp
    1618/     886 : 1400                	MOVE.b	d0,d2					; copy byte
    1619/     888 : 6100 05D8           	BSR		LAB_GBYT				; restore BASIC byte
    1620/     88C : 3F00                	MOVE.w	d0,-(sp)				; push GOTO/GOSUB token
    1621/     88E : B03C 008D           	CMP.b		#TK_GOSUB,d0			; compare with GOSUB token
    1622/     892 : 6708                	BEQ.s		LAB_176C				; branch if GOSUB
    1623/     894 :                     
    1624/     894 : B03C 0089           	CMP.b		#TK_GOTO,d0				; compare with GOTO token
    1625/     898 : 6600 F980           	BNE		LAB_SNER				; if not GOTO do syntax error, then warm start
    1626/     89C :                     
    1627/     89C :                     ; next character was GOTO or GOSUB
    1628/     89C :                     
    1629/     89C :                     LAB_176C
    1630/     89C : 5302                	SUBQ.b	#1,d2					; decrement index (byte value)
    1631/     89E : 6606                	BNE.s		LAB_1773				; branch if not zero
    1632/     8A0 :                     
    1633/     8A0 : 301F                	MOVE.w	(sp)+,d0				; pull GOTO/GOSUB token
    1634/     8A2 : 6000 FDB8           	BRA		LAB_1602				; go execute it
    1635/     8A6 :                     
    1636/     8A6 :                     LAB_1773
    1637/     8A6 : 6100 05B8           	BSR		LAB_IGBY				; increment & scan memory
    1638/     8AA : 610A                	BSR.s		LAB_GFPN				; get fixed-point number into temp integer & d1
    1639/     8AC :                     								; (skip this n)
    1640/     8AC : B03C 002C           	CMP.b		#$2C,d0				; compare next character with ","
    1641/     8B0 : 67EA                	BEQ.s		LAB_176C				; loop if ","
    1642/     8B2 :                     
    1643/     8B2 : 301F                	MOVE.w	(sp)+,d0				; pull GOTO/GOSUB token (run out of options)
    1644/     8B4 : 4E75                	RTS							; and exit
    1645/     8B6 :                     
    1646/     8B6 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 32 - 10/11/2023 21:18:52


    1647/     8B6 :                     ;************************************************************************************
    1648/     8B6 :                     ;
    1649/     8B6 :                     ; get fixed-point number into temp integer & d1
    1650/     8B6 :                     ; interpret number from (a5), leave (a5) pointing to byte after #
    1651/     8B6 :                     
    1652/     8B6 :                     LAB_GFPN
    1653/     8B6 : 7200                	MOVEQ		#$00,d1				; clear integer register
    1654/     8B8 : 2001                	MOVE.l	d1,d0					; clear d0
    1655/     8BA : 6100 05A6           	BSR		LAB_GBYT				; scan memory, Cb=1 if "0"-"9", & get byte
    1656/     8BE : 642E                	BCC.s		LAB_1786				; return if carry clear, chr was not "0"-"9"
    1657/     8C0 :                     
    1658/     8C0 : 2F02                	MOVE.l	d2,-(sp)				; save d2
    1659/     8C2 :                     LAB_1785
    1660/     8C2 : 2401                	MOVE.l	d1,d2					; copy integer register
    1661/     8C4 : D281                	ADD.l		d1,d1					; *2
    1662/     8C6 : 6500 F952           	BCS		LAB_SNER				; if overflow do syntax error, then warm start
    1663/     8CA :                     
    1664/     8CA : D281                	ADD.l		d1,d1					; *4
    1665/     8CC : 6500 F94C           	BCS		LAB_SNER				; if overflow do syntax error, then warm start
    1666/     8D0 :                     
    1667/     8D0 : D282                	ADD.l		d2,d1					; *1 + *4
    1668/     8D2 : 6500 F946           	BCS		LAB_SNER				; if overflow do syntax error, then warm start
    1669/     8D6 :                     
    1670/     8D6 : D281                	ADD.l		d1,d1					; *10
    1671/     8D8 : 6500 F940           	BCS		LAB_SNER				; if overflow do syntax error, then warm start
    1672/     8DC :                     
    1673/     8DC : 903C 0030           	SUB.b		#$30,d0				; subtract $30 from byte
    1674/     8E0 : D280                	ADD.l		d0,d1					; add to integer register, the top 24 bits are
    1675/     8E2 :                     								; always clear
    1676/     8E2 : 6900 F936           	BVS		LAB_SNER				; if overflow do syntax error, then warm start
    1677/     8E6 :                     								; this makes the maximum line number 2147483647
    1678/     8E6 : 6100 0578           	BSR		LAB_IGBY				; increment & scan memory
    1679/     8EA : 65D6                	BCS.s		LAB_1785				; loop for next character if "0"-"9"
    1680/     8EC :                     
    1681/     8EC : 241F                	MOVE.l	(sp)+,d2				; restore d2
    1682/     8EE :                     LAB_1786
    1683/     8EE : 2741 042A           	MOVE.l	d1,Itemp(a3)			; save Itemp
    1684/     8F2 : 4E75                	RTS
    1685/     8F4 :                     
    1686/     8F4 :                     
    1687/     8F4 :                     ;************************************************************************************
    1688/     8F4 :                     ;
    1689/     8F4 :                     ; perform DEC
    1690/     8F4 :                     
    1691/     8F4 :                     LAB_DEC
    1692/     8F4 : 3F3C 8180           	MOVE.w	#$8180,-(sp)			; set -1 sign/exponent
    1693/     8F8 : 600A                	BRA.s		LAB_17B7				; go do DEC
    1694/     8FA :                     
    1695/     8FA :                     
    1696/     8FA :                     ;************************************************************************************
    1697/     8FA :                     ;
    1698/     8FA :                     ; perform INC
    1699/     8FA :                     
    1700/     8FA :                     LAB_INC
    1701/     8FA : 3F3C 8100           	MOVE.w	#$8100,-(sp)			; set 1 sign/exponent
    1702/     8FE : 6004                	BRA.s		LAB_17B7				; go do INC
    1703/     900 :                     
    1704/     900 :                     								; was "," so another INCR variable to do
    1705/     900 :                     LAB_17B8
    1706/     900 : 6100 055E           	BSR		LAB_IGBY				; increment and scan memory
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 33 - 10/11/2023 21:18:52


    1707/     904 :                     LAB_17B7
    1708/     904 : 6100 076C           	BSR		LAB_GVAR				; get variable address in a0
    1709/     908 :                     
    1710/     908 : 6732                	BEQ.s		LAB_INCT				; if variable not found skip the inc/dec
    1711/     90A : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
    1712/     90E :                     								; $00=float
    1713/     90E : 6B00 F8DE           	BMI		LAB_TMER				; if string do "Type mismatch" error/warm start
    1714/     912 :                     
    1715/     912 : 6636                	BNE.s		LAB_INCI				; go do integer INC/DEC
    1716/     914 :                     
    1717/     914 : 2748 0472           	MOVE.l	a0,Lvarpl(a3)			; save var address
    1718/     918 : 6100 130E           	BSR		LAB_UFAC				; unpack memory (a0) into FAC1
    1719/     91C : 277C 8000 0000      	MOVE.l	#$80000000,FAC2_m(a3)		; set FAC2 mantissa for 1
              922 : 0598             
    1720/     924 : 3017                	MOVE.w	(sp),d0				; move exponent & sign to d0
    1721/     926 : 3740 059C           	MOVE.w	d0,FAC2_e(a3)			; move exponent & sign to FAC2
    1722/     92A : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; make sign compare = FAC1 sign
    1723/     930 : B12B 059E           	EOR.b		d0,FAC_sc(a3)			; make sign compare (FAC1_s EOR FAC2_s)
    1724/     934 : 6100 100E           	BSR		LAB_ADD				; add FAC2 to FAC1
    1725/     938 : 6100 130A           	BSR		LAB_PFAC				; pack FAC1 into variable (Lvarpl)
    1726/     93C :                     LAB_INCT
    1727/     93C : 6100 0524           	BSR		LAB_GBYT				; scan memory
    1728/     940 : 0C00 002C           	CMPI.b	#$2C,d0				; compare with ","
    1729/     944 : 67BA                	BEQ.s		LAB_17B8				; continue if "," (another variable to do)
    1730/     946 :                     
    1731/     946 : 544F                	ADDQ.w	#2,sp					; else dump sign & exponent
    1732/     948 : 4E75                	RTS
    1733/     94A :                     
    1734/     94A :                     LAB_INCI
    1735/     94A : 4A2F 0001           	TST.b		1(sp)					; test sign
    1736/     94E : 6604                	BNE.s		LAB_DECI				; branch if DEC
    1737/     950 :                     
    1738/     950 : 5290                	ADDQ.l	#1,(a0)				; increment variable
    1739/     952 : 60E8                	BRA.s		LAB_INCT				; go scan for more
    1740/     954 :                     
    1741/     954 :                     LAB_DECI
    1742/     954 : 5390                	SUBQ.l	#1,(a0)				; decrement variable
    1743/     956 : 60E4                	BRA.s		LAB_INCT				; go scan for more
    1744/     958 :                     
    1745/     958 :                     
    1746/     958 :                     ;************************************************************************************
    1747/     958 :                     ;
    1748/     958 :                     ; perform LET
    1749/     958 :                     
    1750/     958 :                     LAB_LET
    1751/     958 : 6100 0714           	BSR		LAB_SVAR				; search for or create a variable
    1752/     95C :                     								; return the variable address in a0
    1753/     95C : 2748 0472           	MOVE.l	a0,Lvarpl(a3)			; save variable address
    1754/     960 : 1F2B 05B5           	MOVE.b	Dtypef(a3),-(sp)			; push var data type, $80=string, $40=integer,
    1755/     964 :                     								; $00=float
    1756/     964 : 70BD                	MOVEQ		#TK_EQUAL-$100,d0			; get = token
    1757/     966 : 6100 04F0           	BSR		LAB_SCCA				; scan for CHR$(d0), else do syntax error/warm
    1758/     96A :                     								; start
    1759/     96A : 6100 0394           	BSR		LAB_EVEX				; evaluate expression
    1760/     96E : 102B 05B5           	MOVE.b	Dtypef(a3),d0			; copy expression data type
    1761/     972 : 175F 05B5           	MOVE.b	(sp)+,Dtypef(a3)			; pop variable data type
    1762/     976 : E318                	ROL.b		#1,d0					; set carry if expression type = string
    1763/     978 : 6100 0372           	BSR		LAB_CKTM				; type match check, set C for string
    1764/     97C : 6700 12C6           	BEQ		LAB_PFAC				; if number pack FAC1 into variable Lvarpl & RET
    1765/     980 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 34 - 10/11/2023 21:18:52


    1766/     980 :                     ; string LET
    1767/     980 :                     
    1768/     980 :                     LAB_17D5
    1769/     980 : 246B 0472           	MOVEA.l	Lvarpl(a3),a2			; get pointer to variable
    1770/     984 :                     LAB_17D6
    1771/     984 : 206B 0590           	MOVEA.l	FAC1_m(a3),a0			; get descriptor pointer
    1772/     988 : 2250                	MOVEA.l	(a0),a1				; get string pointer
    1773/     98A : B3EB 0446           	CMP.l		Sstorl(a3),a1			; compare string memory start with string
    1774/     98E :                     								; pointer
    1775/     98E : 6516                	BCS.s		LAB_1811				; if it was in program memory assign the value
    1776/     990 :                     								; and exit
    1777/     990 :                     
    1778/     990 : B1EB 0432           	CMPA.l	Sfncl(a3),a0			; compare functions start with descriptor
    1779/     994 :                     								; pointer
    1780/     994 : 6510                	BCS.s		LAB_1811				; branch if >= (string is on stack)
    1781/     996 :                     
    1782/     996 :                     								; string is variable$ make space and copy string
    1783/     996 :                     LAB_1810
    1784/     996 : 7200                	MOVEQ		#0,d1					; clear length
    1785/     998 : 3228 0004           	MOVE.w	4(a0),d1				; get string length
    1786/     99C : 2050                	MOVEA.l	(a0),a0				; get string pointer
    1787/     99E : 6100 0B06           	BSR		LAB_20C9				; copy string
    1788/     9A2 : 206B 0590           	MOVEA.l	FAC1_m(a3),a0			; get descriptor pointer back
    1789/     9A6 :                     								; clean stack & assign value to string variable
    1790/     9A6 :                     LAB_1811
    1791/     9A6 : B9C8                	CMPA.l	a0,a4					; is string on the descriptor stack
    1792/     9A8 : 6602                	BNE.s		LAB_1813				; skip pop if not
    1793/     9AA :                     
    1794/     9AA : 5C4C                	ADDQ.w	#$06,a4				; else update stack pointer
    1795/     9AC :                     LAB_1813
    1796/     9AC : 24D8                	MOVE.l	(a0)+,(a2)+				; save pointer to variable
    1797/     9AE : 3490                	MOVE.w	(a0),(a2)				; save length to variable
    1798/     9B0 :                     RTS_008
    1799/     9B0 : 4E75                	RTS
    1800/     9B2 :                     
    1801/     9B2 :                     
    1802/     9B2 :                     ;************************************************************************************
    1803/     9B2 :                     ;
    1804/     9B2 :                     ; perform GET
    1805/     9B2 :                     
    1806/     9B2 :                     LAB_GET
    1807/     9B2 : 6100 06BA           	BSR		LAB_SVAR				; search for or create a variable
    1808/     9B6 :                     								; return the variable address in a0
    1809/     9B6 : 2748 0472           	MOVE.l	a0,Lvarpl(a3)			; save variable address as GET variable
    1810/     9BA : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
    1811/     9BE :                     								; $00=float
    1812/     9BE : 6B0C                	BMI.s		LAB_GETS				; go get string character
    1813/     9C0 :                     
    1814/     9C0 :                     								; was numeric get
    1815/     9C0 : 6100 1DF2           	BSR		INGET					; get input byte
    1816/     9C4 : 6100 09BC           	BSR		LAB_1FD0				; convert d0 to unsigned byte in FAC1
    1817/     9C8 : 6000 127A           	BRA		LAB_PFAC				; pack FAC1 into variable (Lvarpl) & return
    1818/     9CC :                     
    1819/     9CC :                     LAB_GETS
    1820/     9CC : 7200                	MOVEQ		#$00,d1				; assume no byte
    1821/     9CE : 2041                	MOVE.l	d1,a0					; assume null string
    1822/     9D0 : 6100 1DE2           	BSR		INGET					; get input byte
    1823/     9D4 : 6408                	BCC.s		LAB_NoSt				; branch if no byte received
    1824/     9D6 :                     
    1825/     9D6 : 7201                	MOVEQ		#$01,d1				; string is single byte
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 35 - 10/11/2023 21:18:52


    1826/     9D8 : 6100 0AFE           	BSR		LAB_2115				; make string space d1 bytes long
    1827/     9DC :                     								; return a0 = pointer, other registers unchanged
    1828/     9DC :                     
    1829/     9DC : 1080                	MOVE.b	d0,(a0)				; save byte in string (byte IS string!)
    1830/     9DE :                     LAB_NoSt
    1831/     9DE : 6100 0ADE           	BSR		LAB_RTST				; push string on descriptor stack
    1832/     9E2 :                     								; a0 = pointer, d1 = length
    1833/     9E2 :                     
    1834/     9E2 : 609C                	BRA.s		LAB_17D5				; do string LET & return
    1835/     9E4 :                     
    1836/     9E4 :                     
    1837/     9E4 :                     ;************************************************************************************
    1838/     9E4 :                     ;
    1839/     9E4 :                     ; PRINT
    1840/     9E4 :                     
    1841/     9E4 :                     LAB_1829
    1842/     9E4 : 6100 00B4           	BSR		LAB_18C6				; print string from stack
    1843/     9E8 :                     LAB_182C
    1844/     9E8 : 6100 0478           	BSR		LAB_GBYT				; scan memory
    1845/     9EC :                     
    1846/     9EC :                     ; perform PRINT
    1847/     9EC :                     
    1848/     9EC :                     LAB_PRINT
    1849/     9EC : 674A                	BEQ.s		LAB_CRLF				; if nothing following just print CR/LF
    1850/     9EE :                     
    1851/     9EE :                     LAB_1831
    1852/     9EE : B03C 00A8           	CMP.b		#TK_TAB,d0				; compare with TAB( token
    1853/     9F2 : 6764                	BEQ.s		LAB_18A2				; go do TAB/SPC
    1854/     9F4 :                     
    1855/     9F4 : B03C 00AC           	CMP.b		#TK_SPC,d0				; compare with SPC( token
    1856/     9F8 : 675E                	BEQ.s		LAB_18A2				; go do TAB/SPC
    1857/     9FA :                     
    1858/     9FA : B03C 002C           	CMP.b		#',',d0				; compare with ","
    1859/     9FE : 6740                	BEQ.s		LAB_188B				; go do move to next TAB mark
    1860/     A00 :                     
    1861/     A00 : B03C 003B           	CMP.b		#';',d0				; compare with ";"
    1862/     A04 : 6700 0086           	BEQ		LAB_18BD				; if ";" continue with PRINT processing
    1863/     A08 :                     
    1864/     A08 : 6100 02F6           	BSR		LAB_EVEX				; evaluate expression
    1865/     A0C : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
    1866/     A10 :                     								; $00=float
    1867/     A10 : 6BD2                	BMI.s		LAB_1829				; branch if string
    1868/     A12 :                     
    1869/     A12 :                     ; replace the two lines above with this code
    1870/     A12 :                     
    1871/     A12 :                     ;	MOVE.b	Dtypef(a3),d0			; get data type flag, $80=string, $00=numeric
    1872/     A12 :                     ;	BMI.s		LAB_1829				; branch if string
    1873/     A12 :                     
    1874/     A12 : 6100 13B2           	BSR		LAB_2970				; convert FAC1 to string
    1875/     A16 : 6100 0A60           	BSR		LAB_20AE				; print " terminated string to FAC1 stack
    1876/     A1A :                     
    1877/     A1A :                     ; don't check fit if terminal width byte is zero
    1878/     A1A :                     
    1879/     A1A : 7000                	MOVEQ		#0,d0					; clear d0
    1880/     A1C : 102B 05E6           	MOVE.b	TWidth(a3),d0			; get terminal width byte
    1881/     A20 : 670C                	BEQ.s		LAB_185E				; skip check if zero
    1882/     A22 :                     
    1883/     A22 : 902C 0007           	SUB.b		7(a4),d0				; subtract string length
    1884/     A26 : 902B 05E5           	SUB.b		TPos(a3),d0				; subtract terminal position
    1885/     A2A : 6402                	BCC		LAB_185E				; branch if less than terminal width
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 36 - 10/11/2023 21:18:52


    1886/     A2C :                     
    1887/     A2C : 610A                	BSR.s		LAB_CRLF				; else print CR/LF
    1888/     A2E :                     LAB_185E
    1889/     A2E : 616A                	BSR.s		LAB_18C6				; print string from stack
    1890/     A30 : 60B6                	BRA.s		LAB_182C				; always go continue processing line
    1891/     A32 :                     
    1892/     A32 :                     
    1893/     A32 :                     ;************************************************************************************
    1894/     A32 :                     ;
    1895/     A32 :                     ; CR/LF return to BASIC from BASIC input handler
    1896/     A32 :                     ; leaves a0 pointing to the buffer start
    1897/     A32 :                     
    1898/     A32 :                     LAB_1866
    1899/     A32 : 11BC 0000 1000      	MOVE.b	#$00,(a0,d1.w)			; null terminate input
    1900/     A38 :                     
    1901/     A38 :                     ; print CR/LF
    1902/     A38 :                     
    1903/     A38 :                     LAB_CRLF
    1904/     A38 : 700D                	MOVEQ		#$0D,d0				; load [CR]
    1905/     A3A : 6174                	BSR.s		LAB_PRNA				; go print the character
    1906/     A3C : 700A                	MOVEQ		#$0A,d0				; load [LF]
    1907/     A3E : 6070                	BRA.s		LAB_PRNA				; go print the character & return
    1908/     A40 :                     
    1909/     A40 :                     LAB_188B
    1910/     A40 : 142B 05E5           	MOVE.b	TPos(a3),d2				; get terminal position
    1911/     A44 : B42B 05E7           	CMP.b		Iclim(a3),d2			; compare with input column limit
    1912/     A48 : 6504                	BCS.s		LAB_1898				; branch if less than Iclim
    1913/     A4A :                     
    1914/     A4A : 61EC                	BSR.s		LAB_CRLF				; else print CR/LF (next line)
    1915/     A4C : 603E                	BRA.s		LAB_18BD				; continue with PRINT processing
    1916/     A4E :                     
    1917/     A4E :                     LAB_1898
    1918/     A4E : 942B 05E2           	SUB.b		TabSiz(a3),d2			; subtract TAB size
    1919/     A52 : 64FA                	BCC.s		LAB_1898				; loop if result was >= 0
    1920/     A54 :                     
    1921/     A54 : 4402                	NEG.b		d2					; twos complement it
    1922/     A56 : 6022                	BRA.s		LAB_18B7				; print d2 spaces
    1923/     A58 :                     
    1924/     A58 :                     								; do TAB/SPC
    1925/     A58 :                     LAB_18A2
    1926/     A58 : 3F00                	MOVE.w	d0,-(sp)				; save token
    1927/     A5A : 6100 0D6C           	BSR		LAB_SGBY				; increment and get byte, result in d0 and Itemp
    1928/     A5E : 3400                	MOVE.w	d0,d2					; copy byte
    1929/     A60 : 6100 0400           	BSR		LAB_GBYT				; get basic byte back
    1930/     A64 : B03C 0029           	CMP.b		#$29,d0				; is next character ")"
    1931/     A68 : 6600 F7B0           	BNE		LAB_SNER				; if not do syntax error, then warm start
    1932/     A6C :                     
    1933/     A6C : 301F                	MOVE.w	(sp)+,d0				; get token back
    1934/     A6E : B03C 00A8           	CMP.b		#TK_TAB,d0				; was it TAB ?
    1935/     A72 : 6606                	BNE.s		LAB_18B7				; branch if not (was SPC)
    1936/     A74 :                     
    1937/     A74 :                     								; calculate TAB offset
    1938/     A74 : 942B 05E5           	SUB.b		TPos(a3),d2				; subtract terminal position
    1939/     A78 : 6312                	BLS.s		LAB_18BD				; branch if result was <= 0
    1940/     A7A :                     								; can't TAB backwards or already there
    1941/     A7A :                     
    1942/     A7A :                     								; print d2.b spaces
    1943/     A7A :                     LAB_18B7
    1944/     A7A : 7000                	MOVEQ		#0,d0					; clear longword
    1945/     A7C : 5300                	SUBQ.b	#1,d0					; make d0 = $FF
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 37 - 10/11/2023 21:18:52


    1946/     A7E : C480                	AND.l		d0,d2					; mask for byte only
    1947/     A80 : 670A                	BEQ.s		LAB_18BD				; branch if zero
    1948/     A82 :                     
    1949/     A82 : 7020                	MOVEQ		#$20,d0				; load " "
    1950/     A84 : 5302                	SUBQ.b	#1,d2					; adjust for DBF loop
    1951/     A86 :                     LAB_18B8
    1952/     A86 : 6128                	BSR.s		LAB_PRNA				; go print
    1953/     A88 : 51CA FFFC           	DBF		d2,LAB_18B8				; decrement count and loop if not all done
    1954/     A8C :                     
    1955/     A8C :                     								; continue with PRINT processing
    1956/     A8C :                     LAB_18BD
    1957/     A8C : 6100 03D2           	BSR		LAB_IGBY				; increment & scan memory
    1958/     A90 : 6600 FF5C           	BNE		LAB_1831				; if byte continue executing PRINT
    1959/     A94 :                     
    1960/     A94 : 4E75                	RTS							; exit if nothing more to print
    1961/     A96 :                     
    1962/     A96 :                     
    1963/     A96 :                     ;************************************************************************************
    1964/     A96 :                     ;
    1965/     A96 :                     ; print null terminated string from a0
    1966/     A96 :                     
    1967/     A96 :                     LAB_18C3
    1968/     A96 : 6100 09E0           	BSR		LAB_20AE				; print terminated string to FAC1/stack
    1969/     A9A :                     
    1970/     A9A :                     ; print string from stack
    1971/     A9A :                     
    1972/     A9A :                     LAB_18C6
    1973/     A9A : 6100 0BD0           	BSR		LAB_22B6				; pop string off descriptor stack or from memory
    1974/     A9E :                     								; returns with d0 = length, a0 = pointer
    1975/     A9E : 670C                	BEQ.s		RTS_009				; exit (RTS) if null string
    1976/     AA0 :                     
    1977/     AA0 : 3200                	MOVE.w	d0,d1					; copy length & set Z flag
    1978/     AA2 : 5341                	SUBQ.w	#1,d1					; -1 for BF loop
    1979/     AA4 :                     LAB_18CD
    1980/     AA4 : 1018                	MOVE.b	(a0)+,d0				; get byte from string
    1981/     AA6 : 6108                	BSR.s		LAB_PRNA				; go print the character
    1982/     AA8 : 51C9 FFFA           	DBF		d1,LAB_18CD				; decrement count and loop if not done yet
    1983/     AAC :                     
    1984/     AAC :                     RTS_009
    1985/     AAC : 4E75                	RTS
    1986/     AAE :                     
    1987/     AAE :                     
    1988/     AAE :                     ;************************************************************************************
    1989/     AAE :                     ;
    1990/     AAE :                     ; print "?" character
    1991/     AAE :                     
    1992/     AAE :                     LAB_18E3
    1993/     AAE : 703F                	MOVEQ		#$3F,d0				; load "?" character
    1994/     AB0 :                     
    1995/     AB0 :                     
    1996/     AB0 :                     ;************************************************************************************
    1997/     AB0 :                     ;
    1998/     AB0 :                     ; print character in d0, includes the null handler and infinite line length code
    1999/     AB0 :                     ; changes no registers
    2000/     AB0 :                     
    2001/     AB0 :                     LAB_PRNA
    2002/     AB0 : 2F01                	MOVE.l	d1,-(sp)				; save d1
    2003/     AB2 : B03C 0020           	CMP.b		#$20,d0				; compare with " "
    2004/     AB6 : 6528                	BCS.s		LAB_18F9				; branch if less, non printing character
    2005/     AB8 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 38 - 10/11/2023 21:18:52


    2006/     AB8 :                     								; don't check fit if terminal width byte is zero
    2007/     AB8 : 122B 05E6           	MOVE.b	TWidth(a3),d1			; get terminal width
    2008/     ABC : 6610                	BNE.s		LAB_18F0				; branch if not zero (not infinite length)
    2009/     ABE :                     
    2010/     ABE :                     								; is "infinite line" so check TAB position
    2011/     ABE : 122B 05E5           	MOVE.b	TPos(a3),d1				; get position
    2012/     AC2 : 922B 05E2           	SUB.b		TabSiz(a3),d1			; subtract TAB size
    2013/     AC6 : 6614                	BNE.s		LAB_18F7				; skip reset if different
    2014/     AC8 :                     
    2015/     AC8 : 1741 05E5           	MOVE.b	d1,TPos(a3)				; else reset position
    2016/     ACC : 600E                	BRA.s		LAB_18F7				; go print character
    2017/     ACE :                     
    2018/     ACE :                     LAB_18F0
    2019/     ACE : B22B 05E5           	CMP.b		TPos(a3),d1				; compare with terminal character position
    2020/     AD2 : 6608                	BNE.s		LAB_18F7				; branch if not at end of line
    2021/     AD4 :                     
    2022/     AD4 : 2F00                	MOVE.l	d0,-(sp)				; save d0
    2023/     AD6 : 6100 FF60           	BSR		LAB_CRLF				; else print CR/LF
    2024/     ADA : 201F                	MOVE.l	(sp)+,d0				; restore d0
    2025/     ADC :                     LAB_18F7
    2026/     ADC : 522B 05E5           	ADDQ.b	#$01,TPos(a3)			; increment terminal position
    2027/     AE0 :                     LAB_18F9
    2028/     AE0 : 4EAB 0412           	JSR		V_OUTP(a3)				; output byte via output vector
    2029/     AE4 : B03C 000D           	CMP.b		#$0D,d0				; compare with [CR]
    2030/     AE8 : 6618                	BNE.s		LAB_188A				; branch if not [CR]
    2031/     AEA :                     
    2032/     AEA :                     								; else print nullct nulls after the [CR]
    2033/     AEA : 7200                	MOVEQ		#$00,d1				; clear d1
    2034/     AEC : 122B 05E4           	MOVE.b	Nullct(a3),d1			; get null count
    2035/     AF0 : 670C                	BEQ.s		LAB_1886				; branch if no nulls
    2036/     AF2 :                     
    2037/     AF2 : 7000                	MOVEQ		#$00,d0				; load [NULL]
    2038/     AF4 :                     LAB_1880
    2039/     AF4 : 4EAB 0412           	JSR		V_OUTP(a3)				; go print the character
    2040/     AF8 : 51C9 FFFA           	DBF		d1,LAB_1880				; decrement count and loop if not all done
    2041/     AFC :                     
    2042/     AFC : 700D                	MOVEQ		#$0D,d0				; restore the character
    2043/     AFE :                     LAB_1886
    2044/     AFE : 1741 05E5           	MOVE.b	d1,TPos(a3)				; clear terminal position
    2045/     B02 :                     LAB_188A
    2046/     B02 : 221F                	MOVE.l	(sp)+,d1				; restore d1
    2047/     B04 : 4E75                	RTS
    2048/     B06 :                     
    2049/     B06 :                     
    2050/     B06 :                     ;************************************************************************************
    2051/     B06 :                     ;
    2052/     B06 :                     ; handle bad input data
    2053/     B06 :                     
    2054/     B06 :                     LAB_1904
    2055/     B06 : 2A5F                	MOVEA.l	(sp)+,a5				; restore execute pointer
    2056/     B08 : 4A2B 05E0           	TST.b		Imode(a3)				; test input mode flag, $00=INPUT, $98=READ
    2057/     B0C : 6A0A                	BPL.s		LAB_1913				; branch if INPUT (go do redo)
    2058/     B0E :                     
    2059/     B0E : 276B 045E 0452      	MOVE.l	Dlinel(a3),Clinel(a3)		; save DATA line as current line
    2060/     B14 : 6000 F6D8           	BRA		LAB_TMER				; do type mismatch error, then warm start
    2061/     B18 :                     
    2062/     B18 :                     								; mode was INPUT
    2063/     B18 :                     LAB_1913
    2064/     B18 : 41FA 2A76           	LEA		LAB_REDO(pc),a0			; point to redo message
    2065/     B1C : 6100 FF78           	BSR		LAB_18C3				; print null terminated string from memory
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 39 - 10/11/2023 21:18:52


    2066/     B20 : 2A6B 045A           	MOVEA.l	Cpntrl(a3),a5			; save continue pointer as BASIC execute pointer
    2067/     B24 : 4E75                	RTS
    2068/     B26 :                     
    2069/     B26 :                     
    2070/     B26 :                     ;************************************************************************************
    2071/     B26 :                     ;
    2072/     B26 :                     ; perform INPUT
    2073/     B26 :                     
    2074/     B26 :                     LAB_INPUT
    2075/     B26 : 6100 0862           	BSR		LAB_CKRN				; check not direct (back here if ok)
    2076/     B2A : B03C 0022           	CMP.b		#'"',d0				; compare the next byte with open quote
    2077/     B2E : 660E                	BNE.s		LAB_1934				; if no prompt string just go get the input
    2078/     B30 :                     
    2079/     B30 : 6100 0306           	BSR		LAB_1BC1				; print "..." string
    2080/     B34 : 703B                	MOVEQ		#';',d0				; set the search character to ";"
    2081/     B36 : 6100 0320           	BSR		LAB_SCCA				; scan for CHR$(d0), else do syntax error/warm
    2082/     B3A :                     								; start
    2083/     B3A : 6100 FF5E           	BSR		LAB_18C6				; print string from Sutill/Sutilh
    2084/     B3E :                     								; finished the prompt, now read the data
    2085/     B3E :                     LAB_1934
    2086/     B3E : 6100 F804           	BSR		LAB_INLN				; print "? " and get BASIC input
    2087/     B42 :                     								; return a0 pointing to the buffer start
    2088/     B42 : 7000                	MOVEQ		#0,d0					; flag INPUT
    2089/     B44 : 4A10                	TST.b		(a0)					; test first byte from buffer
    2090/     B46 : 660A                	BNE.s		LAB_1953				; branch if not null input
    2091/     B48 :                     
    2092/     B48 : 6000 FB58           	BRA		LAB_1647				; go do BREAK exit
    2093/     B4C :                     
    2094/     B4C :                     
    2095/     B4C :                     ;************************************************************************************
    2096/     B4C :                     ;
    2097/     B4C :                     ; perform READ
    2098/     B4C :                     
    2099/     B4C :                     LAB_READ
    2100/     B4C : 206B 0462           	MOVEA.l	Dptrl(a3),a0			; get the DATA pointer
    2101/     B50 : 7098                	MOVEQ		#$98-$100,d0			; flag READ
    2102/     B52 :                     LAB_1953
    2103/     B52 : 1740 05E0           	MOVE.b	d0,Imode(a3)			; set input mode flag, $00=INPUT, $98=READ
    2104/     B56 : 2748 0466           	MOVE.l	a0,Rdptrl(a3)			; save READ pointer
    2105/     B5A :                     
    2106/     B5A :                     								; READ or INPUT the next variable from list
    2107/     B5A :                     LAB_195B
    2108/     B5A : 6100 0512           	BSR		LAB_SVAR				; search for or create a variable
    2109/     B5E :                     								; return the variable address in a0
    2110/     B5E : 2748 0472           	MOVE.l	a0,Lvarpl(a3)			; save variable address as LET variable
    2111/     B62 : 2F0D                	MOVE.l	a5,-(sp)				; save BASIC execute pointer
    2112/     B64 :                     LAB_1961
    2113/     B64 : 2A6B 0466           	MOVEA.l	Rdptrl(a3),a5			; set READ pointer as BASIC execute pointer
    2114/     B68 : 6100 02F8           	BSR		LAB_GBYT				; scan memory
    2115/     B6C : 661E                	BNE.s		LAB_1986				; if not null go get the value
    2116/     B6E :                     
    2117/     B6E :                     								; the pointer was to a null entry
    2118/     B6E : 4A2B 05E0           	TST.b		Imode(a3)				; test input mode flag, $00=INPUT, $98=READ
    2119/     B72 : 6B72                	BMI.s		LAB_19DD				; branch if READ (go find the next statement)
    2120/     B74 :                     
    2121/     B74 :                     								; else the mode was INPUT so get more
    2122/     B74 : 6100 FF38           	BSR		LAB_18E3				; print a "?" character
    2123/     B78 : 6100 F7CA           	BSR		LAB_INLN				; print "? " and get BASIC input
    2124/     B7C :                     								; return a0 pointing to the buffer start
    2125/     B7C : 4A10                	TST.b		(a0)					; test the first byte from the buffer
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 40 - 10/11/2023 21:18:52


    2126/     B7E : 6604                	BNE.s		LAB_1984				; if not null input go handle it
    2127/     B80 :                     
    2128/     B80 : 6000 FB20           	BRA		LAB_1647				; else go do the BREAK exit
    2129/     B84 :                     
    2130/     B84 :                     LAB_1984
    2131/     B84 : 2A48                	MOVEA.l	a0,a5					; set the execute pointer to the buffer
    2132/     B86 : 534D                	SUBQ.w	#1,a5					; decrement the execute pointer
    2133/     B88 :                     
    2134/     B88 :                     LAB_1985
    2135/     B88 : 6100 02D6           	BSR		LAB_IGBY				; increment & scan memory
    2136/     B8C :                     LAB_1986
    2137/     B8C : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
    2138/     B90 :                     								; $00=float
    2139/     B90 : 6A20                	BPL.s		LAB_19B0				; branch if numeric
    2140/     B92 :                     
    2141/     B92 :                     								; else get string
    2142/     B92 : 1400                	MOVE.b	d0,d2					; save search character
    2143/     B94 : B03C 0022           	CMP.b		#$22,d0				; was it " ?
    2144/     B98 : 6706                	BEQ.s		LAB_1999				; branch if so
    2145/     B9A :                     
    2146/     B9A : 743A                	MOVEQ		#':',d2				; set new search character
    2147/     B9C : 702C                	MOVEQ		#',',d0				; other search character is ","
    2148/     B9E : 534D                	SUBQ.w	#1,a5					; decrement BASIC execute pointer
    2149/     BA0 :                     LAB_1999
    2150/     BA0 : 524D                	ADDQ.w	#1,a5					; increment BASIC execute pointer
    2151/     BA2 : 1600                	MOVE.b	d0,d3					; set second search character
    2152/     BA4 : 204D                	MOVEA.l	a5,a0					; BASIC execute pointer is source
    2153/     BA6 :                     
    2154/     BA6 : 6100 08D4           	BSR		LAB_20B4				; print d2/d3 terminated string to FAC1 stack
    2155/     BAA :                     								; d2 = Srchc, d3 = Asrch, a0 is source
    2156/     BAA : 2A4A                	MOVEA.l	a2,a5					; copy end of string to BASIC execute pointer
    2157/     BAC : 6100 FDD2           	BSR		LAB_17D5				; go do string LET
    2158/     BB0 : 6010                	BRA.s		LAB_19B6				; go check string terminator
    2159/     BB2 :                     
    2160/     BB2 :                     								; get numeric INPUT
    2161/     BB2 :                     LAB_19B0
    2162/     BB2 : 1F2B 05B5           	MOVE.b	Dtypef(a3),-(sp)			; save variable data type
    2163/     BB6 : 6100 1DA6           	BSR		LAB_2887				; get FAC1 from string
    2164/     BBA : 175F 05B5           	MOVE.b	(sp)+,Dtypef(a3)			; restore variable data type
    2165/     BBE : 6100 1084           	BSR		LAB_PFAC				; pack FAC1 into (Lvarpl)
    2166/     BC2 :                     LAB_19B6
    2167/     BC2 : 6100 029E           	BSR		LAB_GBYT				; scan memory
    2168/     BC6 : 670A                	BEQ.s		LAB_19C2				; branch if null (last entry)
    2169/     BC8 :                     
    2170/     BC8 : B03C 002C           	CMP.b		#',',d0				; else compare with ","
    2171/     BCC : 6600 FF38           	BNE		LAB_1904				; if not "," go handle bad input data
    2172/     BD0 :                     
    2173/     BD0 : 524D                	ADDQ.w	#1,a5					; else was "," so point to next chr
    2174/     BD2 :                     								; got good input data
    2175/     BD2 :                     LAB_19C2
    2176/     BD2 : 274D 0466           	MOVE.l	a5,Rdptrl(a3)			; save the read pointer for now
    2177/     BD6 : 2A5F                	MOVEA.l	(sp)+,a5				; restore the execute pointer
    2178/     BD8 : 6100 0288           	BSR		LAB_GBYT				; scan the memory
    2179/     BDC : 6736                	BEQ.s		LAB_1A03				; if null go do extra ignored message
    2180/     BDE :                     
    2181/     BDE : 487A FF7A           	PEA		LAB_195B(pc)			; set return address
    2182/     BE2 : 6000 0272           	BRA		LAB_1C01				; scan for "," else do syntax error/warm start
    2183/     BE6 :                     								; then go INPUT next variable from list
    2184/     BE6 :                     
    2185/     BE6 :                     								; find next DATA statement or do "Out of Data"
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 41 - 10/11/2023 21:18:52


    2186/     BE6 :                     								; error
    2187/     BE6 :                     LAB_19DD
    2188/     BE6 : 6100 FBFE           	BSR		LAB_SNBS				; scan for next BASIC statement ([:] or [EOL])
    2189/     BEA :                     								; returns a0 as pointer to [:] or [EOL]
    2190/     BEA : 2A48                	MOVEA.l	a0,a5					; add index, now = pointer to [EOL]/[EOS]
    2191/     BEC : 524D                	ADDQ.w	#1,a5					; pointer to next character
    2192/     BEE : B03C 003A           	CMP.b		#':',d0				; was it statement end?
    2193/     BF2 : 6712                	BEQ.s		LAB_19F6				; branch if [:]
    2194/     BF4 :                     
    2195/     BF4 :                     								; was [EOL] so find next line
    2196/     BF4 :                     
    2197/     BF4 : 320D                	MOVE.w	a5,d1					; past pad byte(s)
    2198/     BF6 : C27C 0001           	AND.w		#1,d1					; mask odd bit
    2199/     BFA : DAC1                	ADD.w		d1,a5					; add pointer
    2200/     BFC : 241D                	MOVE.l	(a5)+,d2				; get next line pointer
    2201/     BFE : 6700 F612           	BEQ		LAB_ODER				; branch if end of program
    2202/     C02 :                     
    2203/     C02 : 275D 045E           	MOVE.l	(a5)+,Dlinel(a3)			; save current DATA line
    2204/     C06 :                     LAB_19F6
    2205/     C06 : 6100 025A           	BSR		LAB_GBYT				; scan memory
    2206/     C0A : B03C 0083           	CMP.b		#TK_DATA,d0				; compare with "DATA" token
    2207/     C0E : 6700 FF78           	BEQ		LAB_1985				; was "DATA" so go do next READ
    2208/     C12 :                     
    2209/     C12 : 60D2                	BRA.s		LAB_19DD				; go find next statement if not "DATA"
    2210/     C14 :                     
    2211/     C14 :                     ; end of INPUT/READ routine
    2212/     C14 :                     
    2213/     C14 :                     LAB_1A03
    2214/     C14 : 206B 0466           	MOVEA.l	Rdptrl(a3),a0			; get temp READ pointer
    2215/     C18 : 4A2B 05E0           	TST.b		Imode(a3)				; get input mode flag, $00=INPUT, $98=READ
    2216/     C1C : 6A06                	BPL.s		LAB_1A0E				; branch if INPUT
    2217/     C1E :                     
    2218/     C1E : 2748 0462           	MOVE.l	a0,Dptrl(a3)			; else save temp READ pointer as DATA pointer
    2219/     C22 : 4E75                	RTS
    2220/     C24 :                     
    2221/     C24 :                     								; we were getting INPUT
    2222/     C24 :                     LAB_1A0E
    2223/     C24 : 4A10                	TST.b		(a0)					; test next byte
    2224/     C26 : 6602                	BNE.s		LAB_1A1B				; error if not end of INPUT
    2225/     C28 :                     
    2226/     C28 : 4E75                	RTS
    2227/     C2A :                     								; user typed too much
    2228/     C2A :                     LAB_1A1B
    2229/     C2A : 41FA 2954           	LEA		LAB_IMSG(pc),a0			; point to extra ignored message
    2230/     C2E : 6000 FE66           	BRA		LAB_18C3				; print null terminated string from memory & RTS
    2231/     C32 :                     
    2232/     C32 :                     
    2233/     C32 :                     ;************************************************************************************
    2234/     C32 :                     ;
    2235/     C32 :                     ; perform NEXT
    2236/     C32 :                     
    2237/     C32 :                     LAB_NEXT
    2238/     C32 : 6610                	BNE.s		LAB_1A46				; branch if NEXT var
    2239/     C34 :                     
    2240/     C34 : 584F                	ADDQ.w	#4,sp					; back past return address
    2241/     C36 : 0C57 0081           	CMP.w		#TK_FOR,(sp)			; is FOR token on stack?
    2242/     C3A : 6600 F5E2           	BNE		LAB_NFER				; if not do NEXT without FOR err/warm start
    2243/     C3E :                     
    2244/     C3E : 206F 0002           	MOVEA.l	2(sp),a0				; get stacked FOR variable pointer
    2245/     C42 : 601C                	BRA.s		LAB_11BD				; branch always (no variable to search for)
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 42 - 10/11/2023 21:18:52


    2246/     C44 :                     
    2247/     C44 :                     ; NEXT var
    2248/     C44 :                     
    2249/     C44 :                     LAB_1A46
    2250/     C44 : 6100 042C           	BSR		LAB_GVAR				; get variable address in a0
    2251/     C48 : 584F                	ADDQ.w	#4,sp					; back past return address
    2252/     C4A : 303C 0081           	MOVE.w	#TK_FOR,d0				; set for FOR token
    2253/     C4E : 721C                	MOVEQ		#$1C,d1				; set for FOR use size
    2254/     C50 : 6002                	BRA.s		LAB_11A6				; enter loop for next variable search
    2255/     C52 :                     
    2256/     C52 :                     LAB_11A5
    2257/     C52 : DFC1                	ADDA.l	d1,sp					; add FOR stack use size
    2258/     C54 :                     LAB_11A6
    2259/     C54 : B057                	CMP.w		(sp),d0				; is FOR token on stack?
    2260/     C56 : 6600 F5C6           	BNE		LAB_NFER				; if not found do NEXT without FOR error and
    2261/     C5A :                     								; warm start
    2262/     C5A :                     
    2263/     C5A :                     								; was FOR token
    2264/     C5A : B1EF 0002           	CMPA.l	2(sp),a0				; compare var pointer with stacked var pointer
    2265/     C5E : 66F2                	BNE.s		LAB_11A5				; loop if no match found
    2266/     C60 :                     
    2267/     C60 :                     LAB_11BD
    2268/     C60 : 376F 0006 059C      	MOVE.w	6(sp),FAC2_e(a3)			; get STEP value exponent and sign
    2269/     C66 : 276F 0008 0598      	MOVE.l	8(sp),FAC2_m(a3)			; get STEP value mantissa
    2270/     C6C :                     
    2271/     C6C : 176F 0012 05B5      	MOVE.b	18(sp),Dtypef(a3)			; restore FOR variable data type
    2272/     C72 : 6100 021E           	BSR		LAB_1C19				; check type and unpack (a0)
    2273/     C76 :                     
    2274/     C76 : 176B 059D 059E      	MOVE.b	FAC2_s(a3),FAC_sc(a3)		; save FAC2 sign as sign compare
    2275/     C7C : 102B 0595           	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
    2276/     C80 : B12B 059E           	EOR.b		d0,FAC_sc(a3)			; EOR to create sign compare
    2277/     C84 :                     
    2278/     C84 : 2748 0472           	MOVE.l	a0,Lvarpl(a3)			; save variable pointer
    2279/     C88 : 6100 0CBA           	BSR		LAB_ADD				; add STEP value to FOR variable
    2280/     C8C : 176F 0012 05B5      	MOVE.b	18(sp),Dtypef(a3)			; restore FOR variable data type (again)
    2281/     C92 : 6100 0FB0           	BSR		LAB_PFAC				; pack FAC1 into FOR variable (Lvarpl)
    2282/     C96 :                     
    2283/     C96 : 376F 000C 059C      	MOVE.w	12(sp),FAC2_e(a3)			; get TO value exponent and sign
    2284/     C9C : 276F 000E 0598      	MOVE.l	14(sp),FAC2_m(a3)			; get TO value mantissa
    2285/     CA2 :                     
    2286/     CA2 : 176B 059D 059E      	MOVE.b	FAC2_s(a3),FAC_sc(a3)		; save FAC2 sign as sign compare
    2287/     CA8 : 102B 0595           	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
    2288/     CAC : B12B 059E           	EOR.b		d0,FAC_sc(a3)			; EOR to create sign compare
    2289/     CB0 :                     
    2290/     CB0 : 6100 103C           	BSR		LAB_27FA				; compare FAC1 with FAC2 (TO value)
    2291/     CB4 :                     								; returns d0=+1 if FAC1 > FAC2
    2292/     CB4 :                     								; returns d0= 0 if FAC1 = FAC2
    2293/     CB4 :                     								; returns d0=-1 if FAC1 < FAC2
    2294/     CB4 :                     
    2295/     CB4 : 322F 0006           	MOVE.w	6(sp),d1				; get STEP value exponent and sign
    2296/     CB8 : B141                	EOR.w		d0,d1					; EOR compare result with STEP exponent and sign
    2297/     CBA :                     
    2298/     CBA : 4A00                	TST.b		d0					; test for =
    2299/     CBC : 6704                	BEQ.s		LAB_1A90				; branch if = (loop INcomplete)
    2300/     CBE :                     
    2301/     CBE : 4A01                	TST.b		d1					; test result
    2302/     CC0 : 6A0E                	BPL.s		LAB_1A9B				; branch if > (loop complete)
    2303/     CC2 :                     
    2304/     CC2 :                     								; loop back and do it all again
    2305/     CC2 :                     LAB_1A90
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 43 - 10/11/2023 21:18:52


    2306/     CC2 : 276F 0014 0452      	MOVE.l	20(sp),Clinel(a3)			; reset current line
    2307/     CC8 : 2A6F 0018           	MOVE.l	24(sp),a5				; reset BASIC execute pointer
    2308/     CCC : 6000 F970           	BRA		LAB_15C2				; go do interpreter inner loop
    2309/     CD0 :                     
    2310/     CD0 :                     								; loop complete so carry on
    2311/     CD0 :                     LAB_1A9B
    2312/     CD0 : DEFC 001C           	ADDA.w	#28,sp				; add 28 to dump FOR structure
    2313/     CD4 : 6100 018C           	BSR		LAB_GBYT				; scan memory
    2314/     CD8 : B03C 002C           	CMP.b		#$2C,d0				; compare with ","
    2315/     CDC : 6600 F960           	BNE		LAB_15C2				; if not "," go do interpreter inner loop
    2316/     CE0 :                     
    2317/     CE0 :                     								; was "," so another NEXT variable to do
    2318/     CE0 : 6100 017E           	BSR		LAB_IGBY				; else increment & scan memory
    2319/     CE4 : 6100 FF5E           	BSR		LAB_1A46				; do NEXT (var)
    2320/     CE8 :                     
    2321/     CE8 :                     
    2322/     CE8 :                     ;************************************************************************************
    2323/     CE8 :                     ;
    2324/     CE8 :                     ; evaluate expression & check is numeric, else do type mismatch
    2325/     CE8 :                     
    2326/     CE8 :                     LAB_EVNM
    2327/     CE8 : 6116                	BSR.s		LAB_EVEX				; evaluate expression
    2328/     CEA :                     
    2329/     CEA :                     
    2330/     CEA :                     ;************************************************************************************
    2331/     CEA :                     ;
    2332/     CEA :                     ; check if source is numeric, else do type mismatch
    2333/     CEA :                     
    2334/     CEA :                     LAB_CTNM
    2335/     CEA : B040                	CMP.w		d0,d0					; required type is numeric so clear carry
    2336/     CEC :                     
    2337/     CEC :                     
    2338/     CEC :                     ;************************************************************************************
    2339/     CEC :                     ;
    2340/     CEC :                     ; type match check, set C for string, clear C for numeric
    2341/     CEC :                     
    2342/     CEC :                     LAB_CKTM
    2343/     CEC : 082B 0007 05B5      	BTST.b	#7,Dtypef(a3)			; test data type flag, don't change carry
    2344/     CF2 : 6606                	BNE.s		LAB_1ABA				; branch if data type is string
    2345/     CF4 :                     
    2346/     CF4 :                     								; else data type was numeric
    2347/     CF4 : 6500 F4F8           	BCS		LAB_TMER				; if required type is string do type mismatch
    2348/     CF8 :                     								; error
    2349/     CF8 :                     
    2350/     CF8 : 4E75                	RTS
    2351/     CFA :                     								; data type was string, now check required type
    2352/     CFA :                     LAB_1ABA
    2353/     CFA : 6400 F4F2           	BCC		LAB_TMER				; if required type is numeric do type mismatch
    2354/     CFE :                     								; error
    2355/     CFE : 4E75                	RTS
    2356/     D00 :                     
    2357/     D00 :                     
    2358/     D00 :                     ;************************************************************************************
    2359/     D00 :                     ;
    2360/     D00 :                     ; this routine evaluates any type of expression. first it pushes an end marker so
    2361/     D00 :                     ; it knows when the expression has been evaluated, this is a precedence value of zero.
    2362/     D00 :                     ; next the first value is evaluated, this can be an in line value, either numeric or
    2363/     D00 :                     ; string, a variable or array element of any type, a function or even an expression
    2364/     D00 :                     ; in parenthesis. this value is kept in FAC_1
    2365/     D00 :                     ; after the value is evaluated a test is made on the next BASIC program byte, if it
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 44 - 10/11/2023 21:18:52


    2366/     D00 :                     ; is a comparrison operator i.e. "<", "=" or ">", then the corresponding bit is set
    2367/     D00 :                     ; in the comparison evaluation flag. this test loops until no more comparrison operators
    2368/     D00 :                     ; are found or more than one of any type is found. in the last case an error is generated
    2369/     D00 :                     
    2370/     D00 :                     ; evaluate expression
    2371/     D00 :                     
    2372/     D00 :                     LAB_EVEX
    2373/     D00 : 534D                	SUBQ.w	#1,a5					; decrement BASIC execute pointer
    2374/     D02 :                     LAB_EVEZ
    2375/     D02 : 7200                	MOVEQ		#0,d1					; clear precedence word
    2376/     D04 : 1741 05B5           	MOVE.b	d1,Dtypef(a3)			; clear the data type, $80=string, $40=integer,
    2377/     D08 :                     								; $00=float
    2378/     D08 : 601C                	BRA.s		LAB_1ACD				; enter loop
    2379/     D0A :                     
    2380/     D0A :                     ; get vector, set up operator then continue evaluation
    2381/     D0A :                     
    2382/     D0A :                     LAB_1B43
    2383/     D0A : 41FA 22CA           	LEA		LAB_OPPT(pc),a0			; point to operator vector table
    2384/     D0E : 3030 1002           	MOVE.w	2(a0,d1.w),d0			; get vector offset
    2385/     D12 : 4870 0000           	PEA		(a0,d0.w)				; push vector
    2386/     D16 :                     
    2387/     D16 : 2F2B 0590           	MOVE.l	FAC1_m(a3),-(sp)			; push FAC1 mantissa
    2388/     D1A : 3F2B 0594           	MOVE.w	FAC1_e(a3),-(sp)			; push sign and exponent
    2389/     D1E : 1F2B 05E3           	MOVE.b	comp_f(a3),-(sp)			; push comparison evaluation flag
    2390/     D22 :                     
    2391/     D22 : 3230 1000           	MOVE.w	(a0,d1.w),d1			; get precedence value
    2392/     D26 :                     LAB_1ACD
    2393/     D26 : 3F01                	MOVE.w	d1,-(sp)				; push precedence value
    2394/     D28 : 6100 00E4           	BSR		LAB_GVAL				; get value from line
    2395/     D2C : 177C 0000 05E3      	MOVE.b	#$00,comp_f(a3)			; clear compare function flag
    2396/     D32 :                     LAB_1ADB
    2397/     D32 : 6100 012E           	BSR		LAB_GBYT				; scan memory
    2398/     D36 :                     LAB_1ADE
    2399/     D36 : 903C 00BC           	SUB.b		#TK_GT,d0				; subtract token for > (lowest compare function)
    2400/     D3A : 652A                	BCS.s		LAB_1AFA				; branch if < TK_GT
    2401/     D3C :                     
    2402/     D3C : B03C 0003           	CMP.b		#$03,d0				; compare with ">" to "<" tokens
    2403/     D40 : 650A                	BCS.s		LAB_1AE0				; branch if <= TK_SGN (is compare function)
    2404/     D42 :                     
    2405/     D42 : 4A2B 05E3           	TST.b		comp_f(a3)				; test compare function flag
    2406/     D46 : 6660                	BNE.s		LAB_1B2A				; branch if compare function
    2407/     D48 :                     
    2408/     D48 : 6000 0086           	BRA		LAB_1B78				; go do functions
    2409/     D4C :                     
    2410/     D4C :                     								; was token for > = or < (d0 = 0, 1 or 2)
    2411/     D4C :                     LAB_1AE0
    2412/     D4C : 7201                	MOVEQ		#1,d1					; set to 0000 0001
    2413/     D4E : E121                	ASL.b		d0,d1					; 1 if >, 2 if =, 4 if <
    2414/     D50 : 102B 05E3           	MOVE.b	comp_f(a3),d0			; copy old compare function flag
    2415/     D54 : B32B 05E3           	EOR.b		d1,comp_f(a3)			; EOR in this compare function bit
    2416/     D58 : B02B 05E3           	CMP.b		comp_f(a3),d0			; compare old with new compare function flag
    2417/     D5C : 6400 F4BC           	BCC		LAB_SNER				; if new <= old comp_f do syntax error and warm
    2418/     D60 :                     								; start, there was more than one <, = or >
    2419/     D60 : 6100 00FE           	BSR		LAB_IGBY				; increment & scan memory
    2420/     D64 : 60D0                	BRA.s		LAB_1ADE				; go do next character
    2421/     D66 :                     
    2422/     D66 :                     								; token is < ">" or > "<" tokens
    2423/     D66 :                     LAB_1AFA
    2424/     D66 : 4A2B 05E3           	TST.b		comp_f(a3)				; test compare function flag
    2425/     D6A : 663C                	BNE.s		LAB_1B2A				; branch if compare function
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 45 - 10/11/2023 21:18:52


    2426/     D6C :                     
    2427/     D6C :                     								; was < TK_GT so is operator or lower
    2428/     D6C : D03C 000A           	ADD.b	#(TK_GT-TK_PLUS),d0			; add # of operators (+ -	; / ^ AND OR EOR)
    2429/     D70 : 645E                	BCC.s		LAB_1B78				; branch if < + operator
    2430/     D72 :                     
    2431/     D72 : 6608                	BNE.s		LAB_1B0B				; branch if not + token
    2432/     D74 :                     
    2433/     D74 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
    2434/     D78 :                     								; $00=float
    2435/     D78 : 6B00 087E           	BMI		LAB_224D				; type is string & token was +
    2436/     D7C :                     
    2437/     D7C :                     LAB_1B0B
    2438/     D7C : 7200                	MOVEQ		#0,d1					; clear longword
    2439/     D7E : D000                	ADD.b		d0,d0					; *2
    2440/     D80 : D000                	ADD.b		d0,d0					; *4
    2441/     D82 : 1200                	MOVE.b	d0,d1					; copy to index
    2442/     D84 :                     LAB_1B13
    2443/     D84 : 301F                	MOVE.w	(sp)+,d0				; pull previous precedence
    2444/     D86 : 41FA 224E           	LEA		LAB_OPPT(pc),a0			; set pointer to operator table
    2445/     D8A : B070 1000           	CMP.w		(a0,d1.w),d0			; compare with this opperator precedence
    2446/     D8E : 6446                	BCC.s		LAB_1B7D				; branch if previous precedence (d0) >=
    2447/     D90 :                     
    2448/     D90 : 6100 FF58           	BSR		LAB_CTNM				; check if source is numeric, else type mismatch
    2449/     D94 :                     LAB_1B1C
    2450/     D94 : 3F00                	MOVE.w	d0,-(sp)				; save precedence
    2451/     D96 :                     LAB_1B1D
    2452/     D96 : 6100 FF72           	BSR		LAB_1B43				; get vector, set-up operator and continue
    2453/     D9A :                     								; evaluation
    2454/     D9A : 301F                	MOVE.w	(sp)+,d0				; restore precedence
    2455/     D9C : 222B 05D8           	MOVE.l	prstk(a3),d1			; get stacked function pointer
    2456/     DA0 : 6A22                	BPL.s		LAB_1B3C				; branch if stacked values
    2457/     DA2 :                     
    2458/     DA2 : 3000                	MOVE.w	d0,d0					; copy precedence (set flags)
    2459/     DA4 : 672E                	BEQ.s		LAB_1B7B				; exit if done
    2460/     DA6 :                     
    2461/     DA6 : 603C                	BRA.s		LAB_1B86				; else pop FAC2 & return (do function)
    2462/     DA8 :                     
    2463/     DA8 :                     								; was compare function (< = >)
    2464/     DA8 :                     LAB_1B2A
    2465/     DA8 : 102B 05B5           	MOVE.b	Dtypef(a3),d0			; get data type flag
    2466/     DAC : 122B 05E3           	MOVE.b	comp_f(a3),d1			; get compare function flag
    2467/     DB0 : D000                	ADD.b		d0,d0					; string bit flag into X bit
    2468/     DB2 : D301                	ADDX.b	d1,d1					; shift compare function flag
    2469/     DB4 :                     
    2470/     DB4 : 177C 0000 05B5      	MOVE.b	#0,Dtypef(a3)			; clear data type flag, $00=float
    2471/     DBA : 1741 05E3           	MOVE.b	d1,comp_f(a3)			; save new compare function flag
    2472/     DBE : 534D                	SUBQ.w	#1,a5					; decrement BASIC execute pointer
    2473/     DC0 : 7230                	MOVEQ		#(TK_LT-TK_PLUS)*4,d1		; set offset to last operator entry
    2474/     DC2 : 60C0                	BRA.s		LAB_1B13				; branch always
    2475/     DC4 :                     
    2476/     DC4 :                     LAB_1B3C
    2477/     DC4 : 41FA 2210           	LEA		LAB_OPPT(pc),a0			; point to function vector table
    2478/     DC8 : B070 1000           	CMP.w		(a0,d1.w),d0			; compare with this opperator precedence
    2479/     DCC : 6416                	BCC.s		LAB_1B86				; branch if d0 >=, pop FAC2 & return
    2480/     DCE :                     
    2481/     DCE : 60C4                	BRA.s		LAB_1B1C				; branch always
    2482/     DD0 :                     
    2483/     DD0 :                     ; do functions
    2484/     DD0 :                     
    2485/     DD0 :                     LAB_1B78
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 46 - 10/11/2023 21:18:52


    2486/     DD0 : 72FF                	MOVEQ		#-1,d1				; flag all done
    2487/     DD2 : 301F                	MOVE.w	(sp)+,d0				; pull precedence word
    2488/     DD4 :                     LAB_1B7B
    2489/     DD4 : 6732                	BEQ.s		LAB_1B9D				; exit if done
    2490/     DD6 :                     
    2491/     DD6 :                     LAB_1B7D
    2492/     DD6 : B07C 0064           	CMP.w		#$64,d0				; compare previous precedence with $64
    2493/     DDA : 6704                	BEQ.s		LAB_1B84				; branch if was $64 (< function can be string)
    2494/     DDC :                     
    2495/     DDC : 6100 FF0C           	BSR		LAB_CTNM				; check if source is numeric, else type mismatch
    2496/     DE0 :                     LAB_1B84
    2497/     DE0 : 2741 05D8           	MOVE.l	d1,prstk(a3)			; save current operator index
    2498/     DE4 :                     
    2499/     DE4 :                     								; pop FAC2 & return
    2500/     DE4 :                     LAB_1B86
    2501/     DE4 : 101F                	MOVE.b	(sp)+,d0				; pop comparison evaluation flag
    2502/     DE6 : 1200                	MOVE.b	d0,d1					; copy comparison evaluation flag
    2503/     DE8 : E208                	LSR.b		#1,d0					; shift out comparison evaluation lowest bit
    2504/     DEA : 1740 05E1           	MOVE.b	d0,Cflag(a3)			; save comparison evaluation flag
    2505/     DEE : 375F 059C           	MOVE.w	(sp)+,FAC2_e(a3)			; pop exponent and sign
    2506/     DF2 : 275F 0598           	MOVE.l	(sp)+,FAC2_m(a3)			; pop mantissa
    2507/     DF6 : 176B 059D 059E      	MOVE.b	FAC2_s(a3),FAC_sc(a3)		; copy FAC2 sign
    2508/     DFC : 102B 0595           	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
    2509/     E00 : B12B 059E           	EOR.b		d0,FAC_sc(a3)			; EOR FAC1 sign and set sign compare
    2510/     E04 :                     
    2511/     E04 : E209                	LSR.b		#1,d1					; type bit into X and C
    2512/     E06 : 4E75                	RTS
    2513/     E08 :                     
    2514/     E08 :                     LAB_1B9D
    2515/     E08 : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
    2516/     E0C : 4E75                	RTS
    2517/     E0E :                     
    2518/     E0E :                     
    2519/     E0E :                     ;************************************************************************************
    2520/     E0E :                     ;
    2521/     E0E :                     ; get a value from the BASIC line
    2522/     E0E :                     
    2523/     E0E :                     LAB_GVAL
    2524/     E0E : 6150                	BSR.s		LAB_IGBY				; increment & scan memory
    2525/     E10 : 6500 1B4C           	BCS		LAB_2887				; if numeric get FAC1 from string & return
    2526/     E14 :                     
    2527/     E14 : 4A00                	TST.b		d0					; test byte
    2528/     E16 : 6B00 0090           	BMI		LAB_1BD0				; if -ve go test token values
    2529/     E1A :                     
    2530/     E1A :                     								; else it is either a string, number, variable
    2531/     E1A :                     								; or (<expr>)
    2532/     E1A : B03C 0024           	CMP.b		#'$',d0				; compare with "$"
    2533/     E1E : 6700 1B3E           	BEQ		LAB_2887				; if "$" get hex number from string & return
    2534/     E22 :                     
    2535/     E22 : B03C 0025           	CMP.b		#'%',d0				; else compare with "%"
    2536/     E26 : 6700 1B36           	BEQ		LAB_2887				; if "%" get binary number from string & return
    2537/     E2A :                     
    2538/     E2A : B03C 002E           	CMP.b		#$2E,d0				; compare with "."
    2539/     E2E : 6700 1B2E           	BEQ		LAB_2887				; if so get FAC1 from string and return
    2540/     E32 :                     								; (e.g. .123)
    2541/     E32 :                     
    2542/     E32 :                     								; wasn't a number so ...
    2543/     E32 : B03C 0022           	CMP.b		#$22,d0				; compare with "
    2544/     E36 : 660C                	BNE.s		LAB_1BF3				; if not open quote it must be a variable or
    2545/     E38 :                     								; open bracket
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 47 - 10/11/2023 21:18:52


    2546/     E38 :                     
    2547/     E38 :                     								; was open quote so get the enclosed string
    2548/     E38 :                     
    2549/     E38 :                     ; print "..." string to string stack
    2550/     E38 :                     
    2551/     E38 :                     LAB_1BC1
    2552/     E38 : 101D                	MOVE.b	(a5)+,d0				; increment BASIC execute pointer (past ")
    2553/     E3A :                     								; fastest/shortest method
    2554/     E3A : 204D                	MOVEA.l	a5,a0					; copy basic execute pointer (string start)
    2555/     E3C : 6100 063A           	BSR		LAB_20AE				; print " terminated string to stack
    2556/     E40 : 2A4A                	MOVEA.l	a2,a5					; restore BASIC execute pointer from temp
    2557/     E42 : 4E75                	RTS
    2558/     E44 :                     
    2559/     E44 :                     ; get value from line .. continued
    2560/     E44 :                     								; wasn't any sort of number so ...
    2561/     E44 :                     LAB_1BF3
    2562/     E44 : B03C 0028           	CMP.b		#'(',d0				; compare with "("
    2563/     E48 : 6644                	BNE.s		LAB_1C18				; if not "(" get (var) and return value in FAC1
    2564/     E4A :                     								; and $ flag
    2565/     E4A :                     
    2566/     E4A :                     
    2567/     E4A :                     ;************************************************************************************
    2568/     E4A :                     ;
    2569/     E4A :                     ; evaluate expression within parentheses
    2570/     E4A :                     
    2571/     E4A :                     LAB_1BF7
    2572/     E4A : 6100 FEB6           	BSR		LAB_EVEZ				; evaluate expression (no decrement)
    2573/     E4E :                     
    2574/     E4E :                     
    2575/     E4E :                     ;************************************************************************************
    2576/     E4E :                     ;
    2577/     E4E :                     ; all the 'scan for' routines return the character after the sought character
    2578/     E4E :                     
    2579/     E4E :                     ; scan for ")", else do syntax error, then warm start
    2580/     E4E :                     
    2581/     E4E :                     LAB_1BFB
    2582/     E4E : 7029                	MOVEQ		#$29,d0				; load d0 with ")"
    2583/     E50 : 6006                	BRA.s		LAB_SCCA
    2584/     E52 :                     
    2585/     E52 :                     
    2586/     E52 :                     ;************************************************************************************
    2587/     E52 :                     ;
    2588/     E52 :                     ; scan for "," and get byte, else do Syntax error then warm start
    2589/     E52 :                     
    2590/     E52 :                     LAB_SCGB
    2591/     E52 : 487A 0978           	PEA		LAB_GTBY(pc)			; return address is to get byte parameter
    2592/     E56 :                     
    2593/     E56 :                     
    2594/     E56 :                     ;************************************************************************************
    2595/     E56 :                     ;
    2596/     E56 :                     ; scan for ",", else do syntax error, then warm start
    2597/     E56 :                     
    2598/     E56 :                     LAB_1C01
    2599/     E56 : 702C                	MOVEQ		#$2C,d0				; load d0 with ","
    2600/     E58 :                     
    2601/     E58 :                     
    2602/     E58 :                     ;************************************************************************************
    2603/     E58 :                     ;
    2604/     E58 :                     ; scan for CHR$(d0) , else do syntax error, then warm start
    2605/     E58 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 48 - 10/11/2023 21:18:52


    2606/     E58 :                     LAB_SCCA
    2607/     E58 : B01D                	CMP.b		(a5)+,d0				; check next byte is = d0
    2608/     E5A : 6706                	BEQ.s		LAB_GBYT				; if so go get next
    2609/     E5C :                     
    2610/     E5C : 6000 F3BC           	BRA		LAB_SNER				; else do syntax error/warm start
    2611/     E60 :                     
    2612/     E60 :                     
    2613/     E60 :                     ;************************************************************************************
    2614/     E60 :                     ;
    2615/     E60 :                     ; BASIC increment and scan memory routine
    2616/     E60 :                     
    2617/     E60 :                     LAB_IGBY
    2618/     E60 : 101D                	MOVE.b	(a5)+,d0				; get byte & increment pointer
    2619/     E62 :                     
    2620/     E62 :                     ; scan memory routine, exit with Cb = 1 if numeric character
    2621/     E62 :                     ; also skips any spaces encountered
    2622/     E62 :                     
    2623/     E62 :                     LAB_GBYT
    2624/     E62 : 1015                	MOVE.b	(a5),d0				; get byte
    2625/     E64 :                     
    2626/     E64 : B03C 0020           	CMP.b		#$20,d0				; compare with " "
    2627/     E68 : 67F6                	BEQ.s		LAB_IGBY				; if " " go do next
    2628/     E6A :                     
    2629/     E6A :                     ; test current BASIC byte, exit with Cb = 1 if numeric character
    2630/     E6A :                     
    2631/     E6A : B03C 00A9           	CMP.b		#TK_ELSE,d0				; compare with the token for ELSE
    2632/     E6E : 640E                	BCC.s		RTS_001				; exit if >= (not numeric, carry clear)
    2633/     E70 :                     
    2634/     E70 : B03C 003A           	CMP.b		#$3A,d0				; compare with ":"
    2635/     E74 : 6408                	BCC.s		RTS_001				; exit if >= (not numeric, carry clear)
    2636/     E76 :                     
    2637/     E76 : 1C3C 00D0           	MOVE.b		#$D0,d6				; set -"0"
    2638/     E7A : D006                	ADD.b		d6,d0					; add -"0"
    2639/     E7C : 9006                	SUB.b		d6,d0					; subtract -"0"
    2640/     E7E :                     RTS_001							; carry set if byte = "0"-"9"
    2641/     E7E : 4E75                	RTS
    2642/     E80 :                     
    2643/     E80 :                     
    2644/     E80 :                     ;************************************************************************************
    2645/     E80 :                     ;
    2646/     E80 :                     ; set-up for - operator
    2647/     E80 :                     
    2648/     E80 :                     LAB_1C11
    2649/     E80 : 6100 FE68           	BSR		LAB_CTNM				; check if source is numeric, else type mismatch
    2650/     E84 : 7228                	MOVEQ	#(TK_GT-TK_PLUS)*4,d1			; set offset from base to - operator
    2651/     E86 :                     LAB_1C13
    2652/     E86 : 4FEF 0004           	LEA		4(sp),sp				; dump GVAL return address
    2653/     E8A : 6000 FF0A           	BRA		LAB_1B1D				; continue evaluating expression
    2654/     E8E :                     
    2655/     E8E :                     
    2656/     E8E :                     ;************************************************************************************
    2657/     E8E :                     ;
    2658/     E8E :                     ; variable name set-up
    2659/     E8E :                     ; get (var), return value in FAC_1 & data type flag
    2660/     E8E :                     
    2661/     E8E :                     LAB_1C18
    2662/     E8E : 6100 01E2           	BSR		LAB_GVAR				; get variable address in a0
    2663/     E92 :                     
    2664/     E92 :                     ; return existing variable value
    2665/     E92 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 49 - 10/11/2023 21:18:52


    2666/     E92 :                     LAB_1C19
    2667/     E92 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
    2668/     E96 :                     								; $00=float
    2669/     E96 : 6700 0D90           	BEQ		LAB_UFAC				; if float unpack memory (a0) into FAC1 and
    2670/     E9A :                     								; return
    2671/     E9A :                     
    2672/     E9A : 6A06                	BPL.s		LAB_1C1A				; if integer unpack memory (a0) into FAC1
    2673/     E9C :                     								; and return
    2674/     E9C :                     
    2675/     E9C : 2748 0590           	MOVE.l	a0,FAC1_m(a3)			; else save descriptor pointer in FAC1
    2676/     EA0 : 4E75                	RTS
    2677/     EA2 :                     
    2678/     EA2 :                     LAB_1C1A
    2679/     EA2 : 2010                	MOVE.l	(a0),d0				; get integer value
    2680/     EA4 : 6000 04BC           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
    2681/     EA8 :                     
    2682/     EA8 :                     
    2683/     EA8 :                     ;************************************************************************************
    2684/     EA8 :                     ;
    2685/     EA8 :                     ; get value from line .. continued
    2686/     EA8 :                     ; do tokens
    2687/     EA8 :                     
    2688/     EA8 :                     LAB_1BD0
    2689/     EA8 : B03C 00B3           	CMP.b		#TK_MINUS,d0			; compare with token for -
    2690/     EAC : 67D2                	BEQ.s		LAB_1C11				; branch if - token (do set-up for - operator)
    2691/     EAE :                     
    2692/     EAE :                     								; wasn't -123 so ...
    2693/     EAE : B03C 00B2           	CMP.b		#TK_PLUS,d0				; compare with token for +
    2694/     EB2 : 6700 FF5A           	BEQ		LAB_GVAL				; branch if + token (+n = n so ignore leading +)
    2695/     EB6 :                     
    2696/     EB6 : B03C 00AE           	CMP.b		#TK_NOT,d0				; compare with token for NOT
    2697/     EBA : 6606                	BNE.s		LAB_1BE7				; branch if not token for NOT
    2698/     EBC :                     
    2699/     EBC :                     								; was NOT token
    2700/     EBC : 323C 002C           	MOVE.w	#(TK_EQUAL-TK_PLUS)*4,d1		; offset to NOT function
    2701/     EC0 : 60C4                	BRA.s		LAB_1C13				; do set-up for function then execute
    2702/     EC2 :                     
    2703/     EC2 :                     								; wasn't +, - or NOT so ...
    2704/     EC2 :                     LAB_1BE7
    2705/     EC2 : B03C 00AB           	CMP.b		#TK_FN,d0				; compare with token for FN
    2706/     EC6 : 6700 0514           	BEQ		LAB_201E				; if FN go evaluate FNx
    2707/     ECA :                     
    2708/     ECA :                     								; wasn't +, -, NOT or FN so ...
    2709/     ECA : 903C 00BF           	SUB.b		#TK_SGN,d0				; compare with token for SGN & normalise
    2710/     ECE : 6500 F34A           	BCS		LAB_SNER				; if < SGN token then do syntax error
    2711/     ED2 :                     
    2712/     ED2 :                     ; get value from line .. continued
    2713/     ED2 :                     ; only functions left so set up function references
    2714/     ED2 :                     
    2715/     ED2 :                     ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
    2716/     ED2 :                     ; to process function calls. now the function vector is computed and pushed on the stack
    2717/     ED2 :                     ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
    2718/     ED2 :                     ; is calculated and the routine called, if not this routine just does RTS. whichever
    2719/     ED2 :                     ; happens the RTS at the end of this routine, or the preprocess routine calls, the
    2720/     ED2 :                     ; function code
    2721/     ED2 :                     
    2722/     ED2 :                     ; this also removes some less than elegant code that was used to bypass type checking
    2723/     ED2 :                     ; for functions that returned strings
    2724/     ED2 :                     
    2725/     ED2 : C07C 007F           	AND.w		#$7F,d0				; mask byte
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 50 - 10/11/2023 21:18:52


    2726/     ED6 : D040                	ADD.w		d0,d0					; *2 (2 bytes per function offset)
    2727/     ED8 :                     
    2728/     ED8 : 41FA 20B0           	LEA		LAB_FTBL(pc),a0			; pointer to functions vector table
    2729/     EDC : 3230 0000           	MOVE.w	(a0,d0.w),d1			; get function vector offset
    2730/     EE0 : 4870 1000           	PEA		(a0,d1.w)				; push function vector
    2731/     EE4 :                     
    2732/     EE4 : 41FA 2058           	LEA		LAB_FTPP(pc),a0			; pointer to functions preprocess vector table
    2733/     EE8 : 3030 0000           	MOVE.w	(a0,d0.w),d0			; get function preprocess vector offset
    2734/     EEC : 6712                	BEQ.s		LAB_1C2A				; no preprocess vector so go do function
    2735/     EEE :                     
    2736/     EEE : 41F0 0000           	LEA		(a0,d0.w),a0			; get function preprocess vector
    2737/     EF2 : 4ED0                	JMP		(a0)					; go do preprocess routine then function
    2738/     EF4 :                     
    2739/     EF4 :                     
    2740/     EF4 :                     ;************************************************************************************
    2741/     EF4 :                     ;
    2742/     EF4 :                     ; process string expression in parenthesis
    2743/     EF4 :                     
    2744/     EF4 :                     LAB_PPFS
    2745/     EF4 : 6100 FF54           	BSR		LAB_1BF7				; process expression in parenthesis
    2746/     EF8 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type
    2747/     EFC : 6A00 F2F0           	BPL		LAB_TMER				; if numeric do Type missmatch Error/warm start
    2748/     F00 :                     
    2749/     F00 :                     LAB_1C2A
    2750/     F00 : 4E75                	RTS							; else do function
    2751/     F02 :                     
    2752/     F02 :                     
    2753/     F02 :                     ;************************************************************************************
    2754/     F02 :                     ;
    2755/     F02 :                     ; process numeric expression in parenthesis
    2756/     F02 :                     
    2757/     F02 :                     LAB_PPFN
    2758/     F02 : 6100 FF46           	BSR		LAB_1BF7				; process expression in parenthesis
    2759/     F06 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type
    2760/     F0A : 6B00 F2E2           	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
    2761/     F0E :                     
    2762/     F0E : 4E75                	RTS							; else do function
    2763/     F10 :                     
    2764/     F10 :                     
    2765/     F10 :                     ;************************************************************************************
    2766/     F10 :                     ;
    2767/     F10 :                     ; set numeric data type and increment BASIC execute pointer
    2768/     F10 :                     
    2769/     F10 :                     LAB_PPBI
    2770/     F10 : 177C 0000 05B5      	MOVE.b	#$00,Dtypef(a3)			; clear data type flag, $00=float
    2771/     F16 : 101D                	MOVE.b	(a5)+,d0				; get next BASIC byte
    2772/     F18 : 4E75                	RTS							; do function
    2773/     F1A :                     
    2774/     F1A :                     
    2775/     F1A :                     ;************************************************************************************
    2776/     F1A :                     ;
    2777/     F1A :                     ; process string for LEFT$, RIGHT$ or MID$
    2778/     F1A :                     
    2779/     F1A :                     LAB_LRMS
    2780/     F1A : 6100 FDE6           	BSR		LAB_EVEZ				; evaluate (should be string) expression
    2781/     F1E : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type flag
    2782/     F22 : 6A00 F2CA           	BPL		LAB_TMER				; if type is not string do type mismatch error
    2783/     F26 :                     
    2784/     F26 : 141D                	MOVE.b	(a5)+,d2				; get BASIC byte
    2785/     F28 : B43C 002C           	CMP.b		#',',d2				; compare with comma
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 51 - 10/11/2023 21:18:52


    2786/     F2C : 6600 F2EC           	BNE		LAB_SNER				; if not "," go do syntax error/warm start
    2787/     F30 :                     
    2788/     F30 : 2F2B 0590           	MOVE.l	FAC1_m(a3),-(sp)			; save descriptor pointer
    2789/     F34 : 6100 08AC           	BSR		LAB_GTWO				; get word parameter, result in d0 and Itemp
    2790/     F38 : 205F                	MOVEA.l	(sp)+,a0				; restore descriptor pointer
    2791/     F3A : 4E75                	RTS							; do function
    2792/     F3C :                     
    2793/     F3C :                     
    2794/     F3C :                     ;************************************************************************************
    2795/     F3C :                     ;
    2796/     F3C :                     ; process numeric expression(s) for BIN$ or HEX$
    2797/     F3C :                     
    2798/     F3C :                     LAB_BHSS
    2799/     F3C : 6100 FDC4           	BSR		LAB_EVEZ				; evaluate expression (no decrement)
    2800/     F40 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type
    2801/     F44 : 6B00 F2A8           	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
    2802/     F48 :                     
    2803/     F48 : 6100 0DD0           	BSR		LAB_2831				; convert FAC1 floating to fixed
    2804/     F4C :                     								; result in d0 and Itemp
    2805/     F4C : 7200                	MOVEQ		#0,d1					; set default to no leading "0"s
    2806/     F4E : 141D                	MOVE.b	(a5)+,d2				; get BASIC byte
    2807/     F50 : B43C 002C           	CMP.b		#',',d2				; compare with comma
    2808/     F54 : 660C                	BNE.s		LAB_BHCB				; if not "," go check close bracket
    2809/     F56 :                     
    2810/     F56 : 2F00                	MOVE.l	d0,-(sp)				; copy number to stack
    2811/     F58 : 6100 0872           	BSR		LAB_GTBY				; get byte value
    2812/     F5C : 2200                	MOVE.l	d0,d1					; copy leading 0s #
    2813/     F5E : 201F                	MOVE.l	(sp)+,d0				; restore number from stack
    2814/     F60 : 141D                	MOVE.b	(a5)+,d2				; get BASIC byte
    2815/     F62 :                     LAB_BHCB
    2816/     F62 : B43C 0029           	CMP.b		#')',d2				; compare with close bracket
    2817/     F66 : 6600 F2B2           	BNE		LAB_SNER				; if not ")" do Syntax Error/warm start
    2818/     F6A :                     
    2819/     F6A : 4E75                	RTS							; go do function
    2820/     F6C :                     
    2821/     F6C :                     
    2822/     F6C :                     ;************************************************************************************
    2823/     F6C :                     ;
    2824/     F6C :                     ; perform EOR
    2825/     F6C :                     
    2826/     F6C :                     LAB_EOR
    2827/     F6C : 6116                	BSR.s		GetFirst				; get two values for OR, AND or EOR
    2828/     F6E :                     								; first in d0, and Itemp, second in d2
    2829/     F6E : B580                	EOR.l		d2,d0					; EOR values
    2830/     F70 : 6000 03F0           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
    2831/     F74 :                     
    2832/     F74 :                     
    2833/     F74 :                     ;************************************************************************************
    2834/     F74 :                     ;
    2835/     F74 :                     ; perform OR
    2836/     F74 :                     
    2837/     F74 :                     LAB_OR
    2838/     F74 : 610E                	BSR.s		GetFirst				; get two values for OR, AND or EOR
    2839/     F76 :                     								; first in d0, and Itemp, second in d2
    2840/     F76 : 8082                	OR.l		d2,d0					; do OR
    2841/     F78 : 6000 03E8           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
    2842/     F7C :                     
    2843/     F7C :                     
    2844/     F7C :                     ;************************************************************************************
    2845/     F7C :                     ;
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 52 - 10/11/2023 21:18:52


    2846/     F7C :                     ; perform AND
    2847/     F7C :                     
    2848/     F7C :                     LAB_AND
    2849/     F7C : 6106                	BSR.s		GetFirst				; get two values for OR, AND or EOR
    2850/     F7E :                     								; first in d0, and Itemp, second in d2
    2851/     F7E : C082                	AND.l		d2,d0					; do AND
    2852/     F80 : 6000 03E0           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
    2853/     F84 :                     
    2854/     F84 :                     
    2855/     F84 :                     ;************************************************************************************
    2856/     F84 :                     ;
    2857/     F84 :                     ; get two values for OR, AND, EOR
    2858/     F84 :                     ; first in d0, second in d2
    2859/     F84 :                     
    2860/     F84 :                     GetFirst
    2861/     F84 : 6100 0228           	BSR		LAB_EVIR				; evaluate integer expression (no sign check)
    2862/     F88 :                     								; result in d0 and Itemp
    2863/     F88 : 2400                	MOVE.l	d0,d2					; copy second value
    2864/     F8A : 6100 0CF6           	BSR		LAB_279B				; copy FAC2 to FAC1, get first value in
    2865/     F8E :                     								; expression
    2866/     F8E : 6000 021E           	BRA		LAB_EVIR				; evaluate integer expression (no sign check)
    2867/     F92 :                     								; result in d0 and Itemp & return
    2868/     F92 :                     
    2869/     F92 :                     
    2870/     F92 :                     ;************************************************************************************
    2871/     F92 :                     ;
    2872/     F92 :                     ; perform NOT
    2873/     F92 :                     
    2874/     F92 :                     LAB_EQUAL
    2875/     F92 : 6100 021A           	BSR		LAB_EVIR				; evaluate integer expression (no sign check)
    2876/     F96 :                     								; result in d0 and Itemp
    2877/     F96 : 4680                	NOT.l		d0					; bitwise invert
    2878/     F98 : 6000 03C8           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
    2879/     F9C :                     
    2880/     F9C :                     
    2881/     F9C :                     ;************************************************************************************
    2882/     F9C :                     ;
    2883/     F9C :                     ; perform comparisons
    2884/     F9C :                     ; do < compare
    2885/     F9C :                     
    2886/     F9C :                     LAB_LTHAN
    2887/     F9C : 6100 FD4E           	BSR		LAB_CKTM				; type match check, set C for string
    2888/     FA0 : 6506                	BCS.s		LAB_1CAE				; branch if string
    2889/     FA2 :                     
    2890/     FA2 :                     								; do numeric < compare
    2891/     FA2 : 6100 0D4A           	BSR		LAB_27FA				; compare FAC1 with FAC2
    2892/     FA6 :                     								; returns d0=+1 if FAC1 > FAC2
    2893/     FA6 :                     								; returns d0= 0 if FAC1 = FAC2
    2894/     FA6 :                     								; returns d0=-1 if FAC1 < FAC2
    2895/     FA6 : 6042                	BRA.s		LAB_1CF2				; process result
    2896/     FA8 :                     
    2897/     FA8 :                     								; do string < compare
    2898/     FA8 :                     LAB_1CAE
    2899/     FA8 : 177C 0000 05B5      	MOVE.b	#$00,Dtypef(a3)			; clear data type, $80=string, $40=integer,
    2900/     FAE :                     								; $00=float
    2901/     FAE : 6100 06BC           	BSR		LAB_22B6				; pop string off descriptor stack, or from top
    2902/     FB2 :                     								; of string space returns d0 = length,
    2903/     FB2 :                     								; a0 = pointer
    2904/     FB2 : 2248                	MOVEA.l	a0,a1					; copy string 2 pointer
    2905/     FB4 : 2200                	MOVE.l	d0,d1					; copy string 2 length
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 53 - 10/11/2023 21:18:52


    2906/     FB6 : 206B 0598           	MOVEA.l	FAC2_m(a3),a0			; get string 1 descriptor pointer
    2907/     FBA : 6100 06B4           	BSR		LAB_22BA				; pop (a0) descriptor, returns with ..
    2908/     FBE :                     								; d0 = length, a0 = pointer
    2909/     FBE : 2400                	MOVE.l	d0,d2					; copy length
    2910/     FC0 : 6604                	BNE.s		LAB_1CB5				; branch if not null string
    2911/     FC2 :                     
    2912/     FC2 : 4A81                	TST.l		d1					; test if string 2 is null also
    2913/     FC4 : 6724                	BEQ.s		LAB_1CF2				; if so do string 1 = string 2
    2914/     FC6 :                     
    2915/     FC6 :                     LAB_1CB5
    2916/     FC6 : 9481                	SUB.l		d1,d2					; subtract string 2 length
    2917/     FC8 : 670C                	BEQ.s		LAB_1CD5				; branch if strings = length
    2918/     FCA :                     
    2919/     FCA : 6504                	BCS.s		LAB_1CD4				; branch if string 1 < string 2
    2920/     FCC :                     
    2921/     FCC : 70FF                	MOVEQ		#-1,d0				; set for string 1 > string 2
    2922/     FCE : 6008                	BRA.s		LAB_1CD6				; go do character comapare
    2923/     FD0 :                     
    2924/     FD0 :                     LAB_1CD4
    2925/     FD0 : 2200                	MOVE.l	d0,d1					; string 1 length is compare length
    2926/     FD2 : 7001                	MOVEQ		#1,d0					; and set for string 1 < string 2
    2927/     FD4 : 6002                	BRA.s		LAB_1CD6				; go do character comapare
    2928/     FD6 :                     
    2929/     FD6 :                     LAB_1CD5
    2930/     FD6 : 2002                	MOVE.l	d2,d0					; set for string 1 = string 2
    2931/     FD8 :                     LAB_1CD6
    2932/     FD8 : 5381                	SUBQ.l	#1,d1					; adjust length for DBcc loop
    2933/     FDA :                     
    2934/     FDA :                     								; d1 is length to compare, d0 is <=> for length
    2935/     FDA :                     								; a0 is string 1 pointer, a1 is string 2 pointer
    2936/     FDA :                     LAB_1CE6
    2937/     FDA : B308                	CMPM.b	(a0)+,(a1)+				; compare string bytes (1 with 2)
    2938/     FDC : 56C9 FFFC           	DBNE		d1,LAB_1CE6				; loop if same and not end yet
    2939/     FE0 :                     
    2940/     FE0 : 6708                	BEQ.s		LAB_1CF2				; if = to here, then go use length compare
    2941/     FE2 :                     
    2942/     FE2 : 6404                	BCC.s		LAB_1CDB				; else branch if string 1 > string 2
    2943/     FE4 :                     
    2944/     FE4 : 70FF                	MOVEQ		#-1,d0				; else set for string 1 < string 2
    2945/     FE6 : 6002                	BRA.s		LAB_1CF2				; go set result
    2946/     FE8 :                     
    2947/     FE8 :                     LAB_1CDB
    2948/     FE8 : 7001                	MOVEQ		#1,d0					; and set for string 1 > string 2
    2949/     FEA :                     
    2950/     FEA :                     LAB_1CF2
    2951/     FEA : 5200                	ADDQ.b	#1,d0					; make result 0, 1 or 2
    2952/     FEC : 1200                	MOVE.b	d0,d1					; copy to d1
    2953/     FEE : 7001                	MOVEQ		#1,d0					; set d0 longword
    2954/     FF0 : E338                	ROL.b		d1,d0					; make 1, 2 or 4 (result = flag bit)
    2955/     FF2 : C02B 05E1           	AND.b		Cflag(a3),d0			; AND with comparison evaluation flag
    2956/     FF6 : 6700 0CDE           	BEQ		LAB_27DB				; exit if not a wanted result (i.e. false)
    2957/     FFA :                     
    2958/     FFA : 70FF                	MOVEQ		#-1,d0				; else set -1 (true)
    2959/     FFC : 6000 0CD8           	BRA		LAB_27DB				; save d0 as integer & return
    2960/    1000 :                     
    2961/    1000 :                     
    2962/    1000 :                     LAB_1CFE
    2963/    1000 : 6100 FE54           	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
    2964/    1004 :                     
    2965/    1004 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 54 - 10/11/2023 21:18:52


    2966/    1004 :                     ;************************************************************************************
    2967/    1004 :                     ;
    2968/    1004 :                     ; perform DIM
    2969/    1004 :                     
    2970/    1004 :                     LAB_DIM
    2971/    1004 : 72FF                	MOVEQ		#-1,d1				; set "DIM" flag
    2972/    1006 : 6170                	BSR.s		LAB_1D10				; search for or dimension a variable
    2973/    1008 : 6100 FE58           	BSR		LAB_GBYT				; scan memory
    2974/    100C : 66F2                	BNE.s		LAB_1CFE				; loop and scan for "," if not null
    2975/    100E :                     
    2976/    100E : 4E75                	RTS
    2977/    1010 :                     
    2978/    1010 :                     
    2979/    1010 :                     ;************************************************************************************
    2980/    1010 :                     ;
    2981/    1010 :                     ; perform << (left shift)
    2982/    1010 :                     
    2983/    1010 :                     LAB_LSHIFT
    2984/    1010 : 612E                	BSR.s		GetPair				; get an integer and byte pair
    2985/    1012 :                     								; byte is in d2, integer is in d0 and Itemp
    2986/    1012 : 6708                	BEQ.s		NoShift				; branch if byte zero
    2987/    1014 :                     
    2988/    1014 : B43C 0020           	CMP.b		#$20,d2				; compare bit count with 32d
    2989/    1018 : 6420                	BCC.s		TooBig				; branch if >=
    2990/    101A :                     
    2991/    101A : E5A0                	ASL.l		d2,d0					; shift longword
    2992/    101C :                     NoShift
    2993/    101C : 6000 0344           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
    2994/    1020 :                     
    2995/    1020 :                     
    2996/    1020 :                     ;************************************************************************************
    2997/    1020 :                     ;
    2998/    1020 :                     ; perform >> (right shift)
    2999/    1020 :                     
    3000/    1020 :                     LAB_RSHIFT
    3001/    1020 : 611E                	BSR.s		GetPair				; get an integer and byte pair
    3002/    1022 :                     								; byte is in d2, integer is in d0 and Itemp
    3003/    1022 : 67F8                	BEQ.s		NoShift				; branch if byte zero
    3004/    1024 :                     
    3005/    1024 : B43C 0020           	CMP.b		#$20,d2				; compare bit count with 32d
    3006/    1028 : 650A                	BCS.s		Not2Big				; branch if >= (return shift)
    3007/    102A :                     
    3008/    102A : 4A80                	TST.l		d0					; test sign bit
    3009/    102C : 6A0C                	BPL.s		TooBig				; branch if +ve
    3010/    102E :                     
    3011/    102E : 70FF                	MOVEQ		#-1,d0				; set longword
    3012/    1030 : 6000 0330           	BRA		LAB_AYFC				; convert d0 to longword in FAC1 & RET
    3013/    1034 :                     
    3014/    1034 :                     Not2Big
    3015/    1034 : E4A0                	ASR.l		d2,d0					; shift longword
    3016/    1036 : 6000 032A           	BRA		LAB_AYFC				; convert d0 to longword in FAC1 & RET
    3017/    103A :                     
    3018/    103A :                     TooBig
    3019/    103A : 7000                	MOVEQ		#0,d0					; clear longword
    3020/    103C : 6000 0324           	BRA		LAB_AYFC				; convert d0 to longword in FAC1 & RET
    3021/    1040 :                     
    3022/    1040 :                     
    3023/    1040 :                     ;************************************************************************************
    3024/    1040 :                     ;
    3025/    1040 :                     ; get an integer and byte pair
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 55 - 10/11/2023 21:18:52


    3026/    1040 :                     ; byte is in d2, integer is in d0 and Itemp
    3027/    1040 :                     
    3028/    1040 :                     GetPair
    3029/    1040 : 6100 078E           	BSR		LAB_EVBY				; evaluate byte expression, result in d0 and
    3030/    1044 :                     								; Itemp
    3031/    1044 : 1400                	MOVE.b	d0,d2					; save it
    3032/    1046 : 6100 0C3A           	BSR		LAB_279B				; copy FAC2 to FAC1, get first value in
    3033/    104A :                     								; expression
    3034/    104A : 6100 0162           	BSR		LAB_EVIR				; evaluate integer expression (no sign check)
    3035/    104E :                     								; result in d0 and Itemp
    3036/    104E : 4A02                	TST.b		d2					; test byte value
    3037/    1050 : 4E75                	RTS
    3038/    1052 :                     
    3039/    1052 :                     
    3040/    1052 :                     ;************************************************************************************
    3041/    1052 :                     ;
    3042/    1052 :                     ; check alpha, return C=0 if<"A" or >"Z" or <"a" to "z">
    3043/    1052 :                     
    3044/    1052 :                     LAB_CASC
    3045/    1052 : B03C 0061           	CMP.b		#$61,d0				; compare with "a"
    3046/    1056 : 6410                	BCC.s		LAB_1D83				; if >="a" go check =<"z"
    3047/    1058 :                     
    3048/    1058 :                     
    3049/    1058 :                     ;************************************************************************************
    3050/    1058 :                     ;
    3051/    1058 :                     ; check alpha upper case, return C=0 if<"A" or >"Z"
    3052/    1058 :                     
    3053/    1058 :                     LAB_CAUC
    3054/    1058 : B03C 0041           	CMP.b		#$41,d0				; compare with "A"
    3055/    105C : 6404                	BCC.s		LAB_1D8A				; if >="A" go check =<"Z"
    3056/    105E :                     
    3057/    105E : 8040                	OR		d0,d0					; make C=0
    3058/    1060 : 4E75                	RTS
    3059/    1062 :                     
    3060/    1062 :                     LAB_1D8A
    3061/    1062 : B03C 005B           	CMP.b		#$5B,d0				; compare with "Z"+1
    3062/    1066 :                     								; carry set if byte<="Z"
    3063/    1066 : 4E75                	RTS
    3064/    1068 :                     
    3065/    1068 :                     LAB_1D83
    3066/    1068 : B03C 007B           	CMP.b		#$7B,d0				; compare with "z"+1
    3067/    106C :                     								; carry set if byte<="z"
    3068/    106C : 4E75                	RTS
    3069/    106E :                     
    3070/    106E :                     
    3071/    106E :                     ;************************************************************************************
    3072/    106E :                     ;
    3073/    106E :                     ; search for or create variable. this is used to automatically create a variable if
    3074/    106E :                     ; it is not found. any routines that need to create the variable call LAB_GVAR via
    3075/    106E :                     ; this point and error generation is supressed and the variable will be created
    3076/    106E :                     ;
    3077/    106E :                     ; return pointer to variable in Cvaral and a0
    3078/    106E :                     ; set data type to variable type
    3079/    106E :                     
    3080/    106E :                     LAB_SVAR
    3081/    106E : 6102                	BSR.s		LAB_GVAR				; search for variable
    3082/    1070 :                     LAB_FVAR
    3083/    1070 : 4E75                	RTS
    3084/    1072 :                     
    3085/    1072 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 56 - 10/11/2023 21:18:52


    3086/    1072 :                     ;************************************************************************************
    3087/    1072 :                     ;
    3088/    1072 :                     ; search for variable. if this routine is called from anywhere but the above call and
    3089/    1072 :                     ; the variable searched for does not exist then an error will be returned
    3090/    1072 :                     ;
    3091/    1072 :                     ; DIM flag is in d1.b
    3092/    1072 :                     ; return pointer to variable in Cvaral and a0
    3093/    1072 :                     ; set data type to variable type
    3094/    1072 :                     
    3095/    1072 :                     LAB_GVAR
    3096/    1072 : 7200                	MOVEQ		#$00,d1				; set DIM flag = $00
    3097/    1074 : 6100 FDEC           	BSR		LAB_GBYT				; scan memory (1st character)
    3098/    1078 :                     LAB_1D10
    3099/    1078 : 1741 05B4           	MOVE.b	d1,Defdim(a3)			; save DIM flag
    3100/    107C :                     
    3101/    107C :                     ; search for FN name entry point
    3102/    107C :                     
    3103/    107C :                     LAB_1D12
    3104/    107C : 61D4                	BSR.s		LAB_CASC				; check byte, return C=0 if<"A" or >"Z"
    3105/    107E : 6400 F19A           	BCC		LAB_SNER				; if not, syntax error then warm start
    3106/    1082 :                     
    3107/    1082 :                     								; it is a variable name so ...
    3108/    1082 : 7200                	MOVEQ		#$0,d1				; set index for name byte
    3109/    1084 : 41EB 046A           	LEA		Varname(a3),a0			; pointer to variable name
    3110/    1088 : 2081                	MOVE.l	d1,(a0)				; clear the variable name
    3111/    108A : 1741 05B5           	MOVE.b	d1,Dtypef(a3)			; clear the data type, $80=string, $40=integer,
    3112/    108E :                     								; $00=float
    3113/    108E :                     
    3114/    108E :                     LAB_1D2D
    3115/    108E : B27C 0004           	CMP.w		#$04,d1				; done all significant characters?
    3116/    1092 : 6406                	BCC.s		LAB_1D2E				; if so go ignore any more
    3117/    1094 :                     
    3118/    1094 : 1180 1000           	MOVE.b	d0,(a0,d1.w)			; save the character
    3119/    1098 : 5241                	ADDQ.w	#1,d1					; increment index
    3120/    109A :                     LAB_1D2E
    3121/    109A : 6100 FDC4           	BSR		LAB_IGBY				; increment & scan memory (next character)
    3122/    109E : 65EE                	BCS.s		LAB_1D2D				; branch if character = "0"-"9" (ok)
    3123/    10A0 :                     
    3124/    10A0 :                     								; character wasn't "0" to "9" so ...
    3125/    10A0 : 61B0                	BSR.s		LAB_CASC				; check byte, return C=0 if<"A" or >"Z"
    3126/    10A2 : 65EA                	BCS.s		LAB_1D2D				; branch if = "A"-"Z" (ok)
    3127/    10A4 :                     
    3128/    10A4 :                     								; check if string variable
    3129/    10A4 : B03C 0024           	CMP.b		#'$',d0				; compare with "$"
    3130/    10A8 : 660C                	BNE.s		LAB_1D44				; branch if not string
    3131/    10AA :                     
    3132/    10AA :                     								; type is string
    3133/    10AA : 002B 0080 046B      	OR.b		#$80,Varname+1(a3)		; set top bit of 2nd character, indicate string
    3134/    10B0 : 6100 FDAE           	BSR		LAB_IGBY				; increment & scan memory
    3135/    10B4 : 6010                	BRA.s		LAB_1D45				; skip integer check
    3136/    10B6 :                     
    3137/    10B6 :                     								; check if integer variable
    3138/    10B6 :                     LAB_1D44
    3139/    10B6 : B03C 0026           	CMP.b		#'&',d0				; compare with "&"
    3140/    10BA : 660A                	BNE.s		LAB_1D45				; branch if not integer
    3141/    10BC :                     
    3142/    10BC :                     								; type is integer
    3143/    10BC : 002B 0080 046C      	OR.b		#$80,Varname+2(a3)		; set top bit of 3rd character, indicate integer
    3144/    10C2 : 6100 FD9C           	BSR		LAB_IGBY				; increment & scan memory
    3145/    10C6 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 57 - 10/11/2023 21:18:52


    3146/    10C6 :                     ; after we have determined the variable type we need to determine
    3147/    10C6 :                     ; if it's an array of type
    3148/    10C6 :                     
    3149/    10C6 :                     								; gets here with character after var name in d0
    3150/    10C6 :                     LAB_1D45
    3151/    10C6 : 4A2B 05DF           	TST.b		Sufnxf(a3)				; test function name flag
    3152/    10CA : 670E                	BEQ.s		LAB_1D48				; if not FN or FN variable continue
    3153/    10CC :                     
    3154/    10CC : 6A14                	BPL.s		LAB_1D49				; if FN variable go find or create it
    3155/    10CE :                     
    3156/    10CE :                     								; else was FN name
    3157/    10CE : 202B 046A           	MOVE.l	Varname(a3),d0			; get whole function name
    3158/    10D2 : 7208                	MOVEQ		#8,d1					; set step to next function size -4
    3159/    10D4 : 41EB 0432           	LEA		Sfncl(a3),a0			; get pointer to start of functions
    3160/    10D8 : 601C                	BRA.s		LAB_1D4B				; go find function
    3161/    10DA :                     
    3162/    10DA :                     LAB_1D48
    3163/    10DA : 903C 0028           	SUB.b		#'(',d0				; subtract "("
    3164/    10DE : 6700 00F4           	BEQ		LAB_1E17				; if "(" go find, or make, array
    3165/    10E2 :                     
    3166/    10E2 :                     ; either find or create var
    3167/    10E2 :                     ; var name (1st four characters only!) is in Varname
    3168/    10E2 :                     
    3169/    10E2 :                     								; variable name wasn't var( .. so look for
    3170/    10E2 :                     								; plain variable
    3171/    10E2 :                     LAB_1D49
    3172/    10E2 : 202B 046A           	MOVE.l	Varname(a3),d0			; get whole variable name
    3173/    10E6 :                     LAB_1D4A
    3174/    10E6 : 7204                	MOVEQ		#4,d1					; set step to next variable size -4
    3175/    10E8 : 41EB 0436           	LEA		Svarl(a3),a0			; get pointer to start of variables
    3176/    10EC :                     
    3177/    10EC : 0800 0017           	BTST.l	#23,d0				; test if string name
    3178/    10F0 : 6704                	BEQ.s		LAB_1D4B				; branch if not
    3179/    10F2 :                     
    3180/    10F2 : 5441                	ADDQ.w	#2,d1					; 6 bytes per string entry
    3181/    10F4 : 5848                	ADDQ.w	#(Sstrl-Svarl),a0			; move to string area
    3182/    10F6 :                     
    3183/    10F6 :                     LAB_1D4B
    3184/    10F6 : 2268 0004           	MOVEA.l	4(a0),a1				; get end address
    3185/    10FA : 2050                	MOVEA.l	(a0),a0				; get start address
    3186/    10FC : 6006                	BRA.s		LAB_1D5E				; enter loop at exit check
    3187/    10FE :                     
    3188/    10FE :                     LAB_1D5D
    3189/    10FE : B098                	CMP.l		(a0)+,d0				; compare this variable with name
    3190/    1100 : 6776                	BEQ.s		LAB_1DD7				; branch if match (found var)
    3191/    1102 :                     
    3192/    1102 : D1C1                	ADDA.l	d1,a0					; add offset to next variable
    3193/    1104 :                     LAB_1D5E
    3194/    1104 : B1C9                	CMPA.l	a1,a0					; compare address with variable space end
    3195/    1106 : 66F6                	BNE.s		LAB_1D5D				; if not end go check next
    3196/    1108 :                     
    3197/    1108 : 4A2B 05DF           	TST.b		Sufnxf(a3)				; is it a function or function variable
    3198/    110C : 660A                	BNE.s		LAB_1D94				; if was go do DEF or function variable
    3199/    110E :                     
    3200/    110E :                     								; reached end of variable mem without match
    3201/    110E :                     								; ... so create new variable, possibly
    3202/    110E :                     
    3203/    110E : 45FA FF60           	LEA		LAB_FVAR(pc),a2			; get the address of the create if doesn't
    3204/    1112 :                     								; exist call to LAB_GVAR
    3205/    1112 : B5D7                	CMPA.l	(sp),a2				; compare the return address with expected
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 58 - 10/11/2023 21:18:52


    3206/    1114 : 6600 F0C0           	BNE		LAB_UVER				; if not create go do error or return null
    3207/    1118 :                     
    3208/    1118 :                     ; this will only branch if the call to LAB_GVAR wasn't from LAB_SVAR
    3209/    1118 :                     
    3210/    1118 :                     LAB_1D94
    3211/    1118 : 082B 0000 05DF      	BTST.b	#0,Sufnxf(a3)			; test function search flag
    3212/    111E : 6600 F0BE           	BNE		LAB_UFER				; if not doing DEF then go do undefined
    3213/    1122 :                     								; function error
    3214/    1122 :                     
    3215/    1122 :                     								; else create new variable/function
    3216/    1122 :                     LAB_1D98
    3217/    1122 : 246B 0442           	MOVEA.l	Earryl(a3),a2			; get end of block to move
    3218/    1126 : 240A                	MOVE.l	a2,d2					; copy end of block to move
    3219/    1128 : 9489                	SUB.l		a1,d2					; calculate block to move size
    3220/    112A :                     
    3221/    112A : 204A                	MOVEA.l	a2,a0					; copy end of block to move
    3222/    112C : 5881                	ADDQ.l	#4,d1					; space for one variable/function + name
    3223/    112E : D5C1                	ADDA.l	d1,a2					; add space for one variable/function
    3224/    1130 : 274A 0442           	MOVE.l	a2,Earryl(a3)			; set new array mem end
    3225/    1134 : E28A                	LSR.l		#1,d2					; /2 for word copy
    3226/    1136 : 6712                	BEQ.s		LAB_1DAF				; skip move if zero length block
    3227/    1138 :                     
    3228/    1138 : 5382                	SUBQ.l	#1,d2					; -1 for DFB loop
    3229/    113A : 4842                	SWAP		d2					; swap high word to low word
    3230/    113C :                     LAB_1DAC
    3231/    113C : 4842                	SWAP		d2					; swap high word to low word
    3232/    113E :                     LAB_1DAE
    3233/    113E : 3520                	MOVE.w	-(a0),-(a2)				; copy word
    3234/    1140 : 51CA FFFC           	DBF		d2,LAB_1DAE				; loop until done
    3235/    1144 :                     
    3236/    1144 : 4842                	SWAP		d2					; swap high word to low word
    3237/    1146 : 51CA FFF4           	DBF		d2,LAB_1DAC				; decrement high count and loop until done
    3238/    114A :                     
    3239/    114A :                     ; get here after creating either a function, variable or string
    3240/    114A :                     ; if function set variables start, string start, array start
    3241/    114A :                     ; if variable set string start, array start
    3242/    114A :                     ; if string set array start
    3243/    114A :                     
    3244/    114A :                     LAB_1DAF
    3245/    114A : 4A2B 05DF           	TST.b		Sufnxf(a3)				; was it function
    3246/    114E : 6B08                	BMI.s		LAB_1DB0				; branch if was FN
    3247/    1150 :                     
    3248/    1150 : 0800 0017           	BTST.l	#23,d0				; was it string
    3249/    1154 : 660A                	BNE.s		LAB_1DB2				; branch if string
    3250/    1156 :                     
    3251/    1156 : 6004                	BRA.s		LAB_1DB1				; branch if was plain variable
    3252/    1158 :                     
    3253/    1158 :                     LAB_1DB0
    3254/    1158 : D3AB 0436           	ADD.l		d1,Svarl(a3)			; set new variable memory start
    3255/    115C :                     LAB_1DB1
    3256/    115C : D3AB 043A           	ADD.l		d1,Sstrl(a3)			; set new start of strings
    3257/    1160 :                     LAB_1DB2
    3258/    1160 : D3AB 043E           	ADD.l		d1,Sarryl(a3)			; set new array memory start
    3259/    1164 : 20C0                	MOVE.l	d0,(a0)+				; save variable/function name
    3260/    1166 : 20BC 0000 0000      	MOVE.l	#$00,(a0)				; initialise variable
    3261/    116C : 0800 0017           	BTST.l	#23,d0				; was it string
    3262/    1170 : 6706                	BEQ.s		LAB_1DD7				; branch if not string
    3263/    1172 :                     
    3264/    1172 : 317C 0000 0004      	MOVE.w	#$00,4(a0)				; else initialise string length
    3265/    1178 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 59 - 10/11/2023 21:18:52


    3266/    1178 :                     								; found a match for var ((Vrschl) = ptr)
    3267/    1178 :                     LAB_1DD7
    3268/    1178 : 2200                	MOVE.l	d0,d1					; ........ $....... &....... ........
    3269/    117A : D281                	ADD.l		d1,d1					; .......$ .......& ........ .......0
    3270/    117C : 4841                	SWAP		d1					; ........ .......0 .......$ .......&
    3271/    117E : E219                	ROR.b		#1,d1					; ........ .......0 .......$ &.......
    3272/    1180 : E249                	LSR.w		#1,d1					; ........ .......0 0....... $&......
    3273/    1182 : C23C 00C0           	AND.b		#$C0,d1				; mask the type bits
    3274/    1186 : 1741 05B5           	MOVE.b	d1,Dtypef(a3)			; save the data type
    3275/    118A :                     
    3276/    118A : 177C 0000 05DF      	MOVE.b	#$00,Sufnxf(a3)			; clear FN flag byte
    3277/    1190 : 4E75                	RTS
    3278/    1192 :                     
    3279/    1192 :                     
    3280/    1192 :                     ;************************************************************************************
    3281/    1192 :                     ;
    3282/    1192 :                     ; set-up array pointer, d0, to first element in array
    3283/    1192 :                     ; set d0 to (a0)+2*(Dimcnt)+$0A
    3284/    1192 :                     
    3285/    1192 :                     LAB_1DE6
    3286/    1192 : 7005                	MOVEQ		#5,d0					; set d0 to 5 (*2 = 10, later)
    3287/    1194 : D02B 05DB           	ADD.b		Dimcnt(a3),d0			; add # of dimensions (1, 2 or 3)
    3288/    1198 : D080                	ADD.l		d0,d0					; *2 (bytes per dimension size)
    3289/    119A : D088                	ADD.l		a0,d0					; add array start pointer
    3290/    119C : 4E75                	RTS
    3291/    119E :                     
    3292/    119E :                     
    3293/    119E :                     ;************************************************************************************
    3294/    119E :                     ;
    3295/    119E :                     ; evaluate unsigned integer expression
    3296/    119E :                     
    3297/    119E :                     LAB_EVIN
    3298/    119E : 6100 FCC0           	BSR		LAB_IGBY				; increment & scan memory
    3299/    11A2 : 6100 FB44           	BSR		LAB_EVNM				; evaluate expression & check is numeric,
    3300/    11A6 :                     								; else do type mismatch
    3301/    11A6 :                     
    3302/    11A6 :                     
    3303/    11A6 :                     ;************************************************************************************
    3304/    11A6 :                     ;
    3305/    11A6 :                     ; evaluate positive integer expression, result in d0 and Itemp
    3306/    11A6 :                     
    3307/    11A6 :                     LAB_EVPI
    3308/    11A6 : 4A2B 0595           	TST.b		FAC1_s(a3)				; test FAC1 sign (b7)
    3309/    11AA : 6B00 F062           	BMI		LAB_FCER				; do function call error if -ve
    3310/    11AE :                     
    3311/    11AE :                     
    3312/    11AE :                     ;************************************************************************************
    3313/    11AE :                     ;
    3314/    11AE :                     ; evaluate integer expression, no sign check
    3315/    11AE :                     ; result in d0 and Itemp, exit with flags set correctly
    3316/    11AE :                     
    3317/    11AE :                     LAB_EVIR
    3318/    11AE : 0C2B 00A0 0594      	CMPI.b	#$A0,FAC1_e(a3)			; compare exponent with exponent = 2^32 (n>2^31)
    3319/    11B4 : 6500 0B64           	BCS		LAB_2831				; convert FAC1 floating to fixed
    3320/    11B8 :                     								; result in d0 and Itemp
    3321/    11B8 : 6600 F054           	BNE		LAB_FCER				; if > do function call error, then warm start
    3322/    11BC :                     
    3323/    11BC : 4A2B 0595           	TST.b		FAC1_s(a3)				; test sign of FAC1
    3324/    11C0 : 6A00 0B58           	BPL		LAB_2831				; if +ve then ok
    3325/    11C4 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 60 - 10/11/2023 21:18:52


    3326/    11C4 : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get mantissa
    3327/    11C8 : 4480                	NEG.l		d0					; do -d0
    3328/    11CA : 6800 F042           	BVC		LAB_FCER				; if not $80000000 do FC error, then warm start
    3329/    11CE :                     
    3330/    11CE : 2740 042A           	MOVE.l	d0,Itemp(a3)			; else just set it
    3331/    11D2 : 4E75                	RTS
    3332/    11D4 :                     
    3333/    11D4 :                     
    3334/    11D4 :                     ;************************************************************************************
    3335/    11D4 :                     ;
    3336/    11D4 :                     ; find or make array
    3337/    11D4 :                     
    3338/    11D4 :                     LAB_1E17
    3339/    11D4 : 3F2B 05B4           	MOVE.w	Defdim(a3),-(sp)			; get DIM flag and data type flag (word in mem)
    3340/    11D8 : 7200                	MOVEQ		#0,d1					; clear dimensions count
    3341/    11DA :                     
    3342/    11DA :                     ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
    3343/    11DA :                     
    3344/    11DA :                     LAB_1E1F
    3345/    11DA : 3F01                	MOVE.w	d1,-(sp)				; save dimensions count
    3346/    11DC : 2F2B 046A           	MOVE.l	Varname(a3),-(sp)			; save variable name
    3347/    11E0 : 61BC                	BSR.s		LAB_EVIN				; evaluate integer expression
    3348/    11E2 :                     
    3349/    11E2 : 4840                	SWAP		d0					; swap high word to low word
    3350/    11E4 : 4A40                	TST.w		d0					; test swapped high word
    3351/    11E6 : 6600 F016           	BNE		LAB_ABER				; if too big do array bounds error
    3352/    11EA :                     
    3353/    11EA : 275F 046A           	MOVE.l	(sp)+,Varname(a3)			; restore variable name
    3354/    11EE : 321F                	MOVE.w	(sp)+,d1				; restore dimensions count
    3355/    11F0 : 301F                	MOVE.w	(sp)+,d0				; restore DIM and data type flags
    3356/    11F2 : 3F2B 042C           	MOVE.w	Itemp+2(a3),-(sp)			; stack this dimension size
    3357/    11F6 : 3F00                	MOVE.w	d0,-(sp)				; save DIM and data type flags
    3358/    11F8 : 5241                	ADDQ.w	#1,d1					; increment dimensions count
    3359/    11FA : 6100 FC66           	BSR		LAB_GBYT				; scan memory
    3360/    11FE : B03C 002C           	CMP.b		#$2C,d0				; compare with ","
    3361/    1202 : 67D6                	BEQ.s		LAB_1E1F				; if found go do next dimension
    3362/    1204 :                     
    3363/    1204 : 1741 05DB           	MOVE.b	d1,Dimcnt(a3)			; store dimensions count
    3364/    1208 : 6100 FC44           	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
    3365/    120C : 375F 05B4           	MOVE.w	(sp)+,Defdim(a3)			; restore DIM and data type flags (word in mem)
    3366/    1210 : 206B 043E           	MOVEA.l	Sarryl(a3),a0			; get array mem start
    3367/    1214 :                     
    3368/    1214 :                     ; now check to see if we are at the end of array memory (we would be if there were
    3369/    1214 :                     ; no arrays).
    3370/    1214 :                     
    3371/    1214 :                     LAB_1E5C
    3372/    1214 : 2748 05AC           	MOVE.l	a0,Astrtl(a3)			; save as array start pointer
    3373/    1218 : B1EB 0442           	CMPA.l	Earryl(a3),a0			; compare with array mem end
    3374/    121C : 672E                	BEQ.s		LAB_1EA1				; go build array if not found
    3375/    121E :                     
    3376/    121E :                     								; search for array
    3377/    121E : 2010                	MOVE.l	(a0),d0				; get this array name
    3378/    1220 : B0AB 046A           	CMP.l		Varname(a3),d0			; compare with array name
    3379/    1224 : 670A                	BEQ.s		LAB_1E8D				; array found so branch
    3380/    1226 :                     
    3381/    1226 :                     								; no match
    3382/    1226 : 2068 0004           	MOVEA.l	4(a0),a0				; get this array size
    3383/    122A : D1EB 05AC           	ADDA.l	Astrtl(a3),a0			; add to array start pointer
    3384/    122E : 60E4                	BRA.s		LAB_1E5C				; go check next array
    3385/    1230 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 61 - 10/11/2023 21:18:52


    3386/    1230 :                     								; found array, are we trying to dimension it?
    3387/    1230 :                     LAB_1E8D
    3388/    1230 : 4A2B 05B4           	TST.b		Defdim(a3)				; are we trying to dimension it?
    3389/    1234 : 6600 EFC4           	BNE		LAB_DDER				; if so do double dimension error/warm start
    3390/    1238 :                     
    3391/    1238 :                     ; found the array and we're not dimensioning it so we must find an element in it
    3392/    1238 :                     
    3393/    1238 : 6100 FF58           	BSR		LAB_1DE6				; set data pointer, d0, to the first element
    3394/    123C :                     								; in the array
    3395/    123C : 5048                	ADDQ.w	#8,a0					; index to dimension count
    3396/    123E : 3018                	MOVE.w	(a0)+,d0				; get no of dimensions
    3397/    1240 : B02B 05DB           	CMP.b		Dimcnt(a3),d0			; compare with dimensions count
    3398/    1244 : 6700 0094           	BEQ		LAB_1F28				; found array so go get element
    3399/    1248 :                     
    3400/    1248 : 6000 EF84           	BRA		LAB_WDER				; else wrong so do "Wrong dimensions" error
    3401/    124C :                     
    3402/    124C :                     								; array not found, so possibly build it
    3403/    124C :                     LAB_1EA1
    3404/    124C : 4A2B 05B4           	TST.b		Defdim(a3)				; test the default DIM flag
    3405/    1250 : 6700 EF80           	BEQ		LAB_UDER				; if default flag is clear then we are not
    3406/    1254 :                     								; explicitly dimensioning an array so go
    3407/    1254 :                     								; do an "Undimensioned array" error
    3408/    1254 :                     
    3409/    1254 : 6100 FF3C           	BSR		LAB_1DE6				; set data pointer, d0, to the first element
    3410/    1258 :                     								; in the array
    3411/    1258 : 202B 046A           	MOVE.l	Varname(a3),d0			; get array name
    3412/    125C : 20C0                	MOVE.l	d0,(a0)+				; save array name
    3413/    125E : 7204                	MOVEQ		#4,d1					; set 4 bytes per element
    3414/    1260 : 0800 0017           	BTST.l	#23,d0				; test if string array
    3415/    1264 : 6702                	BEQ.s		LAB_1EDF				; branch if not string
    3416/    1266 :                     
    3417/    1266 : 7206                	MOVEQ		#6,d1					; else 6 bytes per element
    3418/    1268 :                     LAB_1EDF
    3419/    1268 : 2741 05A8           	MOVE.l	d1,Asptl(a3)			; set array data size (bytes per element)
    3420/    126C : 122B 05DB           	MOVE.b	Dimcnt(a3),d1			; get dimensions count
    3421/    1270 : 5848                	ADDQ.w	#4,a0					; skip the array size now (don't know it yet!)
    3422/    1272 : 30C1                	MOVE.w	d1,(a0)+				; set array's dimensions count
    3423/    1274 :                     
    3424/    1274 :                     ; now calculate the array data space size
    3425/    1274 :                     
    3426/    1274 :                     LAB_1EC0
    3427/    1274 :                     
    3428/    1274 :                     ; If you want arrays to dimension themselves by default then comment out the test
    3429/    1274 :                     ; above and uncomment the next three code lines and the label LAB_1ED0
    3430/    1274 :                     
    3431/    1274 :                     ;	MOVE.w	#$0A,d1				; set default dimension value, allow 0 to 9
    3432/    1274 :                     ;	TST.b		Defdim(a3)				; test default DIM flag
    3433/    1274 :                     ;	BNE.s		LAB_1ED0				; branch if b6 of Defdim is clear
    3434/    1274 :                     
    3435/    1274 : 321F                	MOVE.w	(sp)+,d1				; get dimension size
    3436/    1276 :                     ;LAB_1ED0
    3437/    1276 : 30C1                	MOVE.w	d1,(a0)+				; save to array header
    3438/    1278 : 6100 00AE           	BSR		LAB_1F7C				; do this dimension size+1	; array size
    3439/    127C :                     								; (d1+1)*(Asptl), result in d0
    3440/    127C : 2740 05A8           	MOVE.l	d0,Asptl(a3)			; save array data size
    3441/    1280 : 532B 05DB           	SUBQ.b	#1,Dimcnt(a3)			; decrement dimensions count
    3442/    1284 : 66EE                	BNE.s		LAB_1EC0				; loop while not = 0
    3443/    1286 :                     
    3444/    1286 : D1EB 05A8           	ADDA.l	Asptl(a3),a0			; add size to first element address
    3445/    128A : 6500 EF7A           	BCS		LAB_OMER				; if overflow go do "Out of memory" error
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 62 - 10/11/2023 21:18:52


    3446/    128E :                     
    3447/    128E : B1EB 0446           	CMPA.l	Sstorl(a3),a0			; compare with bottom of string memory
    3448/    1292 : 650C                	BCS.s		LAB_1ED6				; branch if less (is ok)
    3449/    1294 :                     
    3450/    1294 : 6100 028E           	BSR		LAB_GARB				; do garbage collection routine
    3451/    1298 : B1EB 0446           	CMPA.l	Sstorl(a3),a0			; compare with bottom of string memory
    3452/    129C : 6400 EF68           	BCC		LAB_OMER				; if Sstorl <= a0 do "Out of memory"
    3453/    12A0 :                     								; error then warm start
    3454/    12A0 :                     
    3455/    12A0 :                     LAB_1ED6							; ok exit, carry set
    3456/    12A0 : 2748 0442           	MOVE.l	a0,Earryl(a3)			; save array mem end
    3457/    12A4 : 7000                	MOVEQ		#0,d0					; zero d0
    3458/    12A6 : 222B 05A8           	MOVE.l	Asptl(a3),d1			; get size in bytes
    3459/    12AA : E289                	LSR.l		#1,d1					; /2 for word fill (may be odd # words)
    3460/    12AC : 5341                	SUBQ.w	#1,d1					; adjust for DBF loop
    3461/    12AE :                     LAB_1ED8
    3462/    12AE : 3100                	MOVE.w	d0,-(a0)				; decrement pointer and clear word
    3463/    12B0 : 51C9 FFFC           	DBF		d1,LAB_1ED8				; decrement & loop until low word done
    3464/    12B4 :                     
    3465/    12B4 : 4841                	SWAP		d1					; swap words
    3466/    12B6 : 4A41                	TST.w		d1					; test high word
    3467/    12B8 : 6706                	BEQ.s		LAB_1F07				; exit if done
    3468/    12BA :                     
    3469/    12BA : 5341                	SUBQ.w	#1,d1					; decrement low (high) word
    3470/    12BC : 4841                	SWAP		d1					; swap back
    3471/    12BE : 60EE                	BRA.s		LAB_1ED8				; go do a whole block
    3472/    12C0 :                     
    3473/    12C0 :                     ; now we need to calculate the array size by doing Earryl - Astrtl
    3474/    12C0 :                     
    3475/    12C0 :                     LAB_1F07
    3476/    12C0 : 206B 05AC           	MOVEA.l	Astrtl(a3),a0			; get for calculation and as pointer
    3477/    12C4 : 202B 0442           	MOVE.l	Earryl(a3),d0			; get array memory end
    3478/    12C8 : 9088                	SUB.l		a0,d0					; calculate array size
    3479/    12CA : 2140 0004           	MOVE.l	d0,4(a0)				; save size to array
    3480/    12CE : 4A2B 05B4           	TST.b		Defdim(a3)				; test default DIM flag
    3481/    12D2 : 6652                	BNE.s		RTS_011				; exit (RET) if this was a DIM command
    3482/    12D4 :                     
    3483/    12D4 :                     								; else, find element
    3484/    12D4 : 5048                	ADDQ.w	#8,a0					; index to dimension count
    3485/    12D6 : 3758 05DB           	MOVE.w	(a0)+,Dimcnt(a3)			; get array's dimension count
    3486/    12DA :                     
    3487/    12DA :                     ; we have found, or built, the array. now we need to find the element
    3488/    12DA :                     
    3489/    12DA :                     LAB_1F28
    3490/    12DA : 7000                	MOVEQ		#0,d0					; clear first result
    3491/    12DC : 2740 05A8           	MOVE.l	d0,Asptl(a3)			; clear array data pointer
    3492/    12E0 :                     
    3493/    12E0 :                     ; compare nth dimension bound (a0) with nth index (sp)+
    3494/    12E0 :                     ; if greater do array bounds error
    3495/    12E0 :                     
    3496/    12E0 :                     LAB_1F2C
    3497/    12E0 : 3218                	MOVE.w	(a0)+,d1				; get nth dimension bound
    3498/    12E2 : B257                	CMP.w		(sp),d1				; compare nth index with nth dimension bound
    3499/    12E4 : 6500 EF18           	BCS		LAB_ABER				; if d1 less or = do array bounds error
    3500/    12E8 :                     
    3501/    12E8 :                     ; now do pointer = pointer	; nth dimension + nth index
    3502/    12E8 :                     
    3503/    12E8 : 4A80                	TST.l		d0					; test pointer
    3504/    12EA : 6702                	BEQ.s		LAB_1F5A				; skip multiply if last result = null
    3505/    12EC :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 63 - 10/11/2023 21:18:52


    3506/    12EC : 613A                	BSR.s		LAB_1F7C				; do this dimension size+1	; array size
    3507/    12EE :                     LAB_1F5A
    3508/    12EE : 7200                	MOVEQ		#0,d1					; clear longword
    3509/    12F0 : 321F                	MOVE.w	(sp)+,d1				; get nth dimension index
    3510/    12F2 : D081                	ADD.l		d1,d0					; add index to size
    3511/    12F4 : 2740 05A8           	MOVE.l	d0,Asptl(a3)			; save array data pointer
    3512/    12F8 :                     
    3513/    12F8 : 532B 05DB           	SUBQ.b	#1,Dimcnt(a3)			; decrement dimensions count
    3514/    12FC : 66E2                	BNE.s		LAB_1F2C				; loop if dimensions still to do
    3515/    12FE :                     
    3516/    12FE : 177C 0000 05B5      	MOVE.b	#0,Dtypef(a3)			; set data type to float
    3517/    1304 : 7203                	MOVEQ		#3,d1					; set for numeric array
    3518/    1306 : 4A2B 046B           	TST.b		Varname+1(a3)			; test if string array
    3519/    130A : 6A0A                	BPL.s		LAB_1F6A				; branch if not string
    3520/    130C :                     
    3521/    130C : 7205                	MOVEQ		#5,d1					; else set for string array
    3522/    130E : 177C 0080 05B5      	MOVE.b	#$80,Dtypef(a3)			; and set data type to string
    3523/    1314 : 600C                	BRA.s		LAB_1F6B				; skip integer test
    3524/    1316 :                     
    3525/    1316 :                     LAB_1F6A
    3526/    1316 : 4A2B 046C           	TST.b		Varname+2(a3)			; test if integer array
    3527/    131A : 6A06                	BPL.s		LAB_1F6B				; branch if not integer
    3528/    131C :                     
    3529/    131C : 177C 0040 05B5      	MOVE.b	#$40,Dtypef(a3)			; else set data type to integer
    3530/    1322 :                     LAB_1F6B
    3531/    1322 : 6104                	BSR.s		LAB_1F7C				; do element size (d1)	; array size (Asptl)
    3532/    1324 : D1C0                	ADDA.l	d0,a0					; add array data start pointer
    3533/    1326 :                     RTS_011
    3534/    1326 : 4E75                	RTS
    3535/    1328 :                     
    3536/    1328 :                     
    3537/    1328 :                     ;************************************************************************************
    3538/    1328 :                     ;
    3539/    1328 :                     ; do this dimension size (d1)	; array data size (Asptl)
    3540/    1328 :                     
    3541/    1328 :                     ; do a 16 x 32 bit multiply
    3542/    1328 :                     ; d1 holds the 16 bit multiplier
    3543/    1328 :                     ; Asptl holds the 32 bit multiplicand
    3544/    1328 :                     
    3545/    1328 :                     ; d0	bbbb  bbbb
    3546/    1328 :                     ; d1	0000  aaaa
    3547/    1328 :                     ;	----------
    3548/    1328 :                     ; d0	rrrr  rrrr
    3549/    1328 :                     
    3550/    1328 :                     LAB_1F7C
    3551/    1328 : 202B 05A8           	MOVE.l	Asptl(a3),d0			; get result
    3552/    132C : 2400                	MOVE.l	d0,d2					; copy it
    3553/    132E : 4842                	SWAP		d2					; shift high word to low word
    3554/    1330 : C0C1                	MULU.w	d1,d0					; d1	; low word = low result
    3555/    1332 : C4C1                	MULU.w	d1,d2					; d1	; high word = high result
    3556/    1334 : 4842                	SWAP		d2					; align words for test
    3557/    1336 : 4A42                	TST.w		d2					; must be zero
    3558/    1338 : 6600 EECC           	BNE		LAB_OMER				; if overflow go do "Out of memory" error
    3559/    133C :                     
    3560/    133C : D082                	ADD.l		d2,d0					; calculate result
    3561/    133E : 6500 EEC6           	BCS		LAB_OMER				; if overflow go do "Out of memory" error
    3562/    1342 :                     
    3563/    1342 : D0AB 05A8           	ADD.l		Asptl(a3),d0			; add original
    3564/    1346 : 6500 EEBE           	BCS		LAB_OMER				; if overflow go do "Out of memory" error
    3565/    134A :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 64 - 10/11/2023 21:18:52


    3566/    134A : 4E75                	RTS
    3567/    134C :                     
    3568/    134C :                     
    3569/    134C :                     ;************************************************************************************
    3570/    134C :                     ;
    3571/    134C :                     ; perform FRE()
    3572/    134C :                     
    3573/    134C :                     LAB_FRE
    3574/    134C : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
    3575/    1350 :                     								; $00=float
    3576/    1350 : 6A04                	BPL.s		LAB_1FB4				; branch if numeric
    3577/    1352 :                     
    3578/    1352 : 6100 0318           	BSR		LAB_22B6				; pop string off descriptor stack, or from
    3579/    1356 :                     								; top of string space, returns d0 = length,
    3580/    1356 :                     								; a0 = pointer
    3581/    1356 :                     
    3582/    1356 :                     								; FRE(n) was numeric so do this
    3583/    1356 :                     LAB_1FB4
    3584/    1356 : 6100 01CC           	BSR		LAB_GARB				; go do garbage collection
    3585/    135A : 202B 0446           	MOVE.l	Sstorl(a3),d0			; get bottom of string space
    3586/    135E : 90AB 0442           	SUB.l		Earryl(a3),d0			; subtract array mem end
    3587/    1362 :                     
    3588/    1362 :                     
    3589/    1362 :                     ;************************************************************************************
    3590/    1362 :                     ;
    3591/    1362 :                     ; convert d0 to signed longword in FAC1
    3592/    1362 :                     
    3593/    1362 :                     LAB_AYFC
    3594/    1362 : 177C 0000 05B5      	MOVE.b	#$00,Dtypef(a3)			; clear data type, $80=string, $40=integer,
    3595/    1368 :                     								; $00=float
    3596/    1368 : 377C A000 0594      	MOVE.w	#$A000,FAC1_e(a3)			; set FAC1 exponent and clear sign (b7)
    3597/    136E : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; save FAC1 mantissa
    3598/    1372 : 6A00 0640           	BPL		LAB_24D0				; convert if +ve
    3599/    1376 :                     
    3600/    1376 : 003C 0001           	ORI.b		#1,CCR				; else set carry
    3601/    137A : 6000 0638           	BRA		LAB_24D0				; do +/- (carry is sign) & normalise FAC1
    3602/    137E :                     
    3603/    137E :                     
    3604/    137E :                     ;************************************************************************************
    3605/    137E :                     ;
    3606/    137E :                     ; remember if the line length is zero (infinite line) then POS(n) will return
    3607/    137E :                     ; position MOD tabsize
    3608/    137E :                     
    3609/    137E :                     ; perform POS()
    3610/    137E :                     
    3611/    137E :                     LAB_POS
    3612/    137E : 102B 05E5           	MOVE.b	TPos(a3),d0				; get terminal position
    3613/    1382 :                     
    3614/    1382 :                     ; convert d0 to unsigned byte in FAC1
    3615/    1382 :                     
    3616/    1382 :                     LAB_1FD0
    3617/    1382 : C0BC 0000 00FF      	AND.l		#$FF,d0				; clear high bits
    3618/    1388 : 60D8                	BRA.s		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
    3619/    138A :                     
    3620/    138A :                     ; check not direct (used by DEF and INPUT)
    3621/    138A :                     
    3622/    138A :                     LAB_CKRN
    3623/    138A : 4A2B 0452           	TST.b		Clinel(a3)				; test current line #
    3624/    138E : 6B00 EE62           	BMI		LAB_IDER				; if -ve go do illegal direct error then warm
    3625/    1392 :                     								; start
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 65 - 10/11/2023 21:18:52


    3626/    1392 :                     
    3627/    1392 : 4E75                	RTS							; can continue so return
    3628/    1394 :                     
    3629/    1394 :                     
    3630/    1394 :                     ;************************************************************************************
    3631/    1394 :                     ;
    3632/    1394 :                     ; perform DEF
    3633/    1394 :                     
    3634/    1394 :                     LAB_DEF
    3635/    1394 : 70AB                	MOVEQ		#TK_FN-$100,d0			; get FN token
    3636/    1396 : 6100 FAC0           	BSR		LAB_SCCA				; scan for CHR$(d0), else syntax error and
    3637/    139A :                     								; warm start
    3638/    139A :                     								; return character after d0
    3639/    139A : 177C 0080 05DF      	MOVE.b	#$80,Sufnxf(a3)			; set FN flag bit
    3640/    13A0 : 6100 FCDA           	BSR		LAB_1D12				; get FN name
    3641/    13A4 : 2748 05B0           	MOVE.l	a0,func_l(a3)			; save function pointer
    3642/    13A8 :                     
    3643/    13A8 : 61E0                	BSR.s		LAB_CKRN				; check not direct (back here if ok)
    3644/    13AA : 0C1D 0028           	CMP.b		#$28,(a5)+				; check next byte is "(" and increment
    3645/    13AE : 6600 EE6A           	BNE		LAB_SNER				; else do syntax error/warm start
    3646/    13B2 :                     
    3647/    13B2 : 177C 007E 05DF      	MOVE.b	#$7E,Sufnxf(a3)			; set FN variable flag bits
    3648/    13B8 : 6100 FCB4           	BSR		LAB_SVAR				; search for or create a variable
    3649/    13BC :                     								; return the variable address in a0
    3650/    13BC : 6100 FA90           	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
    3651/    13C0 : 70BD                	MOVEQ		#TK_EQUAL-$100,d0			; = token
    3652/    13C2 : 6100 FA94           	BSR		LAB_SCCA				; scan for CHR$(A), else syntax error/warm start
    3653/    13C6 :                     								; return character after d0
    3654/    13C6 : 2F2B 046A           	MOVE.l	Varname(a3),-(sp)			; push current variable name
    3655/    13CA : 2F0D                	MOVE.l	a5,-(sp)				; push BASIC execute pointer
    3656/    13CC : 6100 F412           	BSR		LAB_DATA				; go perform DATA, find end of DEF FN statement
    3657/    13D0 : 206B 05B0           	MOVEA.l	func_l(a3),a0			; get the function pointer
    3658/    13D4 : 209F                	MOVE.l	(sp)+,(a0)				; save BASIC execute pointer to function
    3659/    13D6 : 215F 0004           	MOVE.l	(sp)+,4(a0)				; save current variable name to function
    3660/    13DA : 4E75                	RTS
    3661/    13DC :                     
    3662/    13DC :                     
    3663/    13DC :                     ;************************************************************************************
    3664/    13DC :                     ;
    3665/    13DC :                     ; evaluate FNx
    3666/    13DC :                     
    3667/    13DC :                     LAB_201E
    3668/    13DC : 177C 0081 05DF      	MOVE.b	#$81,Sufnxf(a3)			; set FN flag (find not create)
    3669/    13E2 : 6100 FA7C           	BSR		LAB_IGBY				; increment & scan memory
    3670/    13E6 : 6100 FC94           	BSR		LAB_1D12				; get FN name
    3671/    13EA : 1F2B 05B5           	MOVE.b	Dtypef(a3),-(sp)			; push data type flag (function type)
    3672/    13EE : 2F08                	MOVE.l	a0,-(sp)				; push function pointer
    3673/    13F0 : 0C15 0028           	CMP.b		#$28,(a5)				; check next byte is "(", no increment
    3674/    13F4 : 6600 EE24           	BNE		LAB_SNER				; else do syntax error/warm start
    3675/    13F8 :                     
    3676/    13F8 : 6100 FA50           	BSR		LAB_1BF7				; evaluate expression within parentheses
    3677/    13FC : 205F                	MOVEA.l	(sp)+,a0				; pop function pointer
    3678/    13FE : 2748 05B0           	MOVE.l	a0,func_l(a3)			; set function pointer
    3679/    1402 : 1F2B 05B5           	MOVE.b	Dtypef(a3),-(sp)			; push data type flag (function expression type)
    3680/    1406 :                     
    3681/    1406 : 2028 0004           	MOVE.l	4(a0),d0				; get function variable name
    3682/    140A : 6100 FCDA           	BSR		LAB_1D4A				; go find function variable (already created)
    3683/    140E :                     
    3684/    140E :                     								; now check type match for variable
    3685/    140E : 101F                	MOVE.b	(sp)+,d0				; pop data type flag (function expression type)
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 66 - 10/11/2023 21:18:52


    3686/    1410 : E318                	ROL.b		#1,d0					; set carry if type = string
    3687/    1412 : 6100 F8D8           	BSR		LAB_CKTM				; type match check, set C for string
    3688/    1416 :                     
    3689/    1416 :                     								; now stack the function variable value before
    3690/    1416 :                     								; use
    3691/    1416 : 6712                	BEQ.s		LAB_2043				; branch if not string
    3692/    1418 :                     
    3693/    1418 : 43EB 0476           	LEA		des_sk_e(a3),a1			; get string stack pointer max+1
    3694/    141C : B9C9                	CMPA.l	a1,a4					; compare string stack pointer with max+1
    3695/    141E : 6700 EDC6           	BEQ		LAB_SCER				; if no space on the stack go do string too
    3696/    1422 :                     								; complex error
    3697/    1422 :                     
    3698/    1422 : 3928 0004           	MOVE.w	4(a0),-(a4)				; string length on descriptor stack
    3699/    1426 : 2910                	MOVE.l	(a0),-(a4)				; string address on stack
    3700/    1428 : 6002                	BRA.s		LAB_204S				; skip var push
    3701/    142A :                     
    3702/    142A :                     LAB_2043
    3703/    142A : 2F10                	MOVE.l	(a0),-(sp)				; push variable
    3704/    142C :                     LAB_204S
    3705/    142C : 2F08                	MOVE.l	a0,-(sp)				; push variable address
    3706/    142E : 1F2B 05B5           	MOVE.b	Dtypef(a3),-(sp)			; push variable data type
    3707/    1432 :                     
    3708/    1432 : 6132                	BSR.s		LAB_2045				; pack function expression value into (a0)
    3709/    1434 :                     								; (function variable)
    3710/    1434 : 2F0D                	MOVE.l	a5,-(sp)				; push BASIC execute pointer
    3711/    1436 : 206B 05B0           	MOVEA.l	func_l(a3),a0			; get function pointer
    3712/    143A : 2A50                	MOVEA.l	(a0),a5				; save function execute ptr as BASIC execute ptr
    3713/    143C : 6100 F8C2           	BSR		LAB_EVEX				; evaluate expression
    3714/    1440 : 6100 FA20           	BSR		LAB_GBYT				; scan memory
    3715/    1444 : 6600 EDD4           	BNE		LAB_SNER				; if not [EOL] or [EOS] do syntax error and
    3716/    1448 :                     								; warm start
    3717/    1448 :                     
    3718/    1448 : 2A5F                	MOVE.l	(sp)+,a5				; restore BASIC execute pointer
    3719/    144A :                     
    3720/    144A :                     ; restore variable from stack and test data type
    3721/    144A :                     
    3722/    144A : 101F                	MOVE.b	(sp)+,d0				; pull variable data type
    3723/    144C : 205F                	MOVEA.l	(sp)+,a0				; pull variable address
    3724/    144E : 4A00                	TST.b		d0					; test variable data type
    3725/    1450 : 6A08                	BPL.s		LAB_204T				; branch if not string
    3726/    1452 :                     
    3727/    1452 : 209C                	MOVE.l	(a4)+,(a0)				; string address from descriptor stack
    3728/    1454 : 315C 0004           	MOVE.w	(a4)+,4(a0)				; string length from descriptor stack
    3729/    1458 : 6002                	BRA.s		LAB_2044				; skip variable pull
    3730/    145A :                     
    3731/    145A :                     LAB_204T
    3732/    145A : 209F                	MOVE.l	(sp)+,(a0)				; restore variable from stack
    3733/    145C :                     LAB_2044
    3734/    145C : 101F                	MOVE.b	(sp)+,d0				; pop data type flag (function type)
    3735/    145E : E318                	ROL.b		#1,d0					; set carry if type = string
    3736/    1460 : 6100 F88A           	BSR		LAB_CKTM				; type match check, set C for string
    3737/    1464 : 4E75                	RTS
    3738/    1466 :                     
    3739/    1466 :                     LAB_2045
    3740/    1466 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type
    3741/    146A : 6A00 07F0           	BPL		LAB_2778				; if numeric pack FAC1 into variable (a0)
    3742/    146E :                     								; and return
    3743/    146E :                     
    3744/    146E : 2448                	MOVEA.l	a0,a2					; copy variable pointer
    3745/    1470 : 6000 F512           	BRA		LAB_17D6				; go do string LET & return
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 67 - 10/11/2023 21:18:52


    3746/    1474 :                     
    3747/    1474 :                     
    3748/    1474 :                     
    3749/    1474 :                     ;************************************************************************************
    3750/    1474 :                     ;
    3751/    1474 :                     ; perform STR$()
    3752/    1474 :                     
    3753/    1474 :                     LAB_STRS
    3754/    1474 : 6100 0950           	BSR		LAB_2970				; convert FAC1 to string
    3755/    1478 :                     
    3756/    1478 :                     ; scan, set up string
    3757/    1478 :                     ; print " terminated string to FAC1 stack
    3758/    1478 :                     
    3759/    1478 :                     LAB_20AE
    3760/    1478 : 7422                	MOVEQ		#$22,d2				; set Srchc character (terminator 1)
    3761/    147A : 3602                	MOVE.w	d2,d3					; set Asrch character (terminator 2)
    3762/    147C :                     
    3763/    147C :                     ; print d2/d3 terminated string to FAC1 stack
    3764/    147C :                     ; d2 = Srchc, d3 = Asrch, a0 is source
    3765/    147C :                     ; a6 is temp
    3766/    147C :                     
    3767/    147C :                     LAB_20B4
    3768/    147C : 7200                	MOVEQ		#0,d1					; clear longword
    3769/    147E : 5341                	SUBQ.w	#1,d1					; set length to -1
    3770/    1480 : 2448                	MOVEA.l	a0,a2					; copy start to calculate end
    3771/    1482 :                     LAB_20BE
    3772/    1482 : 5241                	ADDQ.w	#1,d1					; increment length
    3773/    1484 : 1030 1000           	MOVE.b	(a0,d1.w),d0			; get byte from string
    3774/    1488 : 6710                	BEQ.s		LAB_20D0				; exit loop if null byte [EOS]
    3775/    148A :                     
    3776/    148A : B002                	CMP.b		d2,d0					; compare with search character (terminator 1)
    3777/    148C : 6704                	BEQ.s		LAB_20CB				; branch if terminator
    3778/    148E :                     
    3779/    148E : B003                	CMP.b		d3,d0					; compare with terminator 2
    3780/    1490 : 66F0                	BNE.s		LAB_20BE				; loop if not terminator 2 (or null string)
    3781/    1492 :                     
    3782/    1492 :                     LAB_20CB
    3783/    1492 : B03C 0022           	CMP.b		#$22,d0				; compare with "
    3784/    1496 : 6602                	BNE.s		LAB_20D0				; branch if not "
    3785/    1498 :                     
    3786/    1498 : 524A                	ADDQ.w	#1,a2					; else increment string start (skip " at end)
    3787/    149A :                     LAB_20D0
    3788/    149A : D5C1                	ADDA.l	d1,a2					; add longowrd length to make string end+1
    3789/    149C :                     
    3790/    149C : B1CB                	CMPA.l	a3,a0					; is string in ram
    3791/    149E : 651E                	BCS.s		LAB_RTST				; if not go push descriptor on stack & exit
    3792/    14A0 :                     								; (could be message string from ROM)
    3793/    14A0 :                     
    3794/    14A0 : B1EB 042E           	CMPA.l	Smeml(a3),a0			; is string in utility ram
    3795/    14A4 : 6418                	BCC.s		LAB_RTST				; if not go push descriptor on stack & exit
    3796/    14A6 :                     								; (is in string or program space)
    3797/    14A6 :                     
    3798/    14A6 :                     								; (else) copy string to string memory
    3799/    14A6 :                     LAB_20C9
    3800/    14A6 : 2248                	MOVEA.l	a0,a1					; copy descriptor pointer
    3801/    14A8 : 2001                	MOVE.l	d1,d0					; copy longword length
    3802/    14AA : 6604                	BNE.s		LAB_20D8				; branch if not null string
    3803/    14AC :                     
    3804/    14AC : 2041                	MOVEA.l	d1,a0					; make null pointer
    3805/    14AE : 600E                	BRA.s		LAB_RTST				; go push descriptor on stack & exit
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 68 - 10/11/2023 21:18:52


    3806/    14B0 :                     
    3807/    14B0 :                     LAB_20D8
    3808/    14B0 : 6126                	BSR.s		LAB_2115				; make string space d1 bytes long
    3809/    14B2 : D1C1                	ADDA.l	d1,a0					; new string end
    3810/    14B4 : D3C1                	ADDA.l	d1,a1					; old string end
    3811/    14B6 : 5340                	SUBQ.w	#1,d0					; -1 for DBF loop
    3812/    14B8 :                     LAB_20E0
    3813/    14B8 : 1121                	MOVE.b	-(a1),-(a0)				; copy byte (source can be odd aligned)
    3814/    14BA : 51C8 FFFC           	DBF		d0,LAB_20E0				; loop until done
    3815/    14BE :                     
    3816/    14BE :                     
    3817/    14BE :                     
    3818/    14BE :                     ;************************************************************************************
    3819/    14BE :                     ;
    3820/    14BE :                     ; check for space on descriptor stack then ...
    3821/    14BE :                     ; put string address and length on descriptor stack & update stack pointers
    3822/    14BE :                     ; start is in a0, length is in d1
    3823/    14BE :                     
    3824/    14BE :                     LAB_RTST
    3825/    14BE : 43EB 0476           	LEA		des_sk_e(a3),a1			; get string stack pointer max+1
    3826/    14C2 : B9C9                	CMPA.l	a1,a4					; compare string stack pointer with max+1
    3827/    14C4 : 6700 ED20           	BEQ		LAB_SCER				; if no space on string stack ..
    3828/    14C8 :                     								; .. go do 'string too complex' error
    3829/    14C8 :                     
    3830/    14C8 :                     								; push string & update pointers
    3831/    14C8 : 3901                	MOVE.w	d1,-(a4)				; string length on descriptor stack
    3832/    14CA : 2908                	MOVE.l	a0,-(a4)				; string address on stack
    3833/    14CC : 274C 0590           	MOVE.l	a4,FAC1_m(a3)			; string descriptor pointer in FAC1
    3834/    14D0 : 177C 0080 05B5      	MOVE.b	#$80,Dtypef(a3)			; save data type flag, $80=string
    3835/    14D6 : 4E75                	RTS
    3836/    14D8 :                     
    3837/    14D8 :                     
    3838/    14D8 :                     ;************************************************************************************
    3839/    14D8 :                     ;
    3840/    14D8 :                     ; build descriptor a0/d1
    3841/    14D8 :                     ; make space in string memory for string d1.w long
    3842/    14D8 :                     ; return pointer in a0/Sutill
    3843/    14D8 :                     
    3844/    14D8 :                     LAB_2115
    3845/    14D8 : 4A41                	TST.w		d1					; test length
    3846/    14DA : 672E                	BEQ.s		LAB_2128				; branch if user wants null string
    3847/    14DC :                     
    3848/    14DC :                     								; make space for string d1 long
    3849/    14DC : 2F00                	MOVE.l	d0,-(sp)				; save d0
    3850/    14DE : 7000                	MOVEQ		#0,d0					; clear longword
    3851/    14E0 : 1740 05DE           	MOVE.b	d0,Gclctd(a3)			; clear garbage collected flag (b7)
    3852/    14E4 : 7001                	MOVEQ		#1,d0					; +1 to possibly round up
    3853/    14E6 : C041                	AND.w		d1,d0					; mask odd bit
    3854/    14E8 : D041                	ADD.w		d1,d0					; ensure d0 is even length
    3855/    14EA : 6404                	BCC.s		LAB_2117				; branch if no overflow
    3856/    14EC :                     
    3857/    14EC : 7001                	MOVEQ		#1,d0					; set to allocate 65536 bytes
    3858/    14EE : 4840                	SWAP		d0					; makes $00010000
    3859/    14F0 :                     LAB_2117
    3860/    14F0 : 206B 0446           	MOVEA.l	Sstorl(a3),a0			; get bottom of string space
    3861/    14F4 : 91C0                	SUBA.l	d0,a0					; subtract string length
    3862/    14F6 : B1EB 0442           	CMPA.l	Earryl(a3),a0			; compare with top of array space
    3863/    14FA : 6512                	BCS.s		LAB_2137				; if less do out of memory error
    3864/    14FC :                     
    3865/    14FC : 2748 0446           	MOVE.l	a0,Sstorl(a3)			; save bottom of string space
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 69 - 10/11/2023 21:18:52


    3866/    1500 : 2748 044E           	MOVE.l	a0,Sutill(a3)			; save string utility pointer
    3867/    1504 : 201F                	MOVE.l	(sp)+,d0				; restore d0
    3868/    1506 : 4A41                	TST.w		d1					; set flags on length
    3869/    1508 : 4E75                	RTS
    3870/    150A :                     
    3871/    150A :                     LAB_2128
    3872/    150A : 3041                	MOVEA.w	d1,a0					; make null pointer
    3873/    150C : 4E75                	RTS
    3874/    150E :                     
    3875/    150E :                     LAB_2137
    3876/    150E : 4A2B 05DE           	TST.b		Gclctd(a3)				; get garbage collected flag
    3877/    1512 : 6B00 ECF2           	BMI		LAB_OMER				; do "Out of memory" error, then warm start
    3878/    1516 :                     
    3879/    1516 : 2F09                	MOVE.l	a1,-(sp)				; save a1
    3880/    1518 : 610A                	BSR.s		LAB_GARB				; else go do garbage collection
    3881/    151A : 225F                	MOVEA.l	(sp)+,a1				; restore a1
    3882/    151C : 177C 0080 05DE      	MOVE.b	#$80,Gclctd(a3)			; set garbage collected flag
    3883/    1522 : 60CC                	BRA.s		LAB_2117				; go try again
    3884/    1524 :                     
    3885/    1524 :                     
    3886/    1524 :                     ;************************************************************************************
    3887/    1524 :                     ;
    3888/    1524 :                     ; garbage collection routine
    3889/    1524 :                     
    3890/    1524 :                     LAB_GARB
    3891/    1524 : 48E7 E0E0           	MOVEM.l	d0-d2/a0-a2,-(sp)			; save registers
    3892/    1528 : 276B 044A 0446      	MOVE.l	Ememl(a3),Sstorl(a3)		; start with no strings
    3893/    152E :                     
    3894/    152E :                     								; re-run routine from last ending
    3895/    152E :                     LAB_214B
    3896/    152E : 222B 0442           	MOVE.l	Earryl(a3),d1			; set highest uncollected string so far
    3897/    1532 : 7000                	MOVEQ		#0,d0					; clear longword
    3898/    1534 : 2240                	MOVEA.l	d0,a1					; clear string to move pointer
    3899/    1536 : 206B 043A           	MOVEA.l	Sstrl(a3),a0			; set pointer to start of strings
    3900/    153A : 41E8 0004           	LEA		4(a0),a0				; index to string pointer
    3901/    153E : 246B 043E           	MOVEA.l	Sarryl(a3),a2			; set end pointer to start of arrays (end of
    3902/    1542 :                     								; strings)
    3903/    1542 : 6008                	BRA.s		LAB_2176				; branch into loop at end loop test
    3904/    1544 :                     
    3905/    1544 :                     LAB_2161
    3906/    1544 : 6100 0084           	BSR		LAB_2206				; test and set if this is the highest string
    3907/    1548 : 41E8 000A           	LEA		10(a0),a0				; increment to next string
    3908/    154C :                     LAB_2176
    3909/    154C : B1CA                	CMPA.l	a2,a0					; compare end of area with pointer
    3910/    154E : 65F4                	BCS.s		LAB_2161				; go do next if not at end
    3911/    1550 :                     
    3912/    1550 :                     ; done strings, now do arrays.
    3913/    1550 :                     
    3914/    1550 : 41E8 FFFC           	LEA		-4(a0),a0				; decrement pointer to start of arrays
    3915/    1554 : 246B 0442           	MOVEA.l	Earryl(a3),a2			; set end pointer to end of arrays
    3916/    1558 : 6024                	BRA.s		LAB_218F				; branch into loop at end loop test
    3917/    155A :                     
    3918/    155A :                     LAB_217E
    3919/    155A : 2428 0004           	MOVE.l	4(a0),d2				; get array size
    3920/    155E : D488                	ADD.l		a0,d2					; makes start of next array
    3921/    1560 :                     
    3922/    1560 : 2010                	MOVE.l	(a0),d0				; get array name
    3923/    1562 : 0800 0017           	BTST		#23,d0				; test string flag
    3924/    1566 : 6714                	BEQ.s		LAB_218B				; branch if not string
    3925/    1568 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 70 - 10/11/2023 21:18:52


    3926/    1568 : 3028 0008           	MOVE.w	8(a0),d0				; get # of dimensions
    3927/    156C : D040                	ADD.w		d0,d0					; *2
    3928/    156E : D0C0                	ADDA.w	d0,a0					; add to skip dimension size(s)
    3929/    1570 : 41E8 000A           	LEA		10(a0),a0				; increment to first element
    3930/    1574 :                     LAB_2183
    3931/    1574 : 6154                	BSR.s		LAB_2206				; test and set if this is the highest string
    3932/    1576 : 5C48                	ADDQ.w	#6,a0					; increment to next element
    3933/    1578 : B1C2                	CMPA.l	d2,a0					; compare with start of next array
    3934/    157A : 66F8                	BNE.s		LAB_2183				; go do next if not at end of array
    3935/    157C :                     
    3936/    157C :                     LAB_218B
    3937/    157C : 2042                	MOVEA.l	d2,a0					; pointer to next array
    3938/    157E :                     LAB_218F
    3939/    157E : B5C8                	CMPA.l	a0,a2					; compare pointer with array end
    3940/    1580 : 66D8                	BNE.s		LAB_217E				; go do next if not at end
    3941/    1582 :                     
    3942/    1582 :                     ; done arrays and variables, now just the descriptor stack to do
    3943/    1582 :                     
    3944/    1582 : 204C                	MOVEA.l	a4,a0					; get descriptor stack pointer
    3945/    1584 : 45EB 048E           	LEA		des_sk(a3),a2			; set end pointer to end of stack
    3946/    1588 : 6006                	BRA.s		LAB_21C4				; branch into loop at end loop test
    3947/    158A :                     
    3948/    158A :                     LAB_21C2
    3949/    158A : 613E                	BSR.s		LAB_2206				; test and set if this is the highest string
    3950/    158C : 41E8 0006           	LEA		6(a0),a0				; increment to next string
    3951/    1590 :                     LAB_21C4
    3952/    1590 : B5C8                	CMPA.l	a0,a2					; compare pointer with stack end
    3953/    1592 : 66F6                	BNE.s		LAB_21C2				; go do next if not at end
    3954/    1594 :                     
    3955/    1594 :                     ; descriptor search complete, now either exit or set-up and move string
    3956/    1594 :                     
    3957/    1594 : 2009                	MOVE.l	a1,d0					; set the flags (a1 is move string)
    3958/    1596 : 672C                	BEQ.s		LAB_21D1				; go tidy up and exit if no move
    3959/    1598 :                     
    3960/    1598 : 2051                	MOVEA.l	(a1),a0				; a0 is now string start
    3961/    159A : 7200                	MOVEQ		#0,d1					; clear d1
    3962/    159C : 3229 0004           	MOVE.w	4(a1),d1				; d1 is string length
    3963/    15A0 : 5281                	ADDQ.l	#1,d1					; +1
    3964/    15A2 : C23C 00FE           	AND.b		#$FE,d1				; make even length
    3965/    15A6 : D1C1                	ADDA.l	d1,a0					; pointer is now to string end+1
    3966/    15A8 : 246B 0446           	MOVEA.l	Sstorl(a3),a2			; is destination end+1
    3967/    15AC : B1CA                	CMPA.l	a2,a0					; does the string need moving
    3968/    15AE : 670C                	BEQ.s		LAB_2240				; branch if not
    3969/    15B0 :                     
    3970/    15B0 : E289                	LSR.l		#1,d1					; word move so do /2
    3971/    15B2 : 5341                	SUBQ.w	#1,d1					; -1 for DBF loop
    3972/    15B4 :                     LAB_2216
    3973/    15B4 : 3520                	MOVE.w	-(a0),-(a2)				; copy word
    3974/    15B6 : 51C9 FFFC           	DBF		d1,LAB_2216				; loop until done
    3975/    15BA :                     
    3976/    15BA : 228A                	MOVE.l	a2,(a1)				; save new string start
    3977/    15BC :                     LAB_2240
    3978/    15BC : 2751 0446           	MOVE.l	(a1),Sstorl(a3)			; string start is new string mem start
    3979/    15C0 : 6000 FF6C           	BRA		LAB_214B				; re-run routine from last ending
    3980/    15C4 :                     								; (but don't collect this string)
    3981/    15C4 :                     
    3982/    15C4 :                     LAB_21D1
    3983/    15C4 : 4CDF 0707           	MOVEM.l	(sp)+,d0-d2/a0-a2			; restore registers
    3984/    15C8 : 4E75                	RTS
    3985/    15CA :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 71 - 10/11/2023 21:18:52


    3986/    15CA :                     ; test and set if this is the highest string
    3987/    15CA :                     
    3988/    15CA :                     LAB_2206
    3989/    15CA : 2010                	MOVE.l	(a0),d0				; get this string pointer
    3990/    15CC : 6728                	BEQ.s		RTS_012				; exit if null string
    3991/    15CE :                     
    3992/    15CE : B280                	CMP.l		d0,d1					; compare with highest uncollected string so far
    3993/    15D0 : 6424                	BCC.s		RTS_012				; exit if <= with highest so far
    3994/    15D2 :                     
    3995/    15D2 : B0AB 0446           	CMP.l		Sstorl(a3),d0			; compare with bottom of string space
    3996/    15D6 : 641E                	BCC.s		RTS_012				; exit if >= bottom of string space
    3997/    15D8 :                     
    3998/    15D8 : 70FF                	MOVEQ		#-1,d0				; d0 = $FFFFFFFF
    3999/    15DA : 3028 0004           	MOVE.w	4(a0),d0				; d0 is string length
    4000/    15DE : 4440                	NEG.w		d0					; make -ve
    4001/    15E0 : C03C 00FE           	AND.b		#$FE,d0				; make -ve even length
    4002/    15E4 : D0AB 0446           	ADD.l		Sstorl(a3),d0			; add string store to -ve length
    4003/    15E8 : B090                	CMP.l		(a0),d0				; compare with string address
    4004/    15EA : 6706                	BEQ.s		LAB_2212				; if = go move string store pointer down
    4005/    15EC :                     
    4006/    15EC : 2210                	MOVE.l	(a0),d1				; highest = current
    4007/    15EE : 2248                	MOVEA.l	a0,a1					; string to move = current
    4008/    15F0 : 4E75                	RTS
    4009/    15F2 :                     
    4010/    15F2 :                     LAB_2212
    4011/    15F2 : 2740 0446           	MOVE.l	d0,Sstorl(a3)			; set new string store start
    4012/    15F6 :                     RTS_012
    4013/    15F6 : 4E75                	RTS
    4014/    15F8 :                     
    4015/    15F8 :                     
    4016/    15F8 :                     ;************************************************************************************
    4017/    15F8 :                     ;
    4018/    15F8 :                     ; concatenate - add strings
    4019/    15F8 :                     ; string descriptor 1 is in FAC1_m, string 2 is in line
    4020/    15F8 :                     
    4021/    15F8 :                     LAB_224D
    4022/    15F8 : 487A F738           	PEA		LAB_1ADB(pc)			; continue evaluation after concatenate
    4023/    15FC : 2F2B 0590           	MOVE.l	FAC1_m(a3),-(sp)			; stack descriptor pointer for string 1
    4024/    1600 :                     
    4025/    1600 : 6100 F80C           	BSR		LAB_GVAL				; get value from line
    4026/    1604 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type flag
    4027/    1608 : 6A00 EBE4           	BPL		LAB_TMER				; if type is not string do type mismatch error
    4028/    160C :                     
    4029/    160C : 205F                	MOVEA.l	(sp)+,a0				; restore descriptor pointer for string 1
    4030/    160E :                     
    4031/    160E :                     ;************************************************************************************
    4032/    160E :                     ;
    4033/    160E :                     ; concatenate
    4034/    160E :                     ; string descriptor 1 is in a0, string descriptor 2 is in FAC1_m
    4035/    160E :                     
    4036/    160E :                     LAB_224E
    4037/    160E : 226B 0590           	MOVEA.l	FAC1_m(a3),a1			; copy descriptor pointer 2
    4038/    1612 : 3228 0004           	MOVE.w	4(a0),d1				; get length 1
    4039/    1616 : D269 0004           	ADD.w		4(a1),d1				; add length 2
    4040/    161A : 6500 EBCE           	BCS		LAB_SLER				; if overflow go do 'string too long' error
    4041/    161E :                     
    4042/    161E : 2F08                	MOVE.l	a0,-(sp)				; save descriptor pointer 1
    4043/    1620 : 6100 FEB6           	BSR		LAB_2115				; make space d1 bytes long
    4044/    1624 : 2748 0598           	MOVE.l	a0,FAC2_m(a3)			; save new string start pointer
    4045/    1628 : 2057                	MOVEA.l	(sp),a0				; copy descriptor pointer 1 from stack
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 72 - 10/11/2023 21:18:52


    4046/    162A : 3028 0004           	MOVE.w	4(a0),d0				; get length
    4047/    162E : 2050                	MOVEA.l	(a0),a0				; get string pointer
    4048/    1630 : 6120                	BSR.s		LAB_229E				; copy string d0 bytes long from a0 to Sutill
    4049/    1632 :                     								; return with a0 = pointer, d1 = length
    4050/    1632 :                     
    4051/    1632 : 206B 0590           	MOVEA.l	FAC1_m(a3),a0			; get descriptor pointer for string 2
    4052/    1636 : 6138                	BSR.s		LAB_22BA				; pop (a0) descriptor, returns with ..
    4053/    1638 :                     								; a0 = pointer, d0 = length
    4054/    1638 : 6118                	BSR.s		LAB_229E				; copy string d0 bytes long from a0 to Sutill
    4055/    163A :                     								; return with a0 = pointer, d1 = length
    4056/    163A :                     
    4057/    163A : 205F                	MOVEA.l	(sp)+,a0				; get descriptor pointer for string 1
    4058/    163C : 6132                	BSR.s		LAB_22BA				; pop (a0) descriptor, returns with ..
    4059/    163E :                     								; d0 = length, a0 = pointer
    4060/    163E :                     
    4061/    163E : 206B 0598           	MOVEA.l	FAC2_m(a3),a0			; retreive the result string pointer
    4062/    1642 : 2208                	MOVE.l	a0,d1					; copy the result string pointer
    4063/    1644 : 6700 FE78           	BEQ		LAB_RTST				; if it is a null string just return it
    4064/    1648 :                     								; a0 = pointer, d1 = length
    4065/    1648 :                     
    4066/    1648 : 4481                	NEG.l		d1					; else make the start pointer negative
    4067/    164A : D2AB 044E           	ADD.l		Sutill(a3),d1			; add the end pointert to give the length
    4068/    164E : 6000 FE6E           	BRA		LAB_RTST				; push string on descriptor stack
    4069/    1652 :                     								; a0 = pointer, d1 = length
    4070/    1652 :                     
    4071/    1652 :                     
    4072/    1652 :                     ;************************************************************************************
    4073/    1652 :                     ;
    4074/    1652 :                     ; copy string d0 bytes long from a0 to Sutill
    4075/    1652 :                     ; return with a0 = pointer, d1 = length
    4076/    1652 :                     
    4077/    1652 :                     LAB_229E
    4078/    1652 : 3200                	MOVE.w	d0,d1					; copy and check length
    4079/    1654 : 6714                	BEQ.s		RTS_013				; skip copy if null
    4080/    1656 :                     
    4081/    1656 : 226B 044E           	MOVEA.l	Sutill(a3),a1			; get destination pointer
    4082/    165A : 2F09                	MOVE.l	a1,-(sp)				; save destination string pointer
    4083/    165C : 5340                	SUBQ.w	#1,d0					; subtract for DBF loop
    4084/    165E :                     LAB_22A0
    4085/    165E : 12D8                	MOVE.b	(a0)+,(a1)+				; copy byte
    4086/    1660 : 51C8 FFFC           	DBF		d0,LAB_22A0				; loop if not done
    4087/    1664 :                     
    4088/    1664 : 2749 044E           	MOVE.l	a1,Sutill(a3)			; update Sutill to end of copied string
    4089/    1668 : 205F                	MOVEA.l	(sp)+,a0				; restore destination string pointer
    4090/    166A :                     RTS_013
    4091/    166A : 4E75                	RTS
    4092/    166C :                     
    4093/    166C :                     
    4094/    166C :                     ;************************************************************************************
    4095/    166C :                     ;
    4096/    166C :                     ; pop string off descriptor stack, or from top of string space
    4097/    166C :                     ; returns with d0.l = length, a0 = pointer
    4098/    166C :                     
    4099/    166C :                     LAB_22B6
    4100/    166C : 206B 0590           	MOVEA.l	FAC1_m(a3),a0			; get descriptor pointer
    4101/    1670 :                     
    4102/    1670 :                     
    4103/    1670 :                     ;************************************************************************************
    4104/    1670 :                     ;
    4105/    1670 :                     ; pop (a0) descriptor off stack or from string space
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 73 - 10/11/2023 21:18:52


    4106/    1670 :                     ; returns with d0.l = length, a0 = pointer
    4107/    1670 :                     
    4108/    1670 :                     LAB_22BA
    4109/    1670 : 48E7 4040           	MOVEM.l	a1/d1,-(sp)				; save other regs
    4110/    1674 : B9C8                	CMPA.l	a0,a4					; is string on the descriptor stack
    4111/    1676 : 6602                	BNE.s		LAB_22BD				; skip pop if not
    4112/    1678 :                     
    4113/    1678 : 5C4C                	ADDQ.w	#$06,a4				; else update stack pointer
    4114/    167A :                     LAB_22BD
    4115/    167A : 7000                	MOVEQ		#0,d0					; clear string length longword
    4116/    167C : 2258                	MOVEA.l	(a0)+,a1				; get string address
    4117/    167E : 3018                	MOVE.w	(a0)+,d0				; get string length
    4118/    1680 :                     
    4119/    1680 : B9C8                	CMPA.l	a0,a4					; was it on the descriptor stack
    4120/    1682 : 6610                	BNE.s		LAB_22E6				; branch if it wasn't
    4121/    1684 :                     
    4122/    1684 : B3EB 0446           	CMPA.l	Sstorl(a3),a1			; compare string address with bottom of string
    4123/    1688 :                     								; space
    4124/    1688 : 660A                	BNE.s		LAB_22E6				; branch if <>
    4125/    168A :                     
    4126/    168A : 7201                	MOVEQ		#1,d1					; mask for odd bit
    4127/    168C : C240                	AND.w		d0,d1					; AND length
    4128/    168E : D280                	ADD.l		d0,d1					; make it fit word aligned length
    4129/    1690 :                     
    4130/    1690 : D3AB 0446           	ADD.l		d1,Sstorl(a3)			; add to bottom of string space
    4131/    1694 :                     LAB_22E6
    4132/    1694 : 2049                	MOVEA.l	a1,a0					; copy to a0
    4133/    1696 : 4CDF 0202           	MOVEM.l	(sp)+,a1/d1				; restore other regs
    4134/    169A : 4A80                	TST.l		d0					; set flags on length
    4135/    169C : 4E75                	RTS
    4136/    169E :                     
    4137/    169E :                     
    4138/    169E :                     ;************************************************************************************
    4139/    169E :                     ;
    4140/    169E :                     ; perform CHR$()
    4141/    169E :                     
    4142/    169E :                     LAB_CHRS
    4143/    169E : 6100 0130           	BSR		LAB_EVBY				; evaluate byte expression, result in d0 and
    4144/    16A2 :                     								; Itemp
    4145/    16A2 :                     LAB_MKCHR
    4146/    16A2 : 7201                	MOVEQ		#1,d1					; string is single byte
    4147/    16A4 : 6100 FE32           	BSR		LAB_2115				; make string space d1 bytes long
    4148/    16A8 :                     								; return a0/Sutill = pointer, others unchanged
    4149/    16A8 : 1080                	MOVE.b	d0,(a0)				; save byte in string (byte IS string!)
    4150/    16AA : 6000 FE12           	BRA		LAB_RTST				; push string on descriptor stack
    4151/    16AE :                     								; a0 = pointer, d1 = length
    4152/    16AE :                     
    4153/    16AE :                     
    4154/    16AE :                     ;************************************************************************************
    4155/    16AE :                     ;
    4156/    16AE :                     ; perform LEFT$()
    4157/    16AE :                     
    4158/    16AE :                     ; enter with a0 is descriptor, d0 & Itemp is word 1
    4159/    16AE :                     
    4160/    16AE :                     LAB_LEFT
    4161/    16AE : C141                	EXG		d0,d1					; word in d1
    4162/    16B0 : 6100 F79C           	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
    4163/    16B4 :                     
    4164/    16B4 : 4A81                	TST.l		d1					; test returned length
    4165/    16B6 : 6722                	BEQ.s		LAB_231C				; branch if null return
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 74 - 10/11/2023 21:18:52


    4166/    16B8 :                     
    4167/    16B8 : 7000                	MOVEQ		#0,d0					; clear start offset
    4168/    16BA : B268 0004           	CMP.w		4(a0),d1				; compare word parameter with string length
    4169/    16BE : 651A                	BCS.s		LAB_231C				; branch if string length > word parameter
    4170/    16C0 :                     
    4171/    16C0 : 6014                	BRA.s		LAB_2317				; go copy whole string
    4172/    16C2 :                     
    4173/    16C2 :                     
    4174/    16C2 :                     ;************************************************************************************
    4175/    16C2 :                     ;
    4176/    16C2 :                     ; perform RIGHT$()
    4177/    16C2 :                     
    4178/    16C2 :                     ; enter with a0 is descriptor, d0 & Itemp is word 1
    4179/    16C2 :                     
    4180/    16C2 :                     LAB_RIGHT
    4181/    16C2 : C141                	EXG		d0,d1					; word in d1
    4182/    16C4 : 6100 F788           	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
    4183/    16C8 :                     
    4184/    16C8 : 4A81                	TST.l		d1					; test returned length
    4185/    16CA : 670E                	BEQ.s		LAB_231C				; branch if null return
    4186/    16CC :                     
    4187/    16CC : 3028 0004           	MOVE.w	4(a0),d0				; get string length
    4188/    16D0 : 9081                	SUB.l		d1,d0					; subtract word
    4189/    16D2 : 6406                	BCC.s		LAB_231C				; branch if string length > word parameter
    4190/    16D4 :                     
    4191/    16D4 :                     								; else copy whole string
    4192/    16D4 :                     LAB_2316
    4193/    16D4 : 7000                	MOVEQ		#0,d0					; clear start offset
    4194/    16D6 :                     LAB_2317
    4195/    16D6 : 3228 0004           	MOVE.w	4(a0),d1				; else make parameter = length
    4196/    16DA :                     
    4197/    16DA :                     ; get here with ...
    4198/    16DA :                     ;   a0 - points to descriptor
    4199/    16DA :                     ;   d0 - is offset from string start
    4200/    16DA :                     ;   d1 - is required string length
    4201/    16DA :                     
    4202/    16DA :                     LAB_231C
    4203/    16DA : 2248                	MOVEA.l	a0,a1					; save string descriptor pointer
    4204/    16DC : 6100 FDFA           	BSR		LAB_2115				; make string space d1 bytes long
    4205/    16E0 :                     								; return a0/Sutill = pointer, others unchanged
    4206/    16E0 : 2049                	MOVEA.l	a1,a0					; restore string descriptor pointer
    4207/    16E2 : 2F00                	MOVE.l	d0,-(sp)				; save start offset (longword)
    4208/    16E4 : 618A                	BSR.s		LAB_22BA				; pop (a0) descriptor, returns with ..
    4209/    16E6 :                     								; d0 = length, a0 = pointer
    4210/    16E6 : D1DF                	ADDA.l	(sp)+,a0				; adjust pointer to start of wanted string
    4211/    16E8 : 3001                	MOVE.w	d1,d0					; length to d0
    4212/    16EA : 6100 FF66           	BSR		LAB_229E				; store string d0 bytes long from (a0) to
    4213/    16EE :                     								; (Sutill) return with a0 = pointer,
    4214/    16EE :                     								; d1 = length
    4215/    16EE : 6000 FDCE           	BRA		LAB_RTST				; push string on descriptor stack
    4216/    16F2 :                     								; a0 = pointer, d1 = length
    4217/    16F2 :                     
    4218/    16F2 :                     
    4219/    16F2 :                     ;************************************************************************************
    4220/    16F2 :                     ;
    4221/    16F2 :                     ; perform MID$()
    4222/    16F2 :                     
    4223/    16F2 :                     ; enter with a0 is descriptor, d0 & Itemp is word 1
    4224/    16F2 :                     
    4225/    16F2 :                     LAB_MIDS
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 75 - 10/11/2023 21:18:52


    4226/    16F2 : 7E00                	MOVEQ		#0,d7					; clear longword
    4227/    16F4 : 5347                	SUBQ.w	#1,d7					; set default length = 65535
    4228/    16F6 : 2F00                	MOVE.l	d0,-(sp)				; save word 1
    4229/    16F8 : 6100 F768           	BSR		LAB_GBYT				; scan memory
    4230/    16FC : B03C 002C           	CMP.b		#',',d0				; was it ","
    4231/    1700 : 660C                	BNE.s		LAB_2358				; branch if not "," (skip second byte get)
    4232/    1702 :                     
    4233/    1702 : 101D                	MOVE.b	(a5)+,d0				; increment pointer past ","
    4234/    1704 : 2F08                	MOVE.l	a0,-(sp)				; save descriptor pointer
    4235/    1706 : 6100 00DA           	BSR		LAB_GTWO				; get word parameter, result in d0 and Itemp
    4236/    170A : 205F                	MOVEA.l	(sp)+,a0				; restore descriptor pointer
    4237/    170C : 2E00                	MOVE.l	d0,d7					; copy length
    4238/    170E :                     LAB_2358
    4239/    170E : 6100 F73E           	BSR		LAB_1BFB				; scan for ")", else do syntax error then warm
    4240/    1712 :                     								; start
    4241/    1712 : 201F                	MOVE.l	(sp)+,d0				; restore word 1
    4242/    1714 : 7200                	MOVEQ		#0,d1					; null length
    4243/    1716 : 5380                	SUBQ.l	#1,d0					; decrement start index (word 1)
    4244/    1718 : 6B00 EAF4           	BMI		LAB_FCER				; if was null do function call error then warm
    4245/    171C :                     								; start
    4246/    171C :                     
    4247/    171C : B068 0004           	CMP.w		4(a0),d0				; compare string length with start index
    4248/    1720 : 64B8                	BCC.s		LAB_231C				; if start not in string do null string (d1=0)
    4249/    1722 :                     
    4250/    1722 : 2207                	MOVE.l	d7,d1					; get length back
    4251/    1724 : DE40                	ADD.w		d0,d7					; d7 now = MID$() end
    4252/    1726 : 6506                	BCS.s		LAB_2368				; already too long so do RIGHT$ equivalent
    4253/    1728 :                     
    4254/    1728 : BE68 0004           	CMP.w		4(a0),d7				; compare string length with start index+length
    4255/    172C : 65AC                	BCS.s		LAB_231C				; if end in string go do string
    4256/    172E :                     
    4257/    172E :                     LAB_2368
    4258/    172E : 3228 0004           	MOVE.w	4(a0),d1				; get string length
    4259/    1732 : 9240                	SUB.w		d0,d1					; subtract start offset
    4260/    1734 : 60A4                	BRA.s		LAB_231C				; go do string (effectively RIGHT$)
    4261/    1736 :                     
    4262/    1736 :                     
    4263/    1736 :                     ;************************************************************************************
    4264/    1736 :                     ;
    4265/    1736 :                     ; perform LCASE$()
    4266/    1736 :                     
    4267/    1736 :                     LAB_LCASE
    4268/    1736 : 6100 FF34           	BSR		LAB_22B6				; pop string off descriptor stack or from memory
    4269/    173A :                     								; returns with d0 = length, a0 = pointer
    4270/    173A : 2200                	MOVE.l	d0,d1					; copy the string length
    4271/    173C : 6756                	BEQ.s		NoString				; if null go return a null string
    4272/    173E :                     
    4273/    173E :                     ; else copy and change the string
    4274/    173E :                     
    4275/    173E : 2248                	MOVEA.l	a0,a1					; copy the string address
    4276/    1740 : 6100 FD96           	BSR		LAB_2115				; make a string space d1 bytes long
    4277/    1744 : D1C1                	ADDA.l	d1,a0					; new string end
    4278/    1746 : D3C1                	ADDA.l	d1,a1					; old string end
    4279/    1748 : 3401                	MOVE.w	d1,d2					; copy length for loop
    4280/    174A : 5342                	SUBQ.w	#1,d2					; -1 for DBF loop
    4281/    174C :                     LC_loop
    4282/    174C : 1021                	MOVE.b	-(a1),d0				; get byte from string
    4283/    174E :                     
    4284/    174E : B03C 005B           	CMP.b		#$5B,d0				; compare with "Z"+1
    4285/    1752 : 640A                	BCC.s		NoUcase				; if > "Z" skip change
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 76 - 10/11/2023 21:18:52


    4286/    1754 :                     
    4287/    1754 : B03C 0041           	CMP.b		#$41,d0				; compare with "A"
    4288/    1758 : 6504                	BCS.s		NoUcase				; if < "A" skip change
    4289/    175A :                     
    4290/    175A : 0000 0020           	ORI.b		#$20,d0				; convert upper case to lower case
    4291/    175E :                     NoUcase
    4292/    175E : 1100                	MOVE.b	d0,-(a0)				; copy upper case byte back to string
    4293/    1760 : 51CA FFEA           	DBF		d2,LC_loop				; decrement and loop if not all done
    4294/    1764 :                     
    4295/    1764 : 602E                	BRA.s		NoString				; tidy up & exit (branch always)
    4296/    1766 :                     
    4297/    1766 :                     
    4298/    1766 :                     ;************************************************************************************
    4299/    1766 :                     ;
    4300/    1766 :                     ; perform UCASE$()
    4301/    1766 :                     
    4302/    1766 :                     LAB_UCASE
    4303/    1766 : 6100 FF04           	BSR		LAB_22B6				; pop string off descriptor stack or from memory
    4304/    176A :                     								; returns with d0 = length, a0 = pointer
    4305/    176A : 2200                	MOVE.l	d0,d1					; copy the string length
    4306/    176C : 6726                	BEQ.s		NoString				; if null go return a null string
    4307/    176E :                     
    4308/    176E :                     ; else copy and change the string
    4309/    176E :                     
    4310/    176E : 2248                	MOVEA.l	a0,a1					; copy the string address
    4311/    1770 : 6100 FD66           	BSR		LAB_2115				; make a string space d1 bytes long
    4312/    1774 : D1C1                	ADDA.l	d1,a0					; new string end
    4313/    1776 : D3C1                	ADDA.l	d1,a1					; old string end
    4314/    1778 : 3401                	MOVE.w	d1,d2					; copy length for loop
    4315/    177A : 5342                	SUBQ.w	#1,d2					; -1 for DBF loop
    4316/    177C :                     UC_loop
    4317/    177C : 1021                	MOVE.b	-(a1),d0				; get a byte from the string
    4318/    177E :                     
    4319/    177E : B03C 0061           	CMP.b		#$61,d0				; compare with "a"
    4320/    1782 : 650A                	BCS.s		NoLcase				; if < "a" skip change
    4321/    1784 :                     
    4322/    1784 : B03C 007B           	CMP.b		#$7B,d0				; compare with "z"+1
    4323/    1788 : 6404                	BCC.s		NoLcase				; if > "z" skip change
    4324/    178A :                     
    4325/    178A : 0200 00DF           	ANDI.b	#$DF,d0				; convert lower case to upper case
    4326/    178E :                     NoLcase
    4327/    178E : 1100                	MOVE.b	d0,-(a0)				; copy upper case byte back to string
    4328/    1790 : 51CA FFEA           	DBF		d2,UC_loop				; decrement and loop if not all done
    4329/    1794 :                     
    4330/    1794 :                     NoString
    4331/    1794 : 6000 FD28           	BRA		LAB_RTST				; push string on descriptor stack
    4332/    1798 :                     								; a0 = pointer, d1 = length
    4333/    1798 :                     
    4334/    1798 :                     
    4335/    1798 :                     ;************************************************************************************
    4336/    1798 :                     ;
    4337/    1798 :                     ; perform SADD()
    4338/    1798 :                     
    4339/    1798 :                     LAB_SADD
    4340/    1798 : 101D                	MOVE.b	(a5)+,d0				; increment pointer
    4341/    179A : 6100 F8D6           	BSR		LAB_GVAR				; get variable address in a0
    4342/    179E : 6100 F6AE           	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
    4343/    17A2 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type flag
    4344/    17A6 : 6A00 EA46           	BPL		LAB_TMER				; if numeric do Type missmatch Error
    4345/    17AA : 2010                	MOVE.l	(a0),d0					; get string address
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 77 - 10/11/2023 21:18:52


    4346/    17AC : 6000 FBB4           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
    4347/    17B0 :                     
    4348/    17B0 :                     
    4349/    17B0 :                     ;************************************************************************************
    4350/    17B0 :                     ;
    4351/    17B0 :                     ; perform LEN()
    4352/    17B0 :                     
    4353/    17B0 :                     LAB_LENS
    4354/    17B0 : 487A FBB0           	PEA		LAB_AYFC(pc)			; set return address to convert d0 to signed
    4355/    17B4 :                     								; longword in FAC1
    4356/    17B4 : 6000 FEB6           	BRA		LAB_22B6				; pop string off descriptor stack or from memory
    4357/    17B8 :                     								; returns with d0 = length, a0 = pointer
    4358/    17B8 :                     
    4359/    17B8 :                     
    4360/    17B8 :                     ;************************************************************************************
    4361/    17B8 :                     ;
    4362/    17B8 :                     ; perform ASC()
    4363/    17B8 :                     
    4364/    17B8 :                     LAB_ASC
    4365/    17B8 : 6100 FEB2           	BSR		LAB_22B6				; pop string off descriptor stack or from memory
    4366/    17BC :                     								; returns with d0 = length, a0 = pointer
    4367/    17BC : 4A40                	TST.w		d0					; test length
    4368/    17BE : 6700 EA4E           	BEQ		LAB_FCER				; if null do function call error then warm start
    4369/    17C2 :                     
    4370/    17C2 : 1010                	MOVE.b	(a0),d0				; get first character byte
    4371/    17C4 : 6000 FBBC           	BRA		LAB_1FD0				; convert d0 to unsigned byte in FAC1 & return
    4372/    17C8 :                     
    4373/    17C8 :                     
    4374/    17C8 :                     ;************************************************************************************
    4375/    17C8 :                     ;
    4376/    17C8 :                     ; increment and get byte, result in d0 and Itemp
    4377/    17C8 :                     
    4378/    17C8 :                     LAB_SGBY
    4379/    17C8 : 6100 F696           	BSR		LAB_IGBY				; increment & scan memory
    4380/    17CC :                     
    4381/    17CC :                     
    4382/    17CC :                     ;************************************************************************************
    4383/    17CC :                     ;
    4384/    17CC :                     ; get byte parameter, result in d0 and Itemp
    4385/    17CC :                     
    4386/    17CC :                     LAB_GTBY
    4387/    17CC : 6100 F51A           	BSR		LAB_EVNM				; evaluate expression & check is numeric,
    4388/    17D0 :                     								; else do type mismatch
    4389/    17D0 :                     
    4390/    17D0 :                     
    4391/    17D0 :                     ;************************************************************************************
    4392/    17D0 :                     ;
    4393/    17D0 :                     ; evaluate byte expression, result in d0 and Itemp
    4394/    17D0 :                     
    4395/    17D0 :                     LAB_EVBY
    4396/    17D0 : 6100 F9D4           	BSR		LAB_EVPI				; evaluate positive integer expression
    4397/    17D4 :                     								; result in d0 and Itemp
    4398/    17D4 : 123C 0080           	MOVE.b		#$80,d1				; set mask/2
    4399/    17D8 : D281                	ADD.l		d1,d1					; =$FFFFFF00
    4400/    17DA : C280                	AND.l		d0,d1					; check top 24 bits
    4401/    17DC : 6600 EA30           	BNE		LAB_FCER				; if <> 0 do function call error/warm start
    4402/    17E0 :                     
    4403/    17E0 : 4E75                	RTS
    4404/    17E2 :                     
    4405/    17E2 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 78 - 10/11/2023 21:18:52


    4406/    17E2 :                     ;************************************************************************************
    4407/    17E2 :                     ;
    4408/    17E2 :                     ; get word parameter, result in d0 and Itemp
    4409/    17E2 :                     
    4410/    17E2 :                     LAB_GTWO
    4411/    17E2 : 6100 F504           	BSR		LAB_EVNM				; evaluate expression & check is numeric,
    4412/    17E6 :                     								; else do type mismatch
    4413/    17E6 : 6100 F9BE           	BSR		LAB_EVPI				; evaluate positive integer expression
    4414/    17EA :                     								; result in d0 and Itemp
    4415/    17EA : 4840                	SWAP		d0					; copy high word to low word
    4416/    17EC : 4A40                	TST.w		d0					; set flags
    4417/    17EE : 6600 EA1E           	BNE		LAB_FCER				; if <> 0 do function call error/warm start
    4418/    17F2 :                     
    4419/    17F2 : 4840                	SWAP		d0					; copy high word to low word
    4420/    17F4 : 4E75                	RTS
    4421/    17F6 :                     
    4422/    17F6 :                     
    4423/    17F6 :                     ;************************************************************************************
    4424/    17F6 :                     ;
    4425/    17F6 :                     ; perform VAL()
    4426/    17F6 :                     
    4427/    17F6 :                     LAB_VAL
    4428/    17F6 : 6100 FE74           	BSR		LAB_22B6				; pop string off descriptor stack or from memory
    4429/    17FA :                     								; returns with d0 = length, a0 = pointer
    4430/    17FA : 6722                	BEQ.s		LAB_VALZ				; string was null so set result = $00
    4431/    17FC :                     								; clear FAC1 exponent & sign & return
    4432/    17FC :                     
    4433/    17FC : 2C4D                	MOVEA.l	a5,a6					; save BASIC execute pointer
    4434/    17FE : 2A48                	MOVEA.l	a0,a5					; copy string pointer to execute pointer
    4435/    1800 : D1C0                	ADDA.l	d0,a0					; string end+1
    4436/    1802 : 1010                	MOVE.b	(a0),d0				; get byte from string+1
    4437/    1804 : 3F00                	MOVE.w	d0,-(sp)				; save it
    4438/    1806 : 2F08                	MOVE.l	a0,-(sp)				; save address
    4439/    1808 : 10BC 0000           	MOVE.b	#0,(a0)				; null terminate string
    4440/    180C : 6100 F654           	BSR		LAB_GBYT				; scan memory
    4441/    1810 : 6100 114C           	BSR		LAB_2887				; get FAC1 from string
    4442/    1814 : 205F                	MOVEA.l	(sp)+,a0				; restore pointer
    4443/    1816 : 301F                	MOVE.w	(sp)+,d0				; pop byte
    4444/    1818 : 1080                	MOVE.b	d0,(a0)				; restore to memory
    4445/    181A : 2A4E                	MOVEA.l	a6,a5					; restore BASIC execute pointer
    4446/    181C : 4E75                	RTS
    4447/    181E :                     
    4448/    181E :                     LAB_VALZ
    4449/    181E : 3740 0594           	MOVE.w	d0,FAC1_e(a3)			; clear FAC1 exponent & sign
    4450/    1822 : 4E75                	RTS
    4451/    1824 :                     
    4452/    1824 :                     
    4453/    1824 :                     ;************************************************************************************
    4454/    1824 :                     ;
    4455/    1824 :                     ; get two parameters for POKE or WAIT, first parameter in a0, second in d0
    4456/    1824 :                     
    4457/    1824 :                     LAB_GADB
    4458/    1824 : 6100 F4C2           	BSR		LAB_EVNM				; evaluate expression & check is numeric,
    4459/    1828 :                     								; else do type mismatch
    4460/    1828 : 6100 F984           	BSR		LAB_EVIR				; evaluate integer expression
    4461/    182C :                     								; (does FC error not OF error if out of range)
    4462/    182C : 2F00                	MOVE.l	d0,-(sp)				; copy to stack
    4463/    182E : 6100 F626           	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
    4464/    1832 : 6198                	BSR.s		LAB_GTBY				; get byte parameter, result in d0 and Itemp
    4465/    1834 : 205F                	MOVEA.l	(sp)+,a0				; pull address
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 79 - 10/11/2023 21:18:52


    4466/    1836 : 4E75                	RTS
    4467/    1838 :                     
    4468/    1838 :                     
    4469/    1838 :                     ;************************************************************************************
    4470/    1838 :                     ;
    4471/    1838 :                     ; get two parameters for DOKE or WAITW, first parameter in a0, second in d0
    4472/    1838 :                     
    4473/    1838 :                     LAB_GADW
    4474/    1838 : 611E                	BSR.s		LAB_GEAD				; get even address for word/long memory actions
    4475/    183A :                     								; address returned in d0 and on the stack
    4476/    183A : 6100 F61A           	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
    4477/    183E : 6100 F4A8           	BSR		LAB_EVNM				; evaluate expression & check is numeric,
    4478/    1842 :                     								; else do type mismatch
    4479/    1842 : 6100 F96A           	BSR		LAB_EVIR				; evaluate integer expression
    4480/    1846 :                     								; result in d0 and Itemp
    4481/    1846 : 4840                	SWAP		d0					; swap words
    4482/    1848 : 4A40                	TST.w		d0					; test high word
    4483/    184A : 6706                	BEQ.s		LAB_XGADW				; exit if null
    4484/    184C :                     
    4485/    184C : 5240                	ADDQ.w	#1,d0					; increment word
    4486/    184E : 6600 E9BE           	BNE		LAB_FCER				; if <> 0 do function call error/warm start
    4487/    1852 :                     
    4488/    1852 :                     LAB_XGADW
    4489/    1852 : 4840                	SWAP		d0					; swap words back
    4490/    1854 : 205F                	MOVEA.l	(sp)+,a0				; pull address
    4491/    1856 : 4E75                	RTS
    4492/    1858 :                     
    4493/    1858 :                     
    4494/    1858 :                     ;************************************************************************************
    4495/    1858 :                     ;
    4496/    1858 :                     ; get even address (for word or longword memory actions)
    4497/    1858 :                     ; address returned in d0 and on the stack
    4498/    1858 :                     ; does address error if the address is odd
    4499/    1858 :                     
    4500/    1858 :                     LAB_GEAD
    4501/    1858 : 6100 F48E           	BSR		LAB_EVNM				; evaluate expression & check is numeric,
    4502/    185C :                     								; else do type mismatch
    4503/    185C : 6100 F950           	BSR		LAB_EVIR				; evaluate integer expression
    4504/    1860 :                     								; (does FC error not OF error if out of range)
    4505/    1860 : 0800 0000           	BTST		#0,d0					; test low bit of longword
    4506/    1864 : 6600 E964           	BNE		LAB_ADER				; if address is odd do address error/warm start
    4507/    1868 :                     
    4508/    1868 : 2057                	MOVEA.l	(sp),a0				; copy return address
    4509/    186A : 2E80                	MOVE.l	d0,(sp)				; even address on stack
    4510/    186C : 4ED0                	JMP		(a0)					; effectively RTS
    4511/    186E :                     
    4512/    186E :                     
    4513/    186E :                     ;************************************************************************************
    4514/    186E :                     ;
    4515/    186E :                     ; perform PEEK()
    4516/    186E :                     
    4517/    186E :                     LAB_PEEK
    4518/    186E : 6100 F93E           	BSR		LAB_EVIR				; evaluate integer expression
    4519/    1872 :                     								; (does FC error not OF error if out of range)
    4520/    1872 : 2040                	MOVEA.l	d0,a0					; copy to address register
    4521/    1874 : 1010                	MOVE.b	(a0),d0				; get byte
    4522/    1876 : 6000 FB0A           	BRA		LAB_1FD0				; convert d0 to unsigned byte in FAC1 & return
    4523/    187A :                     
    4524/    187A :                     
    4525/    187A :                     ;************************************************************************************
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 80 - 10/11/2023 21:18:52


    4526/    187A :                     ;
    4527/    187A :                     ; perform POKE
    4528/    187A :                     
    4529/    187A :                     LAB_POKE
    4530/    187A : 61A8                	BSR.s		LAB_GADB				; get two parameters for POKE or WAIT
    4531/    187C :                     								; first parameter in a0, second in d0
    4532/    187C : 1080                	MOVE.b	d0,(a0)				; put byte in memory
    4533/    187E : 4E75                	RTS
    4534/    1880 :                     
    4535/    1880 :                     
    4536/    1880 :                     ;************************************************************************************
    4537/    1880 :                     ;
    4538/    1880 :                     ; perform DEEK()
    4539/    1880 :                     
    4540/    1880 :                     LAB_DEEK
    4541/    1880 : 6100 F92C           	BSR		LAB_EVIR				; evaluate integer expression
    4542/    1884 :                     								; (does FC error not OF error if out of range)
    4543/    1884 : E208                	LSR.b		#1,d0					; shift bit 0 to carry
    4544/    1886 : 6500 E942           	BCS		LAB_ADER				; if address is odd do address error/warm start
    4545/    188A :                     
    4546/    188A : D000                	ADD.b		d0,d0					; shift byte back
    4547/    188C : C188                	EXG		d0,a0					; copy to address register
    4548/    188E : 7000                	MOVEQ		#0,d0					; clear top bits
    4549/    1890 : 3010                	MOVE.w	(a0),d0				; get word
    4550/    1892 : 6000 FACE           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
    4551/    1896 :                     
    4552/    1896 :                     
    4553/    1896 :                     ;************************************************************************************
    4554/    1896 :                     ;
    4555/    1896 :                     ; perform LEEK()
    4556/    1896 :                     
    4557/    1896 :                     LAB_LEEK
    4558/    1896 : 6100 F916           	BSR		LAB_EVIR				; evaluate integer expression
    4559/    189A :                     								; (does FC error not OF error if out of range)
    4560/    189A : E208                	LSR.b		#1,d0					; shift bit 0 to carry
    4561/    189C : 6500 E92C           	BCS		LAB_ADER				; if address is odd do address error/warm start
    4562/    18A0 :                     
    4563/    18A0 : D000                	ADD.b		d0,d0					; shift byte back
    4564/    18A2 : C188                	EXG		d0,a0					; copy to address register
    4565/    18A4 : 2010                	MOVE.l	(a0),d0				; get longword
    4566/    18A6 : 6000 FABA           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
    4567/    18AA :                     
    4568/    18AA :                     
    4569/    18AA :                     ;************************************************************************************
    4570/    18AA :                     ;
    4571/    18AA :                     ; perform DOKE
    4572/    18AA :                     
    4573/    18AA :                     LAB_DOKE
    4574/    18AA : 618C                	BSR.s		LAB_GADW				; get two parameters for DOKE or WAIT
    4575/    18AC :                     								; first parameter in a0, second in d0
    4576/    18AC : 3080                	MOVE.w	d0,(a0)				; put word in memory
    4577/    18AE : 4E75                	RTS
    4578/    18B0 :                     
    4579/    18B0 :                     
    4580/    18B0 :                     ;************************************************************************************
    4581/    18B0 :                     ;
    4582/    18B0 :                     ; perform LOKE
    4583/    18B0 :                     
    4584/    18B0 :                     LAB_LOKE
    4585/    18B0 : 61A6                	BSR.s		LAB_GEAD				; get even address for word/long memory actions
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 81 - 10/11/2023 21:18:52


    4586/    18B2 :                     								; address returned in d0 and on the stack
    4587/    18B2 : 6100 F5A2           	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
    4588/    18B6 : 6100 F430           	BSR		LAB_EVNM				; evaluate expression & check is numeric,
    4589/    18BA :                     								; else do type mismatch
    4590/    18BA : 6100 F8F2           	BSR		LAB_EVIR				; evaluate integer value (no sign check)
    4591/    18BE : 205F                	MOVEA.l	(sp)+,a0				; pull address
    4592/    18C0 : 2080                	MOVE.l	d0,(a0)				; put longword in memory
    4593/    18C2 :                     RTS_015
    4594/    18C2 : 4E75                	RTS
    4595/    18C4 :                     
    4596/    18C4 :                     
    4597/    18C4 :                     ;************************************************************************************
    4598/    18C4 :                     ;
    4599/    18C4 :                     ; perform SWAP
    4600/    18C4 :                     
    4601/    18C4 :                     LAB_SWAP
    4602/    18C4 : 6100 F7AC           	BSR		LAB_GVAR				; get variable 1 address in a0
    4603/    18C8 : 2F08                	MOVE.l	a0,-(sp)				; save variable 1 address
    4604/    18CA : 182B 05B5           	MOVE.b	Dtypef(a3),d4			; copy variable 1 data type, $80=string,
    4605/    18CE :                     								; $40=inetger, $00=float
    4606/    18CE :                     
    4607/    18CE : 6100 F586           	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
    4608/    18D2 : 6100 F79E           	BSR		LAB_GVAR				; get variable 2 address in a0
    4609/    18D6 : 245F                	MOVEA.l	(sp)+,a2				; restore variable 1 address
    4610/    18D8 : B82B 05B5           	CMP.b		Dtypef(a3),d4			; compare variable 1 data type with variable 2
    4611/    18DC :                     								; data type
    4612/    18DC : 6600 E910           	BNE		LAB_TMER				; if not both the same type do "Type mismatch"
    4613/    18E0 :                     								; error then warm start
    4614/    18E0 :                     
    4615/    18E0 : 2010                	MOVE.l	(a0),d0				; get variable 2
    4616/    18E2 : 20D2                	MOVE.l	(a2),(a0)+				; copy variable 1 to variable 2
    4617/    18E4 : 24C0                	MOVE.l	d0,(a2)+				; save variable 2 to variable 1
    4618/    18E6 :                     
    4619/    18E6 : 4A04                	TST.b		d4					; check data type
    4620/    18E8 : 6AD8                	BPL.s		RTS_015				; exit if not string
    4621/    18EA :                     
    4622/    18EA : 3010                	MOVE.w	(a0),d0				; get string 2 length
    4623/    18EC : 3092                	MOVE.w	(a2),(a0)				; copy string 1 length to string 2 length
    4624/    18EE : 3480                	MOVE.w	d0,(a2)				; save string 2 length to string 1 length
    4625/    18F0 : 4E75                	RTS
    4626/    18F2 :                     
    4627/    18F2 :                     
    4628/    18F2 :                     ;************************************************************************************
    4629/    18F2 :                     ;
    4630/    18F2 :                     ; perform USR
    4631/    18F2 :                     
    4632/    18F2 :                     LAB_USR
    4633/    18F2 : 4EAB 0406           	JSR		Usrjmp(a3)				; do user vector
    4634/    18F6 : 6000 F556           	BRA		LAB_1BFB				; scan for ")", else do syntax error/warm start
    4635/    18FA :                     
    4636/    18FA :                     
    4637/    18FA :                     ;************************************************************************************
    4638/    18FA :                     ;
    4639/    18FA :                     ; perform LOAD
    4640/    18FA :                     
    4641/    18FA :                     LAB_LOAD
    4642/    18FA : 4EEB 0418           	JMP		V_LOAD(a3)				; do load vector
    4643/    18FE :                     
    4644/    18FE :                     
    4645/    18FE :                     ;************************************************************************************
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 82 - 10/11/2023 21:18:52


    4646/    18FE :                     ;
    4647/    18FE :                     ; perform SAVE
    4648/    18FE :                     
    4649/    18FE :                     LAB_SAVE
    4650/    18FE : 4EEB 041E           	JMP		V_SAVE(a3)				; do save vector
    4651/    1902 :                     
    4652/    1902 :                     
    4653/    1902 :                     ;************************************************************************************
    4654/    1902 :                     ;
    4655/    1902 :                     ; perform CALL
    4656/    1902 :                     
    4657/    1902 :                     LAB_CALL
    4658/    1902 : 487A F55E           	PEA		LAB_GBYT(pc)			; put return address on stack
    4659/    1906 : 6100 FF50           	BSR		LAB_GEAD				; get even address for word/long memory actions
    4660/    190A :                     								; address returned in d0 and on the stack
    4661/    190A : 4E75                	RTS							; effectively calls the routine
    4662/    190C :                     
    4663/    190C :                     ; if the called routine exits correctly then it will return via the get byte routine.
    4664/    190C :                     ; this will then get the next byte for the interpreter and return
    4665/    190C :                     
    4666/    190C :                     
    4667/    190C :                     ;************************************************************************************
    4668/    190C :                     ;
    4669/    190C :                     ; perform WAIT
    4670/    190C :                     
    4671/    190C :                     LAB_WAIT
    4672/    190C : 6100 FF16           	BSR		LAB_GADB				; get two parameters for POKE or WAIT
    4673/    1910 :                     								; first parameter in a0, second in d0
    4674/    1910 : 2F08                	MOVE.l	a0,-(sp)				; save address
    4675/    1912 : 3F00                	MOVE.w	d0,-(sp)				; save byte
    4676/    1914 : 7400                	MOVEQ		#0,d2					; clear mask
    4677/    1916 : 6100 F54A           	BSR		LAB_GBYT				; scan memory
    4678/    191A : 6706                	BEQ.s		LAB_2441				; skip if no third argument
    4679/    191C :                     
    4680/    191C : 6100 F534           	BSR		LAB_SCGB				; scan for "," & get byte,
    4681/    1920 :                     								; else do syntax error/warm start
    4682/    1920 : 2400                	MOVE.l	d0,d2					; copy mask
    4683/    1922 :                     LAB_2441
    4684/    1922 : 321F                	MOVE.w	(sp)+,d1				; get byte
    4685/    1924 : 205F                	MOVEA.l	(sp)+,a0				; get address
    4686/    1926 :                     LAB_2445
    4687/    1926 : 1010                	MOVE.b	(a0),d0				; read memory byte
    4688/    1928 : B500                	EOR.b		d2,d0					; EOR with second argument (mask)
    4689/    192A : C001                	AND.b		d1,d0					; AND with first argument (byte)
    4690/    192C : 67F8                	BEQ.s		LAB_2445				; loop if result is zero
    4691/    192E :                     
    4692/    192E : 4E75                	RTS
    4693/    1930 :                     
    4694/    1930 :                     
    4695/    1930 :                     ;************************************************************************************
    4696/    1930 :                     ;
    4697/    1930 :                     ; perform subtraction, FAC1 from FAC2
    4698/    1930 :                     
    4699/    1930 :                     LAB_SUBTRACT
    4700/    1930 : 0A2B 0080 0595      	EORI.b	#$80,FAC1_s(a3)			; complement FAC1 sign
    4701/    1936 : 176B 059D 059E      	MOVE.b	FAC2_s(a3),FAC_sc(a3)		; copy FAC2 sign byte
    4702/    193C :                     
    4703/    193C : 102B 0595           	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign byte
    4704/    1940 : B12B 059E           	EOR.b		d0,FAC_sc(a3)			; EOR with FAC2 sign
    4705/    1944 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 83 - 10/11/2023 21:18:52


    4706/    1944 :                     
    4707/    1944 :                     ;************************************************************************************
    4708/    1944 :                     ;
    4709/    1944 :                     ; add FAC2 to FAC1
    4710/    1944 :                     
    4711/    1944 :                     LAB_ADD
    4712/    1944 : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get exponent
    4713/    1948 : 6700 0338           	BEQ		LAB_279B				; FAC1 was zero so copy FAC2 to FAC1 & return
    4714/    194C :                     
    4715/    194C :                     								; FAC1 is non zero
    4716/    194C : 41EB 0598           	LEA		FAC2_m(a3),a0			; set pointer1 to FAC2 mantissa
    4717/    1950 : 102B 059C           	MOVE.b	FAC2_e(a3),d0			; get FAC2 exponent
    4718/    1954 : 6746                	BEQ.s		RTS_016				; exit if zero
    4719/    1956 :                     
    4720/    1956 : 902B 0594           	SUB.b		FAC1_e(a3),d0			; subtract FAC1 exponent
    4721/    195A : 6722                	BEQ.s		LAB_24A8				; branch if = (go add mantissa)
    4722/    195C :                     
    4723/    195C : 650A                	BCS.s		LAB_249C				; branch if FAC2 < FAC1
    4724/    195E :                     
    4725/    195E :                     								; FAC2 > FAC1
    4726/    195E : 376B 059C 0594      	MOVE.w	FAC2_e(a3),FAC1_e(a3)		; copy sign and exponent of FAC2
    4727/    1964 : 4400                	NEG.b		d0					; negate exponent difference (make diff -ve)
    4728/    1966 : 5148                	SUBQ.w	#8,a0					; pointer1 to FAC1
    4729/    1968 :                     
    4730/    1968 :                     LAB_249C
    4731/    1968 : 4400                	NEG.b		d0					; negate exponent difference (make diff +ve)
    4732/    196A : 2F01                	MOVE.l	d1,-(sp)				; save d1
    4733/    196C : B03C 0020           	CMP.b		#32,d0				; compare exponent diff with 32
    4734/    1970 : 6D04                	BLT.s		LAB_2467				; branch if range >= 32
    4735/    1972 :                     
    4736/    1972 : 7200                	MOVEQ		#0,d1					; clear d1
    4737/    1974 : 6004                	BRA.s		LAB_2468				; go clear smaller mantissa
    4738/    1976 :                     
    4739/    1976 :                     LAB_2467
    4740/    1976 : 2210                	MOVE.l	(a0),d1				; get FACx mantissa
    4741/    1978 : E0A9                	LSR.l		d0,d1					; shift d0 times right
    4742/    197A :                     LAB_2468
    4743/    197A : 2081                	MOVE.l	d1,(a0)				; save it back
    4744/    197C : 221F                	MOVE.l	(sp)+,d1				; restore d1
    4745/    197E :                     
    4746/    197E :                     								; exponents are equal now do mantissa add or
    4747/    197E :                     								; subtract
    4748/    197E :                     LAB_24A8
    4749/    197E : 4A2B 059E           	TST.b		FAC_sc(a3)				; test sign compare (FAC1 EOR FAC2)
    4750/    1982 : 6B1A                	BMI.s		LAB_24F8				; if <> go do subtract
    4751/    1984 :                     
    4752/    1984 : 202B 0598           	MOVE.l	FAC2_m(a3),d0			; get FAC2 mantissa
    4753/    1988 : D0AB 0590           	ADD.l		FAC1_m(a3),d0			; add FAC1 mantissa
    4754/    198C : 640A                	BCC.s		LAB_24F7				; save and exit if no carry (FAC1 is normal)
    4755/    198E :                     
    4756/    198E : E290                	ROXR.l	#1,d0					; else shift carry back into mantissa
    4757/    1990 : 522B 0594           	ADDQ.b	#1,FAC1_e(a3)			; increment FAC1 exponent
    4758/    1994 : 6500 E874           	BCS		LAB_OFER				; if carry do overflow error & warm start
    4759/    1998 :                     
    4760/    1998 :                     LAB_24F7
    4761/    1998 : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; save mantissa
    4762/    199C :                     RTS_016
    4763/    199C : 4E75                	RTS
    4764/    199E :                     								; signs are different
    4765/    199E :                     LAB_24F8
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 84 - 10/11/2023 21:18:52


    4766/    199E : 43EB 0590           	LEA		FAC1_m(a3),a1			; pointer 2 to FAC1
    4767/    19A2 : B3C8                	CMPA.l	a0,a1					; compare pointers
    4768/    19A4 : 6602                	BNE.s		LAB_24B4				; branch if <>
    4769/    19A6 :                     
    4770/    19A6 : 5049                	ADDQ.w	#8,a1					; else pointer2 to FAC2
    4771/    19A8 :                     
    4772/    19A8 :                     								; take smaller from bigger (take sign of bigger)
    4773/    19A8 :                     LAB_24B4
    4774/    19A8 : 2011                	MOVE.l	(a1),d0				; get larger mantissa
    4775/    19AA : 2210                	MOVE.l	(a0),d1				; get smaller mantissa
    4776/    19AC : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; save larger mantissa
    4777/    19B0 : 93AB 0590           	SUB.l		d1,FAC1_m(a3)			; subtract smaller
    4778/    19B4 :                     
    4779/    19B4 :                     
    4780/    19B4 :                     ;************************************************************************************
    4781/    19B4 :                     ;
    4782/    19B4 :                     ; do +/- (carry is sign) & normalise FAC1
    4783/    19B4 :                     
    4784/    19B4 :                     LAB_24D0
    4785/    19B4 : 640A                	BCC.s		LAB_24D5				; branch if result is +ve
    4786/    19B6 :                     
    4787/    19B6 :                     								; erk! subtract is the wrong way round so
    4788/    19B6 :                     								; negate everything
    4789/    19B6 : 0A2B 00FF 0595      	EORI.b	#$FF,FAC1_s(a3)			; complement FAC1 sign
    4790/    19BC : 44AB 0590           	NEG.l		FAC1_m(a3)				; negate FAC1 mantissa
    4791/    19C0 :                     
    4792/    19C0 :                     
    4793/    19C0 :                     ;************************************************************************************
    4794/    19C0 :                     ;
    4795/    19C0 :                     ; normalise FAC1
    4796/    19C0 :                     
    4797/    19C0 :                     LAB_24D5
    4798/    19C0 : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get mantissa
    4799/    19C4 : 6B2E                	BMI.s		LAB_24DA				; mantissa is normal so just exit
    4800/    19C6 :                     
    4801/    19C6 : 6606                	BNE.s		LAB_24D9				; mantissa is not zero so go normalise FAC1
    4802/    19C8 :                     
    4803/    19C8 : 3740 0594           	MOVE.w	d0,FAC1_e(a3)			; else make FAC1 = +zero
    4804/    19CC : 4E75                	RTS
    4805/    19CE :                     
    4806/    19CE :                     LAB_24D9
    4807/    19CE : 2F01                	MOVE.l	d1,-(sp)				; save d1
    4808/    19D0 : 2200                	MOVE.l	d0,d1					; mantissa to d1
    4809/    19D2 : 7000                	MOVEQ		#0,d0					; clear d0
    4810/    19D4 : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get exponent byte
    4811/    19D8 : 6714                	BEQ.s		LAB_24D8				; if exponent is zero then clean up and exit
    4812/    19DA :                     LAB_24D6
    4813/    19DA : D281                	ADD.l		d1,d1					; shift mantissa, ADD is quicker for a single
    4814/    19DC :                     								; shift
    4815/    19DC : 5BC8 FFFC           	DBMI		d0,LAB_24D6				; decrement exponent and loop if mantissa and
    4816/    19E0 :                     								; exponent +ve
    4817/    19E0 :                     
    4818/    19E0 : 4A40                	TST.w		d0					; test exponent
    4819/    19E2 : 670A                	BEQ.s		LAB_24D8				; if exponent is zero make FAC1 zero
    4820/    19E4 :                     
    4821/    19E4 : 6A02                	BPL.s		LAB_24D7				; if exponent is >zero go save FAC1
    4822/    19E6 :                     
    4823/    19E6 : 7001                	MOVEQ		#1,d0					; else set for zero after correction
    4824/    19E8 :                     LAB_24D7
    4825/    19E8 : 5300                	SUBQ.b	#1,d0					; adjust exponent for loop
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 85 - 10/11/2023 21:18:52


    4826/    19EA : 2741 0590           	MOVE.l	d1,FAC1_m(a3)			; save normalised mantissa
    4827/    19EE :                     LAB_24D8
    4828/    19EE : 221F                	MOVE.l	(sp)+,d1				; restore d1
    4829/    19F0 : 1740 0594           	MOVE.b	d0,FAC1_e(a3)			; save corrected exponent
    4830/    19F4 :                     LAB_24DA
    4831/    19F4 : 4E75                	RTS
    4832/    19F6 :                     
    4833/    19F6 :                     
    4834/    19F6 :                     ;************************************************************************************
    4835/    19F6 :                     ;
    4836/    19F6 :                     ; perform LOG()
    4837/    19F6 :                     
    4838/    19F6 :                     LAB_LOG
    4839/    19F6 : 4A2B 0595           	TST.b		FAC1_s(a3)				; test sign
    4840/    19FA : 6B00 E812           	BMI		LAB_FCER				; if -ve do function call error/warm start
    4841/    19FE :                     
    4842/    19FE : 7E00                	MOVEQ		#0,d7					; clear d7
    4843/    1A00 : 1747 059E           	MOVE.b	d7,FAC_sc(a3)			; clear sign compare
    4844/    1A04 : 1E2B 0594           	MOVE.b	FAC1_e(a3),d7			; get exponent
    4845/    1A08 : 6700 E804           	BEQ		LAB_FCER				; if 0 do function call error/warm start
    4846/    1A0C :                     
    4847/    1A0C : 9EBC 0000 0081      	SUB.l		#$81,d7				; normalise exponent
    4848/    1A12 : 177C 0081 0594      	MOVE.b	#$81,FAC1_e(a3)			; force a value between 1 and 2
    4849/    1A18 : 2C2B 0590           	MOVE.l	FAC1_m(a3),d6			; copy mantissa
    4850/    1A1C :                     
    4851/    1A1C : 277C 8000 0000      	MOVE.l	#$80000000,FAC2_m(a3)		; set mantissa for 1
             1A22 : 0598             
    4852/    1A24 : 377C 8100 059C      	MOVE.w	#$8100,FAC2_e(a3)			; set exponent for 1
    4853/    1A2A : 6100 FF18           	BSR		LAB_ADD				; find arg+1
    4854/    1A2E : 7000                	MOVEQ		#0,d0					; setup for calc skip
    4855/    1A30 : 3740 059C           	MOVE.w	d0,FAC2_e(a3)			; set FAC1 for zero result
    4856/    1A34 : DC86                	ADD.l		d6,d6					; shift 1 bit out
    4857/    1A36 : 2746 0598           	MOVE.l	d6,FAC2_m(a3)			; put back FAC2
    4858/    1A3A : 6758                	BEQ.s		LAB_LONN				; if 0 skip calculation
    4859/    1A3C :                     
    4860/    1A3C : 377C 8000 059C      	MOVE.w	#$8000,FAC2_e(a3)			; set exponent for .5
    4861/    1A42 : 6100 0130           	BSR		LAB_DIVIDE				; do (arg-1)/(arg+1)
    4862/    1A46 : 4A2B 0594           	TST.b		FAC1_e(a3)				; test exponent
    4863/    1A4A : 6748                	BEQ.s		LAB_LONN				; if 0 skip calculation
    4864/    1A4C :                     
    4865/    1A4C : 122B 0594           	MOVE.b	FAC1_e(a3),d1			; get exponent
    4866/    1A50 : 923C 0082           	SUB.b		#$82,d1				; normalise and two integer bits
    4867/    1A54 : 4401                	NEG.b		d1					; negate for shift
    4868/    1A56 :                     ;	CMP.b		#$1F,d1				; will mantissa vanish?
    4869/    1A56 :                     ;	BGT.s		LAB_dunno				; if so do ???
    4870/    1A56 :                     
    4871/    1A56 : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get mantissa
    4872/    1A5A : E2A8                	LSR.l		d1,d0					; shift in two integer bits
    4873/    1A5C :                     
    4874/    1A5C :                     ; d0 = arg
    4875/    1A5C :                     ; d0 = x, d1 = y
    4876/    1A5C :                     ; d2 = x1, d3 = y1
    4877/    1A5C :                     ; d4 = shift count
    4878/    1A5C :                     ; d5 = loop count
    4879/    1A5C :                     ; d6 = z
    4880/    1A5C :                     ; a0 = table pointer
    4881/    1A5C :                     
    4882/    1A5C : 7C00                	MOVEQ		#0,d6					; z = 0
    4883/    1A5E : 223C 4000 0000      	MOVE.l	#1<<30,d1				; y = 1
    4884/    1A64 : 41FA 1408           	LEA		TAB_HTHET(pc),a0			; get pointer to hyperbolic tangent table
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 86 - 10/11/2023 21:18:52


    4885/    1A68 : 7A1E                	MOVEQ		#30,d5				; loop 31 times
    4886/    1A6A : 7801                	MOVEQ		#1,d4					; set shift count
    4887/    1A6C : 6006                	BRA.s		LAB_LOCC				; entry point for loop
    4888/    1A6E :                     
    4889/    1A6E :                     LAB_LAAD
    4890/    1A6E : E8A2                	ASR.l		d4,d2					; x1 >> i
    4891/    1A70 : 9282                	SUB.l		d2,d1					; y = y - x1
    4892/    1A72 : DC90                	ADD.l		(a0),d6				; z = z + tanh(i)
    4893/    1A74 :                     LAB_LOCC
    4894/    1A74 : 2400                	MOVE.l	d0,d2					; x1 = x
    4895/    1A76 : 2601                	MOVE.l	d1,d3					; y1 = Y
    4896/    1A78 : E8A3                	ASR.l		d4,d3					; y1 >> i
    4897/    1A7A : 6402                	BCC.s		LAB_LOLP
    4898/    1A7C :                     
    4899/    1A7C : 5283                	ADDQ.l	#1,d3
    4900/    1A7E :                     LAB_LOLP
    4901/    1A7E : 9083                	SUB.l		d3,d0					; x = x - y1
    4902/    1A80 : 6AEC                	BPL.s		LAB_LAAD				; branch if > 0
    4903/    1A82 :                     
    4904/    1A82 : 2002                	MOVE.l	d2,d0					; get x back
    4905/    1A84 : 5848                	ADDQ.w	#4,a0					; next entry
    4906/    1A86 : 5284                	ADDQ.l	#1,d4					; next i
    4907/    1A88 : E28B                	LSR.l		#1,d3					; /2
    4908/    1A8A : 6704                	BEQ.s		LAB_LOCX				; branch y1 = 0
    4909/    1A8C :                     
    4910/    1A8C : 51CD FFF0           	DBF		d5,LAB_LOLP				; decrement and loop if not done
    4911/    1A90 :                     
    4912/    1A90 :                     								; now sort out the result
    4913/    1A90 :                     LAB_LOCX
    4914/    1A90 : DC86                	ADD.l		d6,d6					; *2
    4915/    1A92 : 2006                	MOVE.l	d6,d0					; setup for d7 = 0
    4916/    1A94 :                     LAB_LONN
    4917/    1A94 : 2800                	MOVE.l	d0,d4					; save cordic result
    4918/    1A96 : 7A00                	MOVEQ		#0,d5					; set default exponent sign
    4919/    1A98 : 4A87                	TST.l		d7					; check original exponent sign
    4920/    1A9A : 6716                	BEQ.s		LAB_LOXO				; branch if original was 0
    4921/    1A9C :                     
    4922/    1A9C : 6A04                	BPL.s		LAB_LOXP				; branch if was +ve
    4923/    1A9E :                     
    4924/    1A9E : 4487                	NEG.l		d7					; make original exponent +ve
    4925/    1AA0 : 7A80                	MOVEQ		#$80-$100,d5			; make sign -ve
    4926/    1AA2 :                     LAB_LOXP
    4927/    1AA2 : 1745 0595           	MOVE.b	d5,FAC1_s(a3)			; save original exponent sign
    4928/    1AA6 : 4847                	SWAP		d7					; 16 bit shift
    4929/    1AA8 : E18F                	LSL.l		#8,d7					; easy first part
    4930/    1AAA : 7A88                	MOVEQ		#$88-$100,d5			; start with byte
    4931/    1AAC :                     LAB_LONE
    4932/    1AAC : 5385                	SUBQ.l	#1,d5					; decrement exponent
    4933/    1AAE : DE87                	ADD.l		d7,d7					; shift mantissa
    4934/    1AB0 : 6AFA                	BPL.s		LAB_LONE				; loop if not normal
    4935/    1AB2 :                     
    4936/    1AB2 :                     LAB_LOXO
    4937/    1AB2 : 2747 0590           	MOVE.l	d7,FAC1_m(a3)			; save original exponent as mantissa
    4938/    1AB6 : 1745 0594           	MOVE.b	d5,FAC1_e(a3)			; save exponent for this
    4939/    1ABA : 277C B172 17F8      	MOVE.l	#$B17217F8,FAC2_m(a3)		; LOG(2) mantissa
             1AC0 : 0598             
    4940/    1AC2 : 377C 8000 059C      	MOVE.w	#$8000,FAC2_e(a3)			; LOG(2) exponent & sign
    4941/    1AC8 : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; make sign compare = FAC1 sign
    4942/    1ACE : 6118                	BSR.s		LAB_MULTIPLY			; do multiply
    4943/    1AD0 : 2744 0598           	MOVE.l	d4,FAC2_m(a3)			; save cordic result
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 87 - 10/11/2023 21:18:52


    4944/    1AD4 : 6710                	BEQ.s		LAB_LOWZ				; branch if zero
    4945/    1AD6 :                     
    4946/    1AD6 : 377C 8200 059C      	MOVE.w	#$8200,FAC2_e(a3)			; set exponent & sign
    4947/    1ADC : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; clear sign compare
    4948/    1AE2 : 6100 FE60           	BSR		LAB_ADD				; and add for final result
    4949/    1AE6 :                     
    4950/    1AE6 :                     LAB_LOWZ
    4951/    1AE6 : 4E75                	RTS
    4952/    1AE8 :                     
    4953/    1AE8 :                     
    4954/    1AE8 :                     ;************************************************************************************
    4955/    1AE8 :                     ;
    4956/    1AE8 :                     ; multiply FAC1 by FAC2
    4957/    1AE8 :                     
    4958/    1AE8 :                     LAB_MULTIPLY
    4959/    1AE8 : 48E7 F800           	MOVEM.l	d0-d4,-(sp)				; save registers
    4960/    1AEC : 4A2B 0594           	TST.b		FAC1_e(a3)				; test FAC1 exponent
    4961/    1AF0 : 6776                	BEQ.s		LAB_MUUF				; if exponent zero go make result zero
    4962/    1AF2 :                     
    4963/    1AF2 : 102B 059C           	MOVE.b	FAC2_e(a3),d0			; get FAC2 exponent
    4964/    1AF6 : 6770                	BEQ.s		LAB_MUUF				; if exponent zero go make result zero
    4965/    1AF8 :                     
    4966/    1AF8 : 176B 059E 0595      	MOVE.b	FAC_sc(a3),FAC1_s(a3)		; sign compare becomes sign
    4967/    1AFE :                     
    4968/    1AFE : D02B 0594           	ADD.b		FAC1_e(a3),d0			; multiply exponents by adding
    4969/    1B02 : 640A                	BCC.s		LAB_MNOC				; branch if no carry
    4970/    1B04 :                     
    4971/    1B04 : 903C 0080           	SUB.b		#$80,d0				; normalise result
    4972/    1B08 : 6400 E700           	BCC		LAB_OFER				; if no carry do overflow
    4973/    1B0C :                     
    4974/    1B0C : 6006                	BRA.s		LAB_MADD				; branch
    4975/    1B0E :                     
    4976/    1B0E :                     								; no carry for exponent add
    4977/    1B0E :                     LAB_MNOC
    4978/    1B0E : 903C 0080           	SUB.b		#$80,d0				; normalise result
    4979/    1B12 : 6554                	BCS.s		LAB_MUUF				; return zero if underflow
    4980/    1B14 :                     
    4981/    1B14 :                     LAB_MADD
    4982/    1B14 : 1740 0594           	MOVE.b	d0,FAC1_e(a3)			; save exponent
    4983/    1B18 :                     
    4984/    1B18 :                     								; d1 (FAC1) x d2 (FAC2)
    4985/    1B18 : 222B 0590           	MOVE.l	FAC1_m(a3),d1			; get FAC1 mantissa
    4986/    1B1C : 242B 0598           	MOVE.l	FAC2_m(a3),d2			; get FAC2 mantissa
    4987/    1B20 :                     
    4988/    1B20 : 3801                	MOVE.w	d1,d4					; copy low word FAC1
    4989/    1B22 : 2001                	MOVE.l	d1,d0					; copy long word FAC1
    4990/    1B24 : 4840                	SWAP		d0					; high word FAC1 to low word FAC1
    4991/    1B26 : 3600                	MOVE.w	d0,d3					; copy high word FAC1
    4992/    1B28 :                     
    4993/    1B28 : C2C2                	MULU		d2,d1					; low word FAC2 x low word FAC1
    4994/    1B2A : C0C2                	MULU		d2,d0					; low word FAC2 x high word FAC1
    4995/    1B2C : 4842                	SWAP		d2					; high word FAC2 to low word FAC2
    4996/    1B2E : C8C2                	MULU		d2,d4					; high word FAC2 x low word FAC1
    4997/    1B30 : C6C2                	MULU		d2,d3					; high word FAC2 x high word FAC1
    4998/    1B32 :                     
    4999/    1B32 :                     ; done multiply, now add partial products
    5000/    1B32 :                     
    5001/    1B32 :                     ;			d1 =					aaaa  ----	FAC2_L x FAC1_L
    5002/    1B32 :                     ;			d0 =				bbbb  aaaa		FAC2_L x FAC1_H
    5003/    1B32 :                     ;			d4 =				bbbb  aaaa		FAC2_H x FAC1_L
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 88 - 10/11/2023 21:18:52


    5004/    1B32 :                     ;			d3 =			cccc  bbbb			FAC2_H x FAC1_H
    5005/    1B32 :                     ;			product =		mmmm  mmmm
    5006/    1B32 :                     
    5007/    1B32 : D2BC 0000 8000      	ADD.L		#$8000,d1				; round up lowest word
    5008/    1B38 : 4241                	CLR.w		d1					; clear low word, don't need it
    5009/    1B3A : 4841                	SWAP		d1					; align high word
    5010/    1B3C : D280                	ADD.l		d0,d1					; add FAC2_L x FAC1_H (can't be carry)
    5011/    1B3E :                     LAB_MUF1
    5012/    1B3E : D284                	ADD.l		d4,d1					; now add intermediate (FAC2_H x FAC1_L)
    5013/    1B40 : 6406                	BCC.s		LAB_MUF2				; branch if no carry
    5014/    1B42 :                     
    5015/    1B42 : D6BC 0001 0000      	ADD.l		#$10000,d3				; else correct result
    5016/    1B48 :                     LAB_MUF2
    5017/    1B48 : D2BC 0000 8000      	ADD.l		#$8000,d1				; round up low word
    5018/    1B4E : 4241                	CLR.w		d1					; clear low word
    5019/    1B50 : 4841                	SWAP		d1					; align for final add
    5020/    1B52 : D283                	ADD.l		d3,d1					; add FAC2_H x FAC1_H, result
    5021/    1B54 : 6B08                	BMI.s		LAB_MUF3				; branch if normalisation not needed
    5022/    1B56 :                     
    5023/    1B56 : D281                	ADD.l		d1,d1					; shift mantissa
    5024/    1B58 : 532B 0594           	SUBQ.b	#1,FAC1_e(a3)			; adjust exponent
    5025/    1B5C : 670A                	BEQ.s		LAB_MUUF				; branch if underflow
    5026/    1B5E :                     
    5027/    1B5E :                     LAB_MUF3
    5028/    1B5E : 2741 0590           	MOVE.l	d1,FAC1_m(a3)			; save mantissa
    5029/    1B62 :                     LAB_MUEX
    5030/    1B62 : 4CDF 001F           	MOVEM.l	(sp)+,d0-d4				; restore registers
    5031/    1B66 : 4E75                	RTS
    5032/    1B68 :                     								; either zero or underflow result
    5033/    1B68 :                     LAB_MUUF
    5034/    1B68 : 7000                	MOVEQ		#0,d0					; quick clear
    5035/    1B6A : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; clear mantissa
    5036/    1B6E : 3740 0594           	MOVE.w	d0,FAC1_e(a3)			; clear sign and exponent
    5037/    1B72 : 60EE                	BRA.s		LAB_MUEX				; restore regs & exit
    5038/    1B74 :                     
    5039/    1B74 :                     
    5040/    1B74 :                     ;************************************************************************************
    5041/    1B74 :                     ;
    5042/    1B74 :                     ; do FAC2/FAC1, result in FAC1
    5043/    1B74 :                     ; fast hardware divide version
    5044/    1B74 :                     
    5045/    1B74 :                     LAB_DIVIDE
    5046/    1B74 : 2F07                	MOVE.l	d7,-(sp)				; save d7
    5047/    1B76 : 7000                	MOVEQ		#0,d0					; clear FAC2 exponent
    5048/    1B78 : 2400                	MOVE.l	d0,d2					; clear FAC1 exponent
    5049/    1B7A :                     
    5050/    1B7A : 142B 0594           	MOVE.b	FAC1_e(a3),d2			; get FAC1 exponent
    5051/    1B7E : 6700 E676           	BEQ		LAB_DZER				; if zero go do /0 error
    5052/    1B82 :                     
    5053/    1B82 : 102B 059C           	MOVE.b	FAC2_e(a3),d0			; get FAC2 exponent
    5054/    1B86 : 6766                	BEQ.s		LAB_DIV0				; if zero return zero
    5055/    1B88 :                     
    5056/    1B88 : 9042                	SUB.w		d2,d0					; get result exponent by subtracting
    5057/    1B8A : D07C 0080           	ADD.w		#$80,d0				; correct 16 bit exponent result
    5058/    1B8E :                     
    5059/    1B8E : 176B 059E 0595      	MOVE.b	FAC_sc(a3),FAC1_s(a3)		; sign compare is result sign
    5060/    1B94 :                     
    5061/    1B94 :                     ; now to do 32/32 bit mantissa divide
    5062/    1B94 :                     
    5063/    1B94 : 422B 059F           	CLR.b		flag(a3)				; clear 'flag' byte
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 89 - 10/11/2023 21:18:52


    5064/    1B98 : 262B 0590           	MOVE.l	FAC1_m(a3),d3			; get FAC1 mantissa
    5065/    1B9C : 282B 0598           	MOVE.l	FAC2_m(a3),d4			; get FAC2 mantissa
    5066/    1BA0 : B883                	CMP.l		d3,d4					; compare FAC2 with FAC1 mantissa
    5067/    1BA2 : 6744                	BEQ.s		LAB_MAN1				; set mantissa result = 1 if equal
    5068/    1BA4 :                     
    5069/    1BA4 : 6506                	BCS.s		AC1gtAC2				; branch if FAC1 > FAC2
    5070/    1BA6 :                     
    5071/    1BA6 : 9883                	SUB.l		d3,d4					; subtract FAC1 from FAC2, result now must be <1
    5072/    1BA8 : 562B 059F           	ADDQ.b	#3,flag(a3)				; FAC2>FAC1 so set 'flag' byte
    5073/    1BAC :                     AC1gtAC2
    5074/    1BAC : 6146                	BSR.s		LAB_32_16				; do 32/16 divide
    5075/    1BAE : 4841                	SWAP		d1					; move 16 bit result to high word
    5076/    1BB0 : 2802                	MOVE.l	d2,d4					; copy remainder longword
    5077/    1BB2 : 6142                	BSR.s		LAB_3216				; do 32/16 divide again (skip copy d4 to d2)
    5078/    1BB4 : 84C5                	DIVU.w	d5,d2					; now divide remainder to make guard word
    5079/    1BB6 : 1E2B 059F           	MOVE.b	flag(a3),d7				; now normalise, get flag byte back
    5080/    1BBA : 6708                	BEQ.s		LAB_DIVX				; skip add if null
    5081/    1BBC :                     
    5082/    1BBC :                     ; else result was >1 so we need to add 1 to result mantissa and adjust exponent
    5083/    1BBC :                     
    5084/    1BBC : E20F                	LSR.b		#1,d7					; shift 1 into eXtend
    5085/    1BBE : E291                	ROXR.l	#1,d1					; shift extend result >>
    5086/    1BC0 : E252                	ROXR.w	#1,d2					; shift extend guard word >>
    5087/    1BC2 : 5200                	ADDQ.b	#1,d0					; adjust exponent
    5088/    1BC4 :                     
    5089/    1BC4 :                     ; now round result to 32 bits
    5090/    1BC4 :                     
    5091/    1BC4 :                     LAB_DIVX
    5092/    1BC4 : D442                	ADD.w		d2,d2					; guard bit into eXtend bit
    5093/    1BC6 : 6408                	BCC.s		L_DIVRND				; branch if guard=0
    5094/    1BC8 :                     
    5095/    1BC8 : 5281                	ADDQ.l	#1,d1					; add guard to mantissa
    5096/    1BCA : 6404                	BCC.s		L_DIVRND				; branch if no overflow
    5097/    1BCC :                     
    5098/    1BCC :                     LAB_SET1
    5099/    1BCC : E291                	ROXR.l	#1,d1					; shift extend result >>
    5100/    1BCE : 5240                	ADDQ.w	#1,d0					; adjust exponent
    5101/    1BD0 :                     
    5102/    1BD0 :                     								; test for over/under flow
    5103/    1BD0 :                     L_DIVRND
    5104/    1BD0 : 3600                	MOVE.w	d0,d3					; copy exponent
    5105/    1BD2 : 6B1A                	BMI.s		LAB_DIV0				; if -ve return zero
    5106/    1BD4 :                     
    5107/    1BD4 : 0243 FF00           	ANDI.w	#$FF00,d3				; mask word high byte
    5108/    1BD8 : 6600 E630           	BNE		LAB_OFER				; branch if overflow
    5109/    1BDC :                     
    5110/    1BDC :                     								; move result into FAC1
    5111/    1BDC :                     LAB_XDIV
    5112/    1BDC : 2E1F                	MOVE.l	(sp)+,d7				; restore d7
    5113/    1BDE : 1740 0594           	MOVE.b	d0,FAC1_e(a3)			; save result exponent
    5114/    1BE2 : 2741 0590           	MOVE.l	d1,FAC1_m(a3)			; save result mantissa
    5115/    1BE6 : 4E75                	RTS
    5116/    1BE8 :                     
    5117/    1BE8 :                     ; FAC1 mantissa = FAC2 mantissa so set result mantissa
    5118/    1BE8 :                     
    5119/    1BE8 :                     LAB_MAN1
    5120/    1BE8 : 7201                	MOVEQ		#1,d1					; set bit
    5121/    1BEA : E2A9                	LSR.l		d1,d1					; bit into eXtend
    5122/    1BEC : 60DE                	BRA.s		LAB_SET1				; set mantissa, adjust exponent and exit
    5123/    1BEE :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 90 - 10/11/2023 21:18:52


    5124/    1BEE :                     ; result is zero
    5125/    1BEE :                     
    5126/    1BEE :                     LAB_DIV0
    5127/    1BEE : 7000                	MOVEQ		#0,d0					; zero exponent & sign
    5128/    1BF0 : 2200                	MOVE.l	d0,d1					; zero mantissa
    5129/    1BF2 : 60E8                	BRA		LAB_XDIV				; exit divide
    5130/    1BF4 :                     
    5131/    1BF4 :                     ; divide 16 bits into 32, AB/Ex
    5132/    1BF4 :                     ;
    5133/    1BF4 :                     ; d4			AAAA	BBBB				; 32 bit numerator
    5134/    1BF4 :                     ; d3			EEEE	xxxx				; 16 bit denominator
    5135/    1BF4 :                     ;
    5136/    1BF4 :                     ; returns -
    5137/    1BF4 :                     ;
    5138/    1BF4 :                     ; d1			xxxx	DDDD				; 16 bit result
    5139/    1BF4 :                     ; d2				HHHH	IIII			; 32 bit remainder
    5140/    1BF4 :                     
    5141/    1BF4 :                     LAB_32_16
    5142/    1BF4 : 2404                	MOVE.l	d4,d2					; copy FAC2 mantissa		(AB)
    5143/    1BF6 :                     LAB_3216
    5144/    1BF6 : 2A03                	MOVE.l	d3,d5					; copy FAC1 mantissa		(EF)
    5145/    1BF8 : 4245                	CLR.w		d5					; clear low word d1		(Ex)
    5146/    1BFA : 4845                	SWAP		d5					; swap high word to low word	(xE)
    5147/    1BFC :                     
    5148/    1BFC :                     ; d3			EEEE	FFFF				; denominator copy
    5149/    1BFC :                     ; d5		0000	EEEE					; denominator high word
    5150/    1BFC :                     ; d2			AAAA	BBBB				; numerator copy
    5151/    1BFC :                     ; d4			AAAA	BBBB				; numerator
    5152/    1BFC :                     
    5153/    1BFC : 88C5                	DIVU.w	d5,d4					; do FAC2/FAC1 high word	(AB/E)
    5154/    1BFE : 6802                	BVC.s		LAB_LT_1				; if no overflow DIV was ok
    5155/    1C00 :                     
    5156/    1C00 : 78FF                	MOVEQ		#-1,d4				; else set default value
    5157/    1C02 :                     
    5158/    1C02 :                     ; done the divide, now check the result, we have ...
    5159/    1C02 :                     
    5160/    1C02 :                     ; d3			EEEE	FFFF				; denominator copy
    5161/    1C02 :                     ; d5		0000	EEEE					; denominator high word
    5162/    1C02 :                     ; d2			AAAA	BBBB				; numerator copy
    5163/    1C02 :                     ; d4			MMMM	DDDD				; result MOD and DIV
    5164/    1C02 :                     
    5165/    1C02 :                     LAB_LT_1
    5166/    1C02 : 3C04                	MOVE.w	d4,d6					; copy 16 bit result
    5167/    1C04 : 3204                	MOVE.w	d4,d1					; copy 16 bit result again
    5168/    1C06 :                     
    5169/    1C06 :                     ; we now have ..
    5170/    1C06 :                     ; d3			EEEE	FFFF				; denominator copy
    5171/    1C06 :                     ; d5		0000	EEEE					; denominator high word
    5172/    1C06 :                     ; d6			xxxx  DDDD				; result DIV copy
    5173/    1C06 :                     ; d1			xxxx  DDDD				; result DIV copy
    5174/    1C06 :                     ; d2			AAAA	BBBB				; numerator copy
    5175/    1C06 :                     ; d4			MMMM	DDDD				; result MOD and DIV
    5176/    1C06 :                     
    5177/    1C06 :                     ; now multiply out 32 bit denominator by 16 bit result
    5178/    1C06 :                     ; QRS = AB*D
    5179/    1C06 :                     
    5180/    1C06 : CCC3                	MULU.w	d3,d6					; FFFF	; DDDD =       rrrr  SSSS
    5181/    1C08 : C8C5                	MULU.w	d5,d4					; EEEE	; DDDD = QQQQ  rrrr
    5182/    1C0A :                     
    5183/    1C0A :                     ; we now have ..
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 91 - 10/11/2023 21:18:52


    5184/    1C0A :                     ; d3			EEEE	FFFF				; denominator copy
    5185/    1C0A :                     ; d5		0000	EEEE					; denominator high word
    5186/    1C0A :                     ; d6				rrrr  SSSS			; 48 bit result partial low
    5187/    1C0A :                     ; d1			xxxx  DDDD				; result DIV copy
    5188/    1C0A :                     ; d2			AAAA	BBBB				; numerator copy
    5189/    1C0A :                     ; d4			QQQQ	rrrr				; 48 bit result partial
    5190/    1C0A :                     
    5191/    1C0A : 3E06                	MOVE.w	d6,d7					; copy low word of low multiply
    5192/    1C0C :                     
    5193/    1C0C :                     ; d7				xxxx	SSSS			; 48 bit result partial low
    5194/    1C0C :                     
    5195/    1C0C : 4246                	CLR.w		d6					; clear low word of low multiply
    5196/    1C0E : 4846                	SWAP		d6					; high word of low multiply to low word
    5197/    1C10 :                     
    5198/    1C10 :                     ; d6			0000	rrrr				; high word of 48 bit result partial low
    5199/    1C10 :                     
    5200/    1C10 : D886                	ADD.l		d6,d4
    5201/    1C12 :                     
    5202/    1C12 :                     ; d4			QQQQ	RRRR				; 48 bit result partial high longword
    5203/    1C12 :                     
    5204/    1C12 : 7C00                	MOVEQ		#0,d6					; clear to extend numerator to 48 bits
    5205/    1C14 :                     
    5206/    1C14 :                     ; now do GHI = AB0 - QRS (which is the remainder)
    5207/    1C14 :                     
    5208/    1C14 : 9C47                	SUB.w		d7,d6					; low word subtract
    5209/    1C16 :                     
    5210/    1C16 :                     ; d6				xxxx	IIII			; remainder low word
    5211/    1C16 :                     
    5212/    1C16 : 9584                	SUBX.l	d4,d2					; high longword subtract
    5213/    1C18 :                     
    5214/    1C18 :                     ; d2			GGGG	HHHH				; remainder high longword
    5215/    1C18 :                     
    5216/    1C18 :                     ; now if we got the divide correct then the remainder high longword will be +ve
    5217/    1C18 :                     
    5218/    1C18 : 6A08                	BPL.s		L_DDIV				; branch if result is ok (<needed)
    5219/    1C1A :                     
    5220/    1C1A :                     ; remainder was -ve so DDDD is too big
    5221/    1C1A :                     
    5222/    1C1A :                     LAB_REMM
    5223/    1C1A : 5341                	SUBQ.w	#1,d1					; adjust DDDD
    5224/    1C1C :                     
    5225/    1C1C :                     ; d3				xxxx	FFFF			; denominator copy
    5226/    1C1C :                     ; d6				xxxx	IIII			; remainder low word
    5227/    1C1C :                     
    5228/    1C1C : DC43                	ADD.w		d3,d6					; add EF*1 low remainder low word
    5229/    1C1E :                     
    5230/    1C1E :                     ; d5			0000	EEEE				; denominator high word
    5231/    1C1E :                     ; d2			GGGG	HHHH				; remainder high longword
    5232/    1C1E :                     
    5233/    1C1E : D585                	ADDX.l	d5,d2					; add extend EF*1 to remainder high longword
    5234/    1C20 : 6BF8                	BMI.s		LAB_REMM				; loop if result still too big
    5235/    1C22 :                     
    5236/    1C22 :                     ; all done and result correct or <
    5237/    1C22 :                     
    5238/    1C22 :                     L_DDIV
    5239/    1C22 : 4842                	SWAP		d2					; remainder mid word to high word
    5240/    1C24 :                     
    5241/    1C24 :                     ; d2			HHHH	GGGG				; (high word /should/ be $0000)
    5242/    1C24 :                     
    5243/    1C24 : 3406                	MOVE.w	d6,d2					; remainder in high word
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 92 - 10/11/2023 21:18:52


    5244/    1C26 :                     
    5245/    1C26 :                     ; d2				HHHH	IIII			; now is 32 bit remainder
    5246/    1C26 :                     ; d1			xxxx	DDDD				; 16 bit result
    5247/    1C26 :                     
    5248/    1C26 : 4E75                	RTS
    5249/    1C28 :                     
    5250/    1C28 :                     
    5251/    1C28 :                     ;************************************************************************************
    5252/    1C28 :                     ;
    5253/    1C28 :                     ; unpack memory (a0) into FAC1
    5254/    1C28 :                     
    5255/    1C28 :                     LAB_UFAC
    5256/    1C28 : 2010                	MOVE.l	(a0),d0				; get packed value
    5257/    1C2A : 4840                	SWAP		d0					; exponent and sign into least significant word
    5258/    1C2C : 3740 0594           	MOVE.w	d0,FAC1_e(a3)			; save exponent and sign
    5259/    1C30 : 6708                	BEQ.s		LAB_NB1T				; branch if exponent (and the rest) zero
    5260/    1C32 :                     
    5261/    1C32 : 807C 0080           	OR.w		#$80,d0				; set MSb
    5262/    1C36 : 4840                	SWAP		d0					; word order back to normal
    5263/    1C38 : E180                	ASL.l		#8,d0					; shift exponent & clear guard byte
    5264/    1C3A :                     LAB_NB1T
    5265/    1C3A : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; move into FAC1
    5266/    1C3E :                     
    5267/    1C3E : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
    5268/    1C42 : 4E75                	RTS
    5269/    1C44 :                     
    5270/    1C44 :                     
    5271/    1C44 :                     ;************************************************************************************
    5272/    1C44 :                     ;
    5273/    1C44 :                     ; set numeric variable, pack FAC1 into Lvarpl
    5274/    1C44 :                     
    5275/    1C44 :                     LAB_PFAC
    5276/    1C44 : 2F08                	MOVE.l	a0,-(sp)				; save pointer
    5277/    1C46 : 206B 0472           	MOVEA.l	Lvarpl(a3),a0			; get destination pointer
    5278/    1C4A : 082B 0006 05B5      	BTST		#6,Dtypef(a3)			; test data type
    5279/    1C50 : 670C                	BEQ.s		LAB_277C				; branch if floating
    5280/    1C52 :                     
    5281/    1C52 : 6100 00C6           	BSR		LAB_2831				; convert FAC1 floating to fixed
    5282/    1C56 :                     								; result in d0 and Itemp
    5283/    1C56 : 2080                	MOVE.l	d0,(a0)				; save in var
    5284/    1C58 : 205F                	MOVE.l	(sp)+,a0				; restore pointer
    5285/    1C5A : 4E75                	RTS
    5286/    1C5C :                     
    5287/    1C5C :                     
    5288/    1C5C :                     ;************************************************************************************
    5289/    1C5C :                     ;
    5290/    1C5C :                     ; normalise round and pack FAC1 into (a0)
    5291/    1C5C :                     
    5292/    1C5C :                     LAB_2778
    5293/    1C5C : 2F08                	MOVE.l	a0,-(sp)				; save pointer
    5294/    1C5E :                     LAB_277C
    5295/    1C5E : 6100 FD60           	BSR		LAB_24D5				; normalise FAC1
    5296/    1C62 : 612C                	BSR.s		LAB_27BA				; round FAC1
    5297/    1C64 : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get FAC1 mantissa
    5298/    1C68 : E098                	ROR.l		#8,d0					; align 24/32 bit mantissa
    5299/    1C6A : 4840                	SWAP		d0					; exponent/sign into 0-15
    5300/    1C6C : C07C 007F           	AND.w		#$7F,d0				; clear exponent and sign bit
    5301/    1C70 : 022B 0080 0595      	ANDI.b	#$80,FAC1_s(a3)			; clear non sign bits in sign
    5302/    1C76 : 806B 0594           	OR.w		FAC1_e(a3),d0			; OR in exponent and sign
    5303/    1C7A : 4840                	SWAP		d0					; move exponent and sign back to 16-31
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 93 - 10/11/2023 21:18:52


    5304/    1C7C : 2080                	MOVE.l	d0,(a0)				; store in destination
    5305/    1C7E : 205F                	MOVE.l	(sp)+,a0				; restore pointer
    5306/    1C80 : 4E75                	RTS
    5307/    1C82 :                     
    5308/    1C82 :                     
    5309/    1C82 :                     ;************************************************************************************
    5310/    1C82 :                     ;
    5311/    1C82 :                     ; copy FAC2 to FAC1
    5312/    1C82 :                     
    5313/    1C82 :                     LAB_279B
    5314/    1C82 : 376B 059C 0594      	MOVE.w	FAC2_e(a3),FAC1_e(a3)		; copy exponent & sign
    5315/    1C88 : 276B 0598 0590      	MOVE.l	FAC2_m(a3),FAC1_m(a3)		; copy mantissa
    5316/    1C8E : 4E75                	RTS
    5317/    1C90 :                     
    5318/    1C90 :                     
    5319/    1C90 :                     ;************************************************************************************
    5320/    1C90 :                     ;
    5321/    1C90 :                     ; round FAC1
    5322/    1C90 :                     
    5323/    1C90 :                     LAB_27BA
    5324/    1C90 : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
    5325/    1C94 : 6720                	BEQ.s		LAB_27C4				; branch if zero
    5326/    1C96 :                     
    5327/    1C96 : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get FAC1
    5328/    1C9A : D0BC 0000 0080      	ADD.l		#$80,d0				; round to 24 bit
    5329/    1CA0 : 640A                	BCC.s		LAB_27C3				; branch if no overflow
    5330/    1CA2 :                     
    5331/    1CA2 : E290                	ROXR.l	#1,d0					; shift FAC1 mantissa
    5332/    1CA4 : 522B 0594           	ADDQ.b	#1,FAC1_e(a3)			; correct exponent
    5333/    1CA8 : 6500 E560           	BCS		LAB_OFER				; if carry do overflow error & warm start
    5334/    1CAC :                     
    5335/    1CAC :                     LAB_27C3
    5336/    1CAC : C03C 0000           	AND.b		#$00,d0				; clear guard byte
    5337/    1CB0 : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; save back to FAC1
    5338/    1CB4 : 4E75                	RTS
    5339/    1CB6 :                     
    5340/    1CB6 :                     LAB_27C4
    5341/    1CB6 : 1740 0595           	MOVE.b	d0,FAC1_s(a3)			; make zero always +ve
    5342/    1CBA :                     RTS_017
    5343/    1CBA : 4E75                	RTS
    5344/    1CBC :                     
    5345/    1CBC :                     
    5346/    1CBC :                     ;************************************************************************************
    5347/    1CBC :                     ;
    5348/    1CBC :                     ; get FAC1 sign
    5349/    1CBC :                     ; return d0=-1,C=1/-ve d0=+1,C=0/+ve
    5350/    1CBC :                     
    5351/    1CBC :                     LAB_27CA
    5352/    1CBC : 7000                	MOVEQ		#0,d0					; clear d0
    5353/    1CBE : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
    5354/    1CC2 : 67F6                	BEQ.s		RTS_017				; exit if zero (already correct SGN(0)=0)
    5355/    1CC4 :                     
    5356/    1CC4 :                     
    5357/    1CC4 :                     ;************************************************************************************
    5358/    1CC4 :                     ;
    5359/    1CC4 :                     ; return d0=-1,C=1/-ve d0=+1,C=0/+ve
    5360/    1CC4 :                     ; no = 0 check
    5361/    1CC4 :                     
    5362/    1CC4 :                     LAB_27CE
    5363/    1CC4 : 102B 0595           	MOVE.b	FAC1_s(a3),d0			; else get FAC1 sign (b7)
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 94 - 10/11/2023 21:18:52


    5364/    1CC8 :                     
    5365/    1CC8 :                     
    5366/    1CC8 :                     ;************************************************************************************
    5367/    1CC8 :                     ;
    5368/    1CC8 :                     ; return d0=-1,C=1/-ve d0=+1,C=0/+ve
    5369/    1CC8 :                     ; no = 0 check, sign in d0
    5370/    1CC8 :                     
    5371/    1CC8 :                     LAB_27D0
    5372/    1CC8 : 4880                	EXT.w		d0					; make word
    5373/    1CCA : 48C0                	EXT.l		d0					; make longword
    5374/    1CCC : E080                	ASR.l		#8,d0					; move sign bit through byte to carry
    5375/    1CCE : 65EA                	BCS.s		RTS_017				; exit if carry set
    5376/    1CD0 :                     
    5377/    1CD0 : 7001                	MOVEQ		#1,d0					; set result for +ve sign
    5378/    1CD2 : 4E75                	RTS
    5379/    1CD4 :                     
    5380/    1CD4 :                     
    5381/    1CD4 :                     ;************************************************************************************
    5382/    1CD4 :                     ;
    5383/    1CD4 :                     ; perform SGN()
    5384/    1CD4 :                     
    5385/    1CD4 :                     LAB_SGN
    5386/    1CD4 : 61E6                	BSR.s		LAB_27CA				; get FAC1 sign
    5387/    1CD6 :                     								; return d0=-1/-ve d0=+1/+ve
    5388/    1CD6 :                     
    5389/    1CD6 :                     
    5390/    1CD6 :                     ;************************************************************************************
    5391/    1CD6 :                     ;
    5392/    1CD6 :                     ; save d0 as integer longword
    5393/    1CD6 :                     
    5394/    1CD6 :                     LAB_27DB
    5395/    1CD6 : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; save FAC1 mantissa
    5396/    1CDA : 377C A000 0594      	MOVE.w	#$A000,FAC1_e(a3)			; set FAC1 exponent & sign
    5397/    1CE0 : D080                	ADD.l		d0,d0					; top bit into carry
    5398/    1CE2 : 6000 FCD0           	BRA		LAB_24D0				; do +/- (carry is sign) & normalise FAC1
    5399/    1CE6 :                     
    5400/    1CE6 :                     
    5401/    1CE6 :                     ;************************************************************************************
    5402/    1CE6 :                     ;
    5403/    1CE6 :                     ; perform ABS()
    5404/    1CE6 :                     
    5405/    1CE6 :                     LAB_ABS
    5406/    1CE6 : 177C 0000 0595      	MOVE.b	#0,FAC1_s(a3)			; clear FAC1 sign
    5407/    1CEC : 4E75                	RTS
    5408/    1CEE :                     
    5409/    1CEE :                     
    5410/    1CEE :                     ;************************************************************************************
    5411/    1CEE :                     ;
    5412/    1CEE :                     ; compare FAC1 with FAC2
    5413/    1CEE :                     ; returns d0=+1 Cb=0 if FAC1 > FAC2
    5414/    1CEE :                     ; returns d0= 0 Cb=0 if FAC1 = FAC2
    5415/    1CEE :                     ; returns d0=-1 Cb=1 if FAC1 < FAC2
    5416/    1CEE :                     
    5417/    1CEE :                     LAB_27FA
    5418/    1CEE : 122B 059C           	MOVE.b	FAC2_e(a3),d1			; get FAC2 exponent
    5419/    1CF2 : 67C8                	BEQ.s		LAB_27CA				; branch if FAC2 exponent=0 & get FAC1 sign
    5420/    1CF4 :                     								; d0=-1,C=1/-ve d0=+1,C=0/+ve
    5421/    1CF4 :                     
    5422/    1CF4 : 102B 059E           	MOVE.b	FAC_sc(a3),d0			; get FAC sign compare
    5423/    1CF8 : 6BCA                	BMI.s		LAB_27CE				; if signs <> do return d0=-1,C=1/-ve
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 95 - 10/11/2023 21:18:52


    5424/    1CFA :                     								; d0=+1,C=0/+ve & return
    5425/    1CFA :                     
    5426/    1CFA : 102B 0595           	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
    5427/    1CFE : B22B 0594           	CMP.b		FAC1_e(a3),d1			; compare FAC1 exponent with FAC2 exponent
    5428/    1D02 : 660A                	BNE.s		LAB_2828				; branch if different
    5429/    1D04 :                     
    5430/    1D04 : 222B 0598           	MOVE.l	FAC2_m(a3),d1			; get FAC2 mantissa
    5431/    1D08 : B2AB 0590           	CMP.l		FAC1_m(a3),d1			; compare mantissas
    5432/    1D0C : 6708                	BEQ.s		LAB_282F				; exit if mantissas equal
    5433/    1D0E :                     
    5434/    1D0E :                     ; gets here if number <> FAC1
    5435/    1D0E :                     
    5436/    1D0E :                     LAB_2828
    5437/    1D0E : 65B8                	BCS.s		LAB_27D0				; if FAC1 > FAC2 return d0=-1,C=1/-ve d0=+1,
    5438/    1D10 :                     								; C=0/+ve
    5439/    1D10 :                     
    5440/    1D10 : 0A00 0080           	EORI.b	#$80,d0				; else toggle FAC1 sign
    5441/    1D14 :                     LAB_282E
    5442/    1D14 : 60B2                	BRA.s		LAB_27D0				; return d0=-1,C=1/-ve d0=+1,C=0/+ve
    5443/    1D16 :                     
    5444/    1D16 :                     LAB_282F
    5445/    1D16 : 7000                	MOVEQ		#0,d0					; clear result
    5446/    1D18 : 4E75                	RTS
    5447/    1D1A :                     
    5448/    1D1A :                     
    5449/    1D1A :                     ;************************************************************************************
    5450/    1D1A :                     ;
    5451/    1D1A :                     ; convert FAC1 floating to fixed
    5452/    1D1A :                     ; result in d0 and Itemp, sets flags correctly
    5453/    1D1A :                     
    5454/    1D1A :                     LAB_2831
    5455/    1D1A : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; copy mantissa
    5456/    1D1E : 6732                	BEQ.s		LAB_284J				; branch if mantissa = 0
    5457/    1D20 :                     
    5458/    1D20 : 2F01                	MOVE.l	d1,-(sp)				; save d1
    5459/    1D22 : 123C 00A0           	MOVE.b		#$A0,d1				; set for no floating bits
    5460/    1D26 : 922B 0594           	SUB.b		FAC1_e(a3),d1			; subtract FAC1 exponent
    5461/    1D2A : 6500 E4DE           	BCS		LAB_OFER				; do overflow if too big
    5462/    1D2E :                     
    5463/    1D2E : 660E                	BNE.s		LAB_284G				; branch if exponent was not $A0
    5464/    1D30 :                     
    5465/    1D30 : 4A2B 0595           	TST.b		FAC1_s(a3)				; test FAC1 sign
    5466/    1D34 : 6A1A                	BPL.s		LAB_284H				; branch if FAC1 +ve
    5467/    1D36 :                     
    5468/    1D36 : 4480                	NEG.l		d0
    5469/    1D38 : 6916                	BVS.s		LAB_284H				; branch if was $80000000
    5470/    1D3A :                     
    5471/    1D3A : 6000 E4CE           	BRA		LAB_OFER				; do overflow if too big
    5472/    1D3E :                     
    5473/    1D3E :                     LAB_284G
    5474/    1D3E : B23C 0020           	CMP.b		#$20,d1				; compare with minimum result for integer
    5475/    1D42 : 6502                	BCS.s		LAB_284L				; if < minimum just do shift
    5476/    1D44 :                     
    5477/    1D44 : 7000                	MOVEQ		#0,d0					; else return zero
    5478/    1D46 :                     LAB_284L
    5479/    1D46 : E2A8                	LSR.l		d1,d0					; shift integer
    5480/    1D48 :                     
    5481/    1D48 : 4A2B 0595           	TST.b		FAC1_s(a3)				; test FAC1 sign (b7)
    5482/    1D4C : 6A02                	BPL.s		LAB_284H				; branch if FAC1 +ve
    5483/    1D4E :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 96 - 10/11/2023 21:18:52


    5484/    1D4E : 4480                	NEG.l		d0					; negate integer value
    5485/    1D50 :                     LAB_284H
    5486/    1D50 : 221F                	MOVE.l	(sp)+,d1				; restore d1
    5487/    1D52 :                     LAB_284J
    5488/    1D52 : 2740 042A           	MOVE.l	d0,Itemp(a3)			; save result to Itemp
    5489/    1D56 : 4E75                	RTS
    5490/    1D58 :                     
    5491/    1D58 :                     
    5492/    1D58 :                     ;************************************************************************************
    5493/    1D58 :                     ;
    5494/    1D58 :                     ; perform INT()
    5495/    1D58 :                     
    5496/    1D58 :                     LAB_INT
    5497/    1D58 : 103C 00A0           	MOVE.b		#$A0,d0				; set for no floating bits
    5498/    1D5C : 902B 0594           	SUB.b		FAC1_e(a3),d0			; subtract FAC1 exponent
    5499/    1D60 : 6310                	BLS.s		LAB_IRTS				; exit if exponent >= $A0
    5500/    1D62 :                     								; (too big for fraction part!)
    5501/    1D62 :                     
    5502/    1D62 : B03C 0020           	CMP.b		#$20,d0				; compare with minimum result for integer
    5503/    1D66 : 6400 0262           	BCC		LAB_POZE				; if >= minimum go return 0
    5504/    1D6A :                     								; (too small for integer part!)
    5505/    1D6A :                     
    5506/    1D6A : 72FF                	MOVEQ		#-1,d1				; set integer mask
    5507/    1D6C : E1A1                	ASL.l		d0,d1					; shift mask [8+2*d0]
    5508/    1D6E : C3AB 0590           	AND.l		d1,FAC1_m(a3)			; mask mantissa
    5509/    1D72 :                     LAB_IRTS
    5510/    1D72 : 4E75                	RTS
    5511/    1D74 :                     
    5512/    1D74 :                     
    5513/    1D74 :                     ;************************************************************************************
    5514/    1D74 :                     ;
    5515/    1D74 :                     ; print " in line [LINE #]"
    5516/    1D74 :                     
    5517/    1D74 :                     LAB_2953
    5518/    1D74 : 41FA 1800           	LEA		LAB_LMSG(pc),a0			; point to " in line " message
    5519/    1D78 : 6100 ED1C           	BSR		LAB_18C3				; print null terminated string
    5520/    1D7C :                     
    5521/    1D7C :                     								; Print Basic line #
    5522/    1D7C : 202B 0452           	MOVE.l	Clinel(a3),d0			; get current line
    5523/    1D80 :                     
    5524/    1D80 :                     
    5525/    1D80 :                     ;************************************************************************************
    5526/    1D80 :                     ;
    5527/    1D80 :                     ; print d0 as unsigned integer
    5528/    1D80 :                     
    5529/    1D80 :                     LAB_295E
    5530/    1D80 : 43FA 0DEE           	LEA		Bin2dec(pc),a1			; get table address
    5531/    1D84 : 7200                	MOVEQ		#0,d1					; table index
    5532/    1D86 : 41EB 05CC           	LEA		Usdss(a3),a0			; output string start
    5533/    1D8A : 2401                	MOVE.l	d1,d2					; output string index
    5534/    1D8C :                     LAB_2967
    5535/    1D8C : 2631 1000           	MOVE.l	(a1,d1.w),d3			; get table value
    5536/    1D90 : 6714                	BEQ.s		LAB_2969				; exit if end marker
    5537/    1D92 :                     
    5538/    1D92 : 782F                	MOVEQ		#'0'-1,d4				; set character to "0"-1
    5539/    1D94 :                     LAB_2968
    5540/    1D94 : 5244                	ADDQ.w	#1,d4					; next numeric character
    5541/    1D96 : 9083                	SUB.l		d3,d0					; subtract table value
    5542/    1D98 : 6AFA                	BPL.s		LAB_2968				; not overdone so loop
    5543/    1D9A :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 97 - 10/11/2023 21:18:52


    5544/    1D9A : D083                	ADD.l		d3,d0					; correct value
    5545/    1D9C : 1184 2000           	MOVE.b	d4,(a0,d2.w)			; character out to string
    5546/    1DA0 : 5841                	ADDQ.w	#4,d1					; increment table pointer
    5547/    1DA2 : 5242                	ADDQ.w	#1,d2					; increment output string pointer
    5548/    1DA4 : 60E6                	BRA.s		LAB_2967				; loop
    5549/    1DA6 :                     
    5550/    1DA6 :                     LAB_2969
    5551/    1DA6 : D03C 0030           	ADD.b		#'0',d0				; make last character
    5552/    1DAA : 1180 2000           	MOVE.b	d0,(a0,d2.w)			; character out to string
    5553/    1DAE : 5348                	SUBQ.w	#1,a0					; decrement a0 (allow simple loop)
    5554/    1DB0 :                     
    5555/    1DB0 :                     								; now find non zero start of string
    5556/    1DB0 :                     LAB_296A
    5557/    1DB0 : 5248                	ADDQ.w	#1,a0					; increment a0 (this will never carry to b16)
    5558/    1DB2 : 43EB 05D5           	LEA		BHsend-1(a3),a1			; get string end
    5559/    1DB6 : B1C9                	CMPA.l	a1,a0					; are we at end
    5560/    1DB8 : 6700 ECDC           	BEQ		LAB_18C3				; if so print null terminated string and RETURN
    5561/    1DBC :                     
    5562/    1DBC : 0C10 0030           	CMPI.b	#'0',(a0)				; is character "0" ?
    5563/    1DC0 : 67EE                	BEQ.s		LAB_296A				; loop if so
    5564/    1DC2 :                     
    5565/    1DC2 : 6000 ECD2           	BRA		LAB_18C3				; print null terminated string from memory & RET
    5566/    1DC6 :                     
    5567/    1DC6 :                     
    5568/    1DC6 :                     ;************************************************************************************
    5569/    1DC6 :                     ;
    5570/    1DC6 :                     ; convert FAC1 to ASCII string result in (a0)
    5571/    1DC6 :                     ; STR$() function enters here
    5572/    1DC6 :                     
    5573/    1DC6 :                     ; now outputs 7 significant digits
    5574/    1DC6 :                     
    5575/    1DC6 :                     ; d0 is character out
    5576/    1DC6 :                     ; d1 is save index
    5577/    1DC6 :                     ; d2 is gash
    5578/    1DC6 :                     
    5579/    1DC6 :                     ; a0 is output string pointer
    5580/    1DC6 :                     
    5581/    1DC6 :                     LAB_2970
    5582/    1DC6 : 43EB 05C6           	LEA		Decss(a3),a1			; set output string start
    5583/    1DCA :                     
    5584/    1DCA : 7420                	MOVEQ		#' ',d2				; character = " ", assume +ve
    5585/    1DCC : 08AB 0007 0595      	BCLR.b	#7,FAC1_s(a3)			; test and clear FAC1 sign (b7)
    5586/    1DD2 : 6702                	BEQ.s		LAB_2978				; branch if +ve
    5587/    1DD4 :                     
    5588/    1DD4 : 742D                	MOVEQ		#'-',d2				; else character = "-"
    5589/    1DD6 :                     LAB_2978
    5590/    1DD6 : 1282                	MOVE.b	d2,(a1)				; save the sign character
    5591/    1DD8 : 142B 0594           	MOVE.b	FAC1_e(a3),d2			; get FAC1 exponent
    5592/    1DDC : 6608                	BNE.s		LAB_2989				; branch if FAC1<>0
    5593/    1DDE :                     
    5594/    1DDE :                     								; exponent was $00 so FAC1 is 0
    5595/    1DDE : 7030                	MOVEQ		#'0',d0				; set character = "0"
    5596/    1DE0 : 7201                	MOVEQ		#1,d1					; set output string index
    5597/    1DE2 : 6000 01A8           	BRA		LAB_2A89				; save last character, [EOT] & exit
    5598/    1DE6 :                     
    5599/    1DE6 :                     								; FAC1 is some non zero value
    5600/    1DE6 :                     LAB_2989
    5601/    1DE6 : 177C 0000 05AC      	MOVE.b	#0,numexp(a3)			; clear number exponent count
    5602/    1DEC : B43C 0081           	CMP.b		#$81,d2				; compare FAC1 exponent with $81 (>1.00000)
    5603/    1DF0 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 98 - 10/11/2023 21:18:52


    5604/    1DF0 : 6448                	BCC.s		LAB_299C				; branch if FAC1=>1
    5605/    1DF2 :                     
    5606/    1DF2 :                     								; else FAC1 < 1
    5607/    1DF2 : 277C 9896 8000      	MOVE.l	#$98968000,FAC2_m(a3)		; 10000000 mantissa
             1DF8 : 0598             
    5608/    1DFA : 377C 9800 059C      	MOVE.w	#$9800,FAC2_e(a3)			; 10000000 exponent & sign
    5609/    1E00 : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; make FAC1 sign sign compare
    5610/    1E06 : 6100 FCE0           	BSR		LAB_MULTIPLY			; do FAC2*FAC1
    5611/    1E0A :                     
    5612/    1E0A : 177C 00F9 05AC      	MOVE.b	#$F9,numexp(a3)			; set number exponent count (-7)
    5613/    1E10 : 6028                	BRA.s		LAB_299C				; go test for fit
    5614/    1E12 :                     
    5615/    1E12 :                     LAB_29B9
    5616/    1E12 : 376B 0594 059C      	MOVE.w	FAC1_e(a3),FAC2_e(a3)		; copy exponent & sign from FAC1 to FAC2
    5617/    1E18 : 276B 0590 0598      	MOVE.l	FAC1_m(a3),FAC2_m(a3)		; copy FAC1 mantissa to FAC2 mantissa
    5618/    1E1E : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; save FAC1_s as sign compare
    5619/    1E24 :                     
    5620/    1E24 : 277C CCCC CCCD      	MOVE.l	#$CCCCCCCD,FAC1_m(a3)		; 1/10 mantissa
             1E2A : 0590             
    5621/    1E2C : 377C 7D00 0594      	MOVE.w	#$7D00,FAC1_e(a3)			; 1/10 exponent & sign
    5622/    1E32 : 6100 FCB4           	BSR		LAB_MULTIPLY			; do FAC2*FAC1, effectively divide by 10 but
    5623/    1E36 :                     								; faster
    5624/    1E36 :                     
    5625/    1E36 : 522B 05AC           	ADDQ.b	#1,numexp(a3)			; increment number exponent count
    5626/    1E3A :                     LAB_299C
    5627/    1E3A : 277C 9896 7F70      	MOVE.l	#$98967F70,FAC2_m(a3)		; 9999999.4375 mantissa
             1E40 : 0598             
    5628/    1E42 : 377C 9800 059C      	MOVE.w	#$9800,FAC2_e(a3)			; 9999999.4375 exponent & sign
    5629/    1E48 :                     								; (max before scientific notation)
    5630/    1E48 : 6100 0150           	BSR		LAB_27F0				; fast compare FAC1 with FAC2
    5631/    1E4C :                     								; returns d0=+1 C=0 if FAC1 > FAC2
    5632/    1E4C :                     								; returns d0= 0 C=0 if FAC1 = FAC2
    5633/    1E4C :                     								; returns d0=-1 C=1 if FAC1 < FAC2
    5634/    1E4C : 62C4                	BHI.s		LAB_29B9				; go do /10 if FAC1 > 9999999.4375
    5635/    1E4E :                     
    5636/    1E4E : 6750                	BEQ.s		LAB_29C3				; branch if FAC1 = 9999999.4375
    5637/    1E50 :                     
    5638/    1E50 :                     								; FAC1 < 9999999.4375
    5639/    1E50 : 277C F423 F800      	MOVE.l	#$F423F800,FAC2_m(a3)		; set mantissa for 999999.5
             1E56 : 0598             
    5640/    1E58 : 377C 9400 059C      	MOVE.w	#$9400,FAC2_e(a3)			; set exponent for 999999.5
    5641/    1E5E :                     
    5642/    1E5E : 41EB 0590           	LEA		FAC1_m(a3),a0			; set pointer for x10
    5643/    1E62 :                     LAB_29A7
    5644/    1E62 : 6100 0136           	BSR		LAB_27F0				; fast compare FAC1 with FAC2
    5645/    1E66 :                     								; returns d0=+1 C=0 if FAC1 > FAC2
    5646/    1E66 :                     								; returns d0= 0 C=0 if FAC1 = FAC2
    5647/    1E66 :                     								; returns d0=-1 C=1 if FAC1 < FAC2
    5648/    1E66 : 6220                	BHI.s		LAB_29C0				; branch if FAC1 > 99999.9375,no decimal places
    5649/    1E68 :                     
    5650/    1E68 :                     								; FAC1 <= 999999.5 so do x 10
    5651/    1E68 : 2010                	MOVE.l	(a0),d0				; get FAC1 mantissa
    5652/    1E6A : 1228 0004           	MOVE.b	4(a0),d1				; get FAC1 exponent
    5653/    1E6E : 2400                	MOVE.l	d0,d2					; copy it
    5654/    1E70 : E488                	LSR.l		#2,d0					; /4
    5655/    1E72 : D082                	ADD.l		d2,d0					; add FAC1 (x1.125)
    5656/    1E74 : 6404                	BCC.s		LAB_29B7				; branch if no carry
    5657/    1E76 :                     
    5658/    1E76 : E290                	ROXR.l	#1,d0					; shift carry back in
    5659/    1E78 : 5201                	ADDQ.b	#1,d1					; increment exponent (never overflows)
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 99 - 10/11/2023 21:18:52


    5660/    1E7A :                     LAB_29B7
    5661/    1E7A : 5601                	ADDQ.b	#3,d1					; correct exponent ( 8 x 1.125 = 10 )
    5662/    1E7C :                     								; (never overflows)
    5663/    1E7C : 2080                	MOVE.l	d0,(a0)				; save new mantissa
    5664/    1E7E : 1141 0004           	MOVE.b	d1,4(a0)				; save new exponent
    5665/    1E82 : 532B 05AC           	SUBQ.b	#1,numexp(a3)			; decrement number exponent count
    5666/    1E86 : 60DA                	BRA.s		LAB_29A7				; go test again
    5667/    1E88 :                     
    5668/    1E88 :                     								; now we have just the digits to do
    5669/    1E88 :                     LAB_29C0
    5670/    1E88 : 277C 8000 0000      	MOVE.l	#$80000000,FAC2_m(a3)		; set mantissa for 0.5
             1E8E : 0598             
    5671/    1E90 : 377C 8000 059C      	MOVE.w	#$8000,FAC2_e(a3)			; set exponent for 0.5
    5672/    1E96 : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; sign compare = sign
    5673/    1E9C : 6100 FAA6           	BSR		LAB_ADD				; add the 0.5 to FAC1 (round FAC1)
    5674/    1EA0 :                     
    5675/    1EA0 :                     LAB_29C3
    5676/    1EA0 : 6100 FE78           	BSR		LAB_2831				; convert FAC1 floating to fixed
    5677/    1EA4 :                     								; result in d0 and Itemp
    5678/    1EA4 : 7401                	MOVEQ		#$01,d2				; set default digits before dp = 1
    5679/    1EA6 : 102B 05AC           	MOVE.b	numexp(a3),d0			; get number exponent count
    5680/    1EAA : D03C 0008           	ADD.b		#8,d0					; allow 7 digits before point
    5681/    1EAE : 6B0C                	BMI.s		LAB_29D9				; if -ve then 1 digit before dp
    5682/    1EB0 :                     
    5683/    1EB0 : B03C 0009           	CMP.b		#$09,d0				; d0>=9 if n>=1E7
    5684/    1EB4 : 6406                	BCC.s		LAB_29D9				; branch if >= $09
    5685/    1EB6 :                     
    5686/    1EB6 :                     								; < $08
    5687/    1EB6 : 5300                	SUBQ.b	#1,d0					; take 1 from digit count
    5688/    1EB8 : 1400                	MOVE.b	d0,d2					; copy byte
    5689/    1EBA : 7002                	MOVEQ		#$02,d0				; set exponent adjust
    5690/    1EBC :                     LAB_29D9
    5691/    1EBC : 7200                	MOVEQ		#0,d1					; set output string index
    5692/    1EBE : 5500                	SUBQ.b	#2,d0					; -2
    5693/    1EC0 : 1740 05AD           	MOVE.b	d0,expcnt(a3)			; save exponent adjust
    5694/    1EC4 : 1742 05AC           	MOVE.b	d2,numexp(a3)			; save digits before dp count
    5695/    1EC8 : 1002                	MOVE.b	d2,d0					; copy digits before dp count
    5696/    1ECA : 6702                	BEQ.s		LAB_29E4				; branch if no digits before dp
    5697/    1ECC :                     
    5698/    1ECC : 6A14                	BPL.s		LAB_29F7				; branch if digits before dp
    5699/    1ECE :                     
    5700/    1ECE :                     LAB_29E4
    5701/    1ECE : 5281                	ADDQ.l	#1,d1					; increment index
    5702/    1ED0 : 13BC 002E 1000      	MOVE.b	#'.',(a1,d1.w)			; save to output string
    5703/    1ED6 :                     
    5704/    1ED6 : 4A02                	TST.b		d2					; test digits before dp count
    5705/    1ED8 : 6708                	BEQ.s		LAB_29F7				; branch if no digits before dp
    5706/    1EDA :                     
    5707/    1EDA : 5281                	ADDQ.l	#1,d1					; increment index
    5708/    1EDC : 13BC 0030 1000      	MOVE.b	#'0',(a1,d1.w)			; save to output string
    5709/    1EE2 :                     LAB_29F7
    5710/    1EE2 : 7400                	MOVEQ		#0,d2					; clear index (point to 1,000,000)
    5711/    1EE4 : 7080                	MOVEQ		#$80-$100,d0			; set output character
    5712/    1EE6 :                     LAB_29FB
    5713/    1EE6 : 41FA 1122           	LEA		LAB_2A9A(pc),a0			; get base of table
    5714/    1EEA : 2630 2000           	MOVE.l	(a0,d2.w),d3			; get table value
    5715/    1EEE :                     LAB_29FD
    5716/    1EEE : 5200                	ADDQ.b	#1,d0					; increment output character
    5717/    1EF0 : D7AB 042A           	ADD.l		d3,Itemp(a3)			; add to (now fixed) mantissa
    5718/    1EF4 : 0800 0007           	BTST		#7,d0					; set test sense (z flag only)
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 100 - 10/11/2023 21:18:52


    5719/    1EF8 : 6504                	BCS.s		LAB_2A18				; did carry so has wrapped past zero
    5720/    1EFA :                     
    5721/    1EFA : 67F2                	BEQ.s		LAB_29FD				; no wrap and +ve test so try again
    5722/    1EFC :                     
    5723/    1EFC : 6002                	BRA.s		LAB_2A1A				; found this digit
    5724/    1EFE :                     
    5725/    1EFE :                     LAB_2A18
    5726/    1EFE : 66EE                	BNE.s		LAB_29FD				; wrap and -ve test so try again
    5727/    1F00 :                     
    5728/    1F00 :                     LAB_2A1A
    5729/    1F00 : 6406                	BCC.s		LAB_2A21				; branch if +ve test result
    5730/    1F02 :                     
    5731/    1F02 : 4400                	NEG.b		d0					; negate the digit number
    5732/    1F04 : D03C 000B           	ADD.b		#$0B,d0				; and subtract from 11 decimal
    5733/    1F08 :                     LAB_2A21
    5734/    1F08 : D03C 002F           	ADD.b		#$2F,d0				; add "0"-1 to result
    5735/    1F0C : 5842                	ADDQ.w	#4,d2					; increment index to next less power of ten
    5736/    1F0E : 5241                	ADDQ.w	#1,d1					; increment output string index
    5737/    1F10 : 1600                	MOVE.b	d0,d3					; copy character to d3
    5738/    1F12 : C63C 007F           	AND.b		#$7F,d3				; mask out top bit
    5739/    1F16 : 1383 1000           	MOVE.b	d3,(a1,d1.w)			; save to output string
    5740/    1F1A : 042B 0001 05AC      	SUB.b		#1,numexp(a3)			; decrement # of characters before the dp
    5741/    1F20 : 6608                	BNE.s		LAB_2A3B				; branch if still characters to do
    5742/    1F22 :                     
    5743/    1F22 :                     								; else output the point
    5744/    1F22 : 5281                	ADDQ.l	#1,d1					; increment index
    5745/    1F24 : 13BC 002E 1000      	MOVE.b	#'.',(a1,d1.w)			; save to output string
    5746/    1F2A :                     LAB_2A3B
    5747/    1F2A : C03C 0080           	AND.b		#$80,d0				; mask test sense bit
    5748/    1F2E : 0A00 0080           	EORI.b	#$80,d0				; invert it
    5749/    1F32 : B43C 001C           	CMP.b		#LAB_2A9B-LAB_2A9A,d2		; compare table index with max+4
    5750/    1F36 : 66AE                	BNE.s		LAB_29FB				; loop if not max
    5751/    1F38 :                     
    5752/    1F38 :                     								; now remove trailing zeroes
    5753/    1F38 :                     LAB_2A4B
    5754/    1F38 : 1031 1000           	MOVE.b	(a1,d1.w),d0			; get character from output string
    5755/    1F3C : 5381                	SUBQ.l	#1,d1					; decrement output string index
    5756/    1F3E : B03C 0030           	CMP.b		#'0',d0				; compare with "0"
    5757/    1F42 : 67F4                	BEQ.s		LAB_2A4B				; loop until non "0" character found
    5758/    1F44 :                     
    5759/    1F44 : B03C 002E           	CMP.b		#'.',d0				; compare with "."
    5760/    1F48 : 6702                	BEQ.s		LAB_2A58				; branch if was dp
    5761/    1F4A :                     
    5762/    1F4A :                     								; else restore last character
    5763/    1F4A : 5281                	ADDQ.l	#1,d1					; increment output string index
    5764/    1F4C :                     LAB_2A58
    5765/    1F4C : 13BC 002B 1002      	MOVE.b	#'+',2(a1,d1.w)			; save character "+" to output string
    5766/    1F52 : 4A2B 05AD           	TST.b		expcnt(a3)				; test exponent count
    5767/    1F56 : 6738                	BEQ.s		LAB_2A8C				; if zero go set null terminator & exit
    5768/    1F58 :                     
    5769/    1F58 :                     								; exponent isn't zero so write exponent
    5770/    1F58 : 6A0A                	BPL.s		LAB_2A68				; branch if exponent count +ve
    5771/    1F5A :                     
    5772/    1F5A : 13BC 002D 1002      	MOVE.b	#'-',2(a1,d1.w)			; save character "-" to output string
    5773/    1F60 : 442B 05AD           	NEG.b		expcnt(a3)				; convert -ve to +ve
    5774/    1F64 :                     LAB_2A68
    5775/    1F64 : 13BC 0045 1001      	MOVE.b	#'E',1(a1,d1.w)			; save character "E" to output string
    5776/    1F6A : 142B 05AD           	MOVE.b	expcnt(a3),d2			; get exponent count
    5777/    1F6E : 702F                	MOVEQ		#$2F,d0				; one less than "0" character
    5778/    1F70 :                     LAB_2A74
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 101 - 10/11/2023 21:18:52


    5779/    1F70 : 5200                	ADDQ.b	#1,d0					; increment 10's character
    5780/    1F72 : 943C 000A           	SUB.b		#$0A,d2				; subtract 10 from exponent count
    5781/    1F76 : 64F8                	BCC.s		LAB_2A74				; loop while still >= 0
    5782/    1F78 :                     
    5783/    1F78 : D43C 003A           	ADD.b		#$3A,d2				; add character ":", $30+$0A, result is 10-value
    5784/    1F7C : 1380 1003           	MOVE.b	d0,3(a1,d1.w)			; save 10's character to output string
    5785/    1F80 : 1382 1004           	MOVE.b	d2,4(a1,d1.w)			; save 1's character to output string
    5786/    1F84 : 13BC 0000 1005      	MOVE.b	#0,5(a1,d1.w)			; save null terminator after last character
    5787/    1F8A : 600A                	BRA.s		LAB_2A91				; go set string pointer (a0) and exit
    5788/    1F8C :                     
    5789/    1F8C :                     LAB_2A89
    5790/    1F8C : 1380 1000           	MOVE.b	d0,(a1,d1.w)			; save last character to output string
    5791/    1F90 :                     LAB_2A8C
    5792/    1F90 : 13BC 0000 1001      	MOVE.b	#0,1(a1,d1.w)			; save null terminator after last character
    5793/    1F96 :                     LAB_2A91
    5794/    1F96 : 2049                	MOVEA.l	a1,a0					; set result string pointer (a0)
    5795/    1F98 : 4E75                	RTS
    5796/    1F9A :                     
    5797/    1F9A :                     
    5798/    1F9A :                     ;************************************************************************************
    5799/    1F9A :                     ;
    5800/    1F9A :                     ; fast compare FAC1 with FAC2
    5801/    1F9A :                     ; assumes both are +ve and FAC2>0
    5802/    1F9A :                     ; returns d0=+1 C=0 if FAC1 > FAC2
    5803/    1F9A :                     ; returns d0= 0 C=0 if FAC1 = FAC2
    5804/    1F9A :                     ; returns d0=-1 C=1 if FAC1 < FAC2
    5805/    1F9A :                     
    5806/    1F9A :                     LAB_27F0
    5807/    1F9A : 7000                	MOVEQ		#0,d0					; set for FAC1 = FAC2
    5808/    1F9C : 122B 059C           	MOVE.b	FAC2_e(a3),d1			; get FAC2 exponent
    5809/    1FA0 : B22B 0594           	CMP.b		FAC1_e(a3),d1			; compare FAC1 exponent with FAC2 exponent
    5810/    1FA4 : 660A                	BNE.s		LAB_27F1				; branch if different
    5811/    1FA6 :                     
    5812/    1FA6 : 222B 0598           	MOVE.l	FAC2_m(a3),d1			; get FAC2 mantissa
    5813/    1FAA : B2AB 0590           	CMP.l		FAC1_m(a3),d1			; compare mantissas
    5814/    1FAE : 6708                	BEQ.s		LAB_27F3				; exit if mantissas equal
    5815/    1FB0 :                     
    5816/    1FB0 :                     LAB_27F1
    5817/    1FB0 : 6504                	BCS.s		LAB_27F2				; if FAC1 > FAC2 return d0=+1,C=0
    5818/    1FB2 :                     
    5819/    1FB2 : 5380                	SUBQ.l	#1,d0					; else FAC1 < FAC2 return d0=-1,C=1
    5820/    1FB4 : 4E75                	RTS
    5821/    1FB6 :                     
    5822/    1FB6 :                     LAB_27F2
    5823/    1FB6 : 5280                	ADDQ.l	#1,d0
    5824/    1FB8 :                     LAB_27F3
    5825/    1FB8 : 4E75                	RTS
    5826/    1FBA :                     
    5827/    1FBA :                     
    5828/    1FBA :                     ;************************************************************************************
    5829/    1FBA :                     ;
    5830/    1FBA :                     ; make FAC1 = 1
    5831/    1FBA :                     
    5832/    1FBA :                     LAB_POON
    5833/    1FBA : 277C 8000 0000      	MOVE.l	#$80000000,FAC1_m(a3)		; 1 mantissa
             1FC0 : 0590             
    5834/    1FC2 : 377C 8100 0594      	MOVE.w	#$8100,FAC1_e(a3)			; 1 exonent & sign
    5835/    1FC8 : 4E75                	RTS
    5836/    1FCA :                     
    5837/    1FCA :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 102 - 10/11/2023 21:18:52


    5838/    1FCA :                     ;************************************************************************************
    5839/    1FCA :                     ;
    5840/    1FCA :                     ; make FAC1 = 0
    5841/    1FCA :                     
    5842/    1FCA :                     LAB_POZE
    5843/    1FCA : 7000                	MOVEQ		#0,d0					; clear longword
    5844/    1FCC : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; 0 mantissa
    5845/    1FD0 : 3740 0594           	MOVE.w	d0,FAC1_e(a3)			; 0 exonent & sign
    5846/    1FD4 : 4E75                	RTS
    5847/    1FD6 :                     
    5848/    1FD6 :                     
    5849/    1FD6 :                     ;************************************************************************************
    5850/    1FD6 :                     ;
    5851/    1FD6 :                     ; perform power function
    5852/    1FD6 :                     ; the number is in FAC2, the power is in FAC1
    5853/    1FD6 :                     ; no longer trashes Itemp
    5854/    1FD6 :                     
    5855/    1FD6 :                     LAB_POWER
    5856/    1FD6 : 4A2B 0594           	TST.b		FAC1_e(a3)				; test power
    5857/    1FDA : 67DE                	BEQ.s		LAB_POON				; if zero go return 1
    5858/    1FDC :                     
    5859/    1FDC : 4A2B 059C           	TST.b		FAC2_e(a3)				; test number
    5860/    1FE0 : 67E8                	BEQ.s		LAB_POZE				; if zero go return 0
    5861/    1FE2 :                     
    5862/    1FE2 : 1F2B 059D           	MOVE.b	FAC2_s(a3),-(sp)			; save number sign
    5863/    1FE6 : 6A20                	BPL.s		LAB_POWP				; power of positive number
    5864/    1FE8 :                     
    5865/    1FE8 : 7200                	MOVEQ		#0,d1					; clear d1
    5866/    1FEA : 1741 059D           	MOVE.b	d1,FAC2_s(a3)			; make sign +ve
    5867/    1FEE :                     
    5868/    1FEE :                     								; number sign was -ve and can only be raised to
    5869/    1FEE :                     								; an integer power which gives an x +j0 result,
    5870/    1FEE :                     								; else do 'function call' error
    5871/    1FEE : 122B 0594           	MOVE.b	FAC1_e(a3),d1			; get power exponent
    5872/    1FF2 : 927C 0080           	SUB.w		#$80,d1				; normalise to .5
    5873/    1FF6 : 6300 E216           	BLS		LAB_FCER				; if 0<power<1 then do 'function call' error
    5874/    1FFA :                     
    5875/    1FFA :                     								; now shift all the integer bits out
    5876/    1FFA : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get power mantissa
    5877/    1FFE : E3A0                	ASL.l		d1,d0					; shift mantissa
    5878/    2000 : 6600 E20C           	BNE		LAB_FCER				; if power<>INT(power) then do 'function call'
    5879/    2004 :                     								; error
    5880/    2004 :                     
    5881/    2004 : 6502                	BCS.s		LAB_POWP				; if integer value odd then leave result -ve
    5882/    2006 :                     
    5883/    2006 : 1E80                	MOVE.b	d0,(sp)				; save result sign +ve
    5884/    2008 :                     LAB_POWP
    5885/    2008 : 2F2B 0590           	MOVE.l	FAC1_m(a3),-(sp)			; save power mantissa
    5886/    200C : 3F2B 0594           	MOVE.w	FAC1_e(a3),-(sp)			; save power sign & exponent
    5887/    2010 :                     
    5888/    2010 : 6100 FC70           	BSR		LAB_279B				; copy number to FAC1
    5889/    2014 : 6100 F9E0           	BSR		LAB_LOG				; find log of number
    5890/    2018 :                     
    5891/    2018 : 301F                	MOVE.w	(sp)+,d0				; get power sign & exponent
    5892/    201A : 275F 0598           	MOVE.l	(sp)+,FAC2_m(a3)			; get power mantissa
    5893/    201E : 3740 059C           	MOVE.w	d0,FAC2_e(a3)			; save sign & exponent to FAC2
    5894/    2022 : 1740 059E           	MOVE.b	d0,FAC_sc(a3)			; save sign as sign compare
    5895/    2026 : 102B 0595           	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
    5896/    202A : B12B 059E           	EOR.b		d0,FAC_sc(a3)			; make sign compare (FAC1_s EOR FAC2_s)
    5897/    202E :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 103 - 10/11/2023 21:18:52


    5898/    202E : 6100 FAB8           	BSR		LAB_MULTIPLY			; multiply by power
    5899/    2032 : 6158                	BSR.s		LAB_EXP				; find exponential
    5900/    2034 : 175F 0595           	MOVE.b	(sp)+,FAC1_s(a3)			; restore number sign
    5901/    2038 : 4E75                	RTS
    5902/    203A :                     
    5903/    203A :                     
    5904/    203A :                     ;************************************************************************************
    5905/    203A :                     ;
    5906/    203A :                     ; do - FAC1
    5907/    203A :                     
    5908/    203A :                     LAB_GTHAN
    5909/    203A : 4A2B 0594           	TST.b		FAC1_e(a3)				; test for non zero FAC1
    5910/    203E : 6706                	BEQ.s		RTS_020				; branch if null
    5911/    2040 :                     
    5912/    2040 : 0A2B 0080 0595      	EORI.b	#$80,FAC1_s(a3)			; (else) toggle FAC1 sign bit
    5913/    2046 :                     RTS_020
    5914/    2046 : 4E75                	RTS
    5915/    2048 :                     
    5916/    2048 :                     
    5917/    2048 :                     ;************************************************************************************
    5918/    2048 :                     ;
    5919/    2048 :                     								; return +1
    5920/    2048 :                     LAB_EX1
    5921/    2048 : 277C 8000 0000      	MOVE.l	#$80000000,FAC1_m(a3)		; +1 mantissa
             204E : 0590             
    5922/    2050 : 377C 8100 0594      	MOVE.w	#$8100,FAC1_e(a3)			; +1 sign & exponent
    5923/    2056 : 4E75                	RTS
    5924/    2058 :                     								; do over/under flow
    5925/    2058 :                     LAB_EXOU
    5926/    2058 : 4A2B 0595           	TST.b		FAC1_s(a3)				; test sign
    5927/    205C : 6A00 E1AC           	BPL		LAB_OFER				; was +ve so do overflow error
    5928/    2060 :                     
    5929/    2060 :                     								; else underflow so return zero
    5930/    2060 : 7000                	MOVEQ		#0,d0					; clear longword
    5931/    2062 : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; 0 mantissa
    5932/    2066 : 3740 0594           	MOVE.w	d0,FAC1_e(a3)			; 0 sign & exponent
    5933/    206A : 4E75                	RTS
    5934/    206C :                     								; fraction was zero so do 2^n
    5935/    206C :                     LAB_EXOF
    5936/    206C : 277C 8000 0000      	MOVE.l	#$80000000,FAC1_m(a3)		; +n mantissa
             2072 : 0590             
    5937/    2074 : 177C 0000 0595      	MOVE.b	#0,FAC1_s(a3)			; clear sign
    5938/    207A : 4A2B 05B4           	TST.b		cosout(a3)				; test sign flag
    5939/    207E : 6A02                	BPL.s		LAB_EXOL				; branch if +ve
    5940/    2080 :                     
    5941/    2080 : 4481                	NEG.l		d1					; else do 1/2^n
    5942/    2082 :                     LAB_EXOL
    5943/    2082 : D23C 0081           	ADD.b		#$81,d1				; adjust exponent
    5944/    2086 : 1741 0594           	MOVE.b	d1,FAC1_e(a3)			; save exponent
    5945/    208A : 4E75                	RTS
    5946/    208C :                     
    5947/    208C :                     ; perform EXP()	(x^e)
    5948/    208C :                     ; valid input range is -88 to +88
    5949/    208C :                     
    5950/    208C :                     LAB_EXP
    5951/    208C : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get exponent
    5952/    2090 : 67B6                	BEQ.s		LAB_EX1				; return 1 for zero in
    5953/    2092 :                     
    5954/    2092 : B03C 0064           	CMP.b		#$64,d0				; compare exponent with min
    5955/    2096 : 65B0                	BCS.s		LAB_EX1				; if smaller just return 1
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 104 - 10/11/2023 21:18:52


    5956/    2098 :                     
    5957/    2098 :                     ;	MOVEM.l	d1-d6/a0,-(sp)			; save the registers
    5958/    2098 : 177C 0000 05B4      	MOVE.b	#0,cosout(a3)			; flag +ve number
    5959/    209E : 222B 0590           	MOVE.l	FAC1_m(a3),d1			; get mantissa
    5960/    20A2 : B03C 0087           	CMP.b		#$87,d0				; compare exponent with max
    5961/    20A6 : 62B0                	BHI.s		LAB_EXOU				; go do over/under flow if greater
    5962/    20A8 :                     
    5963/    20A8 : 6608                	BNE.s		LAB_EXCM				; branch if less
    5964/    20AA :                     
    5965/    20AA :                     								; else is 2^7
    5966/    20AA : B2BC B00F 33C7      	CMP.l		#$B00F33C7,d1			; compare mantissa with n*2^7 max
    5967/    20B0 : 64A6                	BCC.s		LAB_EXOU				; if => go over/underflow
    5968/    20B2 :                     
    5969/    20B2 :                     LAB_EXCM
    5970/    20B2 : 4A2B 0595           	TST.b		FAC1_s(a3)				; test sign
    5971/    20B6 : 6A0C                	BPL.s		LAB_EXPS				; branch if arg +ve
    5972/    20B8 :                     
    5973/    20B8 : 177C 00FF 05B4      	MOVE.b	#$FF,cosout(a3)			; flag -ve number
    5974/    20BE : 177C 0000 0595      	MOVE.b	#0,FAC1_s(a3)			; take absolute value
    5975/    20C4 :                     LAB_EXPS
    5976/    20C4 :                     								; now do n/LOG(2)
    5977/    20C4 : 277C B8AA 3B29      	MOVE.l	#$B8AA3B29,FAC2_m(a3)		; 1/LOG(2) mantissa
             20CA : 0598             
    5978/    20CC : 377C 8100 059C      	MOVE.w	#$8100,FAC2_e(a3)			; 1/LOG(2) exponent & sign
    5979/    20D2 : 177C 0000 059E      	MOVE.b	#0,FAC_sc(a3)			; we know they're both +ve
    5980/    20D8 : 6100 FA0E           	BSR		LAB_MULTIPLY			; effectively divide by log(2)
    5981/    20DC :                     
    5982/    20DC :                     								; max here is +/- 127
    5983/    20DC :                     								; now separate integer and fraction
    5984/    20DC : 177C 0000 05D9      	MOVE.b	#0,tpower(a3)			; clear exponent add byte
    5985/    20E2 : 1A2B 0594           	MOVE.b	FAC1_e(a3),d5			; get exponent
    5986/    20E6 : 9A3C 0080           	SUB.b		#$80,d5				; normalise
    5987/    20EA : 6324                	BLS.s		LAB_ESML				; branch if < 1 (d5 is 0 or -ve)
    5988/    20EC :                     
    5989/    20EC :                     								; result is > 1
    5990/    20EC : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get mantissa
    5991/    20F0 : 2200                	MOVE.l	d0,d1					; copy it
    5992/    20F2 : 2C05                	MOVE.l	d5,d6					; copy normalised exponent
    5993/    20F4 :                     
    5994/    20F4 : 4446                	NEG.w		d6					; make -ve
    5995/    20F6 : DC7C 0020           	ADD.w		#32,d6				; is now 32-d6
    5996/    20FA : ECA9                	LSR.l		d6,d1					; just integer bits
    5997/    20FC : 1741 05D9           	MOVE.b	d1,tpower(a3)			; set exponent add byte
    5998/    2100 :                     
    5999/    2100 : EBA8                	LSL.l		d5,d0					; shift out integer bits
    6000/    2102 : 6700 FF68           	BEQ		LAB_EXOF				; fraction is zero so do 2^n
    6001/    2106 :                     
    6002/    2106 : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; fraction to FAC1
    6003/    210A : 377C 8000 0594      	MOVE.w	#$8000,FAC1_e(a3)			; set exponent & sign
    6004/    2110 :                     
    6005/    2110 :                     								; multiple was < 1
    6006/    2110 :                     LAB_ESML
    6007/    2110 : 277C B172 17F8      	MOVE.l	#$B17217F8,FAC2_m(a3)		; LOG(2) mantissa
             2116 : 0598             
    6008/    2118 : 377C 8000 059C      	MOVE.w	#$8000,FAC2_e(a3)			; LOG(2) exponent & sign
    6009/    211E : 177C 0000 059E      	MOVE.b	#0,FAC_sc(a3)			; clear sign compare
    6010/    2124 : 6100 F9C2           	BSR		LAB_MULTIPLY			; multiply by log(2)
    6011/    2128 :                     
    6012/    2128 : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get mantissa
    6013/    212C : 1A2B 0594           	MOVE.b	FAC1_e(a3),d5			; get exponent
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 105 - 10/11/2023 21:18:52


    6014/    2130 : 9A7C 0082           	SUB.w		#$82,d5				; normalise and -2 (result is -1 to -30)
    6015/    2134 : 4445                	NEG.w		d5					; make +ve
    6016/    2136 : EAA8                	LSR.l		d5,d0					; shift for 2 integer bits
    6017/    2138 :                     
    6018/    2138 :                     ; d0 = arg
    6019/    2138 :                     ; d6 = x, d1 = y
    6020/    2138 :                     ; d2 = x1, d3 = y1
    6021/    2138 :                     ; d4 = shift count
    6022/    2138 :                     ; d5 = loop count
    6023/    2138 :                     								; now do cordic set-up
    6024/    2138 : 7200                	MOVEQ		#0,d1					; y = 0
    6025/    213A : 2C3C 26A3 D110      	MOVE.l	#KFCTSEED,d6			; x = 1 with jkh inverse factored out
    6026/    2140 : 41FA 0D2C           	LEA		TAB_HTHET(pc),a0			; get pointer to hyperbolic arctan table
    6027/    2144 : 7800                	MOVEQ		#0,d4					; clear shift count
    6028/    2146 :                      
    6029/    2146 :                     								; cordic loop, shifts 4 and 13 (and 39
    6030/    2146 :                     								; if it went that far) need to be repeated
    6031/    2146 : 7A03                	MOVEQ		#3,d5					; 4 loops
    6032/    2148 : 6136                	BSR.s		LAB_EXCC				; do loops 1 through 4
    6033/    214A : 5948                	SUBQ.w	#4,a0					; do table entry again
    6034/    214C : 5384                	SUBQ.l	#1,d4					; do shift count again
    6035/    214E : 7A09                	MOVEQ		#9,d5					; 10 loops
    6036/    2150 : 612E                	BSR.s		LAB_EXCC				; do loops 4 (again) through 13
    6037/    2152 : 5948                	SUBQ.w	#4,a0					; do table entry again
    6038/    2154 : 5384                	SUBQ.l	#1,d4					; do shift count again
    6039/    2156 : 7A12                	MOVEQ		#18,d5				; 19 loops
    6040/    2158 : 6126                	BSR.s		LAB_EXCC				; do loops 13 (again) through 31
    6041/    215A :                      
    6042/    215A :                     								; now get the result
    6043/    215A : 4A2B 05B4           	TST.b		cosout(a3)				; test sign flag
    6044/    215E : 6A06                	BPL.s		LAB_EXPL				; branch if +ve
    6045/    2160 :                     
    6046/    2160 : 4481                	NEG.l		d1					; do -y
    6047/    2162 : 442B 05D9           	NEG.b		tpower(a3)				; do -exp
    6048/    2166 :                     LAB_EXPL
    6049/    2166 : 7083                	MOVEQ		#$83-$100,d0			; set exponent
    6050/    2168 : DC81                	ADD.l		d1,d6					; y = y +/- x
    6051/    216A : 6B06                	BMI.s		LAB_EXRN				; branch if result normal
    6052/    216C :                     
    6053/    216C :                     LAB_EXNN
    6054/    216C : 5380                	SUBQ.l	#1,d0					; decrement exponent
    6055/    216E : DC86                	ADD.l		d6,d6					; shift mantissa
    6056/    2170 : 6AFA                	BPL.s		LAB_EXNN				; loop if not normal
    6057/    2172 :                     
    6058/    2172 :                     LAB_EXRN
    6059/    2172 : 2746 0590           	MOVE.l	d6,FAC1_m(a3)			; save exponent result
    6060/    2176 : D02B 05D9           	ADD.b		tpower(a3),d0			; add integer part
    6061/    217A : 1740 0594           	MOVE.b	d0,FAC1_e(a3)			; save exponent
    6062/    217E :                     ;	MOVEM.l	(sp)+,d1-d6/a0			; restore registers
    6063/    217E : 4E75                	RTS
    6064/    2180 :                      
    6065/    2180 :                     								; cordic loop
    6066/    2180 :                     LAB_EXCC
    6067/    2180 : 5284                	ADDQ.l	#1,d4					; increment shift count
    6068/    2182 : 2406                	MOVE.l	d6,d2					; x1 = x
    6069/    2184 : E8A2                	ASR.l		d4,d2					; x1 >> n
    6070/    2186 : 2601                	MOVE.l	d1,d3					; y1 = y
    6071/    2188 : E8A3                	ASR.l		d4,d3					; y1 >> n
    6072/    218A : 4A80                	TST.l		d0					; test arg
    6073/    218C : 6B0C                	BMI.s		LAB_EXAD				; branch if -ve
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 106 - 10/11/2023 21:18:52


    6074/    218E :                     
    6075/    218E : D282                	ADD.l		d2,d1					; y = y + x1
    6076/    2190 : DC83                	ADD.l		d3,d6					; x = x + y1
    6077/    2192 : 9098                	SUB.l		(a0)+,d0				; arg = arg - atnh(a0)
    6078/    2194 : 51CD FFEA           	DBF		d5,LAB_EXCC				; decrement and loop if not done
    6079/    2198 :                     
    6080/    2198 : 4E75                	RTS
    6081/    219A :                     
    6082/    219A :                     LAB_EXAD
    6083/    219A : 9282                	SUB.l		d2,d1					; y = y - x1
    6084/    219C : 9C83                	SUB.l		d3,d6					; x = x + y1
    6085/    219E : D098                	ADD.l		(a0)+,d0				; arg = arg + atnh(a0)
    6086/    21A0 : 51CD FFDE           	DBF		d5,LAB_EXCC				; decrement and loop if not done
    6087/    21A4 :                     
    6088/    21A4 : 4E75                	RTS
    6089/    21A6 :                     
    6090/    21A6 :                     
    6091/    21A6 :                     ;************************************************************************************
    6092/    21A6 :                     ;
    6093/    21A6 :                     ; RND(n), 32 bit Galois version. make n=0 for 19th next number in sequence or n<>0
    6094/    21A6 :                     ; to get 19th next number in sequence after seed n. This version of the PRNG uses
    6095/    21A6 :                     ; the Galois method and a sample of 65536 bytes produced gives the following values.
    6096/    21A6 :                     
    6097/    21A6 :                     ; Entropy = 7.997442 bits per byte
    6098/    21A6 :                     ; Optimum compression would reduce these 65536 bytes by 0 percent
    6099/    21A6 :                     
    6100/    21A6 :                     ; Chi square distribution for 65536 samples is 232.01, and
    6101/    21A6 :                     ; randomly would exceed this value 75.00 percent of the time
    6102/    21A6 :                     
    6103/    21A6 :                     ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
    6104/    21A6 :                     ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
    6105/    21A6 :                     ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
    6106/    21A6 :                     
    6107/    21A6 :                     LAB_RND
    6108/    21A6 : 4A2B 0594           	TST.b		FAC1_e(a3)				; get FAC1 exponent
    6109/    21AA : 6708                	BEQ.s		NextPRN				; do next random number if zero
    6110/    21AC :                     
    6111/    21AC :                     								; else get seed into random number store
    6112/    21AC : 41EB 05A0           	LEA		PRNlword(a3),a0			; set PRNG pointer
    6113/    21B0 : 6100 FAAA           	BSR		LAB_2778				; pack FAC1 into (a0)
    6114/    21B4 :                     NextPRN
    6115/    21B4 : 72AF                	MOVEQ		#$AF-$100,d1			; set EOR value
    6116/    21B6 : 7412                	MOVEQ		#18,d2				; do this 19 times
    6117/    21B8 : 202B 05A0           	MOVE.l	PRNlword(a3),d0			; get current
    6118/    21BC :                     Ninc0
    6119/    21BC : D080                	ADD.l		d0,d0					; shift left 1 bit
    6120/    21BE : 6402                	BCC.s		Ninc1					; branch if bit 32 not set
    6121/    21C0 :                     
    6122/    21C0 : B300                	EOR.b		d1,d0					; do Galois LFSR feedback
    6123/    21C2 :                     Ninc1
    6124/    21C2 : 51CA FFF8           	DBF		d2,Ninc0				; loop
    6125/    21C6 :                     
    6126/    21C6 : 2740 05A0           	MOVE.l	d0,PRNlword(a3)			; save back to seed word
    6127/    21CA : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; copy to FAC1 mantissa
    6128/    21CE : 377C 8000 0594      	MOVE.w	#$8000,FAC1_e(a3)			; set the exponent and clear the sign
    6129/    21D4 : 6000 F7EA           	BRA		LAB_24D5				; normalise FAC1 & return
    6130/    21D8 :                     
    6131/    21D8 :                     
    6132/    21D8 :                     ;************************************************************************************
    6133/    21D8 :                     ;
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 107 - 10/11/2023 21:18:52


    6134/    21D8 :                     ; cordic TAN(x) routine, TAN(x) = SIN(x)/COS(x)
    6135/    21D8 :                     ; x = angle in radians
    6136/    21D8 :                     
    6137/    21D8 :                     LAB_TAN
    6138/    21D8 : 6138                	BSR.s		LAB_SIN				; go do SIN/COS cordic compute
    6139/    21DA : 376B 0594 059C      	MOVE.w	FAC1_e(a3),FAC2_e(a3)		; copy exponent & sign from FAC1 to FAC2
    6140/    21E0 : 276B 0590 0598      	MOVE.l	FAC1_m(a3),FAC2_m(a3)		; copy FAC1 mantissa to FAC2 mantissa
    6141/    21E6 : 2741 0590           	MOVE.l	d1,FAC1_m(a3)			; get COS(x) mantissa
    6142/    21EA : 1743 0594           	MOVE.b	d3,FAC1_e(a3)			; get COS(x) exponent
    6143/    21EE : 6700 E01A           	BEQ		LAB_OFER				; do overflow if COS = 0
    6144/    21F2 :                     
    6145/    21F2 : 6100 F7CC           	BSR		LAB_24D5				; normalise FAC1
    6146/    21F6 : 6000 F97C           	BRA		LAB_DIVIDE				; do FAC2/FAC1 and return, FAC_sc set by SIN
    6147/    21FA :                     								; COS calculation
    6148/    21FA :                     
    6149/    21FA :                     
    6150/    21FA :                     ;************************************************************************************
    6151/    21FA :                     ;
    6152/    21FA :                     ; cordic SIN(x), COS(x) routine
    6153/    21FA :                     ; x = angle in radians
    6154/    21FA :                     
    6155/    21FA :                     LAB_COS
    6156/    21FA : 277C C90F DAA3      	MOVE.l	#$C90FDAA3,FAC2_m(a3)		; pi/2 mantissa (LSB is rounded up so
             2200 : 0598             
    6157/    2202 :                     								; COS(PI/2)=0)
    6158/    2202 : 377C 8100 059C      	MOVE.w	#$8100,FAC2_e(a3)			; pi/2 exponent and sign
    6159/    2208 : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; sign = FAC1 sign (b7)
    6160/    220E : 6100 F734           	BSR		LAB_ADD				; add FAC2 to FAC1, adjust for COS(x)
    6161/    2212 :                     
    6162/    2212 :                     
    6163/    2212 :                     ;************************************************************************************
    6164/    2212 :                     ;
    6165/    2212 :                     ; SIN/COS cordic calculator
    6166/    2212 :                     
    6167/    2212 :                     LAB_SIN
    6168/    2212 : 177C 0000 05B4      	MOVE.b	#0,cosout(a3)			; set needed result
    6169/    2218 :                     
    6170/    2218 : 277C A2F9 836F      	MOVE.l	#$A2F9836F,FAC2_m(a3)		; 1/pi mantissa (LSB is rounded up so SIN(PI)=0)
             221E : 0598             
    6171/    2220 : 377C 7F00 059C      	MOVE.w	#$7F00,FAC2_e(a3)			; 1/pi exponent & sign
    6172/    2226 : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; sign = FAC1 sign (b7)
    6173/    222C : 6100 F8BA           	BSR		LAB_MULTIPLY			; multiply by 1/pi
    6174/    2230 :                     
    6175/    2230 : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
    6176/    2234 : 671C                	BEQ.s		LAB_SCZE				; branch if zero
    6177/    2236 :                     
    6178/    2236 : 41FA 0B36           	LEA		TAB_SNCO(pc),a0			; get pointer to constants table
    6179/    223A : 2C2B 0590           	MOVE.l	FAC1_m(a3),d6			; get FAC1 mantissa
    6180/    223E : 5300                	SUBQ.b	#1,d0					; 2 radians in 360 degrees so /2
    6181/    2240 : 6710                	BEQ.s		LAB_SCZE				; branch if zero
    6182/    2242 :                     
    6183/    2242 : 903C 0080           	SUB.b		#$80,d0				; normalise exponent
    6184/    2246 : 6B18                	BMI.s		LAB_SCL0				; branch if < 1
    6185/    2248 :                     
    6186/    2248 :                     								; X is > 1
    6187/    2248 : B03C 0020           	CMP.b		#$20,d0				; is it >= 2^32
    6188/    224C : 6404                	BCC.s		LAB_SCZE				; may as well do zero
    6189/    224E :                     
    6190/    224E : E1AE                	LSL.l		d0,d6					; shift out integer part bits
    6191/    2250 : 6618                	BNE.s		LAB_CORD				; if fraction go test quadrant and adjust
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 108 - 10/11/2023 21:18:52


    6192/    2252 :                     
    6193/    2252 :                     								; else no fraction so do zero
    6194/    2252 :                     LAB_SCZE
    6195/    2252 : 7481                	MOVEQ		#$81-$100,d2			; set exponent for 1.0
    6196/    2254 : 7600                	MOVEQ		#0,d3					; set exponent for 0.0
    6197/    2256 : 203C 8000 0000      	MOVE.l	#$80000000,d0			; mantissa for 1.0
    6198/    225C : 2203                	MOVE.l	d3,d1					; mantissa for 0.0
    6199/    225E : 6062                	BRA.s		outloop				; go output it
    6200/    2260 :                     
    6201/    2260 :                     								; x is < 1
    6202/    2260 :                     LAB_SCL0
    6203/    2260 : 4400                	NEG.b		d0					; make +ve
    6204/    2262 : B03C 001E           	CMP.b		#$1E,d0				; is it <= 2^-30
    6205/    2266 : 64EA                	BCC.s		LAB_SCZE				; may as well do zero
    6206/    2268 :                     
    6207/    2268 : E0AE                	LSR.l		d0,d6					; shift out <= 2^-32 bits
    6208/    226A :                     
    6209/    226A :                     ; cordic calculator, argument in d6
    6210/    226A :                     ; table pointer in a0, returns in d0-d3
    6211/    226A :                     
    6212/    226A :                     LAB_CORD
    6213/    226A : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; copy as sign compare for TAN
    6214/    2270 : DC86                	ADD.l		d6,d6					; shift 0.5 bit into carry
    6215/    2272 : 6406                	BCC.s		LAB_LTPF				; branch if less than 0.5
    6216/    2274 :                     
    6217/    2274 : 0A2B 00FF 0595      	EORI.b	#$FF,FAC1_s(a3)			; toggle result sign
    6218/    227A :                     LAB_LTPF
    6219/    227A : DC86                	ADD.l		d6,d6					; shift 0.25 bit into carry
    6220/    227C : 640C                	BCC.s		LAB_LTPT				; branch if less than 0.25
    6221/    227E :                     
    6222/    227E : 0A2B 00FF 05B4      	EORI.b	#$FF,cosout(a3)			; toggle needed result
    6223/    2284 : 0A2B 00FF 059E      	EORI.b	#$FF,FAC_sc(a3)			; toggle sign compare for TAN
    6224/    228A :                     
    6225/    228A :                     LAB_LTPT
    6226/    228A : E48E                	LSR.l		#2,d6					; shift the bits back (clear integer bits)
    6227/    228C : 67C4                	BEQ.s		LAB_SCZE				; no fraction so go do zero
    6228/    228E :                     
    6229/    228E :                     								; set start values
    6230/    228E : 7A01                	MOVEQ		#1,d5					; set bit count
    6231/    2290 : 2028 FFFC           	MOVE.l	-4(a0),d0				; get multiply constant (1st itteration d0)
    6232/    2294 : 2200                	MOVE.l	d0,d1					; 1st itteration d1
    6233/    2296 : 9C98                	SUB.l		(a0)+,d6				; 1st always +ve so do 1st step
    6234/    2298 : 6008                	BRA.s		mainloop				; jump into routine
    6235/    229A :                     
    6236/    229A :                     subloop
    6237/    229A : 9C98                	SUB.l		(a0)+,d6				; z = z - arctan(i)/2pi
    6238/    229C : 9083                	SUB.l		d3,d0					; x = x - y1
    6239/    229E : D282                	ADD.l		d2,d1					; y = y + x1
    6240/    22A0 : 6012                	BRA.s		nexta					; back to main loop
    6241/    22A2 :                     
    6242/    22A2 :                     mainloop
    6243/    22A2 : 2400                	MOVE.l	d0,d2					; x1 = x
    6244/    22A4 : EAA2                	ASR.l		d5,d2					; / (2 ^ i)
    6245/    22A6 : 2601                	MOVE.l	d1,d3					; y1 = y
    6246/    22A8 : EAA3                	ASR.l		d5,d3					; / (2 ^ i)
    6247/    22AA : 4A86                	TST.l		d6					; test sign (is 2^0 bit)
    6248/    22AC : 6AEC                	BPL.s		subloop				; go do subtract if > 1
    6249/    22AE :                     
    6250/    22AE : DC98                	ADD.l		(a0)+,d6				; z = z + arctan(i)/2pi
    6251/    22B0 : D083                	ADD.l		d3,d0					; x = x + y1
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 109 - 10/11/2023 21:18:52


    6252/    22B2 : 9282                	SUB.l		d2,d1					; y = y + x1
    6253/    22B4 :                     nexta
    6254/    22B4 : 5285                	ADDQ.l	#1,d5					; i = i + 1
    6255/    22B6 : BABC 0000 001E      	CMP.l		#$1E,d5				; check end condition
    6256/    22BC : 66E4                	BNE.s		mainloop				; loop if not all done
    6257/    22BE :                     
    6258/    22BE :                     								; now untangle output value
    6259/    22BE : 7481                	MOVEQ		#$81-$100,d2			; set exponent for 0 to .99 rec.
    6260/    22C0 : 2602                	MOVE.l	d2,d3					; copy it for cos output
    6261/    22C2 :                     outloop
    6262/    22C2 : 4A2B 05B4           	TST.b		cosout(a3)				; did we want cos output?
    6263/    22C6 : 6B04                	BMI.s		subexit				; if so skip
    6264/    22C8 :                     
    6265/    22C8 : C141                	EXG		d0,d1					; swap SIN and COS mantissas
    6266/    22CA : C543                	EXG		d2,d3					; swap SIN and COS exponents
    6267/    22CC :                     subexit
    6268/    22CC : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; set result mantissa
    6269/    22D0 : 1742 0594           	MOVE.b	d2,FAC1_e(a3)			; set result exponent
    6270/    22D4 : 6000 F6EA           	BRA		LAB_24D5				; normalise FAC1 & return
    6271/    22D8 :                     
    6272/    22D8 :                     
    6273/    22D8 :                     
    6274/    22D8 :                     ;************************************************************************************
    6275/    22D8 :                     ;
    6276/    22D8 :                     ; perform ATN()
    6277/    22D8 :                     
    6278/    22D8 :                     LAB_ATN
    6279/    22D8 : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
    6280/    22DC : 6700 00AC           	BEQ		RTS_021				; ATN(0) = 0 so skip calculation
    6281/    22E0 :                     
    6282/    22E0 : 177C 0000 05B4      	MOVE.b	#0,cosout(a3)			; set result needed
    6283/    22E6 : B03C 0081           	CMP.b		#$81,d0				; compare exponent with 1
    6284/    22EA : 6528                	BCS.s		LAB_ATLE				; branch if n<1
    6285/    22EC :                     
    6286/    22EC : 6608                	BNE.s		LAB_ATGO				; branch if n>1
    6287/    22EE :                     
    6288/    22EE : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get mantissa
    6289/    22F2 : D080                	ADD.l		d0,d0					; shift left
    6290/    22F4 : 671E                	BEQ.s		LAB_ATLE				; branch if n=1
    6291/    22F6 :                     
    6292/    22F6 :                     LAB_ATGO
    6293/    22F6 : 277C 8000 0000      	MOVE.l	#$80000000,FAC2_m(a3)		; set mantissa for 1
             22FC : 0598             
    6294/    22FE : 377C 8100 059C      	MOVE.w	#$8100,FAC2_e(a3)			; set exponent for 1
    6295/    2304 : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; sign compare = sign
    6296/    230A : 6100 F868           	BSR		LAB_DIVIDE				; do 1/n
    6297/    230E : 177C 00FF 05B4      	MOVE.b	#$FF,cosout(a3)			; set inverse result needed
    6298/    2314 :                     LAB_ATLE
    6299/    2314 : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get FAC1 mantissa
    6300/    2318 : 123C 0082           	MOVE.b		#$82,d1				; set to correct exponent
    6301/    231C : 922B 0594           	SUB.b		FAC1_e(a3),d1			; subtract FAC1 exponent (always <= 1)
    6302/    2320 : E2A8                	LSR.l		d1,d0					; shift in two integer part bits
    6303/    2322 : 41FA 0ACA           	LEA		TAB_ATNC(pc),a0			; get pointer to arctan table
    6304/    2326 : 7C00                	MOVEQ		#0,d6					; Z = 0
    6305/    2328 : 223C 4000 0000      	MOVE.l	#1<<30,d1				; y = 1
    6306/    232E : 7A1D                	MOVEQ		#29,d5				; loop 30 times
    6307/    2330 : 7801                	MOVEQ		#1,d4					; shift counter
    6308/    2332 : 6006                	BRA.s		LAB_ATCD				; enter loop
    6309/    2334 :                     
    6310/    2334 :                     LAB_ATNP
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 110 - 10/11/2023 21:18:52


    6311/    2334 : E8A2                	ASR.l		d4,d2					; x1 / 2^i
    6312/    2336 : D282                	ADD.l		d2,d1					; y = y + x1
    6313/    2338 : DC90                	ADD.l		(a0),d6				; z = z + atn(i)
    6314/    233A :                     LAB_ATCD
    6315/    233A : 2400                	MOVE.l	d0,d2					; x1 = x
    6316/    233C : 2601                	MOVE.l	d1,d3					; y1 = y
    6317/    233E : E8A3                	ASR.l		d4,d3					; y1 / 2^i
    6318/    2340 :                     LAB_CATN
    6319/    2340 : 9083                	SUB.l		d3,d0					; x = x - y1
    6320/    2342 : 6AF0                	BPL.s		LAB_ATNP				; branch if x >= 0
    6321/    2344 :                     
    6322/    2344 : 2002                	MOVE.l	d2,d0					; else get x back
    6323/    2346 : 5848                	ADDQ.w	#4,a0					; increment pointer
    6324/    2348 : 5284                	ADDQ.l	#1,d4					; increment i
    6325/    234A : E283                	ASR.l		#1,d3					; y1 / 2^i
    6326/    234C : 51CD FFF2           	DBF		d5,LAB_CATN				; decrement and loop if not done
    6327/    2350 :                     
    6328/    2350 : 177C 0082 0594      	MOVE.b	#$82,FAC1_e(a3)			; set new exponent
    6329/    2356 : 2746 0590           	MOVE.l	d6,FAC1_m(a3)			; save mantissa
    6330/    235A : 6100 F664           	BSR		LAB_24D5				; normalise FAC1
    6331/    235E :                     
    6332/    235E : 4A2B 05B4           	TST.b		cosout(a3)				; was it > 1 ?
    6333/    2362 : 6A26                	BPL.s		RTS_021				; branch if not
    6334/    2364 :                     
    6335/    2364 : 1E2B 0595           	MOVE.b	FAC1_s(a3),d7			; get sign
    6336/    2368 : 177C 0000 0595      	MOVE.b	#0,FAC1_s(a3)			; clear sign
    6337/    236E : 277C C90F DAA2      	MOVE.l	#$C90FDAA2,FAC2_m(a3)		; set -(pi/2)
             2374 : 0598             
    6338/    2376 : 377C 8180 059C      	MOVE.w	#$8180,FAC2_e(a3)			; set exponent and sign
    6339/    237C : 177C 00FF 059E      	MOVE.b	#$FF,FAC_sc(a3)			; set sign compare
    6340/    2382 : 6100 F5C0           	BSR		LAB_ADD				; perform addition, FAC2 to FAC1
    6341/    2386 : 1747 0595           	MOVE.b	d7,FAC1_s(a3)			; restore sign
    6342/    238A :                     RTS_021
    6343/    238A : 4E75                	RTS
    6344/    238C :                     
    6345/    238C :                     
    6346/    238C :                     ;************************************************************************************
    6347/    238C :                     ;
    6348/    238C :                     ; perform BITSET
    6349/    238C :                     
    6350/    238C :                     LAB_BITSET
    6351/    238C : 6100 F496           	BSR		LAB_GADB				; get two parameters for POKE or WAIT
    6352/    2390 :                     								; first parameter in a0, second in d0
    6353/    2390 : B03C 0008           	CMP.b		#$08,d0				; only 0 to 7 are allowed
    6354/    2394 : 6400 DE78           	BCC		LAB_FCER				; branch if > 7
    6355/    2398 :                     
    6356/    2398 : 01D0                	BSET		d0,(a0)				; set bit
    6357/    239A : 4E75                	RTS
    6358/    239C :                     
    6359/    239C :                     
    6360/    239C :                     ;************************************************************************************
    6361/    239C :                     ;
    6362/    239C :                     ; perform BITCLR
    6363/    239C :                     
    6364/    239C :                     LAB_BITCLR
    6365/    239C : 6100 F486           	BSR		LAB_GADB				; get two parameters for POKE or WAIT
    6366/    23A0 :                     								; first parameter in a0, second in d0
    6367/    23A0 : B03C 0008           	CMP.b		#$08,d0				; only 0 to 7 are allowed
    6368/    23A4 : 6400 DE68           	BCC		LAB_FCER				; branch if > 7
    6369/    23A8 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 111 - 10/11/2023 21:18:52


    6370/    23A8 : 0190                	BCLR		d0,(a0)				; clear bit
    6371/    23AA : 4E75                	RTS
    6372/    23AC :                     
    6373/    23AC :                     
    6374/    23AC :                     ;************************************************************************************
    6375/    23AC :                     ;
    6376/    23AC :                     ; perform BITTST()
    6377/    23AC :                     
    6378/    23AC :                     LAB_BTST
    6379/    23AC : 101D                	MOVE.b	(a5)+,d0				; increment BASIC pointer
    6380/    23AE : 6100 F474           	BSR		LAB_GADB				; get two parameters for POKE or WAIT
    6381/    23B2 :                     								; first parameter in a0, second in d0
    6382/    23B2 : B03C 0008           	CMP.b		#$08,d0				; only 0 to 7 are allowed
    6383/    23B6 : 6400 DE56           	BCC		LAB_FCER				; branch if > 7
    6384/    23BA :                     
    6385/    23BA : 2200                	MOVE.l	d0,d1					; copy bit # to test
    6386/    23BC : 6100 EAA4           	BSR		LAB_GBYT				; get next BASIC byte
    6387/    23C0 : B03C 0029           	CMP.b		#')',d0				; is next character ")"
    6388/    23C4 : 6600 DE54           	BNE		LAB_SNER				; if not ")" go do syntax error, then warm start
    6389/    23C8 :                     
    6390/    23C8 : 6100 EA96           	BSR		LAB_IGBY				; update execute pointer (to character past ")")
    6391/    23CC : 7000                	MOVEQ		#0,d0					; set the result as zero
    6392/    23CE : 0310                	BTST		d1,(a0)				; test bit
    6393/    23D0 : 6700 F904           	BEQ		LAB_27DB				; branch if zero (already correct)
    6394/    23D4 :                     
    6395/    23D4 : 70FF                	MOVEQ		#-1,d0				; set for -1 result
    6396/    23D6 : 6000 F8FE           	BRA		LAB_27DB				; go do SGN tail
    6397/    23DA :                     
    6398/    23DA :                     
    6399/    23DA :                     ;************************************************************************************
    6400/    23DA :                     ;
    6401/    23DA :                     ; perform USING$()
    6402/    23DA :                     
    6403/    23DA : =$0                 fsd		EQU	 0						;   (sp) format string descriptor pointer
    6404/    23DA : =$4                 fsti	EQU	 4						;  4(sp) format string this index
    6405/    23DA : =$6                 fsli	EQU	 6						;  6(sp) format string last index
    6406/    23DA : =$8                 fsdpi	EQU	 8						;  8(sp) format string decimal point index
    6407/    23DA : =$A                 fsdc	EQU	10						; 10(sp) format string decimal characters
    6408/    23DA : =$8                 fend	EQU	12-4						;  x(sp) end-4, fsd is popped by itself
    6409/    23DA :                     
    6410/    23DA : ='#'                ofchr	EQU	'#'						; the overflow character
    6411/    23DA :                     
    6412/    23DA :                     LAB_USINGS
    6413/    23DA : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type, $80=string
    6414/    23DE : 6A00 DDE6           	BPL		LAB_FOER				; if not string type go do format error
    6415/    23E2 :                     
    6416/    23E2 : 246B 0590           	MOVEA.l	FAC1_m(a3),a2			; get the format string descriptor pointer
    6417/    23E6 : 3E2A 0004           	MOVE.w	4(a2),d7				; get the format string length
    6418/    23EA : 6700 DDDA           	BEQ		LAB_FOER				; if null string go do format error
    6419/    23EE :                     
    6420/    23EE :                     ; clear the format string values
    6421/    23EE :                     
    6422/    23EE : 7000                	MOVEQ		#0,d0					; clear d0
    6423/    23F0 : 3F00                	MOVE.w	d0,-(sp)				; clear the format string decimal characters
    6424/    23F2 : 3F00                	MOVE.w	d0,-(sp)				; clear the format string decimal point index
    6425/    23F4 : 3F00                	MOVE.w	d0,-(sp)				; clear the format string last index
    6426/    23F6 : 3F00                	MOVE.w	d0,-(sp)				; clear the format string this index
    6427/    23F8 : 2F0A                	MOVE.l	a2,-(sp)				; save the format string descriptor pointer
    6428/    23FA :                     
    6429/    23FA :                     ; make a null return string for the first string add
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 112 - 10/11/2023 21:18:52


    6430/    23FA :                     
    6431/    23FA : 7200                	MOVEQ		#0,d1					; make a null string
    6432/    23FC : 2041                	MOVEA.l	d1,a0					; with a null pointer
    6433/    23FE : 6100 F0BE           	BSR		LAB_RTST				; push a string on the descriptor stack
    6434/    2402 :                     								; a0 = pointer, d1 = length
    6435/    2402 :                     
    6436/    2402 :                     ; do the USING$() function next value
    6437/    2402 :                     
    6438/    2402 : 101D                	MOVE.b	(a5)+,d0				; get the next BASIC byte
    6439/    2404 :                     LAB_U002
    6440/    2404 : B03C 002C           	CMP.b		#',',d0				; compare with comma
    6441/    2408 : 6600 DE10           	BNE		LAB_SNER				; if not "," go do syntax error
    6442/    240C :                     
    6443/    240C : 6100 028E           	BSR		LAB_ProcFo				; process the format string
    6444/    2410 : 4A02                	TST.b		d2					; test the special characters flag
    6445/    2412 : 6700 DDB2           	BEQ		LAB_FOER				; if no special characters go do format error
    6446/    2416 :                     
    6447/    2416 : 6100 E8E8           	BSR		LAB_EVEX				; evaluate the expression
    6448/    241A : 4A2B 05B5           	TST.b		Dtypef(a3)				; test the data type
    6449/    241E : 6B00 DDCE           	BMI		LAB_TMER				; if string type go do type missmatch error
    6450/    2422 :                     
    6451/    2422 : 4A2B 0594           	TST.b		FAC1_e(a3)				; test FAC1 exponent
    6452/    2426 : 6732                	BEQ.s		LAB_U004				; if FAC1 = 0 skip the rounding
    6453/    2428 :                     
    6454/    2428 : 322F 000A           	MOVE.w	fsdc(sp),d1				; get the format string decimal character count
    6455/    242C : B27C 0008           	CMP.w		#8,d1					; compare the fraction digit count with 8
    6456/    2430 : 6428                	BCC.s		LAB_U004				; if >= 8 skip the rounding
    6457/    2432 :                     
    6458/    2432 : 3001                	MOVE.w	d1,d0					; else copy the fraction digit count
    6459/    2434 : D241                	ADD.w		d1,d1					;	; 2
    6460/    2436 : D240                	ADD.w		d0,d1					;	; 3
    6461/    2438 : D241                	ADD.w		d1,d1					;	; 6
    6462/    243A : 41FA 0844           	LEA		LAB_P_10(pc),a0			; get the rounding table base
    6463/    243E : 2770 1002 0598      	MOVE.l	2(a0,d1.w),FAC2_m(a3)		; get the rounding mantissa
    6464/    2444 : 3030 1000           	MOVE.w	(a0,d1.w),d0			; get the rounding exponent
    6465/    2448 : 907C 0100           	SUB.w		#$100,d0				; effectively divide the mantissa by 2
    6466/    244C : 3740 059C           	MOVE.w	d0,FAC2_e(a3)			; save the rounding exponent
    6467/    2450 : 177C 0000 059E      	MOVE.b	#$00,FAC_sc(a3)			; clear the sign compare
    6468/    2456 : 6100 F4EC           	BSR		LAB_ADD				; round the value to n places
    6469/    245A :                     LAB_U004
    6470/    245A : 6100 F96A           	BSR		LAB_2970				; convert FAC1 to string - not on stack
    6471/    245E :                     
    6472/    245E : 6100 01FE           	BSR		LAB_DupFmt				; duplicate the processed format string section
    6473/    2462 :                     								; returns length in d1, pointer in a0
    6474/    2462 :                     
    6475/    2462 :                     ; process the number string, length in d6, decimal point index in d2
    6476/    2462 :                     
    6477/    2462 : 45EB 05C6           	LEA		Decss(a3),a2			; set the number string start
    6478/    2466 : 7C00                	MOVEQ		#0,d6					; clear the number string index
    6479/    2468 : 782E                	MOVEQ		#'.',d4				; set the decimal point character
    6480/    246A :                     LAB_U005
    6481/    246A : 3406                	MOVE.w	d6,d2					; save the index to flag the decimal point
    6482/    246C :                     LAB_U006
    6483/    246C : 5246                	ADDQ.w	#1,d6					; increment the number string index
    6484/    246E : 1032 6000           	MOVE.b	(a2,d6.w),d0			; get a number string character
    6485/    2472 : 677A                	BEQ.s		LAB_U010				; if null then number complete
    6486/    2474 :                     
    6487/    2474 : B03C 0045           	CMP.b		#'E',d0				; compare the character with an "E"
    6488/    2478 : 6706                	BEQ.s		LAB_U008				; was sx[.x]Esxx so go handle sci notation
    6489/    247A :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 113 - 10/11/2023 21:18:52


    6490/    247A : B004                	CMP.b		d4,d0					; compare the character with "."
    6491/    247C : 66EE                	BNE.s		LAB_U006				; if not decimal point go get the next digit
    6492/    247E :                     
    6493/    247E : 60EA                	BRA.s		LAB_U005				; go save the index and get the next digit
    6494/    2480 :                     
    6495/    2480 :                     ; have found an sx[.x]Esxx number, the [.x] will not be present for a single digit
    6496/    2480 :                     
    6497/    2480 :                     LAB_U008
    6498/    2480 : 3606                	MOVE.w	d6,d3					; copy the index to the "E"
    6499/    2482 : 5343                	SUBQ.w	#1,d3					; -1 gives the last digit index
    6500/    2484 :                     
    6501/    2484 : 5246                	ADDQ.w	#1,d6					; increment the index to the exponent sign
    6502/    2486 : 1032 6000           	MOVE.b	(a2,d6.w),d0			; get the exponent sign character
    6503/    248A : B03C 002D           	CMP.b		#'-',d0				; compare the exponent sign with "-"
    6504/    248E : 6600 DD7E           	BNE		LAB_FCER				; if it wasn't sx[.x]E-xx go do function
    6505/    2492 :                     								; call error
    6506/    2492 :                     
    6507/    2492 :                     ; found an sx[.x]E-xx number so check the exponent magnitude
    6508/    2492 :                     
    6509/    2492 : 5246                	ADDQ.w	#1,d6					; increment the index to the exponent 10s
    6510/    2494 : 1032 6000           	MOVE.b	(a2,d6.w),d0			; get the exponent 10s character
    6511/    2498 : B03C 0030           	CMP.b		#'0',d0				; compare the exponent 10s with "0"
    6512/    249C : 6704                	BEQ.s		LAB_U009				; if it was sx[.x]E-0x go get the exponent
    6513/    249E :                     								; 1s character
    6514/    249E :                     
    6515/    249E : 700A                	MOVEQ		#10,d0				; else start writing at index 10
    6516/    24A0 : 6008                	BRA.s		LAB_U00A				; go copy the digits
    6517/    24A2 :                     
    6518/    24A2 :                     ; found an sx[.x]E-0x number so get the exponent magnitude
    6519/    24A2 :                     
    6520/    24A2 :                     LAB_U009
    6521/    24A2 : 5246                	ADDQ.w	#1,d6					; increment the index to the exponent 1s
    6522/    24A4 : 700F                	MOVEQ		#$0F,d0				; set the mask for the exponent 1s digit
    6523/    24A6 : C032 6000           	AND.b		(a2,d6.w),d0			; get and convert the exponent 1s digit
    6524/    24AA :                     LAB_U00A
    6525/    24AA : 3403                	MOVE.w	d3,d2					; copy the number last digit index
    6526/    24AC : 0C42 0001           	CMPI.w	#1,d2					; is the number of the form sxE-0x
    6527/    24B0 : 6602                	BNE.s		LAB_U00B				; if it is sx.xE-0x skip the increment
    6528/    24B2 :                     
    6529/    24B2 :                     								; else make room for the decimal point
    6530/    24B2 : 5242                	ADDQ.w	#1,d2					; add 1 to the write index
    6531/    24B4 :                     LAB_U00B
    6532/    24B4 : D440                	ADD.w		d0,d2					; add the exponent 1s to the write index
    6533/    24B6 : 700A                	MOVEQ		#10,d0				; set the maximum write index
    6534/    24B8 : 9042                	SUB.w		d2,d0					; compare the index with the maximum
    6535/    24BA : 6E0C                	BGT.s		LAB_U00C				; if the index < the maximum continue
    6536/    24BC :                     
    6537/    24BC : D440                	ADD.w		d0,d2					; else set the index to the maximum
    6538/    24BE : D640                	ADD.w		d0,d3					; adjust the read index
    6539/    24C0 : 0C43 0001           	CMPI.w	#1,d3					; compare the adjusted index with 1
    6540/    24C4 : 6E02                	BGT.s		LAB_U00C				; if > 1 continue
    6541/    24C6 :                     
    6542/    24C6 : 7600                	MOVEQ		#0,d3					; else allow for the decimal point
    6543/    24C8 :                     LAB_U00C
    6544/    24C8 : 3C02                	MOVE.w		d2,d6					; copy the write index as the number
    6545/    24CA :                     								; string length
    6546/    24CA : 7000                	MOVEQ		#0,d0					; clear d0 to null terminate the number
    6547/    24CC :                     								; string
    6548/    24CC :                     LAB_U00D
    6549/    24CC : 1580 2000           	MOVE.b	d0,(a2,d2.w)			; save the character to the number string
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 114 - 10/11/2023 21:18:52


    6550/    24D0 : 5342                	SUBQ.w	#1,d2					; decrement the number write index
    6551/    24D2 : 0C42 0001           	CMPI.w	#1,d2					; compare the number write index with 1
    6552/    24D6 : 6712                	BEQ.s		LAB_U00F				; if at the decimal point go save it
    6553/    24D8 :                     
    6554/    24D8 :                     								; else write a digit to the number string
    6555/    24D8 : 7030                	MOVEQ		#'0',d0				; default to "0"
    6556/    24DA : 4A43                	TST.w		d3					; test the number read index
    6557/    24DC : 67EE                	BEQ.s		LAB_U00D				; if zero just go save the "0"
    6558/    24DE :                     
    6559/    24DE :                     LAB_U00E
    6560/    24DE : 1032 3000           	MOVE.b	(a2,d3.w),d0			; read the next number digit
    6561/    24E2 : 5343                	SUBQ.w	#1,d3					; decrement the read index
    6562/    24E4 : B004                	CMP.b		d4,d0					; compare the digit with "."
    6563/    24E6 : 66E4                	BNE.s		LAB_U00D				; if not "." go save the digit
    6564/    24E8 :                     
    6565/    24E8 : 60F4                	BRA.s		LAB_U00E				; else go get the next digit
    6566/    24EA :                     
    6567/    24EA :                     LAB_U00F
    6568/    24EA : 1584 2000           	MOVE.b	d4,(a2,d2.w)			; save the decimal point
    6569/    24EE :                     LAB_U010
    6570/    24EE : 4A42                	TST.w		d2					; test the number string decimal point index
    6571/    24F0 : 6602                	BNE.s		LAB_U014				; if dp present skip the reset
    6572/    24F2 :                     
    6573/    24F2 : 3406                	MOVE.w	d6,d2					; make the decimal point index = the length
    6574/    24F4 :                     
    6575/    24F4 :                     ; copy the fractional digit characters from the number string
    6576/    24F4 :                     
    6577/    24F4 :                     LAB_U014
    6578/    24F4 : 3602                	MOVE.w	d2,d3					; copy the number string decimal point index
    6579/    24F6 : 5243                	ADDQ.w	#1,d3					; increment the number string index
    6580/    24F8 : 382F 0008           	MOVE.w	fsdpi(sp),d4			; get the new format string decimal point index
    6581/    24FC :                     LAB_U018
    6582/    24FC : 5244                	ADDQ.w	#1,d4					; increment the new format string index
    6583/    24FE : B244                	CMP.w		d4,d1					; compare it with the new format string length
    6584/    2500 : 6322                	BLS.s		LAB_U022				; if done the fraction digits go do integer
    6585/    2502 :                     
    6586/    2502 : 1030 4000           	MOVE.b	(a0,d4.w),d0			; get a new format string character
    6587/    2506 : B03C 0025           	CMP.b		#'%',d0				; compare it with "%"
    6588/    250A : 6706                	BEQ.s		LAB_U01C				; if "%" go copy a number character
    6589/    250C :                     
    6590/    250C : B03C 0023           	CMP.b		#'#',d0				; compare it with "#"
    6591/    2510 : 66EA                	BNE.s		LAB_U018				; if not "#" go do the next new format character
    6592/    2512 :                     
    6593/    2512 :                     LAB_U01C
    6594/    2512 : 7030                	MOVEQ		#'0',d0				; default to "0" character
    6595/    2514 : BC43                	CMP.w		d3,d6					; compare the number string index with length
    6596/    2516 : 6306                	BLS.s		LAB_U020				; if there skip the character get
    6597/    2518 :                     
    6598/    2518 : 1032 3000           	MOVE.b	(a2,d3.w),d0			; get a character from the number string
    6599/    251C : 5243                	ADDQ.w	#1,d3					; increment the number string index
    6600/    251E :                     LAB_U020
    6601/    251E : 1180 4000           	MOVE.b	d0,(a0,d4.w)			; save the number character to the new format
    6602/    2522 :                     								; string
    6603/    2522 : 60D8                	BRA.s		LAB_U018				; go do the next new format character
    6604/    2524 :                     
    6605/    2524 :                     ; now copy the integer digit characters from the number string
    6606/    2524 :                     
    6607/    2524 :                     LAB_U022
    6608/    2524 : 7C00                	MOVEQ		#0,d6					; clear the sign done flag
    6609/    2526 : 7A00                	MOVEQ		#0,d5					; clear the sign present flag
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 115 - 10/11/2023 21:18:52


    6610/    2528 : 5342                	SUBQ.w	#1,d2					; decrement the number string index
    6611/    252A : 6608                	BNE.s		LAB_U026				; if not now at sign continue
    6612/    252C :                     
    6613/    252C : 7401                	MOVEQ		#1,d2					; increment the number string index
    6614/    252E : 15BC 0030 2000      	MOVE.b	#'0',(a2,d2.w)			; replace the point with a zero
    6615/    2534 :                     LAB_U026
    6616/    2534 : 382F 0008           	MOVE.w	fsdpi(sp),d4			; get the new format string decimal point index
    6617/    2538 : B244                	CMP.w		d4,d1					; compare it with the new format string length
    6618/    253A : 6402                	BCC.s		LAB_U02A				; if within the string go use the index
    6619/    253C :                     
    6620/    253C : 3801                	MOVE.w	d1,d4					; else set the index to the end of the string
    6621/    253E :                     LAB_U02A
    6622/    253E : 5344                	SUBQ.w	#1,d4					; decrement the new format string index
    6623/    2540 : 6B62                	BMI.s		LAB_U03E				; if all done go test for any overflow
    6624/    2542 :                     
    6625/    2542 : 1030 4000           	MOVE.b	(a0,d4.w),d0			; else get a new format string character
    6626/    2546 :                     
    6627/    2546 : 7E30                	MOVEQ		#'0',d7				; default to "0" character
    6628/    2548 : B03C 0025           	CMP.b		#'%',d0				; compare it with "%"
    6629/    254C : 6708                	BEQ.s		LAB_U02B				; if "%" go copy a number character
    6630/    254E :                     
    6631/    254E : 7E20                	MOVEQ		#' ',d7				; default to " " character
    6632/    2550 : B03C 0023           	CMP.b		#'#',d0				; compare it with "#"
    6633/    2554 : 6606                	BNE.s		LAB_U02C				; if not "#" go try ","
    6634/    2556 :                     
    6635/    2556 :                     LAB_U02B
    6636/    2556 : 4A42                	TST.w		d2					; test the number string index
    6637/    2558 : 6634                	BNE.s		LAB_U036				; if not at the sign go get a number character
    6638/    255A :                     
    6639/    255A : 6042                	BRA.s		LAB_U03C				; else go save the default character
    6640/    255C :                     
    6641/    255C :                     LAB_U02C
    6642/    255C : B03C 002C           	CMP.b		#',',d0				; compare it with ","
    6643/    2560 : 6610                	BNE.s		LAB_U030				; if not "," go try the sign characters
    6644/    2562 :                     
    6645/    2562 : 4A42                	TST.w		d2					; test the number string index
    6646/    2564 : 6608                	BNE.s		LAB_U02E				; if not at the sign keep the ","
    6647/    2566 :                     
    6648/    2566 : 0C30 0025 40FF      	CMP.b		#'%',-1(a0,d4.w)			; else compare the next format string character
    6649/    256C :                     								; with "%"
    6650/    256C : 6630                	BNE.s		LAB_U03C				; if not "%" keep the default character
    6651/    256E :                     
    6652/    256E :                     LAB_U02E
    6653/    256E : 1E00                	MOVE.b	d0,d7					; else use the "," character
    6654/    2570 : 602C                	BRA.s		LAB_U03C				; go save the character to the string
    6655/    2572 :                     
    6656/    2572 :                     LAB_U030
    6657/    2572 : B03C 002D           	CMP.b		#'-',d0				; compare it with "-"
    6658/    2576 : 6710                	BEQ.s		LAB_U034				; if "-" go do the sign character
    6659/    2578 :                     
    6660/    2578 : B03C 002B           	CMP.b		#'+',d0				; compare it with "+"
    6661/    257C : 66C0                	BNE.s		LAB_U02A				; if not "+" go do the next new format character
    6662/    257E :                     
    6663/    257E : 0C12 002D           	CMP.b		#'-',(a2)				; compare the sign character with "-"
    6664/    2582 : 6704                	BEQ.s		LAB_U034				; if "-" don't change the sign character
    6665/    2584 :                     
    6666/    2584 : 14BC 002B           	MOVE.b	#'+',(a2)				; else make the sign character "+"
    6667/    2588 :                     LAB_U034
    6668/    2588 : 1A00                	MOVE.b	d0,d5					; set the sign present flag
    6669/    258A : 4A42                	TST.w		d2					; test the number string index
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 116 - 10/11/2023 21:18:52


    6670/    258C : 6708                	BEQ.s		LAB_U038				; if at the sign keep the default character
    6671/    258E :                     
    6672/    258E :                     LAB_U036
    6673/    258E : 1E32 2000           	MOVE.b	(a2,d2.w),d7			; else get a character from the number string
    6674/    2592 : 5342                	SUBQ.w	#1,d2					; decrement the number string index
    6675/    2594 : 6008                	BRA.s		LAB_U03C				; go save the character
    6676/    2596 :                     
    6677/    2596 :                     LAB_U038
    6678/    2596 : 4A06                	TST.b		d6					; test the sign done flag
    6679/    2598 : 6604                	BNE.s		LAB_U03C				; if the sign has been done go use the space
    6680/    259A :                     								; character
    6681/    259A :                     
    6682/    259A : 1E12                	MOVE.b	(a2),d7				; else get the sign character
    6683/    259C : 1C07                	MOVE.b	d7,d6					; flag that the sign has been done
    6684/    259E :                     LAB_U03C
    6685/    259E : 1187 4000           	MOVE.b	d7,(a0,d4.w)			; save the number character to the new format
    6686/    25A2 :                     								; string
    6687/    25A2 : 609A                	BRA.s		LAB_U02A				; go do the next new format character
    6688/    25A4 :                     
    6689/    25A4 :                     ; test for overflow conditions
    6690/    25A4 :                     
    6691/    25A4 :                     LAB_U03E
    6692/    25A4 : 4A42                	TST.w		d2					; test the number string index
    6693/    25A6 : 6614                	BNE.s		LAB_U040				; if all the digits aren't done go output
    6694/    25A8 :                     								; an overflow indication
    6695/    25A8 :                     
    6696/    25A8 :                     ; test for sign overflows
    6697/    25A8 :                     
    6698/    25A8 : 4A05                	TST.b		d5					; test the sign present flag
    6699/    25AA : 6754                	BEQ.s		LAB_U04A				; if no sign present go add the string
    6700/    25AC :                     
    6701/    25AC :                     ; there was a sign in the format string
    6702/    25AC :                     
    6703/    25AC : 4A06                	TST.b		d6					; test the sign done flag
    6704/    25AE : 6650                	BNE.s		LAB_U04A				; if the sign is done go add the string
    6705/    25B0 :                     
    6706/    25B0 :                     ; the sign isn't done so see if it was mandatory
    6707/    25B0 :                     
    6708/    25B0 : 0C05 002B           	CMPI.b	#'+',d5				; compare the sign with "+"
    6709/    25B4 : 6706                	BEQ.s		LAB_U040				; if it was "+" go output an overflow
    6710/    25B6 :                     								; indication
    6711/    25B6 :                     
    6712/    25B6 :                     ; the sign wasn't mandatory but the number may have been negative
    6713/    25B6 :                     
    6714/    25B6 : 0C12 002D           	CMP.b		#'-',(a2)				; compare the sign character with "-"
    6715/    25BA : 6644                	BNE.s		LAB_U04A				; if it wasn't "-" go add the string
    6716/    25BC :                     
    6717/    25BC :                     ; else the sign was "-" and a sign hasn't been output so ..
    6718/    25BC :                     
    6719/    25BC :                     ; the number overflowed the format string so replace all the special format characters
    6720/    25BC :                     ; with the overflow character
    6721/    25BC :                     
    6722/    25BC :                     LAB_U040
    6723/    25BC : 7A23                	MOVEQ		#ofchr,d5				; set the overflow character
    6724/    25BE : 3E01                	MOVE.w	d1,d7					; copy the new format string length
    6725/    25C0 : 5347                	SUBQ.w	#1,d7					; adjust for the loop type
    6726/    25C2 : 3C2F 0004           	MOVE.w	fsti(sp),d6				; copy the new format string last index
    6727/    25C6 : 5346                	SUBQ.w	#1,d6					; -1 gives the last character of this string
    6728/    25C8 : 6E02                	BGT.s		LAB_U044				; if not zero continue
    6729/    25CA :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 117 - 10/11/2023 21:18:52


    6730/    25CA : 3C07                	MOVE.w	d7,d6					; else set the format string index to the end
    6731/    25CC :                     LAB_U044
    6732/    25CC : 1031 6000           	MOVE.b	(a1,d6.w),d0			; get a character from the format string
    6733/    25D0 : 0C00 0023           	CMPI.b	#'#',d0				; compare it with "#" special format character
    6734/    25D4 : 671E                	BEQ.s		LAB_U046				; if "#" go use the overflow character
    6735/    25D6 :                     
    6736/    25D6 : 0C00 0025           	CMPI.b	#'%',d0				; compare it with "%" special format character
    6737/    25DA : 6718                	BEQ.s		LAB_U046				; if "%" go use the overflow character
    6738/    25DC :                     
    6739/    25DC : 0C00 002C           	CMPI.b	#',',d0				; compare it with "," special format character
    6740/    25E0 : 6712                	BEQ.s		LAB_U046				; if "," go use the overflow character
    6741/    25E2 :                     
    6742/    25E2 : 0C00 002B           	CMPI.b	#'+',d0				; compare it with "+" special format character
    6743/    25E6 : 670C                	BEQ.s		LAB_U046				; if "+" go use the overflow character
    6744/    25E8 :                     
    6745/    25E8 : 0C00 002D           	CMPI.b	#'-',d0				; compare it with "-" special format character
    6746/    25EC : 6706                	BEQ.s		LAB_U046				; if "-" go use the overflow character
    6747/    25EE :                     
    6748/    25EE : 0C00 002E           	CMPI.b	#'.',d0				; compare it with "." special format character
    6749/    25F2 : 6602                	BNE.s		LAB_U048				; if not "." skip the using overflow character
    6750/    25F4 :                     
    6751/    25F4 :                     LAB_U046
    6752/    25F4 : 1005                	MOVE.b	d5,d0					; use the overflow character
    6753/    25F6 :                     LAB_U048
    6754/    25F6 : 1180 7000           	MOVE.b	d0,(a0,d7.w)			; save the character to the new format string
    6755/    25FA : 5346                	SUBQ.w	#1,d6					; decrement the format string index
    6756/    25FC : 51CF FFCE           	DBF		d7,LAB_U044				; decrement the count and loop if not all done
    6757/    2600 :                     
    6758/    2600 :                     ; add the new string to the previous string
    6759/    2600 :                     
    6760/    2600 :                     LAB_U04A
    6761/    2600 : 41EC 0006           	LEA		6(a4),a0				; get the descriptor pointer for string 1
    6762/    2604 : 274C 0590           	MOVE.l	a4,FAC1_m(a3)			; save the descriptor pointer for string 2
    6763/    2608 : 6100 F004           	BSR		LAB_224E				; concatenate the strings
    6764/    260C :                     
    6765/    260C :                     ; now check for any tail on the format string
    6766/    260C :                     
    6767/    260C : 302F 0004           	MOVE.w	fsti(sp),d0				; get this index
    6768/    2610 : 6720                	BEQ.s		LAB_U04C				; if at start of string skip the output
    6769/    2612 :                     
    6770/    2612 : 3F40 0006           	MOVE.w	d0,fsli(sp)				; save this index to the last index
    6771/    2616 : 6100 0084           	BSR		LAB_ProcFo				; now process the format string
    6772/    261A : 4A02                	TST.b		d2					; test the special characters flag
    6773/    261C : 6614                	BNE.s		LAB_U04C				; if special characters present skip the output
    6774/    261E :                     
    6775/    261E :                     ; else output the new string part
    6776/    261E :                     
    6777/    261E : 613E                	BSR.s		LAB_DupFmt				; duplicate the processed format string section
    6778/    2620 : 3F6F 0004 0006      	MOVE.w	fsti(sp),fsli(sp)			; copy this index to the last index
    6779/    2626 :                     
    6780/    2626 :                     ; add the new string to the previous string
    6781/    2626 :                     
    6782/    2626 : 41EC 0006           	LEA		6(a4),a0				; get the descriptor pointer for string 1
    6783/    262A : 274C 0590           	MOVE.l	a4,FAC1_m(a3)			; save the descriptor pointer for string 2
    6784/    262E : 6100 EFDE           	BSR		LAB_224E				; concatenate the strings
    6785/    2632 :                     
    6786/    2632 :                     ; check for another value or end of function
    6787/    2632 :                     
    6788/    2632 :                     LAB_U04C
    6789/    2632 : 101D                	MOVE.b	(a5)+,d0				; get the next BASIC byte
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 118 - 10/11/2023 21:18:52


    6790/    2634 : B03C 0029           	CMP.b		#')',d0				; compare with close bracket
    6791/    2638 : 6600 FDCA           	BNE		LAB_U002				; if not ")" go do next value
    6792/    263C :                     
    6793/    263C :                     ; pop the result string off the descriptor stack
    6794/    263C :                     
    6795/    263C : 204C                	MOVEA.l	a4,a0					; copy the result string descriptor pointer
    6796/    263E : 222B 0446           	MOVE.l	Sstorl(a3),d1			; save the bottom of string space
    6797/    2642 : 6100 F02C           	BSR		LAB_22BA				; pop (a0) descriptor, returns with ..
    6798/    2646 :                     								; d0 = length, a0 = pointer
    6799/    2646 : 2741 0446           	MOVE.l	d1,Sstorl(a3)			; restore the bottom of string space
    6800/    264A : 2248                	MOVEA.l	a0,a1					; copy the string result pointer
    6801/    264C : 3200                	MOVE.w	d0,d1					; copy the string result length
    6802/    264E :                     
    6803/    264E :                     ; pop the format string off the descriptor stack
    6804/    264E :                     
    6805/    264E : 205F                	MOVEA.l	(sp)+,a0				; pull the format string descriptor pointer
    6806/    2650 : 6100 F01E           	BSR		LAB_22BA				; pop (a0) descriptor, returns with ..
    6807/    2654 :                     								; d0 = length, a0 = pointer
    6808/    2654 :                     
    6809/    2654 : 4FEF 0008           	LEA		fend(sp),sp				; dump the saved values
    6810/    2658 :                     
    6811/    2658 :                     ; push the result string back on the descriptor stack and return
    6812/    2658 :                     
    6813/    2658 : 2049                	MOVEA.l	a1,a0					; copy the result string pointer back
    6814/    265A : 6000 EE62           	BRA		LAB_RTST				; push a string on the descriptor stack and
    6815/    265E :                     								; return. a0 = pointer, d1 = length
    6816/    265E :                     
    6817/    265E :                     
    6818/    265E :                     ;************************************************************************************
    6819/    265E :                     ;
    6820/    265E :                     ; duplicate the processed format string section
    6821/    265E :                     
    6822/    265E :                     								; make a string as long as the format string
    6823/    265E :                     LAB_DupFmt
    6824/    265E : 226F 0004           	MOVEA.l	4+fsd(sp),a1			; get the format string descriptor pointer
    6825/    2662 : 3E29 0004           	MOVE.w	4(a1),d7				; get the format string length
    6826/    2666 : 342F 000A           	MOVE.w	4+fsli(sp),d2			; get the format string last index
    6827/    266A : 3C2F 0008           	MOVE.w	4+fsti(sp),d6			; get the format string this index
    6828/    266E : 3206                	MOVE.w	d6,d1					; copy the format string this index
    6829/    2670 : 9242                	SUB.w		d2,d1					; subtract the format string last index
    6830/    2672 : 6202                	BHI.s		LAB_D002				; if > 0 skip the correction
    6831/    2674 :                     
    6832/    2674 : D247                	ADD.w		d7,d1					; else add the format string length as the
    6833/    2676 :                     								; correction
    6834/    2676 :                     LAB_D002
    6835/    2676 : 6100 EE60           	BSR		LAB_2115				; make string space d1 bytes long
    6836/    267A :                     								; return a0/Sutill = pointer, others unchanged
    6837/    267A :                     
    6838/    267A :                     ; push the new string on the descriptor stack
    6839/    267A :                     
    6840/    267A : 6100 EE42           	BSR		LAB_RTST				; push a string on the descriptor stack and
    6841/    267E :                     								; return. a0 = pointer, d1 = length
    6842/    267E :                     
    6843/    267E :                     ; copy the characters from the format string
    6844/    267E :                     
    6845/    267E : 226F 0004           	MOVEA.l	4+fsd(sp),a1			; get the format string descriptor pointer
    6846/    2682 : 2251                	MOVEA.l	(a1),a1				; get the format string pointer
    6847/    2684 : 7800                	MOVEQ		#0,d4					; clear the new string index
    6848/    2686 :                     LAB_D00A
    6849/    2686 : 11B1 2000 4000      	MOVE.b	(a1,d2.w),(a0,d4.w)		; get a character from the format string and
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 119 - 10/11/2023 21:18:52


    6850/    268C :                     								; save it to the new string
    6851/    268C : 5244                	ADDQ.w	#1,d4					; increment the new string index
    6852/    268E : 5242                	ADDQ.w	#1,d2					; increment the format string index
    6853/    2690 : BE42                	CMP.w		d2,d7					; compare the format index with the length
    6854/    2692 : 6602                	BNE.s		LAB_D00E				; if not there skip the reset
    6855/    2694 :                     
    6856/    2694 : 7400                	MOVEQ		#0,d2					; else reset the format string index
    6857/    2696 :                     LAB_D00E
    6858/    2696 : BC42                	CMP.w		d2,d6					; compare the index with this index
    6859/    2698 : 66EC                	BNE.s		LAB_D00A				; if not equal go do the next character
    6860/    269A :                     
    6861/    269A : 4E75                	RTS
    6862/    269C :                     
    6863/    269C :                     
    6864/    269C :                     ;************************************************************************************
    6865/    269C :                     ;
    6866/    269C :                     ; process the format string
    6867/    269C :                     
    6868/    269C :                     LAB_ProcFo
    6869/    269C : 226F 0004           	MOVEA.l	4+fsd(sp),a1			; get the format string descriptor pointer
    6870/    26A0 : 3E29 0004           	MOVE.w	4(a1),d7				; get the format string length
    6871/    26A4 : 2251                	MOVEA.l	(a1),a1				; get the format string pointer
    6872/    26A6 : 3C2F 000A           	MOVE.w	4+fsli(sp),d6			; get the format string last index
    6873/    26AA :                     
    6874/    26AA : 3F47 000C           	MOVE.w	d7,4+fsdpi(sp)			; set the format string decimal point index
    6875/    26AE :                     ;##	MOVE.w	#-1,4+fsdpi(sp)			; set the format string decimal point index
    6876/    26AE : 7A00                	MOVEQ		#0,d5					; no decimal point
    6877/    26B0 : 7600                	MOVEQ		#0,d3					; no decimal characters
    6878/    26B2 : 7400                	MOVEQ		#0,d2					; no special characters
    6879/    26B4 :                     LAB_P004
    6880/    26B4 : 1031 6000           	MOVE.b	(a1,d6.w),d0			; get a format string byte
    6881/    26B8 :                     
    6882/    26B8 : B03C 002C           	CMP.b		#',',d0				; compare it with ","
    6883/    26BC : 6742                	BEQ.s		LAB_P01A				; if "," go do the next format string byte
    6884/    26BE :                     
    6885/    26BE : B03C 0023           	CMP.b		#'#',d0				; compare it with "#"
    6886/    26C2 : 6706                	BEQ.s		LAB_P008				; if "#" go flag special characters
    6887/    26C4 :                     
    6888/    26C4 : B03C 0025           	CMP.b		#'%',d0				; compare it with "%"
    6889/    26C8 : 6608                	BNE.s		LAB_P00C				; if not "%" go try "+"
    6890/    26CA :                     
    6891/    26CA :                     LAB_P008
    6892/    26CA : 4A85                	TST.l		d5					; test the decimal point flag
    6893/    26CC : 6A10                	BPL.s		LAB_P00E				; if no point skip counting decimal characters
    6894/    26CE :                     
    6895/    26CE : 5243                	ADDQ.w	#1,d3					; else increment the decimal character count
    6896/    26D0 : 602E                	BRA.s		LAB_P01A				; go do the next character
    6897/    26D2 :                     
    6898/    26D2 :                     LAB_P00C
    6899/    26D2 : B03C 002B           	CMP.b		#'+',d0				; compare it with "+"
    6900/    26D6 : 6706                	BEQ.s		LAB_P00E				; if "+" go flag special characters
    6901/    26D8 :                     
    6902/    26D8 : B03C 002D           	CMP.b		#'-',d0				; compare it with "-"
    6903/    26DC : 6604                	BNE.s		LAB_P010				; if not "-" go check decimal point
    6904/    26DE :                     
    6905/    26DE :                     LAB_P00E
    6906/    26DE : 8400                	OR.b		d0,d2					; flag special characters
    6907/    26E0 : 601E                	BRA.s		LAB_P01A				; go do the next character
    6908/    26E2 :                     
    6909/    26E2 :                     LAB_P010
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 120 - 10/11/2023 21:18:52


    6910/    26E2 : B03C 002E           	CMP.b		#'.',d0				; compare it with "."
    6911/    26E6 : 6614                	BNE.s		LAB_P018				; if not "." go check next
    6912/    26E8 :                     
    6913/    26E8 :                     ; "." a decimal point
    6914/    26E8 :                     
    6915/    26E8 : 4A85                	TST.l		d5					; if there is already a decimal point
    6916/    26EA : 6B14                	BMI.s		LAB_P01A				; go do the next character
    6917/    26EC :                     
    6918/    26EC : 3006                	MOVE.w	d6,d0					; copy the decimal point index
    6919/    26EE : 906F 000A           	SUB.w		4+fsli(sp),d0			; calculate it from the scan start
    6920/    26F2 : 3F40 000C           	MOVE.w	d0,4+fsdpi(sp)			; save the decimal point index
    6921/    26F6 : 7AFF                	MOVEQ		#-1,d5				; flag decimal point
    6922/    26F8 : 8400                	OR.b		d0,d2					; flag special characters
    6923/    26FA : 6004                	BRA.s		LAB_P01A				; go do the next character
    6924/    26FC :                     
    6925/    26FC :                     ; was not a special character
    6926/    26FC :                     
    6927/    26FC :                     LAB_P018
    6928/    26FC : 4A02                	TST.b		d2					; test if there have been special characters
    6929/    26FE : 6608                	BNE.s		LAB_P01E				; if so exit the format string process
    6930/    2700 :                     
    6931/    2700 :                     LAB_P01A
    6932/    2700 : 5246                	ADDQ.w	#1,d6					; increment the format string index
    6933/    2702 : BE46                	CMP.w		d6,d7					; compare it with the format string length
    6934/    2704 : 62AE                	BHI.s		LAB_P004				; if length > index go get the next character
    6935/    2706 :                     
    6936/    2706 : 7C00                	MOVEQ		#0,d6					; length = index so reset the format string
    6937/    2708 :                     								; index
    6938/    2708 :                     LAB_P01E
    6939/    2708 : 3F46 0008           	MOVE.w	d6,4+fsti(sp)			; save the format string this index
    6940/    270C : 3F43 000E           	MOVE.w	d3,4+fsdc(sp)			; save the format string decimal characters
    6941/    2710 :                     
    6942/    2710 : 4E75                	RTS
    6943/    2712 :                     
    6944/    2712 :                     
    6945/    2712 :                     ;************************************************************************************
    6946/    2712 :                     ;
    6947/    2712 :                     ; perform BIN$()
    6948/    2712 :                     ; # of leading 0s is in d1, the number is in d0
    6949/    2712 :                     
    6950/    2712 :                     LAB_BINS
    6951/    2712 : B23C 0021           	CMP.b		#$21,d1				; max + 1
    6952/    2716 : 6400 DAF6           	BCC		LAB_FCER				; exit if too big ( > or = )
    6953/    271A :                     
    6954/    271A : 741F                	MOVEQ		#$1F,d2				; bit count-1
    6955/    271C : 41EB 05B6           	LEA		Binss(a3),a0			; point to string
    6956/    2720 : 7830                	MOVEQ		#$30,d4				; "0" character for ADDX
    6957/    2722 :                     NextB1
    6958/    2722 : 7600                	MOVEQ		#0,d3					; clear byte
    6959/    2724 : E288                	LSR.l		#1,d0					; shift bit into Xb
    6960/    2726 : D704                	ADDX.b	d4,d3					; add carry and character to zero
    6961/    2728 : 1183 2000           	MOVE.b	d3,(a0,d2.w)			; save character to string
    6962/    272C : 51CA FFF4           	DBF		d2,NextB1				; decrement and loop if not done
    6963/    2730 :                     
    6964/    2730 :                     ; this is the exit code and is also used by HEX$()
    6965/    2730 :                     
    6966/    2730 :                     EndBHS
    6967/    2730 : 177C 0000 05D6      	MOVE.b	#0,BHsend(a3)			; null terminate the string
    6968/    2736 : 4A01                	TST.b		d1					; test # of characters
    6969/    2738 : 670E                	BEQ.s		NextB2				; go truncate string
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 121 - 10/11/2023 21:18:52


    6970/    273A :                     
    6971/    273A : 4481                	NEG.l		d1					; make -ve
    6972/    273C : D2BC 0000 05D6      	ADD.l		#BHsend,d1				; effectively (end-length)
    6973/    2742 : 41F3 1000           	LEA		0(a3,d1.w),a0			; effectively add (end-length) to pointer
    6974/    2746 : 600E                	BRA.s		BinPr					; go print string
    6975/    2748 :                     
    6976/    2748 :                     ; truncate string to remove leading "0"s
    6977/    2748 :                     
    6978/    2748 :                     NextB2
    6979/    2748 : 1010                	MOVE.b	(a0),d0				; get byte
    6980/    274A : 670A                	BEQ.s		BinPr					; if null then end of string so add 1 and go
    6981/    274C :                     								; print it
    6982/    274C :                     
    6983/    274C : B03C 0030           	CMP.b		#'0',d0				; compare with "0"
    6984/    2750 : 660E                	BNE.s		GoPr					; if not "0" then go print string from here
    6985/    2752 :                     
    6986/    2752 : 5248                	ADDQ.w	#1,a0					; else increment pointer
    6987/    2754 : 60F2                	BRA.s		NextB2				; loop always
    6988/    2756 :                     
    6989/    2756 :                     ; make fixed length output string - ignore overflows!
    6990/    2756 :                     
    6991/    2756 :                     BinPr
    6992/    2756 : 43EB 05D6           	LEA		BHsend(a3),a1			; get string end
    6993/    275A : B1C9                	CMPA.l	a1,a0					; are we at the string end
    6994/    275C : 6602                	BNE.s		GoPr					; branch if not
    6995/    275E :                     
    6996/    275E : 5348                	SUBQ.w	#1,a0					; else need at least one zero
    6997/    2760 :                     GoPr
    6998/    2760 : 6000 ED16           	BRA		LAB_20AE				; print " terminated string to FAC1, stack & RET
    6999/    2764 :                     
    7000/    2764 :                     
    7001/    2764 :                     ;************************************************************************************
    7002/    2764 :                     ;
    7003/    2764 :                     ; perform HEX$()
    7004/    2764 :                     ; # of leading 0s is in d1, the number is in d0
    7005/    2764 :                     
    7006/    2764 :                     LAB_HEXS
    7007/    2764 : B23C 0009           	CMP.b		#$09,d1				; max + 1
    7008/    2768 : 6400 DAA4           	BCC		LAB_FCER				; exit if too big ( > or = )
    7009/    276C :                     
    7010/    276C : 7407                	MOVEQ		#$07,d2				; nibble count-1
    7011/    276E : 41EB 05CE           	LEA		Hexss(a3),a0			; point to string
    7012/    2772 : 7830                	MOVEQ		#$30,d4				; "0" character for ABCD
    7013/    2774 :                     NextH1
    7014/    2774 : 1600                	MOVE.b	d0,d3					; copy lowest byte
    7015/    2776 : E898                	ROR.l		#4,d0					; shift nibble into 0-3
    7016/    2778 : C63C 000F           	AND.b		#$0F,d3				; just this nibble
    7017/    277C : 1A03                	MOVE.b	d3,d5					; copy it
    7018/    277E : DA3C 00F6           	ADD.b		#$F6,d5				; set extend bit
    7019/    2782 : C704                	ABCD		d4,d3					; decimal add extend and character to zero
    7020/    2784 : 1183 2000           	MOVE.b	d3,(a0,d2.w)			; save character to string
    7021/    2788 : 51CA FFEA           	DBF		d2,NextH1				; decrement and loop if not done
    7022/    278C :                     
    7023/    278C : 60A2                	BRA.s		EndBHS				; go process string
    7024/    278E :                     
    7025/    278E :                     
    7026/    278E :                     ;************************************************************************************
    7027/    278E :                     ;
    7028/    278E :                     ; ctrl-c check routine. includes limited "life" byte save for INGET routine
    7029/    278E :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 122 - 10/11/2023 21:18:52


    7030/    278E :                     VEC_CC
    7031/    278E : 4A2B 05E8           	TST.b		ccflag(a3)				; check [CTRL-C] check flag
    7032/    2792 : 661E                	BNE.s		RTS_022				; exit if [CTRL-C] check inhibited
    7033/    2794 :                     
    7034/    2794 : 4EAB 040C           	JSR		V_INPT(a3)				; scan input device
    7035/    2798 : 640E                	BCC.s		LAB_FBA0				; exit if buffer empty
    7036/    279A :                     
    7037/    279A : 1740 05E9           	MOVE.b	d0,ccbyte(a3)			; save received byte
    7038/    279E : 177C 0020 05EA      	MOVE.b	#$20,ccnull(a3)			; set "life" timer for bytes countdown
    7039/    27A4 : 6000 DEDE           	BRA		LAB_1636				; return to BASIC
    7040/    27A8 :                     
    7041/    27A8 :                     LAB_FBA0
    7042/    27A8 : 4A2B 05EA           	TST.b		ccnull(a3)				; get countdown byte
    7043/    27AC : 6704                	BEQ.s		RTS_022				; exit if finished
    7044/    27AE :                     
    7045/    27AE : 532B 05EA           	SUBQ.b	#1,ccnull(a3)			; else decrement countdown
    7046/    27B2 :                     RTS_022
    7047/    27B2 : 4E75                	RTS
    7048/    27B4 :                     
    7049/    27B4 :                     
    7050/    27B4 :                     ;************************************************************************************
    7051/    27B4 :                     ;
    7052/    27B4 :                     ; get byte from input device, no waiting
    7053/    27B4 :                     ; returns with carry set if byte in A
    7054/    27B4 :                     
    7055/    27B4 :                     INGET
    7056/    27B4 : 4EAB 040C           	JSR		V_INPT(a3)				; call scan input device
    7057/    27B8 : 650A                	BCS.s		LAB_FB95				; if byte go reset timer
    7058/    27BA :                     
    7059/    27BA : 102B 05EA           	MOVE.b	ccnull(a3),d0			; get countdown
    7060/    27BE : 67F2                	BEQ.s		RTS_022				; exit if empty
    7061/    27C0 :                     
    7062/    27C0 : 102B 05E9           	MOVE.b	ccbyte(a3),d0			; get last received byte
    7063/    27C4 :                     LAB_FB95
    7064/    27C4 : 177C 0000 05EA      	MOVE.b	#$00,ccnull(a3)			; clear timer because we got a byte
    7065/    27CA : 003C 0001           	ORI.b		#1,CCR				; set carry, flag we got a byte
    7066/    27CE : 4E75                	RTS
    7067/    27D0 :                     
    7068/    27D0 :                     
    7069/    27D0 :                     ;************************************************************************************
    7070/    27D0 :                     ;
    7071/    27D0 :                     ; perform MAX()
    7072/    27D0 :                     
    7073/    27D0 :                     LAB_MAX
    7074/    27D0 : 6100 E530           	BSR		LAB_EVEZ				; evaluate expression (no decrement)
    7075/    27D4 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type
    7076/    27D8 : 6B00 DA14           	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
    7077/    27DC :                     
    7078/    27DC :                     LAB_MAXN
    7079/    27DC : 612E                	BSR.s		LAB_PHFA				; push FAC1, evaluate expression,
    7080/    27DE :                     								; pull FAC2 & compare with FAC1
    7081/    27DE : 64FC                	BCC.s		LAB_MAXN				; branch if no swap to do
    7082/    27E0 :                     
    7083/    27E0 : 6100 F4A0           	BSR		LAB_279B				; copy FAC2 to FAC1
    7084/    27E4 : 60F6                	BRA.s		LAB_MAXN				; go do next
    7085/    27E6 :                     
    7086/    27E6 :                     
    7087/    27E6 :                     ;************************************************************************************
    7088/    27E6 :                     ;
    7089/    27E6 :                     ; perform MIN()
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 123 - 10/11/2023 21:18:52


    7090/    27E6 :                     
    7091/    27E6 :                     LAB_MIN
    7092/    27E6 : 6100 E51A           	BSR		LAB_EVEZ				; evaluate expression (no decrement)
    7093/    27EA : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type
    7094/    27EE : 6B00 D9FE           	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
    7095/    27F2 :                     
    7096/    27F2 :                     LAB_MINN
    7097/    27F2 : 6118                	BSR.s		LAB_PHFA				; push FAC1, evaluate expression,
    7098/    27F4 :                     								; pull FAC2 & compare with FAC1
    7099/    27F4 : 63FC                	BLS.s		LAB_MINN				; branch if no swap to do
    7100/    27F6 :                     
    7101/    27F6 : 6100 F48A           	BSR		LAB_279B				; copy FAC2 to FAC1
    7102/    27FA : 60F6                	BRA.s		LAB_MINN				; go do next (branch always)
    7103/    27FC :                     
    7104/    27FC :                     ; exit routine. don't bother returning to the loop code
    7105/    27FC :                     ; check for correct exit, else so syntax error
    7106/    27FC :                     
    7107/    27FC :                     LAB_MMEC
    7108/    27FC : B03C 0029           	CMP.b		#')',d0				; is it end of function?
    7109/    2800 : 6600 DA18           	BNE		LAB_SNER				; if not do MAX MIN syntax error
    7110/    2804 :                     
    7111/    2804 : 4FEF 0004           	LEA		4(sp),sp				; dump return address (faster)
    7112/    2808 : 6000 E656           	BRA		LAB_IGBY				; update BASIC execute pointer (to chr past ")")
    7113/    280C :                     								; and return
    7114/    280C :                     
    7115/    280C :                     ; check for next, evaluate & return or exit
    7116/    280C :                     ; this is the routine that does most of the work
    7117/    280C :                     
    7118/    280C :                     LAB_PHFA
    7119/    280C : 6100 E654           	BSR		LAB_GBYT				; get next BASIC byte
    7120/    2810 : B03C 002C           	CMP.b		#',',d0				; is there more ?
    7121/    2814 : 66E6                	BNE.s		LAB_MMEC				; if not go do end check
    7122/    2816 :                     
    7123/    2816 : 3F2B 0594           	MOVE.w	FAC1_e(a3),-(sp)			; push exponent and sign
    7124/    281A : 2F2B 0590           	MOVE.l	FAC1_m(a3),-(sp)			; push mantissa
    7125/    281E :                     
    7126/    281E : 6100 E4E2           	BSR		LAB_EVEZ				; evaluate expression (no decrement)
    7127/    2822 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type
    7128/    2826 : 6B00 D9C6           	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
    7129/    282A :                     
    7130/    282A :                     
    7131/    282A :                     								; pop FAC2 (MAX/MIN expression so far)
    7132/    282A : 275F 0598           	MOVE.l	(sp)+,FAC2_m(a3)			; pop mantissa
    7133/    282E :                     
    7134/    282E : 301F                	MOVE.w	(sp)+,d0				; pop exponent and sign
    7135/    2830 : 3740 059C           	MOVE.w	d0,FAC2_e(a3)			; save exponent and sign
    7136/    2834 : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; get FAC1 sign
    7137/    283A : B12B 059E           	EOR.b		d0,FAC_sc(a3)			; EOR to create sign compare
    7138/    283E : 6000 F4AE           	BRA		LAB_27FA				; compare FAC1 with FAC2 & return
    7139/    2842 :                     								; returns d0=+1 Cb=0 if FAC1 > FAC2
    7140/    2842 :                     								; returns d0= 0 Cb=0 if FAC1 = FAC2
    7141/    2842 :                     								; returns d0=-1 Cb=1 if FAC1 < FAC2
    7142/    2842 :                     
    7143/    2842 :                     
    7144/    2842 :                     ;************************************************************************************
    7145/    2842 :                     ;
    7146/    2842 :                     ; perform WIDTH
    7147/    2842 :                     
    7148/    2842 :                     LAB_WDTH
    7149/    2842 : B03C 002C           	CMP.b		#',',d0				; is next byte ","
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 124 - 10/11/2023 21:18:52


    7150/    2846 : 672C                	BEQ.s		LAB_TBSZ				; if so do tab size
    7151/    2848 :                     
    7152/    2848 : 6100 EF82           	BSR		LAB_GTBY				; get byte parameter, result in d0 and Itemp
    7153/    284C : 4A00                	TST.b		d0					; test result
    7154/    284E : 6712                	BEQ.s		LAB_NSTT				; branch if set for infinite line
    7155/    2850 :                     
    7156/    2850 : B03C 0010           	CMP.b		#$10,d0				; else make min width = 16d
    7157/    2854 : 6500 D9B8           	BCS		LAB_FCER				; if less do function call error & exit
    7158/    2858 :                     
    7159/    2858 :                     ; this next compare ensures that we can't exit WIDTH via an error leaving the
    7160/    2858 :                     ; tab size greater than the line length.
    7161/    2858 :                     
    7162/    2858 : B02B 05E2           	CMP.b		TabSiz(a3),d0			; compare with tab size
    7163/    285C : 6404                	BCC.s		LAB_NSTT				; branch if >= tab size
    7164/    285E :                     
    7165/    285E : 1740 05E2           	MOVE.b	d0,TabSiz(a3)			; else make tab size = terminal width
    7166/    2862 :                     LAB_NSTT
    7167/    2862 : 1740 05E6           	MOVE.b	d0,TWidth(a3)			; set the terminal width
    7168/    2866 : 6100 E5FA           	BSR		LAB_GBYT				; get BASIC byte back
    7169/    286A : 672C                	BEQ.s		WExit					; exit if no following
    7170/    286C :                     
    7171/    286C : B03C 002C           	CMP.b		#',',d0				; else is it ","
    7172/    2870 : 6600 D9A8           	BNE		LAB_SNER				; if not do syntax error
    7173/    2874 :                     
    7174/    2874 :                     LAB_TBSZ
    7175/    2874 : 6100 EF52           	BSR		LAB_SGBY				; increment and get byte, result in d0 and Itemp
    7176/    2878 : 4A00                	TST.b		d0					; test TAB size
    7177/    287A : 6B00 D992           	BMI		LAB_FCER				; if >127 do function call error & exit
    7178/    287E :                     
    7179/    287E : B03C 0001           	CMP.b		#1,d0					; compare with min-1
    7180/    2882 : 6500 D98A           	BCS		LAB_FCER				; if <=1 do function call error & exit
    7181/    2886 :                     
    7182/    2886 : 122B 05E6           	MOVE.b	TWidth(a3),d1			; set flags for width
    7183/    288A : 6708                	BEQ.s		LAB_SVTB				; skip check if infinite line
    7184/    288C :                     
    7185/    288C : B02B 05E6           	CMP.b		TWidth(a3),d0			; compare TAB with width
    7186/    2890 : 6E00 D97C           	BGT		LAB_FCER				; branch if too big
    7187/    2894 :                     
    7188/    2894 :                     LAB_SVTB
    7189/    2894 : 1740 05E2           	MOVE.b	d0,TabSiz(a3)			; save TAB size
    7190/    2898 :                     
    7191/    2898 :                     ; calculate tab column limit from TAB size. The Iclim is set to the last tab
    7192/    2898 :                     ; position on a line that still has at least one whole tab width between it
    7193/    2898 :                     ; and the end of the line.
    7194/    2898 :                     
    7195/    2898 :                     WExit
    7196/    2898 : 102B 05E6           	MOVE.b	TWidth(a3),d0			; get width
    7197/    289C : 670A                	BEQ.s		LAB_WDLP				; branch if infinite line
    7198/    289E :                     
    7199/    289E : B02B 05E2           	CMP.b		TabSiz(a3),d0			; compare with tab size
    7200/    28A2 : 6404                	BCC.s		LAB_WDLP				; branch if >= tab size
    7201/    28A4 :                     
    7202/    28A4 : 1740 05E2           	MOVE.b	d0,TabSiz(a3)			; else make tab size = terminal width
    7203/    28A8 :                     LAB_WDLP
    7204/    28A8 : 902B 05E2           	SUB.b		TabSiz(a3),d0			; subtract tab size
    7205/    28AC : 64FA                	BCC.s		LAB_WDLP				; loop while no borrow
    7206/    28AE :                     
    7207/    28AE : D02B 05E2           	ADD.b		TabSiz(a3),d0			; add tab size back
    7208/    28B2 : D02B 05E2           	ADD.b		TabSiz(a3),d0			; add tab size back again
    7209/    28B6 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 125 - 10/11/2023 21:18:52


    7210/    28B6 : 4400                	NEG.b		d0					; make -ve
    7211/    28B8 : D02B 05E6           	ADD.b		TWidth(a3),d0			; subtract remainder from width
    7212/    28BC : 1740 05E7           	MOVE.b	d0,Iclim(a3)			; save tab column limit
    7213/    28C0 :                     RTS_023
    7214/    28C0 : 4E75                	RTS
    7215/    28C2 :                     
    7216/    28C2 :                     
    7217/    28C2 :                     ;************************************************************************************
    7218/    28C2 :                     ;
    7219/    28C2 :                     ; perform SQR()
    7220/    28C2 :                     
    7221/    28C2 :                     ; d0 is number to find the root of
    7222/    28C2 :                     ; d1 is the root result
    7223/    28C2 :                     ; d2 is the remainder
    7224/    28C2 :                     ; d3 is a counter
    7225/    28C2 :                     ; d4 is temp
    7226/    28C2 :                     
    7227/    28C2 :                     LAB_SQR
    7228/    28C2 : 4A2B 0595           	TST.b		FAC1_s(a3)				; test FAC1 sign
    7229/    28C6 : 6B00 D946           	BMI		LAB_FCER				; if -ve do function call error
    7230/    28CA :                     
    7231/    28CA : 4A2B 0594           	TST.b		FAC1_e(a3)				; test exponent
    7232/    28CE : 67F0                	BEQ.s		RTS_023				; exit if zero
    7233/    28D0 :                     
    7234/    28D0 : 48E7 7800           	MOVEM.l	d1-d4,-(sp)				; save registers
    7235/    28D4 : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; copy FAC1
    7236/    28D8 : 7400                	MOVEQ		#0,d2					; clear remainder
    7237/    28DA : 2202                	MOVE.l	d2,d1					; clear root
    7238/    28DC :                     
    7239/    28DC : 761F                	MOVEQ		#$1F,d3				; $1F for DBF, 64 pairs of bits to
    7240/    28DE :                     								; do for a 32 bit result
    7241/    28DE : 082B 0000 0594      	BTST		#0,FAC1_e(a3)			; test exponent odd/even
    7242/    28E4 : 6606                	BNE.s		LAB_SQE2				; if odd only 1 shift first time
    7243/    28E6 :                     
    7244/    28E6 :                     LAB_SQE1
    7245/    28E6 : D080                	ADD.l		d0,d0					; shift highest bit of number ..
    7246/    28E8 : D582                	ADDX.l	d2,d2					; .. into remainder .. never overflows
    7247/    28EA : D281                	ADD.l		d1,d1					; root = root	; 2 .. never overflows
    7248/    28EC :                     LAB_SQE2
    7249/    28EC : D080                	ADD.l		d0,d0					; shift highest bit of number ..
    7250/    28EE : D582                	ADDX.l	d2,d2					; .. into remainder .. never overflows
    7251/    28F0 :                     
    7252/    28F0 : 2801                	MOVE.l	d1,d4					; copy root
    7253/    28F2 : D884                	ADD.l		d4,d4					; 2n
    7254/    28F4 : 5284                	ADDQ.l	#1,d4					; 2n+1
    7255/    28F6 :                     
    7256/    28F6 : B484                	CMP.l		d4,d2					; compare 2n+1 to remainder
    7257/    28F8 : 6504                	BCS.s		LAB_SQNS				; skip sub if remainder smaller
    7258/    28FA :                     
    7259/    28FA : 9484                	SUB.l		d4,d2					; subtract temp from remainder
    7260/    28FC : 5281                	ADDQ.l	#1,d1					; increment root
    7261/    28FE :                     LAB_SQNS
    7262/    28FE : 51CB FFE6           	DBF		d3,LAB_SQE1				; loop if not all done
    7263/    2902 :                     
    7264/    2902 : 2741 0590           	MOVE.l	d1,FAC1_m(a3)			; save result mantissa
    7265/    2906 : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get exponent (d0 is clear here)
    7266/    290A : 907C 0080           	SUB.w		#$80,d0				; normalise
    7267/    290E : E248                	LSR.w		#1,d0					; /2
    7268/    2910 : 6402                	BCC.s		LAB_SQNA				; skip increment if carry clear
    7269/    2912 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 126 - 10/11/2023 21:18:52


    7270/    2912 : 5240                	ADDQ.w	#1,d0					; add bit zero back in (allow for half shift)
    7271/    2914 :                     LAB_SQNA
    7272/    2914 : D07C 0080           	ADD.w		#$80,d0				; re-bias to $80
    7273/    2918 : 1740 0594           	MOVE.b	d0,FAC1_e(a3)			; save it
    7274/    291C : 4CDF 001E           	MOVEM.l	(sp)+,d1-d4				; restore registers
    7275/    2920 : 6000 F09E           	BRA		LAB_24D5				; normalise FAC1 & return
    7276/    2924 :                     
    7277/    2924 :                     
    7278/    2924 :                     ;************************************************************************************
    7279/    2924 :                     ;
    7280/    2924 :                     ; perform VARPTR()
    7281/    2924 :                     
    7282/    2924 :                     LAB_VARPTR
    7283/    2924 : 101D                	MOVE.b	(a5)+,d0				; increment pointer
    7284/    2926 :                     LAB_VARCALL
    7285/    2926 : 6100 E74A           	BSR		LAB_GVAR				; get variable address in a0
    7286/    292A : 6100 E522           	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
    7287/    292E : 2008                	MOVE.l	a0,d0					; copy the variable address
    7288/    2930 : 6000 EA30           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
    7289/    2934 :                     
    7290/    2934 :                     
    7291/    2934 :                     ;************************************************************************************
    7292/    2934 :                     ;
    7293/    2934 :                     ; perform RAMBASE
    7294/    2934 :                     
    7295/    2934 :                     LAB_RAM
    7296/    2934 : 41F8 0400           	LEA		ram_base,a0			; get start of EhBASIC RAM
    7297/    2938 : 2008                	MOVE.l	a0,d0					; copy it
    7298/    293A : 6000 EA26           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
    7299/    293E :                     
    7300/    293E :                     
    7301/    293E :                     ;************************************************************************************
    7302/    293E :                     ;
    7303/    293E :                     ; perform PI
    7304/    293E :                     
    7305/    293E :                     LAB_PI
    7306/    293E : 277C C90F DAA2      	MOVE.l	#$C90FDAA2,FAC1_m(a3)		; pi mantissa (32 bit)
             2944 : 0590             
    7307/    2946 : 377C 8200 0594      	MOVE.w	#$8200,FAC1_e(a3)			; pi exponent and sign
    7308/    294C : 4E75                	RTS
    7309/    294E :                     
    7310/    294E :                     
    7311/    294E :                     ;************************************************************************************
    7312/    294E :                     ;
    7313/    294E :                     ; perform TWOPI
    7314/    294E :                     
    7315/    294E :                     LAB_TWOPI
    7316/    294E : 277C C90F DAA2      	MOVE.l	#$C90FDAA2,FAC1_m(a3)		; 2pi mantissa (32 bit)
             2954 : 0590             
    7317/    2956 : 377C 8300 0594      	MOVE.w	#$8300,FAC1_e(a3)			; 2pi exponent and sign
    7318/    295C : 4E75                	RTS
    7319/    295E :                     
    7320/    295E :                     
    7321/    295E :                     ;************************************************************************************
    7322/    295E :                     ;
    7323/    295E :                     ; get ASCII string equivalent into FAC1 as integer32 or float
    7324/    295E :                     
    7325/    295E :                     ; entry is with a5 pointing to the first character of the string
    7326/    295E :                     ; exit with a5 pointing to the first character after the string
    7327/    295E :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 127 - 10/11/2023 21:18:52


    7328/    295E :                     ; d0 is character
    7329/    295E :                     ; d1 is mantissa
    7330/    295E :                     ; d2 is partial and table mantissa
    7331/    295E :                     ; d3 is mantissa exponent (decimal & binary)
    7332/    295E :                     ; d4 is decimal exponent
    7333/    295E :                     
    7334/    295E :                     ; get FAC1 from string
    7335/    295E :                     ; this routine now handles hex and binary values from strings
    7336/    295E :                     ; starting with "$" and "%" respectively
    7337/    295E :                     
    7338/    295E :                     LAB_2887
    7339/    295E : 48E7 7C00           	MOVEM.l	d1-d5,-(sp)				; save registers
    7340/    2962 : 7200                	MOVEQ		#$00,d1				; clear temp accumulator
    7341/    2964 : 2601                	MOVE.l	d1,d3					; set mantissa decimal exponent count
    7342/    2966 : 2801                	MOVE.l	d1,d4					; clear decimal exponent
    7343/    2968 : 1741 0595           	MOVE.b	d1,FAC1_s(a3)			; clear sign byte
    7344/    296C : 1741 05B5           	MOVE.b	d1,Dtypef(a3)			; set float data type
    7345/    2970 : 1741 05AF           	MOVE.b	d1,expneg(a3)			; clear exponent sign
    7346/    2974 : 6100 E4EC           	BSR		LAB_GBYT				; get first byte back
    7347/    2978 : 653C                	BCS.s		LAB_28FE				; go get floating if 1st character numeric
    7348/    297A :                     
    7349/    297A : B03C 002D           	CMP.b		#'-',d0				; or is it -ve number
    7350/    297E : 6608                	BNE.s		LAB_289A				; branch if not
    7351/    2980 :                     
    7352/    2980 : 177C 00FF 0595      	MOVE.b	#$FF,FAC1_s(a3)			; set sign byte
    7353/    2986 : 6006                	BRA.s		LAB_289C				; now go scan & check for hex/bin/int
    7354/    2988 :                     
    7355/    2988 :                     LAB_289A
    7356/    2988 :                     								; first character wasn't numeric or -
    7357/    2988 : B03C 002B           	CMP.b		#'+',d0				; compare with '+'
    7358/    298C : 6606                	BNE.s		LAB_289D				; branch if not '+' (go check for '.'/hex/binary
    7359/    298E :                     								; /integer)
    7360/    298E :                     	
    7361/    298E :                     LAB_289C
    7362/    298E :                     								; was "+" or "-" to start, so get next character
    7363/    298E : 6100 E4D0           	BSR		LAB_IGBY				; increment & scan memory
    7364/    2992 : 6522                	BCS.s		LAB_28FE				; branch if numeric character
    7365/    2994 :                     
    7366/    2994 :                     LAB_289D
    7367/    2994 : B03C 002E           	CMP.b		#'.',d0				; else compare with '.'
    7368/    2998 : 6700 0092           	BEQ		LAB_2904				; branch if '.'
    7369/    299C :                     
    7370/    299C :                     								; code here for hex/binary/integer numbers
    7371/    299C : B03C 0024           	CMP.b		#'$',d0				; compare with '$'
    7372/    29A0 : 6700 010A           	BEQ		LAB_CHEX				; branch if '$'
    7373/    29A4 :                     
    7374/    29A4 : B03C 0025           	CMP.b		#'%',d0				; else compare with '%'
    7375/    29A8 : 6700 0164           	BEQ		LAB_CBIN				; branch if '%'
    7376/    29AC :                     
    7377/    29AC : 6000 008C           	BRA		LAB_2Y01				; not #.$%& so return 0
    7378/    29B0 :                     
    7379/    29B0 :                     LAB_28FD
    7380/    29B0 : 6100 E4AE           	BSR		LAB_IGBY				; get next character
    7381/    29B4 : 646C                	BCC.s		LAB_2902				; exit loop if not a digit
    7382/    29B6 :                     
    7383/    29B6 :                     LAB_28FE
    7384/    29B6 : 6100 01A8           	BSR		d1x10					; multiply d1 by 10 and add character
    7385/    29BA : 64F4                	BCC.s		LAB_28FD				; loop for more if no overflow
    7386/    29BC :                     
    7387/    29BC :                     LAB_28FF
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 128 - 10/11/2023 21:18:52


    7388/    29BC :                     								; overflowed mantissa, count 10s exponent
    7389/    29BC : 5283                	ADDQ.l	#1,d3					; increment mantissa decimal exponent count
    7390/    29BE : 6100 E4A0           	BSR		LAB_IGBY				; get next character
    7391/    29C2 : 65F8                	BCS.s		LAB_28FF				; loop while numeric character
    7392/    29C4 :                     
    7393/    29C4 :                     								; done overflow, now flush fraction or do E
    7394/    29C4 : B03C 002E           	CMP.b		#'.',d0				; else compare with '.'
    7395/    29C8 : 6606                	BNE.s		LAB_2901				; branch if not '.'
    7396/    29CA :                     
    7397/    29CA :                     LAB_2900
    7398/    29CA :                     								; flush remaining fraction digits
    7399/    29CA : 6100 E494           	BSR		LAB_IGBY				; get next character
    7400/    29CE : 65FA                	BCS		LAB_2900				; loop while numeric character
    7401/    29D0 :                     
    7402/    29D0 :                     LAB_2901
    7403/    29D0 :                     								; done number, only (possible) exponent remains
    7404/    29D0 : B03C 0045           	CMP.b		#'E',d0				; else compare with 'E'
    7405/    29D4 : 6664                	BNE.s		LAB_2Y01				; if not 'E' all done, go evaluate
    7406/    29D6 :                     
    7407/    29D6 :                     								; process exponent
    7408/    29D6 : 6100 E488           	BSR		LAB_IGBY				; get next character
    7409/    29DA : 6528                	BCS.s		LAB_2X04				; branch if digit
    7410/    29DC :                     
    7411/    29DC : B03C 002D           	CMP.b		#'-',d0				; or is it -ve number
    7412/    29E0 : 6706                	BEQ.s		LAB_2X01				; branch if so
    7413/    29E2 :                     
    7414/    29E2 : B03C 00B3           	CMP.b		#TK_MINUS,d0			; or is it -ve number
    7415/    29E6 : 6608                	BNE.s		LAB_2X02				; branch if not
    7416/    29E8 :                     
    7417/    29E8 :                     LAB_2X01
    7418/    29E8 : 177C 00FF 05AF      	MOVE.b	#$FF,expneg(a3)			; set exponent sign
    7419/    29EE : 600E                	BRA.s		LAB_2X03				; now go scan & check exponent
    7420/    29F0 :                     
    7421/    29F0 :                     LAB_2X02
    7422/    29F0 : B03C 002B           	CMP.b		#'+',d0				; or is it +ve number
    7423/    29F4 : 6708                	BEQ.s		LAB_2X03				; branch if so
    7424/    29F6 :                     
    7425/    29F6 : B03C 00B2           	CMP.b		#TK_PLUS,d0				; or is it +ve number
    7426/    29FA : 6600 D81E           	BNE		LAB_SNER				; wasn't - + TK_MINUS TK_PLUS or # so do error
    7427/    29FE :                     
    7428/    29FE :                     LAB_2X03
    7429/    29FE : 6100 E460           	BSR		LAB_IGBY				; get next character
    7430/    2A02 : 6436                	BCC.s		LAB_2Y01				; if not digit all done, go evaluate
    7431/    2A04 :                     LAB_2X04
    7432/    2A04 : C8FC 000A           	MULU		#10,d4				; multiply decimal exponent by 10
    7433/    2A08 : C0BC 0000 00FF      	AND.l		#$FF,d0				; mask character
    7434/    2A0E : 903C 0030           	SUB.b		#'0',d0				; convert to value
    7435/    2A12 : D880                	ADD.l		d0,d4					; add to decimal exponent
    7436/    2A14 : B83C 0030           	CMP.b		#48,d4				; compare with decimal exponent limit+10
    7437/    2A18 : 6FE4                	BLE.s		LAB_2X03				; loop if no overflow/underflow
    7438/    2A1A :                     
    7439/    2A1A :                     LAB_2X05
    7440/    2A1A :                     								; exponent value has overflowed
    7441/    2A1A : 6100 E444           	BSR		LAB_IGBY				; get next character
    7442/    2A1E : 65FA                	BCS.s		LAB_2X05				; loop while numeric digit
    7443/    2A20 :                     
    7444/    2A20 : 6018                	BRA.s		LAB_2Y01				; all done, go evaluate
    7445/    2A22 :                     
    7446/    2A22 :                     LAB_2902
    7447/    2A22 : B03C 002E           	CMP.b		#'.',d0				; else compare with '.'
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 129 - 10/11/2023 21:18:52


    7448/    2A26 : 6704                	BEQ.s		LAB_2904				; branch if was '.'
    7449/    2A28 :                     
    7450/    2A28 : 60A6                	BRA.s		LAB_2901				; branch if not '.' (go check/do 'E')
    7451/    2A2A :                     
    7452/    2A2A :                     LAB_2903
    7453/    2A2A : 5383                	SUBQ.l	#1,d3					; decrement mantissa decimal exponent
    7454/    2A2C :                     LAB_2904
    7455/    2A2C :                     								; was dp so get fraction part
    7456/    2A2C : 6100 E432           	BSR		LAB_IGBY				; get next character
    7457/    2A30 : 649E                	BCC.s		LAB_2901				; exit loop if not a digit (go check/do 'E')
    7458/    2A32 :                     
    7459/    2A32 : 6100 012C           	BSR		d1x10					; multiply d1 by 10 and add character
    7460/    2A36 : 64F2                	BCC.s		LAB_2903				; loop for more if no overflow
    7461/    2A38 :                     
    7462/    2A38 : 6090                	BRA.s		LAB_2900				; else go flush remaining fraction part
    7463/    2A3A :                     
    7464/    2A3A :                     LAB_2Y01
    7465/    2A3A :                     								; now evaluate result
    7466/    2A3A : 4A2B 05AF           	TST.b		expneg(a3)				; test exponent sign
    7467/    2A3E : 6A02                	BPL.s		LAB_2Y02				; branch if sign positive
    7468/    2A40 :                     
    7469/    2A40 : 4484                	NEG.l		d4					; negate decimal exponent
    7470/    2A42 :                     LAB_2Y02
    7471/    2A42 : D883                	ADD.l		d3,d4					; add mantissa decimal exponent
    7472/    2A44 : 7620                	MOVEQ		#32,d3				; set up max binary exponent
    7473/    2A46 : 4A81                	TST.l		d1					; test mantissa
    7474/    2A48 : 6752                	BEQ.s		LAB_rtn0				; if mantissa=0 return 0
    7475/    2A4A :                     
    7476/    2A4A : 6B08                	BMI.s		LAB_2Y04				; branch if already mormalised
    7477/    2A4C :                     
    7478/    2A4C : 5383                	SUBQ.l	#1,d3					; decrement bianry exponent for DBMI loop
    7479/    2A4E :                     LAB_2Y03
    7480/    2A4E : D281                	ADD.l		d1,d1					; shift mantissa
    7481/    2A50 : 5BCB FFFC           	DBMI		d3,LAB_2Y03				; decrement & loop if not normalised
    7482/    2A54 :                     
    7483/    2A54 :                     								; ensure not too big or small
    7484/    2A54 :                     LAB_2Y04
    7485/    2A54 : B8BC 0000 0026      	CMP.l		#38,d4				; compare decimal exponent with max exponent
    7486/    2A5A : 6E00 D7AE           	BGT		LAB_OFER				; if greater do overflow error and warm start
    7487/    2A5E :                     
    7488/    2A5E : B8BC FFFF FFDA      	CMP.l		#-38,d4				; compare decimal exponent with min exponent
    7489/    2A64 : 6D34                	BLT.s		LAB_ret0				; if less just return zero
    7490/    2A66 :                     
    7491/    2A66 : 4484                	NEG.l		d4					; negate decimal exponent to go right way
    7492/    2A68 : C9FC 0006           	MULS		#6,d4					; 6 bytes per entry
    7493/    2A6C : 2F08                	MOVE.l	a0,-(sp)				; save register
    7494/    2A6E : 41FA 0210           	LEA		LAB_P_10(pc),a0			; point to table
    7495/    2A72 : 1770 4000 059C      	MOVE.b	(a0,d4.w),FAC2_e(a3)		; copy exponent for multiply
    7496/    2A78 : 2770 4002 0598      	MOVE.l	2(a0,d4.w),FAC2_m(a3)		; copy table mantissa
    7497/    2A7E : 205F                	MOVE.l	(sp)+,a0				; restore register
    7498/    2A80 :                     
    7499/    2A80 : 0A03 0080           	EORI.b	#$80,d3				; normalise input exponent
    7500/    2A84 : 2741 0590           	MOVE.l	d1,FAC1_m(a3)			; save input mantissa
    7501/    2A88 : 1743 0594           	MOVE.b	d3,FAC1_e(a3)			; save input exponent
    7502/    2A8C : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; set sign as sign compare
    7503/    2A92 :                     
    7504/    2A92 : 4CDF 003E           	MOVEM.l	(sp)+,d1-d5				; restore registers
    7505/    2A96 : 6000 F050           	BRA		LAB_MULTIPLY			; go multiply input by table
    7506/    2A9A :                     
    7507/    2A9A :                     LAB_ret0
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 130 - 10/11/2023 21:18:52


    7508/    2A9A : 7200                	MOVEQ		#0,d1					; clear mantissa
    7509/    2A9C :                     LAB_rtn0
    7510/    2A9C : 2601                	MOVE.l	d1,d3					; clear exponent
    7511/    2A9E : 1743 0594           	MOVE.b	d3,FAC1_e(a3)			; save exponent
    7512/    2AA2 : 2741 0590           	MOVE.l	d1,FAC1_m(a3)			; save mantissa
    7513/    2AA6 : 4CDF 003E           	MOVEM.l	(sp)+,d1-d5				; restore registers
    7514/    2AAA : 4E75                	RTS
    7515/    2AAC :                     
    7516/    2AAC :                     
    7517/    2AAC :                     ;************************************************************************************
    7518/    2AAC :                     ;
    7519/    2AAC :                     ; $ for hex add-on
    7520/    2AAC :                     
    7521/    2AAC :                     ; gets here if the first character was "$" for hex
    7522/    2AAC :                     ; get hex number
    7523/    2AAC :                     
    7524/    2AAC :                     LAB_CHEX
    7525/    2AAC : 177C 0040 05B5      	MOVE.b	#$40,Dtypef(a3)			; set integer numeric data type
    7526/    2AB2 : 7620                	MOVEQ		#32,d3				; set up max binary exponent
    7527/    2AB4 :                     LAB_CHXX
    7528/    2AB4 : 6100 E3AA           	BSR		LAB_IGBY				; increment & scan memory
    7529/    2AB8 : 6514                	BCS.s		LAB_ISHN				; branch if numeric character
    7530/    2ABA :                     
    7531/    2ABA : 803C 0020           	OR.b		#$20,d0				; case convert, allow "A" to "F" and "a" to "f"
    7532/    2ABE : 903C 0061           	SUB.b		#'a',d0				; subtract "a"
    7533/    2AC2 : 652A                	BCS.s		LAB_CHX3				; exit if <"a"
    7534/    2AC4 :                     
    7535/    2AC4 : B03C 0006           	CMP.b		#$06,d0				; compare normalised with $06 (max+1)
    7536/    2AC8 : 6424                	BCC.s		LAB_CHX3				; exit if >"f"
    7537/    2ACA :                     
    7538/    2ACA : D03C 003A           	ADD.b		#$3A,d0				; convert to nibble+"0"
    7539/    2ACE :                     LAB_ISHN
    7540/    2ACE : 616C                	BSR.s		d1x16					; multiply d1 by 16 and add the character
    7541/    2AD0 : 64E2                	BCC.s		LAB_CHXX				; loop for more if no overflow
    7542/    2AD2 :                     
    7543/    2AD2 :                     								; overflowed mantissa, count 16s exponent
    7544/    2AD2 :                     LAB_CHX1
    7545/    2AD2 : 5883                	ADDQ.l	#4,d3					; increment mantissa exponent count
    7546/    2AD4 : 6900 D734           	BVS		LAB_OFER				; do overflow error if overflowed
    7547/    2AD8 :                     
    7548/    2AD8 : 6100 E386           	BSR		LAB_IGBY				; get next character
    7549/    2ADC : 65F4                	BCS.s		LAB_CHX1				; loop while numeric character
    7550/    2ADE :                     
    7551/    2ADE : 803C 0020           	OR.b		#$20,d0				; case convert, allow "A" to "F" and "a" to "f"
    7552/    2AE2 : 903C 0061           	SUB.b		#'a',d0				; subtract "a"
    7553/    2AE6 : 6506                	BCS.s		LAB_CHX3				; exit if <"a"
    7554/    2AE8 :                     
    7555/    2AE8 : B03C 0006           	CMP.b		#$06,d0				; compare normalised with $06 (max+1)
    7556/    2AEC : 65E4                	BCS.s		LAB_CHX1				; loop if <="f"
    7557/    2AEE :                     
    7558/    2AEE :                     								; now return value
    7559/    2AEE :                     LAB_CHX3
    7560/    2AEE : 4A81                	TST.l		d1					; test mantissa
    7561/    2AF0 : 67AA                	BEQ.s		LAB_rtn0				; if mantissa=0 return 0
    7562/    2AF2 :                     
    7563/    2AF2 : 6B08                	BMI.s		LAB_exxf				; branch if already mormalised
    7564/    2AF4 :                     
    7565/    2AF4 : 5383                	SUBQ.l	#1,d3					; decrement bianry exponent for DBMI loop
    7566/    2AF6 :                     LAB_CHX2
    7567/    2AF6 : D281                	ADD.l		d1,d1					; shift mantissa
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 131 - 10/11/2023 21:18:52


    7568/    2AF8 : 5BCB FFFC           	DBMI		d3,LAB_CHX2				; decrement & loop if not normalised
    7569/    2AFC :                     
    7570/    2AFC :                     LAB_exxf
    7571/    2AFC : 0A03 0080           	EORI.b	#$80,d3				; normalise exponent
    7572/    2B00 : 1743 0594           	MOVE.b	d3,FAC1_e(a3)			; save exponent
    7573/    2B04 : 2741 0590           	MOVE.l	d1,FAC1_m(a3)			; save mantissa
    7574/    2B08 : 4CDF 003E           	MOVEM.l	(sp)+,d1-d5				; restore registers
    7575/    2B0C :                     RTS_024
    7576/    2B0C : 4E75                	RTS
    7577/    2B0E :                     
    7578/    2B0E :                     
    7579/    2B0E :                     ;************************************************************************************
    7580/    2B0E :                     ;
    7581/    2B0E :                     ; % for binary add-on
    7582/    2B0E :                     
    7583/    2B0E :                     ; gets here if the first character was "%" for binary
    7584/    2B0E :                     ; get binary number
    7585/    2B0E :                     
    7586/    2B0E :                     LAB_CBIN
    7587/    2B0E : 177C 0040 05B5      	MOVE.b	#$40,Dtypef(a3)			; set integer numeric data type
    7588/    2B14 : 7620                	MOVEQ		#32,d3				; set up max binary exponent
    7589/    2B16 :                     LAB_CBXN
    7590/    2B16 : 6100 E348           	BSR		LAB_IGBY				; increment & scan memory
    7591/    2B1A : 64D2                	BCC.s		LAB_CHX3				; if not numeric character go return value
    7592/    2B1C :                     
    7593/    2B1C : B03C 0032           	CMP.b		#'2',d0				; compare with "2" (max+1)
    7594/    2B20 : 64CC                	BCC.s		LAB_CHX3				; if >="2" go return value
    7595/    2B22 :                     
    7596/    2B22 : 2401                	MOVE.l	d1,d2					; copy value
    7597/    2B24 : 6124                	BSR.s		d1x02					; multiply d1 by 2 and add character
    7598/    2B26 : 64EE                	BCC.s		LAB_CBXN				; loop for more if no overflow
    7599/    2B28 :                     
    7600/    2B28 :                     								; overflowed mantissa, count 2s exponent
    7601/    2B28 :                     LAB_CBX1
    7602/    2B28 : 5283                	ADDQ.l	#1,d3					; increment mantissa exponent count
    7603/    2B2A : 6900 D6DE           	BVS		LAB_OFER				; do overflow error if overflowed
    7604/    2B2E :                     
    7605/    2B2E : 6100 E330           	BSR		LAB_IGBY				; get next character
    7606/    2B32 : 64BA                	BCC.s		LAB_CHX3				; if not numeric character go return value
    7607/    2B34 :                     
    7608/    2B34 : B03C 0032           	CMP.b		#'2',d0				; compare with "2" (max+1)
    7609/    2B38 : 65EE                	BCS.s		LAB_CBX1				; loop if <"2"
    7610/    2B3A :                     
    7611/    2B3A : 60B2                	BRA.s		LAB_CHX3				; if not numeric character go return value
    7612/    2B3C :                     
    7613/    2B3C :                     ; half way decent times 16 and times 2 with overflow checks
    7614/    2B3C :                     
    7615/    2B3C :                     d1x16
    7616/    2B3C : 2401                	MOVE.l	d1,d2					; copy value
    7617/    2B3E : D482                	ADD.l		d2,d2					; times two
    7618/    2B40 : 65CA                	BCS.s		RTS_024				; return if overflow
    7619/    2B42 :                     
    7620/    2B42 : D482                	ADD.l		d2,d2					; times four
    7621/    2B44 : 65C6                	BCS.s		RTS_024				; return if overflow
    7622/    2B46 :                     
    7623/    2B46 : D482                	ADD.l		d2,d2					; times eight
    7624/    2B48 : 65C2                	BCS.s		RTS_024				; return if overflow
    7625/    2B4A :                     
    7626/    2B4A :                     d1x02
    7627/    2B4A : D482                	ADD.l		d2,d2					; times sixteen (ten/two)
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 132 - 10/11/2023 21:18:52


    7628/    2B4C : 65BE                	BCS.s		RTS_024				; return if overflow
    7629/    2B4E :                     
    7630/    2B4E :                     ; now add in new digit
    7631/    2B4E :                     
    7632/    2B4E : C0BC 0000 00FF      	AND.l		#$FF,d0				; mask character
    7633/    2B54 : 903C 0030           	SUB.b		#'0',d0				; convert to value
    7634/    2B58 : D480                	ADD.l		d0,d2					; add to result
    7635/    2B5A : 65B0                	BCS.s		RTS_024				; return if overflow, it should never ever do
    7636/    2B5C :                     								; this
    7637/    2B5C :                     
    7638/    2B5C : 2202                	MOVE.l	d2,d1					; copy result
    7639/    2B5E : 4E75                	RTS
    7640/    2B60 :                     
    7641/    2B60 :                     ; half way decent times 10 with overflow checks
    7642/    2B60 :                     
    7643/    2B60 :                     d1x10
    7644/    2B60 : 2401                	MOVE.l	d1,d2					; copy value
    7645/    2B62 : D482                	ADD.l		d2,d2					; times two
    7646/    2B64 : 6508                	BCS.s		RTS_025				; return if overflow
    7647/    2B66 :                     
    7648/    2B66 : D482                	ADD.l		d2,d2					; times four
    7649/    2B68 : 6504                	BCS.s		RTS_025				; return if overflow
    7650/    2B6A :                     
    7651/    2B6A : D481                	ADD.l		d1,d2					; times five
    7652/    2B6C : 64DC                	BCC.s		d1x02					; do times two and add in new digit if ok
    7653/    2B6E :                     
    7654/    2B6E :                     RTS_025
    7655/    2B6E : 4E75                	RTS
    7656/    2B70 :                     
    7657/    2B70 :                     
    7658/    2B70 :                     ;************************************************************************************
    7659/    2B70 :                     ;
    7660/    2B70 :                     ; token values needed for BASIC
    7661/    2B70 :                     
    7662/    2B70 : =$80                TK_END		EQU $80				; $80
    7663/    2B70 : =$81                TK_FOR		EQU TK_END+1			; $81
    7664/    2B70 : =$82                TK_NEXT		EQU TK_FOR+1			; $82
    7665/    2B70 : =$83                TK_DATA		EQU TK_NEXT+1			; $83
    7666/    2B70 : =$84                TK_INPUT		EQU TK_DATA+1			; $84
    7667/    2B70 : =$85                TK_DIM		EQU TK_INPUT+1			; $85
    7668/    2B70 : =$86                TK_READ		EQU TK_DIM+1			; $86
    7669/    2B70 : =$87                TK_LET		EQU TK_READ+1			; $87
    7670/    2B70 : =$88                TK_DEC		EQU TK_LET+1			; $88
    7671/    2B70 : =$89                TK_GOTO		EQU TK_DEC+1			; $89
    7672/    2B70 : =$8A                TK_RUN		EQU TK_GOTO+1			; $8A
    7673/    2B70 : =$8B                TK_IF			EQU TK_RUN+1			; $8B
    7674/    2B70 : =$8C                TK_RESTORE		EQU TK_IF+1				; $8C
    7675/    2B70 : =$8D                TK_GOSUB		EQU TK_RESTORE+1			; $8D
    7676/    2B70 : =$8E                TK_RETURN		EQU TK_GOSUB+1			; $8E
    7677/    2B70 : =$8F                TK_REM		EQU TK_RETURN+1			; $8F
    7678/    2B70 : =$90                TK_STOP		EQU TK_REM+1			; $90
    7679/    2B70 : =$91                TK_ON			EQU TK_STOP+1			; $91
    7680/    2B70 : =$92                TK_NULL		EQU TK_ON+1				; $92
    7681/    2B70 : =$93                TK_INC		EQU TK_NULL+1			; $93
    7682/    2B70 : =$94                TK_WAIT		EQU TK_INC+1			; $94
    7683/    2B70 : =$95                TK_LOAD		EQU TK_WAIT+1			; $95
    7684/    2B70 : =$96                TK_SAVE		EQU TK_LOAD+1			; $96
    7685/    2B70 : =$97                TK_DEF		EQU TK_SAVE+1			; $97
    7686/    2B70 : =$98                TK_POKE		EQU TK_DEF+1			; $98
    7687/    2B70 : =$99                TK_DOKE		EQU TK_POKE+1			; $99
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 133 - 10/11/2023 21:18:52


    7688/    2B70 : =$9A                TK_LOKE		EQU TK_DOKE+1			; $9A
    7689/    2B70 : =$9B                TK_CALL		EQU TK_LOKE+1			; $9B
    7690/    2B70 : =$9C                TK_DO			EQU TK_CALL+1			; $9C
    7691/    2B70 : =$9D                TK_LOOP		EQU TK_DO+1				; $9D
    7692/    2B70 : =$9E                TK_PRINT		EQU TK_LOOP+1			; $9E
    7693/    2B70 : =$9F                TK_CONT		EQU TK_PRINT+1			; $9F
    7694/    2B70 : =$A0                TK_LIST		EQU TK_CONT+1			; $A0
    7695/    2B70 : =$A1                TK_CLEAR		EQU TK_LIST+1			; $A1
    7696/    2B70 : =$A2                TK_NEW		EQU TK_CLEAR+1			; $A2
    7697/    2B70 : =$A3                TK_WIDTH		EQU TK_NEW+1			; $A3
    7698/    2B70 : =$A4                TK_GET		EQU TK_WIDTH+1			; $A4
    7699/    2B70 : =$A5                TK_SWAP		EQU TK_GET+1			; $A5
    7700/    2B70 : =$A6                TK_BITSET		EQU TK_SWAP+1			; $A6
    7701/    2B70 : =$A7                TK_BITCLR		EQU TK_BITSET+1			; $A7
    7702/    2B70 : =$A8                TK_TAB		EQU TK_BITCLR+1			; $A8
    7703/    2B70 : =$A9                TK_ELSE		EQU TK_TAB+1			; $A9
    7704/    2B70 : =$AA                TK_TO			EQU TK_ELSE+1			; $AA
    7705/    2B70 : =$AB                TK_FN			EQU TK_TO+1				; $AB
    7706/    2B70 : =$AC                TK_SPC		EQU TK_FN+1				; $AC
    7707/    2B70 : =$AD                TK_THEN		EQU TK_SPC+1			; $AD
    7708/    2B70 : =$AE                TK_NOT		EQU TK_THEN+1			; $AE
    7709/    2B70 : =$AF                TK_STEP		EQU TK_NOT+1			; $AF
    7710/    2B70 : =$B0                TK_UNTIL		EQU TK_STEP+1			; $B0
    7711/    2B70 : =$B1                TK_WHILE		EQU TK_UNTIL+1			; $B1
    7712/    2B70 : =$B2                TK_PLUS		EQU TK_WHILE+1			; $B2
    7713/    2B70 : =$B3                TK_MINUS		EQU TK_PLUS+1			; $B3
    7714/    2B70 : =$B4                TK_MULT		EQU TK_MINUS+1			; $B4
    7715/    2B70 : =$B5                TK_DIV		EQU TK_MULT+1			; $B5
    7716/    2B70 : =$B6                TK_POWER		EQU TK_DIV+1			; $B6
    7717/    2B70 : =$B7                TK_AND		EQU TK_POWER+1			; $B7
    7718/    2B70 : =$B8                TK_EOR		EQU TK_AND+1			; $B8
    7719/    2B70 : =$B9                TK_OR			EQU TK_EOR+1			; $B9
    7720/    2B70 : =$BA                TK_RSHIFT		EQU TK_OR+1				; $BA
    7721/    2B70 : =$BB                TK_LSHIFT		EQU TK_RSHIFT+1			; $BB
    7722/    2B70 : =$BC                TK_GT			EQU TK_LSHIFT+1			; $BC
    7723/    2B70 : =$BD                TK_EQUAL		EQU TK_GT+1				; $BD
    7724/    2B70 : =$BE                TK_LT			EQU TK_EQUAL+1			; $BE
    7725/    2B70 : =$BF                TK_SGN		EQU TK_LT+1				; $BF
    7726/    2B70 : =$C0                TK_INT		EQU TK_SGN+1			; $C0
    7727/    2B70 : =$C1                TK_ABS		EQU TK_INT+1			; $C1
    7728/    2B70 : =$C2                TK_USR		EQU TK_ABS+1			; $C2
    7729/    2B70 : =$C3                TK_FRE		EQU TK_USR+1			; $C3
    7730/    2B70 : =$C4                TK_POS		EQU TK_FRE+1			; $C4
    7731/    2B70 : =$C5                TK_SQR		EQU TK_POS+1			; $C5
    7732/    2B70 : =$C6                TK_RND		EQU TK_SQR+1			; $C6
    7733/    2B70 : =$C7                TK_LOG		EQU TK_RND+1			; $C7
    7734/    2B70 : =$C8                TK_EXP		EQU TK_LOG+1			; $C8
    7735/    2B70 : =$C9                TK_COS		EQU TK_EXP+1			; $C9
    7736/    2B70 : =$CA                TK_SIN		EQU TK_COS+1			; $CA
    7737/    2B70 : =$CB                TK_TAN		EQU TK_SIN+1			; $CB
    7738/    2B70 : =$CC                TK_ATN		EQU TK_TAN+1			; $CC
    7739/    2B70 : =$CD                TK_PEEK		EQU TK_ATN+1			; $CD
    7740/    2B70 : =$CE                TK_DEEK		EQU TK_PEEK+1			; $CE
    7741/    2B70 : =$CF                TK_LEEK		EQU TK_DEEK+1			; $CF
    7742/    2B70 : =$D0                TK_LEN		EQU TK_LEEK+1			; $D0
    7743/    2B70 : =$D1                TK_STRS		EQU TK_LEN+1			; $D1
    7744/    2B70 : =$D2                TK_VAL		EQU TK_STRS+1			; $D2
    7745/    2B70 : =$D3                TK_ASC		EQU TK_VAL+1			; $D3
    7746/    2B70 : =$D4                TK_UCASES		EQU TK_ASC+1			; $D4
    7747/    2B70 : =$D5                TK_LCASES		EQU TK_UCASES+1			; $D5
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 134 - 10/11/2023 21:18:52


    7748/    2B70 : =$D6                TK_CHRS		EQU TK_LCASES+1			; $D6
    7749/    2B70 : =$D7                TK_HEXS		EQU TK_CHRS+1			; $D7
    7750/    2B70 : =$D8                TK_BINS		EQU TK_HEXS+1			; $D8
    7751/    2B70 : =$D9                TK_BITTST		EQU TK_BINS+1			; $D9
    7752/    2B70 : =$DA                TK_MAX		EQU TK_BITTST+1			; $DA
    7753/    2B70 : =$DB                TK_MIN		EQU TK_MAX+1			; $DB
    7754/    2B70 : =$DC                TK_RAM		EQU TK_MIN+1			; $DC
    7755/    2B70 : =$DD                TK_PI			EQU TK_RAM+1			; $DD
    7756/    2B70 : =$DE                TK_TWOPI		EQU TK_PI+1				; $DE
    7757/    2B70 : =$DF                TK_VPTR		EQU TK_TWOPI+1			; $DF
    7758/    2B70 : =$E0                TK_SADD		EQU TK_VPTR+1			; $E0
    7759/    2B70 : =$E1                TK_LEFTS		EQU TK_SADD+1			; $E1
    7760/    2B70 : =$E2                TK_RIGHTS		EQU TK_LEFTS+1			; $E2
    7761/    2B70 : =$E3                TK_MIDS		EQU TK_RIGHTS+1			; $E3
    7762/    2B70 : =$E4                TK_USINGS		EQU TK_MIDS+1			; $E4
    7763/    2B70 :                     
    7764/    2B70 :                     
    7765/    2B70 :                     ;************************************************************************************
    7766/    2B70 :                     ;
    7767/    2B70 :                     ; binary to unsigned decimal table
    7768/    2B70 :                     
    7769/    2B70 :                     Bin2dec
    7770/    2B70 : 3B9A CA00           	dc.l	$3B9ACA00					; 1000000000
    7771/    2B74 : 05F5 E100           	dc.l	$05F5E100					; 100000000
    7772/    2B78 : 0098 9680           	dc.l	$00989680					; 10000000
    7773/    2B7C : 000F 4240           	dc.l	$000F4240					; 1000000
    7774/    2B80 : 0001 86A0           	dc.l	$000186A0					; 100000
    7775/    2B84 : 0000 2710           	dc.l	$00002710					; 10000
    7776/    2B88 : 0000 03E8           	dc.l	$000003E8					; 1000
    7777/    2B8C : 0000 0064           	dc.l	$00000064					; 100
    7778/    2B90 : 0000 000A           	dc.l	$0000000A					; 10
    7779/    2B94 : 0000 0000           	dc.l	$00000000					; 0 end marker
    7780/    2B98 :                     
    7781/    2B98 :                     LAB_RSED
    7782/    2B98 : 332E 3232           	dc.l	$332E3232					; 858665522
    7783/    2B9C :                     
    7784/    2B9C :                     ; string to value exponent table
    7785/    2B9C :                     
    7786/    2B9C : FF00                	dc.w	255<<8					; 10**38
    7787/    2B9E : 9676 9951           	dc.l	$96769951
    7788/    2BA2 : FB00                	dc.w	251<<8					; 10**37
    7789/    2BA4 : F0BD C21B           	dc.l	$F0BDC21B
    7790/    2BA8 : F800                	dc.w	248<<8					; 10**36
    7791/    2BAA : C097 CE7C           	dc.l	$C097CE7C
    7792/    2BAE : F500                	dc.w	245<<8					; 10**35
    7793/    2BB0 : 9A13 0B96           	dc.l	$9A130B96
    7794/    2BB4 : F100                	dc.w	241<<8					; 10**34
    7795/    2BB6 : F684 DF57           	dc.l	$F684DF57
    7796/    2BBA : EE00                	dc.w	238<<8					; 10**33
    7797/    2BBC : C537 1912           	dc.l	$C5371912
    7798/    2BC0 : EB00                	dc.w	235<<8					; 10**32
    7799/    2BC2 : 9DC5 ADA8           	dc.l	$9DC5ADA8
    7800/    2BC6 : E700                	dc.w	231<<8					; 10**31
    7801/    2BC8 : FC6F 7C40           	dc.l	$FC6F7C40
    7802/    2BCC : E400                	dc.w	228<<8					; 10**30
    7803/    2BCE : C9F2 C9CD           	dc.l	$C9F2C9CD
    7804/    2BD2 : E100                	dc.w	225<<8					; 10**29
    7805/    2BD4 : A18F 07D7           	dc.l	$A18F07D7
    7806/    2BD8 : DE00                	dc.w	222<<8					; 10**28
    7807/    2BDA : 813F 3979           	dc.l	$813F3979
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 135 - 10/11/2023 21:18:52


    7808/    2BDE : DA00                	dc.w	218<<8					; 10**27
    7809/    2BE0 : CECB 8F28           	dc.l	$CECB8F28
    7810/    2BE4 : D700                	dc.w	215<<8					; 10**26
    7811/    2BE6 : A56F A5BA           	dc.l	$A56FA5BA
    7812/    2BEA : D400                	dc.w	212<<8					; 10**25
    7813/    2BEC : 8459 5161           	dc.l	$84595161
    7814/    2BF0 : D000                	dc.w	208<<8					; 10**24
    7815/    2BF2 : D3C2 1BCF           	dc.l	$D3C21BCF
    7816/    2BF6 : CD00                	dc.w	205<<8					; 10**23
    7817/    2BF8 : A968 163F           	dc.l	$A968163F
    7818/    2BFC : CA00                	dc.w	202<<8					; 10**22
    7819/    2BFE : 8786 7832           	dc.l	$87867832
    7820/    2C02 : C600                	dc.w	198<<8					; 10**21
    7821/    2C04 : D8D7 26B7           	dc.l	$D8D726B7
    7822/    2C08 : C300                	dc.w	195<<8					; 10**20
    7823/    2C0A : AD78 EBC6           	dc.l	$AD78EBC6
    7824/    2C0E : C000                	dc.w	192<<8					; 10**19
    7825/    2C10 : 8AC7 2305           	dc.l	$8AC72305
    7826/    2C14 : BC00                	dc.w	188<<8					; 10**18
    7827/    2C16 : DE0B 6B3A           	dc.l	$DE0B6B3A
    7828/    2C1A : B900                	dc.w	185<<8					; 10**17
    7829/    2C1C : B1A2 BC2F           	dc.l	$B1A2BC2F
    7830/    2C20 : B600                	dc.w	182<<8					; 10**16
    7831/    2C22 : 8E1B C9BF           	dc.l	$8E1BC9BF
    7832/    2C26 : B200                	dc.w	178<<8					; 10**15
    7833/    2C28 : E35F A932           	dc.l	$E35FA932
    7834/    2C2C : AF00                	dc.w	175<<8					; 10**14
    7835/    2C2E : B5E6 20F5           	dc.l	$B5E620F5
    7836/    2C32 : AC00                	dc.w	172<<8					; 10**13
    7837/    2C34 : 9184 E72A           	dc.l	$9184E72A
    7838/    2C38 : A800                	dc.w	168<<8					; 10**12
    7839/    2C3A : E8D4 A510           	dc.l	$E8D4A510
    7840/    2C3E : A500                	dc.w	165<<8					; 10**11
    7841/    2C40 : BA43 B740           	dc.l	$BA43B740
    7842/    2C44 : A200                	dc.w	162<<8					; 10**10
    7843/    2C46 : 9502 F900           	dc.l	$9502F900
    7844/    2C4A : 9E00                	dc.w	158<<8					; 10**9
    7845/    2C4C : EE6B 2800           	dc.l	$EE6B2800
    7846/    2C50 : 9B00                	dc.w	155<<8					; 10**8
    7847/    2C52 : BEBC 2000           	dc.l	$BEBC2000
    7848/    2C56 : 9800                	dc.w	152<<8					; 10**7
    7849/    2C58 : 9896 8000           	dc.l	$98968000
    7850/    2C5C : 9400                	dc.w	148<<8					; 10**6
    7851/    2C5E : F424 0000           	dc.l	$F4240000
    7852/    2C62 : 9100                	dc.w	145<<8					; 10**5
    7853/    2C64 : C350 0000           	dc.l	$C3500000
    7854/    2C68 : 8E00                	dc.w	142<<8					; 10**4
    7855/    2C6A : 9C40 0000           	dc.l	$9C400000
    7856/    2C6E : 8A00                	dc.w	138<<8					; 10**3
    7857/    2C70 : FA00 0000           	dc.l	$FA000000
    7858/    2C74 : 8700                	dc.w	135<<8					; 10**2
    7859/    2C76 : C800 0000           	dc.l	$C8000000
    7860/    2C7A : 8400                	dc.w	132<<8					; 10**1
    7861/    2C7C : A000 0000           	dc.l	$A0000000
    7862/    2C80 :                     LAB_P_10
    7863/    2C80 : 8100                	dc.w	129<<8					; 10**0
    7864/    2C82 : 8000 0000           	dc.l	$80000000
    7865/    2C86 : 7D00                	dc.w	125<<8					; 10**-1
    7866/    2C88 : CCCC CCCD           	dc.l	$CCCCCCCD
    7867/    2C8C : 7A00                	dc.w	122<<8					; 10**-2
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 136 - 10/11/2023 21:18:52


    7868/    2C8E : A3D7 0A3D           	dc.l	$A3D70A3D
    7869/    2C92 : 7700                	dc.w	119<<8					; 10**-3
    7870/    2C94 : 8312 6E98           	dc.l	$83126E98
    7871/    2C98 : 7300                	dc.w	115<<8					; 10**-4
    7872/    2C9A : D1B7 1759           	dc.l	$D1B71759
    7873/    2C9E : 7000                	dc.w	112<<8					; 10**-5
    7874/    2CA0 : A7C5 AC47           	dc.l	$A7C5AC47
    7875/    2CA4 : 6D00                	dc.w	109<<8					; 10**-6
    7876/    2CA6 : 8637 BD06           	dc.l	$8637BD06
    7877/    2CAA : 6900                	dc.w	105<<8					; 10**-7
    7878/    2CAC : D6BF 94D6           	dc.l	$D6BF94D6
    7879/    2CB0 : 6600                	dc.w	102<<8					; 10**-8
    7880/    2CB2 : ABCC 7712           	dc.l	$ABCC7712
    7881/    2CB6 : 6300                	dc.w	99<<8						; 10**-9
    7882/    2CB8 : 8970 5F41           	dc.l	$89705F41
    7883/    2CBC : 5F00                	dc.w	95<<8						; 10**-10
    7884/    2CBE : DBE6 FECF           	dc.l	$DBE6FECF
    7885/    2CC2 : 5C00                	dc.w	92<<8						; 10**-11
    7886/    2CC4 : AFEB FF0C           	dc.l	$AFEBFF0C
    7887/    2CC8 : 5900                	dc.w	89<<8						; 10**-12
    7888/    2CCA : 8CBC CC09           	dc.l	$8CBCCC09
    7889/    2CCE : 5500                	dc.w	85<<8						; 10**-13
    7890/    2CD0 : E12E 1342           	dc.l	$E12E1342
    7891/    2CD4 : 5200                	dc.w	82<<8						; 10**-14
    7892/    2CD6 : B424 DC35           	dc.l	$B424DC35
    7893/    2CDA : 4F00                	dc.w	79<<8						; 10**-15
    7894/    2CDC : 901D 7CF7           	dc.l	$901D7CF7
    7895/    2CE0 : 4B00                	dc.w	75<<8						; 10**-16
    7896/    2CE2 : E695 94BF           	dc.l	$E69594BF
    7897/    2CE6 : 4800                	dc.w	72<<8						; 10**-17
    7898/    2CE8 : B877 AA32           	dc.l	$B877AA32
    7899/    2CEC : 4500                	dc.w	69<<8						; 10**-18
    7900/    2CEE : 9392 EE8F           	dc.l	$9392EE8F
    7901/    2CF2 : 4100                	dc.w	65<<8						; 10**-19
    7902/    2CF4 : EC1E 4A7E           	dc.l	$EC1E4A7E
    7903/    2CF8 : 3E00                	dc.w	62<<8						; 10**-20
    7904/    2CFA : BCE5 0865           	dc.l	$BCE50865
    7905/    2CFE : 3B00                	dc.w	59<<8						; 10**-21
    7906/    2D00 : 971D A050           	dc.l	$971DA050
    7907/    2D04 : 3700                	dc.w	55<<8						; 10**-22
    7908/    2D06 : F1C9 0081           	dc.l	$F1C90081
    7909/    2D0A : 3400                	dc.w	52<<8						; 10**-23
    7910/    2D0C : C16D 9A01           	dc.l	$C16D9A01
    7911/    2D10 : 3100                	dc.w	49<<8						; 10**-24
    7912/    2D12 : 9ABE 14CD           	dc.l	$9ABE14CD
    7913/    2D16 : 2D00                	dc.w	45<<8						; 10**-25
    7914/    2D18 : F796 87AE           	dc.l	$F79687AE
    7915/    2D1C : 2A00                	dc.w	42<<8						; 10**-26
    7916/    2D1E : C612 0625           	dc.l	$C6120625
    7917/    2D22 : 2700                	dc.w	39<<8						; 10**-27
    7918/    2D24 : 9E74 D1B8           	dc.l	$9E74D1B8
    7919/    2D28 : 2300                	dc.w	35<<8						; 10**-28
    7920/    2D2A : FD87 B5F3           	dc.l	$FD87B5F3
    7921/    2D2E : 2000                	dc.w	32<<8						; 10**-29
    7922/    2D30 : CAD2 F7F5           	dc.l	$CAD2F7F5
    7923/    2D34 : 1D00                	dc.w	29<<8						; 10**-30
    7924/    2D36 : A242 5FF7           	dc.l	$A2425FF7
    7925/    2D3A : 1A00                	dc.w	26<<8						; 10**-31
    7926/    2D3C : 81CE B32C           	dc.l	$81CEB32C
    7927/    2D40 : 1600                	dc.w	22<<8						; 10**-32
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 137 - 10/11/2023 21:18:52


    7928/    2D42 : CFB1 1EAD           	dc.l	$CFB11EAD
    7929/    2D46 : 1300                	dc.w	19<<8						; 10**-33
    7930/    2D48 : A627 4BBE           	dc.l	$A6274BBE
    7931/    2D4C : 1000                	dc.w	16<<8						; 10**-34
    7932/    2D4E : 84EC 3C98           	dc.l	$84EC3C98
    7933/    2D52 : 0C00                	dc.w	12<<8						; 10**-35
    7934/    2D54 : D4AD 2DC0           	dc.l	$D4AD2DC0
    7935/    2D58 : 0900                	dc.w	9<<8						; 10**-36
    7936/    2D5A : AA24 2499           	dc.l	$AA242499
    7937/    2D5E : 0600                	dc.w	6<<8						; 10**-37
    7938/    2D60 : 881C EA14           	dc.l	$881CEA14
    7939/    2D64 : 0200                	dc.w	2<<8						; 10**-38
    7940/    2D66 : D9C7 DCED           	dc.l	$D9C7DCED
    7941/    2D6A :                     
    7942/    2D6A :                     
    7943/    2D6A :                     ;************************************************************************************
    7944/    2D6A :                     ;
    7945/    2D6A :                     ; table of constants for cordic SIN/COS/TAN calculations
    7946/    2D6A :                     ; constants are un normalised fractions and are atn(2^-i)/2pi
    7947/    2D6A :                     
    7948/    2D6A : 4DBA 76D4           	dc.l	$4DBA76D4					; SIN/COS multiply constant
    7949/    2D6E :                     TAB_SNCO
    7950/    2D6E : 2000 0000           	dc.l	$20000000					; atn(2^0)/2pi
    7951/    2D72 : 12E4 051E           	dc.l	$12E4051E					; atn(2^1)/2pi
    7952/    2D76 : 09FB 385C           	dc.l	$09FB385C					; atn(2^2)/2pi
    7953/    2D7A : 0511 11D5           	dc.l	$051111D5					; atn(2^3)/2pi
    7954/    2D7E : 028B 0D44           	dc.l	$028B0D44					; atn(2^4)/2pi
    7955/    2D82 : 0145 D7E2           	dc.l	$0145D7E2					; atn(2^5)/2pi
    7956/    2D86 : 00A2 F61F           	dc.l	$00A2F61F					; atn(2^6)/2pi
    7957/    2D8A : 0051 7C56           	dc.l	$00517C56					; atn(2^7)/2pi
    7958/    2D8E : 0028 BE54           	dc.l	$0028BE54					; atn(2^8)/2pi
    7959/    2D92 : 0014 5F2F           	dc.l	$00145F2F					; atn(2^9)/2pi
    7960/    2D96 : 000A 2F99           	dc.l	$000A2F99					; atn(2^10)/2pi
    7961/    2D9A : 0005 17CD           	dc.l	$000517CD					; atn(2^11)/2pi
    7962/    2D9E : 0002 8BE7           	dc.l	$00028BE7					; atn(2^12)/2pi
    7963/    2DA2 : 0001 45F4           	dc.l	$000145F4					; atn(2^13)/2pi
    7964/    2DA6 : 0000 A2FA           	dc.l	$0000A2FA					; atn(2^14)/2pi
    7965/    2DAA : 0000 517D           	dc.l	$0000517D					; atn(2^15)/2pi
    7966/    2DAE : 0000 28BF           	dc.l	$000028BF					; atn(2^16)/2pi
    7967/    2DB2 : 0000 1460           	dc.l	$00001460					; atn(2^17)/2pi
    7968/    2DB6 : 0000 0A30           	dc.l	$00000A30					; atn(2^18)/2pi
    7969/    2DBA : 0000 0518           	dc.l	$00000518					; atn(2^19)/2pi
    7970/    2DBE : 0000 028C           	dc.l	$0000028C					; atn(2^20)/2pi
    7971/    2DC2 : 0000 0146           	dc.l	$00000146					; atn(2^21)/2pi
    7972/    2DC6 : 0000 00A3           	dc.l	$000000A3					; atn(2^22)/2pi
    7973/    2DCA : 0000 0052           	dc.l	$00000052					; atn(2^23)/2pi
    7974/    2DCE : 0000 0029           	dc.l	$00000029					; atn(2^24)/2pi
    7975/    2DD2 : 0000 0015           	dc.l	$00000015					; atn(2^25)/2pi
    7976/    2DD6 : 0000 000B           	dc.l	$0000000B					; atn(2^26)/2pi
    7977/    2DDA : 0000 0006           	dc.l	$00000006					; atn(2^27)/2pi
    7978/    2DDE : 0000 0003           	dc.l	$00000003					; atn(2^28)/2pi
    7979/    2DE2 : 0000 0002           	dc.l	$00000002					; atn(2^29)/2pi
    7980/    2DE6 : 0000 0001           	dc.l	$00000001					; atn(2^30)/2pi
    7981/    2DEA : 0000 0001           	dc.l	$00000001					; atn(2^31)/2pi
    7982/    2DEE :                     
    7983/    2DEE :                     
    7984/    2DEE :                     ;************************************************************************************
    7985/    2DEE :                     ;
    7986/    2DEE :                     ; table of constants for cordic ATN calculation
    7987/    2DEE :                     ; constants are normalised to two integer bits and are atn(2^-i)
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 138 - 10/11/2023 21:18:52


    7988/    2DEE :                     
    7989/    2DEE :                     TAB_ATNC
    7990/    2DEE : 1DAC 6705           	dc.l	$1DAC6705					; atn(2^-1)
    7991/    2DF2 : 0FAD BAFD           	dc.l	$0FADBAFD					; atn(2^-2)
    7992/    2DF6 : 07F5 6EA7           	dc.l	$07F56EA7					; atn(2^-3)
    7993/    2DFA : 03FE AB77           	dc.l	$03FEAB77					; atn(2^-4)
    7994/    2DFE : 01FF D55C           	dc.l	$01FFD55C					; atn(2^-5)
    7995/    2E02 : 00FF FAAB           	dc.l	$00FFFAAB					; atn(2^-6)
    7996/    2E06 : 007F FF55           	dc.l	$007FFF55					; atn(2^-7)
    7997/    2E0A : 003F FFEB           	dc.l	$003FFFEB					; atn(2^-8)
    7998/    2E0E : 001F FFFD           	dc.l	$001FFFFD					; atn(2^-9)
    7999/    2E12 : 0010 0000           	dc.l	$00100000					; atn(2^-10)
    8000/    2E16 : 0008 0000           	dc.l	$00080000					; atn(2^-11)
    8001/    2E1A : 0004 0000           	dc.l	$00040000					; atn(2^-12)
    8002/    2E1E : 0002 0000           	dc.l	$00020000					; atn(2^-13)
    8003/    2E22 : 0001 0000           	dc.l	$00010000					; atn(2^-14)
    8004/    2E26 : 0000 8000           	dc.l	$00008000					; atn(2^-15)
    8005/    2E2A : 0000 4000           	dc.l	$00004000					; atn(2^-16)
    8006/    2E2E : 0000 2000           	dc.l	$00002000					; atn(2^-17)
    8007/    2E32 : 0000 1000           	dc.l	$00001000					; atn(2^-18)
    8008/    2E36 : 0000 0800           	dc.l	$00000800					; atn(2^-19)
    8009/    2E3A : 0000 0400           	dc.l	$00000400					; atn(2^-20)
    8010/    2E3E : 0000 0200           	dc.l	$00000200					; atn(2^-21)
    8011/    2E42 : 0000 0100           	dc.l	$00000100					; atn(2^-22)
    8012/    2E46 : 0000 0080           	dc.l	$00000080					; atn(2^-23)
    8013/    2E4A : 0000 0040           	dc.l	$00000040					; atn(2^-24)
    8014/    2E4E : 0000 0020           	dc.l	$00000020					; atn(2^-25)
    8015/    2E52 : 0000 0010           	dc.l	$00000010					; atn(2^-26)
    8016/    2E56 : 0000 0008           	dc.l	$00000008					; atn(2^-27)
    8017/    2E5A : 0000 0004           	dc.l	$00000004					; atn(2^-28)
    8018/    2E5E : 0000 0002           	dc.l	$00000002					; atn(2^-29)
    8019/    2E62 : 0000 0001           	dc.l	$00000001					; atn(2^-30)
    8020/    2E66 :                     LAB_1D96
    8021/    2E66 : 0000 0000           	dc.l	$00000000					; atn(2^-31)
    8022/    2E6A : 0000 0000           	dc.l	$00000000					; atn(2^-32)
    8023/    2E6E :                     
    8024/    2E6E :                     ; constants are normalised to n integer bits and are tanh(2^-i)
    8025/    2E6E : =$2                 n	equ	2
    8026/    2E6E :                     TAB_HTHET
    8027/    2E6E : 2327 D4F4           	dc.l	$2327d4f4				; atnh(2^-1) .549306144
    8028/    2E72 : 1058 AEFA           	dc.l	$1058aefa				; atnh(2^-2) .255412812
    8029/    2E76 : 080A C48E           	dc.l	$080ac48e				; atnh(2^-3)
    8030/    2E7A : 0401 5622           	dc.l	$04015622				; atnh(2^-4)
    8031/    2E7E : 0200 2AB0           	dc.l	$02002ab0				; atnh(2^-5)
    8032/    2E82 : 0100 0554           	dc.l	$01000554				; atnh(2^-6)
    8033/    2E86 : 0080 00AA           	dc.l	$008000aa				; atnh(2^-7)
    8034/    2E8A : 0040 0014           	dc.l	$00400014				; atnh(2^-8)
    8035/    2E8E : 0020 0002           	dc.l	$00200002				; atnh(2^-9)
    8036/    2E92 : 0010 0000           	dc.l	$00100000				; atnh(2^-10)
    8037/    2E96 : 0008 0000           	dc.l	$00080000				; atnh(2^-11)
    8038/    2E9A : 0004 0000           	dc.l	$00040000				; atnh(2^-12)
    8039/    2E9E : 0002 0000           	dc.l	$00020000				; atnh(2^-13)
    8040/    2EA2 : 0001 0000           	dc.l	$00010000				; atnh(2^-14)
    8041/    2EA6 : 0000 8000           	dc.l	$00008000				; atnh(2^-15)
    8042/    2EAA : 0000 4000           	dc.l	$00004000				; atnh(2^-16)
    8043/    2EAE : 0000 2000           	dc.l	$00002000				; atnh(2^-17)
    8044/    2EB2 : 0000 1000           	dc.l	$00001000				; atnh(2^-18)
    8045/    2EB6 : 0000 0800           	dc.l	$00000800				; atnh(2^-19)
    8046/    2EBA : 0000 0400           	dc.l	$00000400				; atnh(2^-20)
    8047/    2EBE : 0000 0200           	dc.l	$00000200				; atnh(2^-21)
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 139 - 10/11/2023 21:18:52


    8048/    2EC2 : 0000 0100           	dc.l	$00000100				; atnh(2^-22)
    8049/    2EC6 : 0000 0080           	dc.l	$00000080				; atnh(2^-23)
    8050/    2ECA : 0000 0040           	dc.l	$00000040				; atnh(2^-24)
    8051/    2ECE : 0000 0020           	dc.l	$00000020				; atnh(2^-25)
    8052/    2ED2 : 0000 0010           	dc.l	$00000010				; atnh(2^-26)
    8053/    2ED6 : 0000 0008           	dc.l	$00000008				; atnh(2^-27)
    8054/    2EDA : 0000 0004           	dc.l	$00000004				; atnh(2^-28)
    8055/    2EDE : 0000 0002           	dc.l	$00000002				; atnh(2^-29)
    8056/    2EE2 : 0000 0001           	dc.l	$00000001				; atnh(2^-30)
    8057/    2EE6 : 0000 0000           	dc.l	$00000000				; atnh(2^-31)
    8058/    2EEA : 0000 0000           	dc.l	$00000000				; atnh(2^-32)
    8059/    2EEE : =$26A3D110          KFCTSEED	equ	$26A3D110			; $26A3D110
    8060/    2EEE :                     
    8061/    2EEE :                     
    8062/    2EEE :                     ;************************************************************************************
    8063/    2EEE :                     ;
    8064/    2EEE :                     ; command vector table
    8065/    2EEE :                     
    8066/    2EEE :                     LAB_CTBL
    8067/    2EEE : D79E                	dc.w	LAB_END-LAB_CTBL				; END
    8068/    2EF0 : D6D2                	dc.w	LAB_FOR-LAB_CTBL				; FOR
    8069/    2EF2 : DD44                	dc.w	LAB_NEXT-LAB_CTBL				; NEXT
    8070/    2EF4 : D8F2                	dc.w	LAB_DATA-LAB_CTBL				; DATA
    8071/    2EF6 : DC38                	dc.w	LAB_INPUT-LAB_CTBL			; INPUT
    8072/    2EF8 : E116                	dc.w	LAB_DIM-LAB_CTBL				; DIM
    8073/    2EFA : DC5E                	dc.w	LAB_READ-LAB_CTBL				; READ
    8074/    2EFC : DA6A                	dc.w	LAB_LET-LAB_CTBL				; LET
    8075/    2EFE : DA06                	dc.w	LAB_DEC-LAB_CTBL				; DEC	
    8076/    2F00 : D85A                	dc.w	LAB_GOTO-LAB_CTBL				; GOTO
    8077/    2F02 : D822                	dc.w	LAB_RUN-LAB_CTBL				; RUN
    8078/    2F04 : D91A                	dc.w	LAB_IF-LAB_CTBL				; IF
    8079/    2F06 : D7CC                	dc.w	LAB_RESTORE-LAB_CTBL			; RESTORE
    8080/    2F08 : D848                	dc.w	LAB_GOSUB-LAB_CTBL			; GOSUB
    8081/    2F0A : D8DE                	dc.w	LAB_RETURN-LAB_CTBL			; RETURN
    8082/    2F0C : D98C                	dc.w	LAB_REM-LAB_CTBL				; REM
    8083/    2F0E : D7A6                	dc.w	LAB_STOP-LAB_CTBL				; STOP
    8084/    2F10 : D994                	dc.w	LAB_ON-LAB_CTBL				; ON
    8085/    2F12 : D7FA                	dc.w	LAB_NULL-LAB_CTBL				; NULL
    8086/    2F14 : DA0C                	dc.w	LAB_INC-LAB_CTBL				; INC	
    8087/    2F16 : EA1E                	dc.w	LAB_WAIT-LAB_CTBL				; WAIT
    8088/    2F18 : EA0C                	dc.w	LAB_LOAD-LAB_CTBL				; LOAD
    8089/    2F1A : EA10                	dc.w	LAB_SAVE-LAB_CTBL				; SAVE
    8090/    2F1C : E4A6                	dc.w	LAB_DEF-LAB_CTBL				; DEF
    8091/    2F1E : E98C                	dc.w	LAB_POKE-LAB_CTBL				; POKE
    8092/    2F20 : E9BC                	dc.w	LAB_DOKE-LAB_CTBL				; DOKE
    8093/    2F22 : E9C2                	dc.w	LAB_LOKE-LAB_CTBL				; LOKE
    8094/    2F24 : EA14                	dc.w	LAB_CALL-LAB_CTBL				; CALL
    8095/    2F26 : D836                	dc.w	LAB_DO-LAB_CTBL				; DO	
    8096/    2F28 : D888                	dc.w	LAB_LOOP-LAB_CTBL				; LOOP
    8097/    2F2A : DAFE                	dc.w	LAB_PRINT-LAB_CTBL			; PRINT
    8098/    2F2C : D804                	dc.w	LAB_CONT-LAB_CTBL				; CONT
    8099/    2F2E : D61C                	dc.w	LAB_LIST-LAB_CTBL				; LIST
    8100/    2F30 : D618                	dc.w	LAB_CLEAR-LAB_CTBL			; CLEAR
    8101/    2F32 : D5C6                	dc.w	LAB_NEW-LAB_CTBL				; NEW
    8102/    2F34 : F954                	dc.w	LAB_WDTH-LAB_CTBL				; WIDTH
    8103/    2F36 : DAC4                	dc.w	LAB_GET-LAB_CTBL				; GET
    8104/    2F38 : E9D6                	dc.w	LAB_SWAP-LAB_CTBL				; SWAP
    8105/    2F3A : F49E                	dc.w	LAB_BITSET-LAB_CTBL			; BITSET
    8106/    2F3C : F4AE                	dc.w	LAB_BITCLR-LAB_CTBL			; BITCLR
    8107/    2F3E :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 140 - 10/11/2023 21:18:52


    8108/    2F3E :                     
    8109/    2F3E :                     ;************************************************************************************
    8110/    2F3E :                     ;
    8111/    2F3E :                     ; function pre process routine table
    8112/    2F3E :                     
    8113/    2F3E :                     LAB_FTPP
    8114/    2F3E : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; SGN(n)	process numeric expression in ()
    8115/    2F40 : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; INT(n)		"
    8116/    2F42 : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; ABS(n)		"
    8117/    2F44 : DDC4                	dc.w	LAB_EVEZ-LAB_FTPP				; USR(x)	process any expression
    8118/    2F46 : DF0C                	dc.w	LAB_1BF7-LAB_FTPP				; FRE(x)	process any expression in ()
    8119/    2F48 : DF0C                	dc.w	LAB_1BF7-LAB_FTPP				; POS(x)		"
    8120/    2F4A : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; SQR(n)	process numeric expression in ()
    8121/    2F4C : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; RND(n)		"
    8122/    2F4E : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; LOG(n)		"
    8123/    2F50 : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; EXP(n)		"
    8124/    2F52 : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; COS(n)		"
    8125/    2F54 : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; SIN(n)		"
    8126/    2F56 : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; TAN(n)		"
    8127/    2F58 : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; ATN(n)		"
    8128/    2F5A : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; PEEK(n)		"
    8129/    2F5C : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; DEEK(n)		"
    8130/    2F5E : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; LEEK(n)		"
    8131/    2F60 : DFB6                	dc.w	LAB_PPFS-LAB_FTPP				; LEN($)	process string expression in ()
    8132/    2F62 : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; STR$(n)	process numeric expression in ()
    8133/    2F64 : DFB6                	dc.w	LAB_PPFS-LAB_FTPP				; VAL($)	process string expression in ()
    8134/    2F66 : DFB6                	dc.w	LAB_PPFS-LAB_FTPP				; ASC($)		"
    8135/    2F68 : DFB6                	dc.w	LAB_PPFS-LAB_FTPP				; UCASE$($)		"
    8136/    2F6A : DFB6                	dc.w	LAB_PPFS-LAB_FTPP				; LCASE$($)		"
    8137/    2F6C : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; CHR$(n)	process numeric expression in ()
    8138/    2F6E : DFFE                	dc.w	LAB_BHSS-LAB_FTPP				; HEX$()	bin/hex pre process
    8139/    2F70 : DFFE                	dc.w	LAB_BHSS-LAB_FTPP				; BIN$()		"
    8140/    2F72 : 0000                	dc.w	$0000						; BITTST()	none
    8141/    2F74 : 0000                	dc.w	$0000						; MAX()		"
    8142/    2F76 : 0000                	dc.w	$0000						; MIN()		"
    8143/    2F78 : DFD2                	dc.w	LAB_PPBI-LAB_FTPP				; RAMBASE	advance pointer
    8144/    2F7A : DFD2                	dc.w	LAB_PPBI-LAB_FTPP				; PI			"
    8145/    2F7C : DFD2                	dc.w	LAB_PPBI-LAB_FTPP				; TWOPI		"
    8146/    2F7E : 0000                	dc.w	$0000						; VARPTR()	none
    8147/    2F80 : 0000                	dc.w	$0000						; SADD()		"
    8148/    2F82 : DFDC                	dc.w	LAB_LRMS-LAB_FTPP				; LEFT$()	process string expression
    8149/    2F84 : DFDC                	dc.w	LAB_LRMS-LAB_FTPP				; RIGHT$()		"
    8150/    2F86 : DFDC                	dc.w	LAB_LRMS-LAB_FTPP				; MID$()		"
    8151/    2F88 : DDC4                	dc.w	LAB_EVEZ-LAB_FTPP				; USING$(x)	process any expression
    8152/    2F8A :                     
    8153/    2F8A :                     
    8154/    2F8A :                     ;************************************************************************************
    8155/    2F8A :                     ;
    8156/    2F8A :                     ; action addresses for functions
    8157/    2F8A :                     
    8158/    2F8A :                     LAB_FTBL
    8159/    2F8A : ED4A                	dc.w	LAB_SGN-LAB_FTBL				; SGN()
    8160/    2F8C : EDCE                	dc.w	LAB_INT-LAB_FTBL				; INT()
    8161/    2F8E : ED5C                	dc.w	LAB_ABS-LAB_FTBL				; ABS()
    8162/    2F90 : E968                	dc.w	LAB_USR-LAB_FTBL				; USR()
    8163/    2F92 : E3C2                	dc.w	LAB_FRE-LAB_FTBL				; FRE()
    8164/    2F94 : E3F4                	dc.w	LAB_POS-LAB_FTBL				; POS()
    8165/    2F96 : F938                	dc.w	LAB_SQR-LAB_FTBL				; SQR()
    8166/    2F98 : F21C                	dc.w	LAB_RND-LAB_FTBL				; RND()
    8167/    2F9A : EA6C                	dc.w	LAB_LOG-LAB_FTBL				; LOG()
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 141 - 10/11/2023 21:18:52


    8168/    2F9C : F102                	dc.w	LAB_EXP-LAB_FTBL				; EXP()
    8169/    2F9E : F270                	dc.w	LAB_COS-LAB_FTBL				; COS()
    8170/    2FA0 : F288                	dc.w	LAB_SIN-LAB_FTBL				; SIN()
    8171/    2FA2 : F24E                	dc.w	LAB_TAN-LAB_FTBL				; TAN()
    8172/    2FA4 : F34E                	dc.w	LAB_ATN-LAB_FTBL				; ATN()
    8173/    2FA6 : E8E4                	dc.w	LAB_PEEK-LAB_FTBL				; PEEK()
    8174/    2FA8 : E8F6                	dc.w	LAB_DEEK-LAB_FTBL				; DEEK()
    8175/    2FAA : E90C                	dc.w	LAB_LEEK-LAB_FTBL				; LEEK()
    8176/    2FAC : E826                	dc.w	LAB_LENS-LAB_FTBL				; LEN()
    8177/    2FAE : E4EA                	dc.w	LAB_STRS-LAB_FTBL				; STR$()
    8178/    2FB0 : E86C                	dc.w	LAB_VAL-LAB_FTBL				; VAL()
    8179/    2FB2 : E82E                	dc.w	LAB_ASC-LAB_FTBL				; ASC()
    8180/    2FB4 : E7DC                	dc.w	LAB_UCASE-LAB_FTBL			; UCASE$()
    8181/    2FB6 : E7AC                	dc.w	LAB_LCASE-LAB_FTBL			; LCASE$()
    8182/    2FB8 : E714                	dc.w	LAB_CHRS-LAB_FTBL				; CHR$()
    8183/    2FBA : F7DA                	dc.w	LAB_HEXS-LAB_FTBL				; HEX$()
    8184/    2FBC : F788                	dc.w	LAB_BINS-LAB_FTBL				; BIN$()
    8185/    2FBE : F422                	dc.w	LAB_BTST-LAB_FTBL				; BITTST()
    8186/    2FC0 : F846                	dc.w	LAB_MAX-LAB_FTBL				; MAX()
    8187/    2FC2 : F85C                	dc.w	LAB_MIN-LAB_FTBL				; MIN()
    8188/    2FC4 : F9AA                	dc.w	LAB_RAM-LAB_FTBL				; RAMBASE
    8189/    2FC6 : F9B4                	dc.w	LAB_PI-LAB_FTBL				; PI
    8190/    2FC8 : F9C4                	dc.w	LAB_TWOPI-LAB_FTBL			; TWOPI
    8191/    2FCA : F99A                	dc.w	LAB_VARPTR-LAB_FTBL			; VARPTR()
    8192/    2FCC : E80E                	dc.w	LAB_SADD-LAB_FTBL				; SADD()
    8193/    2FCE : E724                	dc.w	LAB_LEFT-LAB_FTBL				; LEFT$()
    8194/    2FD0 : E738                	dc.w	LAB_RIGHT-LAB_FTBL			; RIGHT$()
    8195/    2FD2 : E768                	dc.w	LAB_MIDS-LAB_FTBL				; MID$()
    8196/    2FD4 : F450                	dc.w	LAB_USINGS-LAB_FTBL			; USING$()
    8197/    2FD6 :                     
    8198/    2FD6 :                     
    8199/    2FD6 :                     ;************************************************************************************
    8200/    2FD6 :                     ;
    8201/    2FD6 :                     ; hierarchy and action addresses for operator
    8202/    2FD6 :                     
    8203/    2FD6 :                     LAB_OPPT
    8204/    2FD6 : 0079                	dc.w	$0079						; +
    8205/    2FD8 : E96E                	dc.w	LAB_ADD-LAB_OPPT
    8206/    2FDA : 0079                	dc.w	$0079						; -
    8207/    2FDC : E95A                	dc.w	LAB_SUBTRACT-LAB_OPPT
    8208/    2FDE : 007B                	dc.w	$007B						; *
    8209/    2FE0 : EB12                	dc.w	LAB_MULTIPLY-LAB_OPPT
    8210/    2FE2 : 007B                	dc.w	$007B						; /
    8211/    2FE4 : EB9E                	dc.w	LAB_DIVIDE-LAB_OPPT
    8212/    2FE6 : 007F                	dc.w	$007F						; ^
    8213/    2FE8 : F000                	dc.w	LAB_POWER-LAB_OPPT
    8214/    2FEA : 0050                	dc.w	$0050						; AND
    8215/    2FEC : DFA6                	dc.w	LAB_AND-LAB_OPPT
    8216/    2FEE : 0046                	dc.w	$0046						; EOR
    8217/    2FF0 : DF96                	dc.w	LAB_EOR-LAB_OPPT
    8218/    2FF2 : 0046                	dc.w	$0046						; OR
    8219/    2FF4 : DF9E                	dc.w	LAB_OR-LAB_OPPT
    8220/    2FF6 : 0056                	dc.w	$0056						; >>
    8221/    2FF8 : E04A                	dc.w	LAB_RSHIFT-LAB_OPPT
    8222/    2FFA : 0056                	dc.w	$0056						; <<
    8223/    2FFC : E03A                	dc.w	LAB_LSHIFT-LAB_OPPT
    8224/    2FFE : 007D                	dc.w	$007D						; >
    8225/    3000 : F064                	dc.w	LAB_GTHAN-LAB_OPPT			; used to evaluate -n
    8226/    3002 : 005A                	dc.w	$005A						; =
    8227/    3004 : DFBC                	dc.w	LAB_EQUAL-LAB_OPPT			; used to evaluate NOT
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 142 - 10/11/2023 21:18:52


    8228/    3006 : 0064                	dc.w	$0064						; <
    8229/    3008 : DFC6                	dc.w	LAB_LTHAN-LAB_OPPT
    8230/    300A :                     
    8231/    300A :                     
    8232/    300A :                     ;************************************************************************************
    8233/    300A :                     ;
    8234/    300A :                     ; misc constants
    8235/    300A :                     
    8236/    300A :                     ; This table is used in converting numbers to ASCII.
    8237/    300A :                     ; first four entries for expansion to 9.25 digits
    8238/    300A :                     
    8239/    300A :                     LAB_2A9A
    8240/    300A : FFF0 BDC0           	dc.l	$FFF0BDC0					; -1000000
    8241/    300E : 0001 86A0           	dc.l	$000186A0					; 100000
    8242/    3012 : FFFF D8F0           	dc.l	$FFFFD8F0					; -10000
    8243/    3016 : 0000 03E8           	dc.l	$000003E8					; 1000
    8244/    301A : FFFF FF9C           	dc.l	$FFFFFF9C					; -100
    8245/    301E : 0000 000A           	dc.l	$0000000A					; 10
    8246/    3022 : FFFF FFFF           	dc.l	$FFFFFFFF					; -1
    8247/    3026 :                     LAB_2A9B
    8248/    3026 :                     
    8249/    3026 :                     
    8250/    3026 :                     ;************************************************************************************
    8251/    3026 :                     ;
    8252/    3026 :                     ; new keyword tables
    8253/    3026 :                     
    8254/    3026 :                     ; offsets to keyword tables
    8255/    3026 :                     
    8256/    3026 :                     TAB_CHRT
    8257/    3026 : 0000                	dc.w	TAB_STAR-TAB_STAR				; "*"	$2A
    8258/    3028 : 0002                	dc.w	TAB_PLUS-TAB_STAR				; "+"	$2B
    8259/    302A : FFFF                	dc.w	-1						; "," $2C no keywords
    8260/    302C : 0004                	dc.w	TAB_MNUS-TAB_STAR				; "-"	$2D
    8261/    302E : FFFF                	dc.w	-1						; "." $2E no keywords
    8262/    3030 : 0006                	dc.w	TAB_SLAS-TAB_STAR				; "/"	$2F
    8263/    3032 : FFFF                	dc.w	-1						; "0" $30 no keywords
    8264/    3034 : FFFF                	dc.w	-1						; "1" $31 no keywords
    8265/    3036 : FFFF                	dc.w	-1						; "2" $32 no keywords
    8266/    3038 : FFFF                	dc.w	-1						; "3" $33 no keywords
    8267/    303A : FFFF                	dc.w	-1						; "4" $34 no keywords
    8268/    303C : FFFF                	dc.w	-1						; "5" $35 no keywords
    8269/    303E : FFFF                	dc.w	-1						; "6" $36 no keywords
    8270/    3040 : FFFF                	dc.w	-1						; "7" $37 no keywords
    8271/    3042 : FFFF                	dc.w	-1						; "8" $38 no keywords
    8272/    3044 : FFFF                	dc.w	-1						; "9" $39 no keywords
    8273/    3046 : FFFF                	dc.w	-1						; ";" $3A no keywords
    8274/    3048 : FFFF                	dc.w	-1						; ":" $3B no keywords
    8275/    304A : 0008                	dc.w	TAB_LESS-TAB_STAR				; "<"	$3C
    8276/    304C : 000C                	dc.w	TAB_EQUL-TAB_STAR				; "="	$3D
    8277/    304E : 000E                	dc.w	TAB_MORE-TAB_STAR				; ">"	$3E
    8278/    3050 : 0012                	dc.w	TAB_QEST-TAB_STAR				; "?"	$3F
    8279/    3052 : FFFF                	dc.w	-1						; "@" $40 no keywords
    8280/    3054 : 0014                	dc.w	TAB_ASCA-TAB_STAR				; "A"	$41
    8281/    3056 : 0024                	dc.w	TAB_ASCB-TAB_STAR				; "B"	$42
    8282/    3058 : 003D                	dc.w	TAB_ASCC-TAB_STAR				; "C"	$43
    8283/    305A : 0054                	dc.w	TAB_ASCD-TAB_STAR				; "D"	$44
    8284/    305C : 006D                	dc.w	TAB_ASCE-TAB_STAR				; "E"	$45
    8285/    305E : 007C                	dc.w	TAB_ASCF-TAB_STAR				; "F"	$46
    8286/    3060 : 0086                	dc.w	TAB_ASCG-TAB_STAR				; "G"	$47
    8287/    3062 : 0093                	dc.w	TAB_ASCH-TAB_STAR				; "H"	$48
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 143 - 10/11/2023 21:18:52


    8288/    3064 : 0099                	dc.w	TAB_ASCI-TAB_STAR				; "I"	$49
    8289/    3066 : FFFF                	dc.w	-1						; "J" $4A no keywords
    8290/    3068 : FFFF                	dc.w	-1						; "K" $4B no keywords
    8291/    306A : 00A8                	dc.w	TAB_ASCL-TAB_STAR				; "L"	$4C
    8292/    306C : 00D6                	dc.w	TAB_ASCM-TAB_STAR				; "M"	$4D
    8293/    306E : 00E4                	dc.w	TAB_ASCN-TAB_STAR				; "N"	$4E
    8294/    3070 : 00F3                	dc.w	TAB_ASCO-TAB_STAR				; "O"	$4F
    8295/    3072 : 00F8                	dc.w	TAB_ASCP-TAB_STAR				; "P"	$50
    8296/    3074 : FFFF                	dc.w	-1						; "Q" $51 no keywords
    8297/    3076 : 010D                	dc.w	TAB_ASCR-TAB_STAR				; "R"	$52
    8298/    3078 : 0137                	dc.w	TAB_ASCS-TAB_STAR				; "S"	$53
    8299/    307A : 0162                	dc.w	TAB_ASCT-TAB_STAR				; "T"	$54
    8300/    307C : 0176                	dc.w	TAB_ASCU-TAB_STAR				; "U"	$55
    8301/    307E : 018E                	dc.w	TAB_ASCV-TAB_STAR				; "V"	$56
    8302/    3080 : 019A                	dc.w	TAB_ASCW-TAB_STAR				; "W"	$57
    8303/    3082 : FFFF                	dc.w	-1						; "X" $58 no keywords
    8304/    3084 : FFFF                	dc.w	-1						; "Y" $59 no keywords
    8305/    3086 : FFFF                	dc.w	-1						; "Z" $5A no keywords
    8306/    3088 : FFFF                	dc.w	-1						; "[" $5B no keywords
    8307/    308A : FFFF                	dc.w	-1						; "\" $5C no keywords
    8308/    308C : FFFF                	dc.w	-1						; "]" $5D no keywords
    8309/    308E : 01A9                	dc.w	TAB_POWR-TAB_STAR				; "^"	$5E
    8310/    3090 :                     
    8311/    3090 :                     
    8312/    3090 :                     ;************************************************************************************
    8313/    3090 :                     ;
    8314/    3090 :                     ; Table of Basic keywords for LIST command
    8315/    3090 :                     ; [byte]first character,[byte]remaining length -1
    8316/    3090 :                     ; [word]offset from table start
    8317/    3090 :                     
    8318/    3090 :                     LAB_KEYT
    8319/    3090 : 4501                	dc.b	'E',1
    8320/    3092 : 0071                	dc.w	KEY_END-TAB_STAR				; END
    8321/    3094 : 4601                	dc.b	'F',1
    8322/    3096 : 007C                	dc.w	KEY_FOR-TAB_STAR				; FOR
    8323/    3098 : 4E02                	dc.b	'N',2
    8324/    309A : 00E7                	dc.w	KEY_NEXT-TAB_STAR				; NEXT
    8325/    309C : 4402                	dc.b	'D',2
    8326/    309E : 0054                	dc.w	KEY_DATA-TAB_STAR				; DATA
    8327/    30A0 : 4903                	dc.b	'I',3
    8328/    30A2 : 009E                	dc.w	KEY_INPUT-TAB_STAR			; INPUT
    8329/    30A4 : 4401                	dc.b	'D',1
    8330/    30A6 : 0063                	dc.w	KEY_DIM-TAB_STAR				; DIM
    8331/    30A8 : 5202                	dc.b	'R',2
    8332/    30AA : 0114                	dc.w	KEY_READ-TAB_STAR				; READ
    8333/    30AC : 4C01                	dc.b	'L',1
    8334/    30AE : 00BE                	dc.w	KEY_LET-TAB_STAR				; LET
    8335/    30B0 : 4401                	dc.b	'D',1
    8336/    30B2 : 0058                	dc.w	KEY_DEC-TAB_STAR				; DEC
    8337/    30B4 : 4702                	dc.b	'G',2
    8338/    30B6 : 0089                	dc.w	KEY_GOTO-TAB_STAR				; GOTO
    8339/    30B8 : 5201                	dc.b	'R',1
    8340/    30BA : 0133                	dc.w	KEY_RUN-TAB_STAR				; RUN
    8341/    30BC : 4900                	dc.b	'I',0
    8342/    30BE : 0099                	dc.w	KEY_IF-TAB_STAR				; IF
    8343/    30C0 : 5205                	dc.b	'R',5
    8344/    30C2 : 011B                	dc.w	KEY_RESTORE-TAB_STAR			; RESTORE
    8345/    30C4 : 4703                	dc.b	'G',3
    8346/    30C6 : 008D                	dc.w	KEY_GOSUB-TAB_STAR			; GOSUB
    8347/    30C8 : 5204                	dc.b	'R',4
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 144 - 10/11/2023 21:18:52


    8348/    30CA : 0122                	dc.w	KEY_RETURN-TAB_STAR			; RETURN
    8349/    30CC : 5201                	dc.b	'R',1
    8350/    30CE : 0118                	dc.w	KEY_REM-TAB_STAR				; REM
    8351/    30D0 : 5302                	dc.b	'S',2
    8352/    30D2 : 0154                	dc.w	KEY_STOP-TAB_STAR				; STOP
    8353/    30D4 : 4F00                	dc.b	'O',0
    8354/    30D6 : 00F3                	dc.w	KEY_ON-TAB_STAR				; ON
    8355/    30D8 : 4E02                	dc.b	'N',2
    8356/    30DA : 00EE                	dc.w	KEY_NULL-TAB_STAR				; NULL
    8357/    30DC : 4901                	dc.b	'I',1
    8358/    30DE : 009B                	dc.w	KEY_INC-TAB_STAR				; INC
    8359/    30E0 : 5702                	dc.b	'W',2
    8360/    30E2 : 019A                	dc.w	KEY_WAIT-TAB_STAR				; WAIT
    8361/    30E4 : 4C02                	dc.b	'L',2
    8362/    30E6 : 00C5                	dc.w	KEY_LOAD-TAB_STAR				; LOAD
    8363/    30E8 : 5302                	dc.b	'S',2
    8364/    30EA : 013C                	dc.w	KEY_SAVE-TAB_STAR				; SAVE
    8365/    30EC : 4401                	dc.b	'D',1
    8366/    30EE : 0060                	dc.w	KEY_DEF-TAB_STAR				; DEF
    8367/    30F0 : 5002                	dc.b	'P',2
    8368/    30F2 : 00FF                	dc.w	KEY_POKE-TAB_STAR				; POKE
    8369/    30F4 : 4402                	dc.b	'D',2
    8370/    30F6 : 0066                	dc.w	KEY_DOKE-TAB_STAR				; DOKE
    8371/    30F8 : 4C02                	dc.b	'L',2
    8372/    30FA : 00CD                	dc.w	KEY_LOKE-TAB_STAR				; LOKE
    8373/    30FC : 4302                	dc.b	'C',2
    8374/    30FE : 003D                	dc.w	KEY_CALL-TAB_STAR				; CALL
    8375/    3100 : 4400                	dc.b	'D',0
    8376/    3102 : 006A                	dc.w	KEY_DO-TAB_STAR				; DO
    8377/    3104 : 4C02                	dc.b	'L',2
    8378/    3106 : 00D1                	dc.w	KEY_LOOP-TAB_STAR				; LOOP
    8379/    3108 : 5003                	dc.b	'P',3
    8380/    310A : 0107                	dc.w	KEY_PRINT-TAB_STAR			; PRINT
    8381/    310C : 4302                	dc.b	'C',2
    8382/    310E : 004B                	dc.w	KEY_CONT-TAB_STAR				; CONT
    8383/    3110 : 4C02                	dc.b	'L',2
    8384/    3112 : 00C1                	dc.w	KEY_LIST-TAB_STAR				; LIST
    8385/    3114 : 4303                	dc.b	'C',3
    8386/    3116 : 0046                	dc.w	KEY_CLEAR-TAB_STAR			; CLEAR
    8387/    3118 : 4E01                	dc.b	'N',1
    8388/    311A : 00E4                	dc.w	KEY_NEW-TAB_STAR				; NEW
    8389/    311C : 5703                	dc.b	'W',3
    8390/    311E : 01A3                	dc.w	KEY_WIDTH-TAB_STAR			; WIDTH
    8391/    3120 : 4701                	dc.b	'G',1
    8392/    3122 : 0086                	dc.w	KEY_GET-TAB_STAR				; GET
    8393/    3124 : 5302                	dc.b	'S',2
    8394/    3126 : 015D                	dc.w	KEY_SWAP-TAB_STAR				; SWAP
    8395/    3128 : 4204                	dc.b	'B',4
    8396/    312A : 002F                	dc.w	KEY_BITSET-TAB_STAR			; BITSET
    8397/    312C : 4204                	dc.b	'B',4
    8398/    312E : 0029                	dc.w	KEY_BITCLR-TAB_STAR			; BITCLR
    8399/    3130 : 5402                	dc.b	'T',2
    8400/    3132 : 0162                	dc.w	KEY_TAB-TAB_STAR				; TAB(
    8401/    3134 : 4502                	dc.b	'E',2
    8402/    3136 : 006D                	dc.w	KEY_ELSE-TAB_STAR				; ELSE
    8403/    3138 : 5400                	dc.b	'T',0
    8404/    313A : 016E                	dc.w	KEY_TO-TAB_STAR				; TO
    8405/    313C : 4600                	dc.b	'F',0
    8406/    313E : 007F                	dc.w	KEY_FN-TAB_STAR				; FN
    8407/    3140 : 5302                	dc.b	'S',2
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 145 - 10/11/2023 21:18:52


    8408/    3142 : 0148                	dc.w	KEY_SPC-TAB_STAR				; SPC(
    8409/    3144 : 5402                	dc.b	'T',2
    8410/    3146 : 016A                	dc.w	KEY_THEN-TAB_STAR				; THEN
    8411/    3148 : 4E01                	dc.b	'N',1
    8412/    314A : 00EB                	dc.w	KEY_NOT-TAB_STAR				; NOT
    8413/    314C : 5302                	dc.b	'S',2
    8414/    314E : 0150                	dc.w	KEY_STEP-TAB_STAR				; STEP
    8415/    3150 : 5503                	dc.b	'U',3
    8416/    3152 : 017D                	dc.w	KEY_UNTIL-TAB_STAR			; UNTIL
    8417/    3154 : 5703                	dc.b	'W',3
    8418/    3156 : 019E                	dc.w	KEY_WHILE-TAB_STAR			; WHILE
    8419/    3158 :                     
    8420/    3158 : 2BFF                	dc.b	'+',-1
    8421/    315A : 0002                	dc.w	KEY_PLUS-TAB_STAR				; +
    8422/    315C : 2DFF                	dc.b	'-',-1
    8423/    315E : 0004                	dc.w	KEY_MINUS-TAB_STAR			; -
    8424/    3160 : 2AFF                	dc.b	'*',-1
    8425/    3162 : 0000                	dc.w	KEY_MULT-TAB_STAR				; *
    8426/    3164 : 2FFF                	dc.b	'/',-1
    8427/    3166 : 0006                	dc.w	KEY_DIV-TAB_STAR				; /
    8428/    3168 : 5EFF                	dc.b	'^',-1
    8429/    316A : 01A9                	dc.w	KEY_POWER-TAB_STAR			; ^
    8430/    316C : 4101                	dc.b	'A',1
    8431/    316E : 0018                	dc.w	KEY_AND-TAB_STAR				; AND
    8432/    3170 : 4501                	dc.b	'E',1
    8433/    3172 : 0074                	dc.w	KEY_EOR-TAB_STAR				; EOR
    8434/    3174 : 4F00                	dc.b	'O',0
    8435/    3176 : 00F5                	dc.w	KEY_OR-TAB_STAR				; OR
    8436/    3178 : 3E00                	dc.b	'>',0
    8437/    317A : 000E                	dc.w	KEY_RSHIFT-TAB_STAR			; >>
    8438/    317C : 3C00                	dc.b	'<',0
    8439/    317E : 0008                	dc.w	KEY_LSHIFT-TAB_STAR			; <<
    8440/    3180 : 3EFF                	dc.b	'>',-1
    8441/    3182 : 0010                	dc.w	KEY_GT-TAB_STAR				; >
    8442/    3184 : 3DFF                	dc.b	'=',-1
    8443/    3186 : 000C                	dc.w	KEY_EQUAL-TAB_STAR			; =
    8444/    3188 : 3CFF                	dc.b	'<',-1
    8445/    318A : 000A                	dc.w	KEY_LT-TAB_STAR				; <
    8446/    318C :                     
    8447/    318C : 5302                	dc.b	'S',2
    8448/    318E : 0140                	dc.w	KEY_SGN-TAB_STAR				; SGN(
    8449/    3190 : 4902                	dc.b	'I',2
    8450/    3192 : 00A3                	dc.w	KEY_INT-TAB_STAR				; INT(
    8451/    3194 : 4102                	dc.b	'A',2
    8452/    3196 : 0014                	dc.w	KEY_ABS-TAB_STAR				; ABS(
    8453/    3198 : 5502                	dc.b	'U',2
    8454/    319A : 0189                	dc.w	KEY_USR-TAB_STAR				; USR(
    8455/    319C : 4602                	dc.b	'F',2
    8456/    319E : 0081                	dc.w	KEY_FRE-TAB_STAR				; FRE(
    8457/    31A0 : 5002                	dc.b	'P',2
    8458/    31A2 : 0103                	dc.w	KEY_POS-TAB_STAR				; POS(
    8459/    31A4 : 5302                	dc.b	'S',2
    8460/    31A6 : 014C                	dc.w	KEY_SQR-TAB_STAR				; SQR(
    8461/    31A8 : 5202                	dc.b	'R',2
    8462/    31AA : 012F                	dc.w	KEY_RND-TAB_STAR				; RND(
    8463/    31AC : 4C02                	dc.b	'L',2
    8464/    31AE : 00C9                	dc.w	KEY_LOG-TAB_STAR				; LOG(
    8465/    31B0 : 4502                	dc.b	'E',2
    8466/    31B2 : 0077                	dc.w	KEY_EXP-TAB_STAR				; EXP(
    8467/    31B4 : 4302                	dc.b	'C',2
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 146 - 10/11/2023 21:18:52


    8468/    31B6 : 004F                	dc.w	KEY_COS-TAB_STAR				; COS(
    8469/    31B8 : 5302                	dc.b	'S',2
    8470/    31BA : 0144                	dc.w	KEY_SIN-TAB_STAR				; SIN(
    8471/    31BC : 5402                	dc.b	'T',2
    8472/    31BE : 0166                	dc.w	KEY_TAN-TAB_STAR				; TAN(
    8473/    31C0 : 4102                	dc.b	'A',2
    8474/    31C2 : 001F                	dc.w	KEY_ATN-TAB_STAR				; ATN(
    8475/    31C4 : 5003                	dc.b	'P',3
    8476/    31C6 : 00F8                	dc.w	KEY_PEEK-TAB_STAR				; PEEK(
    8477/    31C8 : 4403                	dc.b	'D',3
    8478/    31CA : 005B                	dc.w	KEY_DEEK-TAB_STAR				; DEEK(
    8479/    31CC : 4C03                	dc.b	'L',3
    8480/    31CE : 00AF                	dc.w	KEY_LEEK-TAB_STAR				; LEEK(
    8481/    31D0 : 4C02                	dc.b	'L',2
    8482/    31D2 : 00BA                	dc.w	KEY_LEN-TAB_STAR				; LEN(
    8483/    31D4 : 5303                	dc.b	'S',3
    8484/    31D6 : 0158                	dc.w	KEY_STRS-TAB_STAR				; STR$(
    8485/    31D8 : 5602                	dc.b	'V',2
    8486/    31DA : 018E                	dc.w	KEY_VAL-TAB_STAR				; VAL(
    8487/    31DC : 4102                	dc.b	'A',2
    8488/    31DE : 001B                	dc.w	KEY_ASC-TAB_STAR				; ASC(
    8489/    31E0 : 5505                	dc.b	'U',5
    8490/    31E2 : 0176                	dc.w	KEY_UCASES-TAB_STAR			; UCASE$(
    8491/    31E4 : 4C05                	dc.b	'L',5
    8492/    31E6 : 00A8                	dc.w	KEY_LCASES-TAB_STAR			; LCASE$(
    8493/    31E8 : 4303                	dc.b	'C',3
    8494/    31EA : 0041                	dc.w	KEY_CHRS-TAB_STAR				; CHR$(
    8495/    31EC : 4803                	dc.b	'H',3
    8496/    31EE : 0093                	dc.w	KEY_HEXS-TAB_STAR				; HEX$(
    8497/    31F0 : 4203                	dc.b	'B',3
    8498/    31F2 : 0024                	dc.w	KEY_BINS-TAB_STAR				; BIN$(
    8499/    31F4 : 4205                	dc.b	'B',5
    8500/    31F6 : 0035                	dc.w	KEY_BITTST-TAB_STAR			; BITTST(
    8501/    31F8 : 4D02                	dc.b	'M',2
    8502/    31FA : 00D6                	dc.w	KEY_MAX-TAB_STAR				; MAX(
    8503/    31FC : 4D02                	dc.b	'M',2
    8504/    31FE : 00DF                	dc.w	KEY_MIN-TAB_STAR				; MIN(
    8505/    3200 : 5205                	dc.b	'R',5
    8506/    3202 : 010D                	dc.w	KEY_RAM-TAB_STAR				; RAMBASE
    8507/    3204 : 5000                	dc.b	'P',0
    8508/    3206 : 00FD                	dc.w	KEY_PI-TAB_STAR				; PI
    8509/    3208 : 5403                	dc.b	'T',3
    8510/    320A : 0170                	dc.w	KEY_TWOPI-TAB_STAR			; TWOPI
    8511/    320C : 5605                	dc.b	'V',5
    8512/    320E : 0192                	dc.w	KEY_VPTR-TAB_STAR				; VARPTR(
    8513/    3210 : 5303                	dc.b	'S',3
    8514/    3212 : 0137                	dc.w	KEY_SADD-TAB_STAR				; SADD(
    8515/    3214 : 4C04                	dc.b	'L',4
    8516/    3216 : 00B4                	dc.w	KEY_LEFTS-TAB_STAR			; LEFT$(
    8517/    3218 : 5205                	dc.b	'R',5
    8518/    321A : 0128                	dc.w	KEY_RIGHTS-TAB_STAR			; RIGHT$(
    8519/    321C : 4D03                	dc.b	'M',3
    8520/    321E : 00DA                	dc.w	KEY_MIDS-TAB_STAR				; MID$(
    8521/    3220 : 5505                	dc.b	'U',5
    8522/    3222 : 0182                	dc.w	KEY_USINGS-TAB_STAR			; USING$(
    8523/    3224 :                     
    8524/    3224 :                     
    8525/    3224 :                     ;************************************************************************************
    8526/    3224 :                     ;
    8527/    3224 :                     ; BASIC error messages
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 147 - 10/11/2023 21:18:52


    8528/    3224 :                     
    8529/    3224 :                     LAB_BAER
    8530/    3224 : 0030                	dc.w	LAB_NF-LAB_BAER				; $00 NEXT without FOR
    8531/    3226 : 0041                	dc.w	LAB_SN-LAB_BAER				; $02 syntax
    8532/    3228 : 0048                	dc.w	LAB_RG-LAB_BAER				; $04 RETURN without GOSUB
    8533/    322A : 005D                	dc.w	LAB_OD-LAB_BAER				; $06 out of data
    8534/    322C : 0069                	dc.w	LAB_FC-LAB_BAER				; $08 function call
    8535/    322E : 0077                	dc.w	LAB_OV-LAB_BAER				; $0A overflow
    8536/    3230 : 0080                	dc.w	LAB_OM-LAB_BAER				; $0C out of memory
    8537/    3232 : 008E                	dc.w	LAB_US-LAB_BAER				; $0E undefined statement
    8538/    3234 : 00A2                	dc.w	LAB_BS-LAB_BAER				; $10 array bounds
    8539/    3236 : 00AF                	dc.w	LAB_DD-LAB_BAER				; $12 double dimension array
    8540/    3238 : 00C0                	dc.w	LAB_D0-LAB_BAER				; $14 divide by 0
    8541/    323A : 00CF                	dc.w	LAB_ID-LAB_BAER				; $16 illegal direct
    8542/    323C : 00DE                	dc.w	LAB_TM-LAB_BAER				; $18 type mismatch
    8543/    323E : 00EC                	dc.w	LAB_LS-LAB_BAER				; $1A long string
    8544/    3240 : 00FC                	dc.w	LAB_ST-LAB_BAER				; $1C string too complex
    8545/    3242 : 010F                	dc.w	LAB_CN-LAB_BAER				; $1E continue error
    8546/    3244 : 011E                	dc.w	LAB_UF-LAB_BAER				; $20 undefined function
    8547/    3246 : 0131                	dc.w	LAB_LD-LAB_BAER				; $22 LOOP without DO
    8548/    3248 : 0141                	dc.w	LAB_UV-LAB_BAER				; $24 undefined variable
    8549/    324A : 0154                	dc.w	LAB_UA-LAB_BAER				; $26 undimensioned array
    8550/    324C : 0168                	dc.w	LAB_WD-LAB_BAER				; $28 wrong dimensions
    8551/    324E : 0179                	dc.w	LAB_AD-LAB_BAER				; $2A address
    8552/    3250 : 0181                	dc.w	LAB_FO-LAB_BAER				; $2C format
    8553/    3252 : 0188                	dc.w	LAB_NI-LAB_BAER				; $2E not implemented
    8554/    3254 :                     
    8555/    3254 : 4E45 5854 2077      LAB_NF	dc.b	'NEXT without FOR',$00
             325A : 6974 686F 7574 
             3260 : 2046 4F52 00       
    8556/    3265 : 5379 6E74 6178 00   LAB_SN	dc.b	'Syntax',$00
    8557/    326C : 5245 5455 524E      LAB_RG	dc.b	'RETURN without GOSUB',$00
             3272 : 2077 6974 686F 
             3278 : 7574 2047 4F53 
             327E : 5542 00          
    8558/    3281 : 4F75 7420 6F66      LAB_OD	dc.b	'Out of DATA',$00
             3287 : 2044 4154 4100    
    8559/    328D : 4675 6E63 7469      LAB_FC	dc.b	'Function call',$00
             3293 : 6F6E 2063 616C 
             3299 : 6C00             
    8560/    329B : 4F76 6572 666C      LAB_OV	dc.b	'Overflow',$00
             32A1 : 6F77 00          
    8561/    32A4 : 4F75 7420 6F66      LAB_OM	dc.b	'Out of memory',$00
             32AA : 206D 656D 6F72 
             32B0 : 7900             
    8562/    32B2 : 556E 6465 6669      LAB_US	dc.b	'Undefined statement',$00
             32B8 : 6E65 6420 7374 
             32BE : 6174 656D 656E 
             32C4 : 7400             
    8563/    32C6 : 4172 7261 7920      LAB_BS	dc.b	'Array bounds',$00
             32CC : 626F 756E 6473 00 
    8564/    32D3 : 446F 7562 6C65      LAB_DD	dc.b	'Double dimension',$00
             32D9 : 2064 696D 656E 
             32DF : 7369 6F6E 00       
    8565/    32E4 : 4469 7669 6465      LAB_D0	dc.b	'Divide by zero',$00
             32EA : 2062 7920 7A65 
             32F0 : 726F 00          
    8566/    32F3 : 496C 6C65 6761      LAB_ID	dc.b	'Illegal direct',$00
             32F9 : 6C20 6469 7265 
             32FF : 6374 00          
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 148 - 10/11/2023 21:18:52


    8567/    3302 : 5479 7065 206D      LAB_TM	dc.b	'Type mismatch',$00
             3308 : 6973 6D61 7463 
             330E : 6800             
    8568/    3310 : 5374 7269 6E67      LAB_LS	dc.b	'String too long',$00
             3316 : 2074 6F6F 206C 
             331C : 6F6E 6700          
    8569/    3320 : 5374 7269 6E67      LAB_ST	dc.b	'String too complex',$00
             3326 : 2074 6F6F 2063 
             332C : 6F6D 706C 6578 00 
    8570/    3333 : 4361 6E27 7420      LAB_CN	dc.b	"Can't continue",$00
             3339 : 636F 6E74 696E 
             333F : 7565 00          
    8571/    3342 : 556E 6465 6669      LAB_UF	dc.b	'Undefined function',$00
             3348 : 6E65 6420 6675 
             334E : 6E63 7469 6F6E 00 
    8572/    3355 : 4C4F 4F50 2077      LAB_LD	dc.b	'LOOP without DO',$00
             335B : 6974 686F 7574 
             3361 : 2044 4F00          
    8573/    3365 : 556E 6465 6669      LAB_UV	dc.b	'Undefined variable',$00
             336B : 6E65 6420 7661 
             3371 : 7269 6162 6C65 00 
    8574/    3378 : 556E 6469 6D65      LAB_UA	dc.b	'Undimensioned array',$00
             337E : 6E73 696F 6E65 
             3384 : 6420 6172 7261 
             338A : 7900             
    8575/    338C : 5772 6F6E 6720      LAB_WD	dc.b	'Wrong dimensions',$00
             3392 : 6469 6D65 6E73 
             3398 : 696F 6E73 00       
    8576/    339D : 4164 6472 6573      LAB_AD	dc.b	'Address',$00
             33A3 : 7300             
    8577/    33A5 : 466F 726D 6174 00   LAB_FO	dc.b	'Format',$00
    8578/    33AC : 4E6F 7420 696D      LAB_NI  dc.b    'Not implemented',$00
             33B2 : 706C 656D 656E 
             33B8 : 7465 6400          
    8579/    33BC :                     
    8580/    33BC :                     
    8581/    33BC :                     ;************************************************************************************
    8582/    33BC :                     ;
    8583/    33BC :                     ; keyword table for line (un)crunching
    8584/    33BC :                     
    8585/    33BC :                     ; [keyword,token
    8586/    33BC :                     ; [keyword,token]]
    8587/    33BC :                     ; end marker (#$00)
    8588/    33BC :                     
    8589/    33BC :                     TAB_STAR
    8590/    33BC :                     KEY_MULT
    8591/    33BC : B400                	dc.b TK_MULT,$00					; *
    8592/    33BE :                     TAB_PLUS
    8593/    33BE :                     KEY_PLUS
    8594/    33BE : B200                	dc.b TK_PLUS,$00					; +
    8595/    33C0 :                     TAB_MNUS
    8596/    33C0 :                     KEY_MINUS
    8597/    33C0 : B300                	dc.b TK_MINUS,$00					; -
    8598/    33C2 :                     TAB_SLAS
    8599/    33C2 :                     KEY_DIV
    8600/    33C2 : B500                	dc.b TK_DIV,$00					; /
    8601/    33C4 :                     TAB_LESS
    8602/    33C4 :                     KEY_LSHIFT
    8603/    33C4 : 3CBB                	dc.b	'<',TK_LSHIFT				; <<
    8604/    33C6 :                     KEY_LT
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 149 - 10/11/2023 21:18:52


    8605/    33C6 : BE                  	dc.b TK_LT						; <
    8606/    33C7 : 00                  	dc.b	$00
    8607/    33C8 :                     TAB_EQUL
    8608/    33C8 :                     KEY_EQUAL
    8609/    33C8 : BD00                	dc.b TK_EQUAL,$00					; =
    8610/    33CA :                     TAB_MORE
    8611/    33CA :                     KEY_RSHIFT
    8612/    33CA : 3EBA                	dc.b	'>',TK_RSHIFT				; >>
    8613/    33CC :                     KEY_GT
    8614/    33CC : BC                  	dc.b TK_GT						; >
    8615/    33CD : 00                  	dc.b	$00
    8616/    33CE :                     TAB_QEST
    8617/    33CE : 9E00                	dc.b TK_PRINT,$00					; ?
    8618/    33D0 :                     TAB_ASCA
    8619/    33D0 :                     KEY_ABS
    8620/    33D0 : 4253 28C1           	dc.b	'BS(',TK_ABS				; ABS(
    8621/    33D4 :                     KEY_AND
    8622/    33D4 : 4E44 B7             	dc.b	'ND',TK_AND					; AND
    8623/    33D7 :                     KEY_ASC
    8624/    33D7 : 5343 28D3           	dc.b	'SC(',TK_ASC				; ASC(
    8625/    33DB :                     KEY_ATN
    8626/    33DB : 544E 28CC           	dc.b	'TN(',TK_ATN				; ATN(
    8627/    33DF : 00                  	dc.b	$00
    8628/    33E0 :                     TAB_ASCB
    8629/    33E0 :                     KEY_BINS
    8630/    33E0 : 494E 2428 D8        	dc.b	'IN$(',TK_BINS				; BIN$(
    8631/    33E5 :                     KEY_BITCLR
    8632/    33E5 : 4954 434C 52A7      	dc.b	'ITCLR',TK_BITCLR				; BITCLR
    8633/    33EB :                     KEY_BITSET
    8634/    33EB : 4954 5345 54A6      	dc.b	'ITSET',TK_BITSET				; BITSET
    8635/    33F1 :                     KEY_BITTST
    8636/    33F1 : 4954 5453 5428 D9   	dc.b	'ITTST(',TK_BITTST			; BITTST(
    8637/    33F8 : 00                  	dc.b	$00
    8638/    33F9 :                     TAB_ASCC
    8639/    33F9 :                     KEY_CALL
    8640/    33F9 : 414C 4C9B           	dc.b	'ALL',TK_CALL				; CALL
    8641/    33FD :                     KEY_CHRS
    8642/    33FD : 4852 2428 D6        	dc.b	'HR$(',TK_CHRS				; CHR$(
    8643/    3402 :                     KEY_CLEAR
    8644/    3402 : 4C45 4152 A1        	dc.b	'LEAR',TK_CLEAR				; CLEAR
    8645/    3407 :                     KEY_CONT
    8646/    3407 : 4F4E 549F           	dc.b	'ONT',TK_CONT				; CONT
    8647/    340B :                     KEY_COS
    8648/    340B : 4F53 28C9           	dc.b	'OS(',TK_COS				; COS(
    8649/    340F : 00                  	dc.b	$00
    8650/    3410 :                     TAB_ASCD
    8651/    3410 :                     KEY_DATA
    8652/    3410 : 4154 4183           	dc.b	'ATA',TK_DATA				; DATA
    8653/    3414 :                     KEY_DEC
    8654/    3414 : 4543 88             	dc.b	'EC',TK_DEC					; DEC
    8655/    3417 :                     KEY_DEEK
    8656/    3417 : 4545 4B28 CE        	dc.b	'EEK(',TK_DEEK				; DEEK(
    8657/    341C :                     KEY_DEF
    8658/    341C : 4546 97             	dc.b	'EF',TK_DEF					; DEF
    8659/    341F :                     KEY_DIM
    8660/    341F : 494D 85             	dc.b	'IM',TK_DIM					; DIM
    8661/    3422 :                     KEY_DOKE
    8662/    3422 : 4F4B 4599           	dc.b	'OKE',TK_DOKE				; DOKE
    8663/    3426 :                     KEY_DO
    8664/    3426 : 4F9C                	dc.b	'O',TK_DO					; DO
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 150 - 10/11/2023 21:18:52


    8665/    3428 : 00                  	dc.b	$00
    8666/    3429 :                     TAB_ASCE
    8667/    3429 :                     KEY_ELSE
    8668/    3429 : 4C53 45A9           	dc.b	'LSE',TK_ELSE				; ELSE
    8669/    342D :                     KEY_END
    8670/    342D : 4E44 80             	dc.b	'ND',TK_END					; END
    8671/    3430 :                     KEY_EOR
    8672/    3430 : 4F52 B8             	dc.b	'OR',TK_EOR					; EOR
    8673/    3433 :                     KEY_EXP
    8674/    3433 : 5850 28C8           	dc.b	'XP(',TK_EXP				; EXP(
    8675/    3437 : 00                  	dc.b	$00
    8676/    3438 :                     TAB_ASCF
    8677/    3438 :                     KEY_FOR
    8678/    3438 : 4F52 81             	dc.b	'OR',TK_FOR					; FOR
    8679/    343B :                     KEY_FN
    8680/    343B : 4EAB                	dc.b	'N',TK_FN					; FN
    8681/    343D :                     KEY_FRE
    8682/    343D : 5245 28C3           	dc.b	'RE(',TK_FRE				; FRE(
    8683/    3441 : 00                  	dc.b	$00
    8684/    3442 :                     TAB_ASCG
    8685/    3442 :                     KEY_GET
    8686/    3442 : 4554 A4             	dc.b	'ET',TK_GET					; GET
    8687/    3445 :                     KEY_GOTO
    8688/    3445 : 4F54 4F89           	dc.b	'OTO',TK_GOTO				; GOTO
    8689/    3449 :                     KEY_GOSUB
    8690/    3449 : 4F53 5542 8D        	dc.b	'OSUB',TK_GOSUB				; GOSUB
    8691/    344E : 00                  	dc.b	$00
    8692/    344F :                     TAB_ASCH
    8693/    344F :                     KEY_HEXS
    8694/    344F : 4558 2428 D700      	dc.b	'EX$(',TK_HEXS,$00			; HEX$(
    8695/    3455 :                     TAB_ASCI
    8696/    3455 :                     KEY_IF
    8697/    3455 : 468B                	dc.b	'F',TK_IF					; IF
    8698/    3457 :                     KEY_INC
    8699/    3457 : 4E43 93             	dc.b	'NC',TK_INC					; INC
    8700/    345A :                     KEY_INPUT
    8701/    345A : 4E50 5554 84        	dc.b	'NPUT',TK_INPUT				; INPUT
    8702/    345F :                     KEY_INT
    8703/    345F : 4E54 28C0           	dc.b	'NT(',TK_INT				; INT(
    8704/    3463 : 00                  	dc.b	$00
    8705/    3464 :                     TAB_ASCL
    8706/    3464 :                     KEY_LCASES
    8707/    3464 : 4341 5345 2428 D5   	dc.b	'CASE$(',TK_LCASES			; LCASE$(
    8708/    346B :                     KEY_LEEK
    8709/    346B : 4545 4B28 CF        	dc.b	'EEK(',TK_LEEK				; LEEK(
    8710/    3470 :                     KEY_LEFTS
    8711/    3470 : 4546 5424 28E1      	dc.b	'EFT$(',TK_LEFTS				; LEFT$(
    8712/    3476 :                     KEY_LEN
    8713/    3476 : 454E 28D0           	dc.b	'EN(',TK_LEN				; LEN(
    8714/    347A :                     KEY_LET
    8715/    347A : 4554 87             	dc.b	'ET',TK_LET					; LET
    8716/    347D :                     KEY_LIST
    8717/    347D : 4953 54A0           	dc.b	'IST',TK_LIST				; LIST
    8718/    3481 :                     KEY_LOAD
    8719/    3481 : 4F41 4495           	dc.b	'OAD',TK_LOAD				; LOAD
    8720/    3485 :                     KEY_LOG
    8721/    3485 : 4F47 28C7           	dc.b	'OG(',TK_LOG				; LOG(
    8722/    3489 :                     KEY_LOKE
    8723/    3489 : 4F4B 459A           	dc.b	'OKE',TK_LOKE				; LOKE
    8724/    348D :                     KEY_LOOP
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 151 - 10/11/2023 21:18:52


    8725/    348D : 4F4F 509D           	dc.b	'OOP',TK_LOOP				; LOOP
    8726/    3491 : 00                  	dc.b	$00
    8727/    3492 :                     TAB_ASCM
    8728/    3492 :                     KEY_MAX
    8729/    3492 : 4158 28DA           	dc.b	'AX(',TK_MAX				; MAX(
    8730/    3496 :                     KEY_MIDS
    8731/    3496 : 4944 2428 E3        	dc.b	'ID$(',TK_MIDS				; MID$(
    8732/    349B :                     KEY_MIN
    8733/    349B : 494E 28DB           	dc.b	'IN(',TK_MIN				; MIN(
    8734/    349F : 00                  	dc.b	$00
    8735/    34A0 :                     TAB_ASCN
    8736/    34A0 :                     KEY_NEW
    8737/    34A0 : 4557 A2             	dc.b	'EW',TK_NEW					; NEW
    8738/    34A3 :                     KEY_NEXT
    8739/    34A3 : 4558 5482           	dc.b	'EXT',TK_NEXT				; NEXT
    8740/    34A7 :                     KEY_NOT
    8741/    34A7 : 4F54 AE             	dc.b	'OT',TK_NOT					; NOT
    8742/    34AA :                     KEY_NULL
    8743/    34AA : 554C 4C92           	dc.b	'ULL',TK_NULL				; NULL
    8744/    34AE : 00                  	dc.b	$00
    8745/    34AF :                     TAB_ASCO
    8746/    34AF :                     KEY_ON
    8747/    34AF : 4E91                	dc.b	'N',TK_ON					; ON
    8748/    34B1 :                     KEY_OR
    8749/    34B1 : 52B9                	dc.b	'R',TK_OR					; OR
    8750/    34B3 : 00                  	dc.b	$00
    8751/    34B4 :                     TAB_ASCP
    8752/    34B4 :                     KEY_PEEK
    8753/    34B4 : 4545 4B28 CD        	dc.b	'EEK(',TK_PEEK				; PEEK(
    8754/    34B9 :                     KEY_PI
    8755/    34B9 : 49DD                	dc.b	'I',TK_PI					; PI
    8756/    34BB :                     KEY_POKE
    8757/    34BB : 4F4B 4598           	dc.b	'OKE',TK_POKE				; POKE
    8758/    34BF :                     KEY_POS
    8759/    34BF : 4F53 28C4           	dc.b	'OS(',TK_POS				; POS(
    8760/    34C3 :                     KEY_PRINT
    8761/    34C3 : 5249 4E54 9E        	dc.b	'RINT',TK_PRINT				; PRINT
    8762/    34C8 : 00                  	dc.b	$00
    8763/    34C9 :                     TAB_ASCR
    8764/    34C9 :                     KEY_RAM
    8765/    34C9 : 414D 4241 5345 DC   	dc.b	'AMBASE',TK_RAM				; RAMBASE
    8766/    34D0 :                     KEY_READ
    8767/    34D0 : 4541 4486           	dc.b	'EAD',TK_READ				; READ
    8768/    34D4 :                     KEY_REM
    8769/    34D4 : 454D 8F             	dc.b	'EM',TK_REM					; REM
    8770/    34D7 :                     KEY_RESTORE
    8771/    34D7 : 4553 544F 5245 8C   	dc.b	'ESTORE',TK_RESTORE			; RESTORE
    8772/    34DE :                     KEY_RETURN
    8773/    34DE : 4554 5552 4E8E      	dc.b	'ETURN',TK_RETURN				; RETURN
    8774/    34E4 :                     KEY_RIGHTS
    8775/    34E4 : 4947 4854 2428 E2   	dc.b	'IGHT$(',TK_RIGHTS			; RIGHT$(
    8776/    34EB :                     KEY_RND
    8777/    34EB : 4E44 28C6           	dc.b	'ND(',TK_RND				; RND(
    8778/    34EF :                     KEY_RUN
    8779/    34EF : 554E 8A             	dc.b	'UN',TK_RUN					; RUN
    8780/    34F2 : 00                  	dc.b	$00
    8781/    34F3 :                     TAB_ASCS
    8782/    34F3 :                     KEY_SADD
    8783/    34F3 : 4144 4428 E0        	dc.b	'ADD(',TK_SADD				; SADD(
    8784/    34F8 :                     KEY_SAVE
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 152 - 10/11/2023 21:18:52


    8785/    34F8 : 4156 4596           	dc.b	'AVE',TK_SAVE				; SAVE
    8786/    34FC :                     KEY_SGN
    8787/    34FC : 474E 28BF           	dc.b	'GN(',TK_SGN				; SGN(
    8788/    3500 :                     KEY_SIN
    8789/    3500 : 494E 28CA           	dc.b	'IN(',TK_SIN				; SIN(
    8790/    3504 :                     KEY_SPC
    8791/    3504 : 5043 28AC           	dc.b	'PC(',TK_SPC				; SPC(
    8792/    3508 :                     KEY_SQR
    8793/    3508 : 5152 28C5           	dc.b	'QR(',TK_SQR				; SQR(
    8794/    350C :                     KEY_STEP
    8795/    350C : 5445 50AF           	dc.b	'TEP',TK_STEP				; STEP
    8796/    3510 :                     KEY_STOP
    8797/    3510 : 544F 5090           	dc.b	'TOP',TK_STOP				; STOP
    8798/    3514 :                     KEY_STRS
    8799/    3514 : 5452 2428 D1        	dc.b	'TR$(',TK_STRS				; STR$(
    8800/    3519 :                     KEY_SWAP
    8801/    3519 : 5741 50A5           	dc.b	'WAP',TK_SWAP				; SWAP
    8802/    351D : 00                  	dc.b	$00
    8803/    351E :                     TAB_ASCT
    8804/    351E :                     KEY_TAB
    8805/    351E : 4142 28A8           	dc.b	'AB(',TK_TAB				; TAB(
    8806/    3522 :                     KEY_TAN
    8807/    3522 : 414E 28CB           	dc.b	'AN(',TK_TAN				; TAN
    8808/    3526 :                     KEY_THEN
    8809/    3526 : 4845 4EAD           	dc.b	'HEN',TK_THEN				; THEN
    8810/    352A :                     KEY_TO
    8811/    352A : 4FAA                	dc.b	'O',TK_TO					; TO
    8812/    352C :                     KEY_TWOPI
    8813/    352C : 574F 5049 DE        	dc.b	'WOPI',TK_TWOPI				; TWOPI
    8814/    3531 : 00                  	dc.b	$00
    8815/    3532 :                     TAB_ASCU
    8816/    3532 :                     KEY_UCASES
    8817/    3532 : 4341 5345 2428 D4   	dc.b	'CASE$(',TK_UCASES			; UCASE$(
    8818/    3539 :                     KEY_UNTIL
    8819/    3539 : 4E54 494C B0        	dc.b	'NTIL',TK_UNTIL				; UNTIL
    8820/    353E :                     KEY_USINGS
    8821/    353E : 5349 4E47 2428 E4   	dc.b	'SING$(',TK_USINGS			; USING$(
    8822/    3545 :                     KEY_USR
    8823/    3545 : 5352 28C2           	dc.b	'SR(',TK_USR				; USR(
    8824/    3549 : 00                  	dc.b	$00
    8825/    354A :                     TAB_ASCV
    8826/    354A :                     KEY_VAL
    8827/    354A : 414C 28D2           	dc.b	'AL(',TK_VAL				; VAL(
    8828/    354E :                     KEY_VPTR
    8829/    354E : 4152 5054 5228 DF   	dc.b	'ARPTR(',TK_VPTR				; VARPTR(
    8830/    3555 : 00                  	dc.b	$00
    8831/    3556 :                     TAB_ASCW
    8832/    3556 :                     KEY_WAIT
    8833/    3556 : 4149 5494           	dc.b	'AIT',TK_WAIT				; WAIT
    8834/    355A :                     KEY_WHILE
    8835/    355A : 4849 4C45 B1        	dc.b	'HILE',TK_WHILE				; WHILE
    8836/    355F :                     KEY_WIDTH
    8837/    355F : 4944 5448 A3        	dc.b	'IDTH',TK_WIDTH				; WIDTH
    8838/    3564 : 00                  	dc.b	$00
    8839/    3565 :                     TAB_POWR
    8840/    3565 :                     KEY_POWER
    8841/    3565 : B600                	dc.b	TK_POWER,$00				; ^
    8842/    3567 :                     
    8843/    3567 :                     
    8844/    3567 :                     ;************************************************************************************
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 153 - 10/11/2023 21:18:52


    8845/    3567 :                     ;
    8846/    3567 :                     ; just messages
    8847/    3567 :                     
    8848/    3567 :                     LAB_BMSG
    8849/    3567 : 0D0A 4272 6561      	dc.b	$0D,$0A,'Break',$00
             356D : 6B00             
    8850/    356F :                     LAB_EMSG
    8851/    356F : 2045 7272 6F72 00   	dc.b	' Error',$00
    8852/    3576 :                     LAB_LMSG
    8853/    3576 : 2069 6E20 6C69      	dc.b	' in line ',$00
             357C : 6E65 2000          
    8854/    3580 :                     LAB_IMSG
    8855/    3580 : 4578 7472 6120      	dc.b	'Extra ignored',$0D,$0A,$00
             3586 : 6967 6E6F 7265 
             358C : 640D 0A00          
    8856/    3590 :                     LAB_REDO
    8857/    3590 : 5265 646F 2066      	dc.b	'Redo from start',$0D,$0A,$00
             3596 : 726F 6D20 7374 
             359C : 6172 740D 0A00    
    8858/    35A2 :                     LAB_RMSG
    8859/    35A2 : 0D0A 5265 6164      	dc.b	$0D,$0A,'Ready',$0D,$0A,$00
             35A8 : 790D 0A00          
    8860/    35AC :                     LAB_SMSG
    8861/    35AC : 2042 7974 6573      	dc.b	' Bytes free',$0D,$0A,$0A
             35B2 : 2066 7265 650D 
             35B8 : 0A0A             
    8862/    35BA : 456E 6861 6E63      	dc.b	'Enhanced 68k BASIC Version 3.54',$0D,$0A,$00
             35C0 : 6564 2036 386B 
             35C6 : 2042 4153 4943 
             35CC : 2056 6572 7369 
             35D2 : 6F6E 2033 2E35 
             35D8 : 340D 0A00          
    8863/    35DC :                     
    8864/    35DC :                     
    8865/    35DC :                     ;************************************************************************************
    8866/    35DC :                     ;
    8867/    35DC :                     ; This lot is in RAM
    8868/    35DC :                     
    8869/    35DC :                     ;    		ORG     ram_addr	; start of RAM
    8870/    35DC :                     ; 
    8871/    35DC :                     ;ram_strt	ds.l	$100		; allow 1K for the stack, this should be plenty
    8872/    35DC :                     ;								; for any BASIC program that doesn't do something
    8873/    35DC :                     ;								; silly, it could even be much less.
    8874/    35DC :                     ;ram_base
    8875/    35DC :                     ;LAB_WARM	ds.w	1			; BASIC warm start entry point
    8876/    35DC :                     ;Wrmjpv		ds.l	1			; BASIC warm start jump vector
    8877/    35DC :                     ;
    8878/    35DC :                     ;Usrjmp		ds.w	1			; USR function JMP address
    8879/    35DC :                     ;Usrjpv		ds.l	1			; USR function JMP vector
    8880/    35DC :                     ;
    8881/    35DC :                     ;; system dependant i/o vectors
    8882/    35DC :                     ;; these are in RAM and are set at start-up
    8883/    35DC :                     ;
    8884/    35DC :                     ;V_INPT		ds.w	1			; non halting scan input device entry point
    8885/    35DC :                     ;V_INPTv		ds.l	1			; non halting scan input device jump vector
    8886/    35DC :                     ;
    8887/    35DC :                     ;V_OUTP		ds.w	1			; send byte to output device entry point
    8888/    35DC :                     ;V_OUTPv		ds.l	1			; send byte to output device jump vector
    8889/    35DC :                     ;
    8890/    35DC :                     ;V_LOAD		ds.w	1			; load BASIC program entry point
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 154 - 10/11/2023 21:18:52


    8891/    35DC :                     ;V_LOADv		ds.l	1			; load BASIC program jump vector
    8892/    35DC :                     ;
    8893/    35DC :                     ;V_SAVE		ds.w	1			; save BASIC program entry point
    8894/    35DC :                     ;V_SAVEv		ds.l	1			; save BASIC program jump vector
    8895/    35DC :                     ;
    8896/    35DC :                     ;V_CTLC		ds.w	1			; save CTRL-C check entry point
    8897/    35DC :                     ;V_CTLCv		ds.l	1			; save CTRL-C check jump vector
    8898/    35DC :                     ;
    8899/    35DC :                     ;Itemp		ds.l	1			; temporary integer	(for GOTO etc)
    8900/    35DC :                     ;
    8901/    35DC :                     ;Smeml		ds.l	1			; start of memory		(start of program)
    8902/    35DC :                     ;
    8903/    35DC :                     ;; the program is stored as a series of lines each line having the following format
    8904/    35DC :                     ;;
    8905/    35DC :                     ;;		ds.l	1			; pointer to the next line or $00000000 if [EOT]
    8906/    35DC :                     ;;		ds.l	1			; line number
    8907/    35DC :                     ;;		ds.b	n			; program bytes
    8908/    35DC :                     ;;		dc.b	$00			; [EOL] marker, there will be a second $00 byte, if
    8909/    35DC :                     ;;						; needed, to pad the line to an even number of bytes
    8910/    35DC :                     ;
    8911/    35DC :                     ;Sfncl		ds.l	1			; start of functions	(end of Program)
    8912/    35DC :                     ;
    8913/    35DC :                     ;; the functions are stored as function name, function execute pointer and function
    8914/    35DC :                     ;; variable name
    8915/    35DC :                     ;;
    8916/    35DC :                     ;;		ds.l	1			; name
    8917/    35DC :                     ;;		ds.l	1			; execute pointer
    8918/    35DC :                     ;;		ds.l	1			; function variable
    8919/    35DC :                     ;
    8920/    35DC :                     ;Svarl		ds.l	1			; start of variables	(end of functions)
    8921/    35DC :                     ;
    8922/    35DC :                     ;; the variables are stored as variable name, variable value
    8923/    35DC :                     ;;
    8924/    35DC :                     ;;		ds.l	1			; name
    8925/    35DC :                     ;;		ds.l	1			; packed float or integer value
    8926/    35DC :                     ;
    8927/    35DC :                     ;Sstrl		ds.l	1			; start of strings	(end of variables)
    8928/    35DC :                     ;
    8929/    35DC :                     ;; the strings are stored as string name, string pointer and string length
    8930/    35DC :                     ;;
    8931/    35DC :                     ;;		ds.l	1			; name
    8932/    35DC :                     ;;		ds.l	1			; string pointer
    8933/    35DC :                     ;;		ds.w	1			; string length
    8934/    35DC :                     ;
    8935/    35DC :                     ;Sarryl		ds.l	1			; start of arrays		(end of strings)
    8936/    35DC :                     ;
    8937/    35DC :                     ;; the arrays are stored as array name, array size, array dimensions count, array
    8938/    35DC :                     ;; dimensions upper bounds and array elements
    8939/    35DC :                     ;;
    8940/    35DC :                     ;;		ds.l	1			; name
    8941/    35DC :                     ;;		ds.l	1			; size including this header
    8942/    35DC :                     ;;		ds.w	1			; dimensions count
    8943/    35DC :                     ;;		ds.w	1			; 1st dimension upper bound
    8944/    35DC :                     ;;		ds.w	1			; 2nd dimension upper bound
    8945/    35DC :                     ;;		...				; ...
    8946/    35DC :                     ;;		ds.w	1			; nth dimension upper bound
    8947/    35DC :                     ;;
    8948/    35DC :                     ;; then (i1+1)*(i2+1)...*(in+1) of either ..
    8949/    35DC :                     ;;
    8950/    35DC :                     ;;		ds.l	1			; packed float or integer value
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 155 - 10/11/2023 21:18:52


    8951/    35DC :                     ;;
    8952/    35DC :                     ;; .. if float or integer, or ..
    8953/    35DC :                     ;;
    8954/    35DC :                     ;;		ds.l	1			; string pointer
    8955/    35DC :                     ;;		ds.w	1			; string length
    8956/    35DC :                     ;;
    8957/    35DC :                     ;; .. if string
    8958/    35DC :                     ;
    8959/    35DC :                     ;Earryl		ds.l	1			; end of arrays		(start of free mem)
    8960/    35DC :                     ;Sstorl		ds.l	1			; string storage		(moving down)
    8961/    35DC :                     ;Ememl		ds.l	1			; end of memory		(upper bound of RAM)
    8962/    35DC :                     ;Sutill		ds.l	1			; string utility ptr
    8963/    35DC :                     ;Clinel		ds.l	1			; current line		(Basic line number)
    8964/    35DC :                     ;Blinel		ds.l	1			; break line		(Basic line number)
    8965/    35DC :                     ;
    8966/    35DC :                     ;Cpntrl		ds.l	1			; continue pointer
    8967/    35DC :                     ;Dlinel		ds.l	1			; current DATA line
    8968/    35DC :                     ;Dptrl		ds.l	1			; DATA pointer
    8969/    35DC :                     ;Rdptrl		ds.l	1			; read pointer
    8970/    35DC :                     ;Varname		ds.l	1			; current var name
    8971/    35DC :                     ;Cvaral		ds.l	1			; current var address
    8972/    35DC :                     ;Lvarpl		ds.l	1			; variable pointer for LET and FOR/NEXT
    8973/    35DC :                     ;
    8974/    35DC :                     ;des_sk_e	ds.l	6			; descriptor stack end address
    8975/    35DC :                     ;des_sk							; descriptor stack start address
    8976/    35DC :                     ;								; use a4 for the descriptor pointer
    8977/    35DC :                     ;			ds.w	1			
    8978/    35DC :                     ;Ibuffs		ds.l	$40			; start of input buffer
    8979/    35DC :                     ;Ibuffe
    8980/    35DC :                     ;								; end of input buffer
    8981/    35DC :                     ;
    8982/    35DC :                     ;FAC1_m		ds.l	1			; FAC1 mantissa1
    8983/    35DC :                     ;FAC1_e		ds.w	1			; FAC1 exponent
    8984/    35DC :                     ;FAC1_s		EQU	FAC1_e+1		; FAC1 sign (b7)
    8985/    35DC :                     ;			ds.w	1			
    8986/    35DC :                     ;
    8987/    35DC :                     ;FAC2_m		ds.l	1			; FAC2 mantissa1
    8988/    35DC :                     ;FAC2_e		ds.l	1			; FAC2 exponent
    8989/    35DC :                     ;FAC2_s		EQU	FAC2_e+1		; FAC2 sign (b7)
    8990/    35DC :                     ;FAC_sc		EQU	FAC2_e+2		; FAC sign comparison, Acc#1 vs #2
    8991/    35DC :                     ;flag		EQU	FAC2_e+3		; flag byte for divide routine
    8992/    35DC :                     ;
    8993/    35DC :                     ;PRNlword	ds.l	1			; PRNG seed long word
    8994/    35DC :                     ;
    8995/    35DC :                     ;ut1_pl		ds.l	1			; utility pointer 1
    8996/    35DC :                     ;
    8997/    35DC :                     ;Asptl		ds.l	1			; array size/pointer
    8998/    35DC :                     ;Astrtl		ds.l	1			; array start pointer
    8999/    35DC :                     ;
    9000/    35DC :                     ;numexp		EQU	Astrtl			; string to float number exponent count
    9001/    35DC :                     ;expcnt		EQU	Astrtl+1		; string to float exponent count
    9002/    35DC :                     ;
    9003/    35DC :                     ;expneg		EQU	Astrtl+3		; string to float eval exponent -ve flag
    9004/    35DC :                     ;
    9005/    35DC :                     ;func_l		ds.l	1			; function pointer
    9006/    35DC :                     ;
    9007/    35DC :                     ;
    9008/    35DC :                     ;								; these two need to be a word aligned pair !
    9009/    35DC :                     ;Defdim		ds.w	1			; default DIM flag
    9010/    35DC :                     ;cosout		EQU	Defdim			; flag which CORDIC output (re-use byte)
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 156 - 10/11/2023 21:18:52


    9011/    35DC :                     ;Dtypef		EQU	Defdim+1		; data type flag, $80=string, $40=integer, $00=float
    9012/    35DC :                     ;
    9013/    35DC :                     ;
    9014/    35DC :                     ;Binss		ds.l	4			; number to bin string start (32 chrs)
    9015/    35DC :                     ;
    9016/    35DC :                     ;Decss		ds.l	1			; number to decimal string start (16 chrs)
    9017/    35DC :                     ;			ds.w	1
    9018/    35DC :                     ;Usdss		ds.w	1			; unsigned decimal string start (10 chrs)
    9019/    35DC :                     ;
    9020/    35DC :                     ;Hexss		ds.l	2			; number to hex string start (8 chrs)
    9021/    35DC :                     ;
    9022/    35DC :                     ;BHsend		ds.w	1			; bin/decimal/hex string end
    9023/    35DC :                     ;
    9024/    35DC :                     ;
    9025/    35DC :                     ;prstk		ds.b	1			; stacked function index
    9026/    35DC :                     ;
    9027/    35DC :                     ;tpower		ds.b	1			; remember CORDIC power
    9028/    35DC :                     ;
    9029/    35DC :                     ;Asrch		ds.b	1			; scan-between-quotes flag, alt search character
    9030/    35DC :                     ;
    9031/    35DC :                     ;Dimcnt		ds.b	1			; # of dimensions
    9032/    35DC :                     ;
    9033/    35DC :                     ;Breakf		ds.b	1			; break flag, $00=END else=break
    9034/    35DC :                     ;Oquote		ds.b	1			; open quote flag (Flag: DATA; LIST; memory)
    9035/    35DC :                     ;Gclctd		ds.b	1			; garbage collected flag
    9036/    35DC :                     ;Sufnxf		ds.b	1			; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
    9037/    35DC :                     ;Imode		ds.b	1			; input mode flag, $00=INPUT, $98=READ
    9038/    35DC :                     ;
    9039/    35DC :                     ;Cflag		ds.b	1			; comparison evaluation flag
    9040/    35DC :                     ;
    9041/    35DC :                     ;TabSiz		ds.b	1			; TAB step size
    9042/    35DC :                     ;
    9043/    35DC :                     ;comp_f		ds.b	1			; compare function flag, bits 0,1 and 2 used
    9044/    35DC :                     ;								; bit 2 set if >
    9045/    35DC :                     ;								; bit 1 set if =
    9046/    35DC :                     ;								; bit 0 set if <
    9047/    35DC :                     ;
    9048/    35DC :                     ;Nullct		ds.b	1			; nulls output after each line
    9049/    35DC :                     ;TPos		ds.b	1			; BASIC terminal position byte
    9050/    35DC :                     ;TWidth		ds.b	1			; BASIC terminal width byte
    9051/    35DC :                     ;Iclim		ds.b	1			; input column limit
    9052/    35DC :                     ;ccflag		ds.b	1			; CTRL-C check flag
    9053/    35DC :                     ;ccbyte		ds.b	1			; CTRL-C last received byte
    9054/    35DC :                     ;ccnull		ds.b	1			; CTRL-C last received byte 'life' timer
    9055/    35DC :                     ;
    9056/    35DC :                     ;
    9057/    35DC :                     ;prg_strt
    9058/    35DC :                     
    9059/    35DC :                     ;************************************************************************************
    9060/    35DC :                     ; EhBASIC keywords quick reference list												*
    9061/    35DC :                     ;************************************************************************************
    9062/    35DC :                     
    9063/    35DC :                     ; glossary
    9064/    35DC :                     
    9065/    35DC :                     ;		<.>		  required
    9066/    35DC :                     ;		{.|.}		  one of required
    9067/    35DC :                     ;		[.]		  optional
    9068/    35DC :                     ;		...		  may repeat as last
    9069/    35DC :                     
    9070/    35DC :                     ;		any		= anything
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 157 - 10/11/2023 21:18:52


    9071/    35DC :                     ;		num		= number
    9072/    35DC :                     ;		state		= statement
    9073/    35DC :                     ;		n		= positive integer
    9074/    35DC :                     ;		str		= string
    9075/    35DC :                     ;		var		= variable
    9076/    35DC :                     ;		nvar		= numeric variable
    9077/    35DC :                     ;		svar		= string variable
    9078/    35DC :                     ;		expr		= expression
    9079/    35DC :                     ;		nexpr		= numeric expression
    9080/    35DC :                     ;		sexpr		= string expression
    9081/    35DC :                     
    9082/    35DC :                     ; statement separator
    9083/    35DC :                     
    9084/    35DC :                     ; :			. [<state>] : [<state>]							; done
    9085/    35DC :                     
    9086/    35DC :                     ; number bases
    9087/    35DC :                     
    9088/    35DC :                     ; %			. %<binary num>								; done
    9089/    35DC :                     ; $			. $<hex num>								; done
    9090/    35DC :                     
    9091/    35DC :                     ; commands
    9092/    35DC :                     
    9093/    35DC :                     ; END		. END										; done
    9094/    35DC :                     ; FOR		. FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]	; done
    9095/    35DC :                     ; NEXT		. NEXT [<nvar>[,<nvar>]...]						; done
    9096/    35DC :                     ; DATA		. DATA [{num|["]str["]}[,{num|["]str["]}]...]	; done
    9097/    35DC :                     ; INPUT		. INPUT [<">str<">;] <var>[,<var>[,<var>]...]	; done
    9098/    35DC :                     ; DIM		. DIM <var>(<nexpr>[,<nexpr>[,<nexpr>]])		; done
    9099/    35DC :                     ; READ		. READ <var>[,<var>[,<var>]...]				; done
    9100/    35DC :                     ; LET		. [LET] <var>=<expr>						; done
    9101/    35DC :                     ; DEC		. DEC <nvar>[,<nvar>[,<nvar>]...]			; done
    9102/    35DC :                     ; GOTO		. GOTO <n>									; done
    9103/    35DC :                     ; RUN		. RUN [<n>]									; done
    9104/    35DC :                     ; IF		. IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]	; done
    9105/    35DC :                     ; RESTORE	. RESTORE [<n>]								; done
    9106/    35DC :                     ; GOSUB		. GOSUB <n>									; done
    9107/    35DC :                     ; RETURN	. RETURN									; done
    9108/    35DC :                     ; REM		. REM [<any>]								; done
    9109/    35DC :                     ; STOP		. STOP										; done
    9110/    35DC :                     ; ON		. ON <nexpr>{GOTO|GOSUB}<n>[,<n>[,<n>]...]	; done
    9111/    35DC :                     ; NULL		. NULL <nexpr>								; done
    9112/    35DC :                     ; INC		. INC <nvar>[,<nvar>[,<nvar>]...]			; done
    9113/    35DC :                     ; WAIT		. WAIT <nexpr>,<nexpr>[,<nexpr>]			; done
    9114/    35DC :                     ; LOAD		. LOAD [<sexpr>]							; done for sim
    9115/    35DC :                     ; SAVE		. SAVE [<sexpr>][,[<n>][-<n>]]				; done for sim
    9116/    35DC :                     ; DEF		. DEF FN<var>(<var>)=<expr>					; done
    9117/    35DC :                     ; POKE		. POKE <nexpr>,<nexpr>						; done
    9118/    35DC :                     ; DOKE		. DOKE <nexpr>,<nexpr>						; done
    9119/    35DC :                     ; LOKE		. LOKE <nexpr>,<nexpr>						; done
    9120/    35DC :                     ; CALL		. CALL <nexpr>								; done
    9121/    35DC :                     ; DO		. DO										; done
    9122/    35DC :                     ; LOOP		. LOOP [{WHILE|UNTIL}<nexpr>]				; done
    9123/    35DC :                     ; PRINT		. PRINT [{;|,}][<expr>][{;|,}[<expr>]...]	; done
    9124/    35DC :                     ; CONT		. CONT										; done
    9125/    35DC :                     ; LIST		. LIST [<n>][-<n>]							; done
    9126/    35DC :                     ; CLEAR		. CLEAR										; done
    9127/    35DC :                     ; NEW		. NEW										; done
    9128/    35DC :                     ; WIDTH		. WIDTH [<n>][,<n>]							; done
    9129/    35DC :                     ; GET		. GET <var>									; done
    9130/    35DC :                     ; SWAP		. SWAP <var>,<var>							; done
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 158 - 10/11/2023 21:18:52


    9131/    35DC :                     ; BITSET	. BITSET <nexpr>,<nexpr>					; done
    9132/    35DC :                     ; BITCLR	. BITCLR <nexpr>,<nexpr>					; done
    9133/    35DC :                     
    9134/    35DC :                     ; sub commands (may not start a statement)
    9135/    35DC :                     
    9136/    35DC :                     ; TAB		. TAB(<nexpr>)								; done
    9137/    35DC :                     ; ELSE		. IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]	; done
    9138/    35DC :                     ; TO		. FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]			; done
    9139/    35DC :                     ; FN		. FN <var>(<expr>)							; done
    9140/    35DC :                     ; SPC		. SPC(<nexpr>)								; done
    9141/    35DC :                     ; THEN		. IF <nexpr> {THEN <{n|comm}>|GOTO <n>}		; done
    9142/    35DC :                     ; NOT		. NOT <nexpr>								; done
    9143/    35DC :                     ; STEP		. FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]			; done
    9144/    35DC :                     ; UNTIL		. LOOP [{WHILE|UNTIL}<nexpr>]				; done
    9145/    35DC :                     ; WHILE		. LOOP [{WHILE|UNTIL}<nexpr>]				; done
    9146/    35DC :                     
    9147/    35DC :                     ; operators
    9148/    35DC :                     
    9149/    35DC :                     ; +			. [expr] + <expr>							; done
    9150/    35DC :                     ; -			. [nexpr] - <nexpr>							; done
    9151/    35DC :                     ; *			. <nexpr>	; <nexpr>						; done fast hardware
    9152/    35DC :                     ; /			. <nexpr> / <nexpr>							; done fast hardware
    9153/    35DC :                     ; ^			. <nexpr> ^ <nexpr>							; done
    9154/    35DC :                     ; AND		. <nexpr> AND <nexpr>						; done
    9155/    35DC :                     ; EOR		. <nexpr> EOR <nexpr>						; done
    9156/    35DC :                     ; OR		. <nexpr> OR <nexpr>						; done
    9157/    35DC :                     ; >>		. <nexpr> >> <nexpr>						; done
    9158/    35DC :                     ; <<		. <nexpr> << <nexpr>						; done
    9159/    35DC :                     
    9160/    35DC :                     ; compare functions
    9161/    35DC :                     
    9162/    35DC :                     ; <			. <expr> < <expr>							; done
    9163/    35DC :                     ; =			. <expr> = <expr>							; done
    9164/    35DC :                     ; >			. <expr> > <expr>							; done
    9165/    35DC :                     
    9166/    35DC :                     ; functions
    9167/    35DC :                     
    9168/    35DC :                     ; SGN		. SGN(<nexpr>)								; done
    9169/    35DC :                     ; INT		. INT(<nexpr>)								; done
    9170/    35DC :                     ; ABS		. ABS(<nexpr>)								; done
    9171/    35DC :                     ; USR		. USR(<expr>)								; done
    9172/    35DC :                     ; FRE		. FRE(<expr>)								; done
    9173/    35DC :                     ; POS		. POS(<expr>)								; done
    9174/    35DC :                     ; SQR		. SQR(<nexpr>)								; done fast shift/sub
    9175/    35DC :                     ; RND		. RND(<nexpr>)								; done 32 bit PRNG
    9176/    35DC :                     ; LOG		. LOG(<nexpr>)								; done fast cordic
    9177/    35DC :                     ; EXP		. EXP(<nexpr>)								; done fast cordic
    9178/    35DC :                     ; COS		. COS(<nexpr>)								; done fast cordic
    9179/    35DC :                     ; SIN		. SIN(<nexpr>)								; done fast cordic
    9180/    35DC :                     ; TAN		. TAN(<nexpr>)								; done fast cordic
    9181/    35DC :                     ; ATN		. ATN(<nexpr>)								; done fast cordic
    9182/    35DC :                     ; PEEK		. PEEK(<nexpr>)								; done
    9183/    35DC :                     ; DEEK		. DEEK(<nexpr>)								; done
    9184/    35DC :                     ; LEEK		. LEEK(<nexpr>)								; done
    9185/    35DC :                     ; LEN		. LEN(<sexpr>)								; done
    9186/    35DC :                     ; STR$		. STR$(<nexpr>)								; done
    9187/    35DC :                     ; VAL		. VAL(<sexpr>)								; done
    9188/    35DC :                     ; ASC		. ASC(<sexpr>)								; done
    9189/    35DC :                     ; UCASE$	. UCASE$(<sexpr>)							; done
    9190/    35DC :                     ; LCASE$	. LCASE$(<sexpr>)							; done
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 159 - 10/11/2023 21:18:52


    9191/    35DC :                     ; CHR$		. CHR$(<nexpr>)								; done
    9192/    35DC :                     ; HEX$		. HEX$(<nexpr>)								; done
    9193/    35DC :                     ; BIN$		. BIN$(<nexpr>)								; done
    9194/    35DC :                     ; BTST		. BTST(<nexpr>,<nexpr>)						; done
    9195/    35DC :                     ; MAX		. MAX(<nexpr>[,<nexpr>[,<nexpr>]...])		; done
    9196/    35DC :                     ; MIN		. MIN(<nexpr>[,<nexpr>[,<nexpr>]...])		; done
    9197/    35DC :                     ; PI		. PI										; done
    9198/    35DC :                     ; TWOPI		. TWOPI										; done
    9199/    35DC :                     ; VARPTR	. VARPTR(<var>)								; done
    9200/    35DC :                     ; SADD		. SADD(<svar>)								; done
    9201/    35DC :                     ; LEFT$		. LEFT$(<sexpr>,<nexpr>)					; done
    9202/    35DC :                     ; RIGHT$	. RIGHT$(<sexpr>,<nexpr>)					; done
    9203/    35DC :                     ; MID$		. MID$(<sexpr>,<nexpr>[,<nexpr>])			; done
    9204/    35DC :                     ; USING$	. USING$(<sexpr>,<nexpr>[,<nexpr>]...])		; done
    9205/    35DC :                     
    9206/    35DC :                     
    9207/    35DC :                     ;************************************************************************************
    9208/    35DC :                     
    9209/    35DC :                     	END	code_start
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 160 - 10/11/2023 21:18:52


  Symbol Table (* = unused):
  --------------------------

 AC1GTAC2 :                    1BAC C |  ACIAC :                       E001 - |
 ACIAD :                       E000 - |
*ARCHITECTURE :                                        "i386-unknown-win32" - |
 ASPTL :                        5A8 C |  ASRCH :                        5DA C |
 ASTRTL :                       5AC C |  BHSEND :                       5D6 C |
 BIN2DEC :                     2B70 C |  BINPR :                       2756 C |
 BINSS :                        5B6 C |  BLINEL :                       456 C |
 BREAKF :                       5DC C | *CASESENSITIVE :                  0 - |
 CCBYTE :                       5E9 C |  CCFLAG :                       5E8 C |
 CCNULL :                       5EA C |  CFLAG :                        5E1 C |
 CLINEL :                       452 C |  CO0 :                           C2 C |
 CODE_START :                   106 C |  COMP_F :                       5E3 C |
*CONSTPI :        3.141592653589793 - |  COSOUT :                       5B4 - |
 CPNTRL :                       45A C | *CVARAL :                       46E C |
 D1X02 :                       2B4A C |  D1X10 :                       2B60 C |
 D1X16 :                       2B3C C | *DATE :                "10/11/2023" - |
 DECSS :                        5C6 C |  DEFDIM :                       5B4 C |
 DES_SK :                       48E C |  DES_SK_E :                     476 C |
 DIMCNT :                       5DB C |  DLINEL :                       45E C |
 DOCMP :                        7AC C |  DOREST :                       798 C |
 DPTRL :                        462 C |  DTYPEF :                       5B5 - |
 EARRYL :                       442 C |  EMEML :                        44A C |
 ENDBHS :                      2730 C |  EXPCNT :                       5AD - |
 EXPNEG :                       5AF - |  FAC1_E :                       594 C |
 FAC1_M :                       590 C |  FAC1_S :                       595 - |
 FAC2_E :                       59C C |  FAC2_M :                       598 C |
 FAC2_S :                       59D - |  FAC_SC :                       59E - |
*FALSE :                          0 - |  FEND :                           8 - |
 FLAG :                         59F - | *FLASH_SUPPORT :                  0 - |
 FSD :                            0 - |  FSDC :                           A - |
 FSDPI :                          8 - |  FSLI :                           6 - |
 FSTI :                           4 - | *FULLPMMU :                       1 - |
 FUNC_L :                       5B0 C |  GCLCTD :                       5DE C |
 GETFIRST :                     F84 C |  GETPAIR :                     1040 C |
 GOPR :                        2760 C | *HAS64 :                          0 - |
*HASFPU :                         0 - | *HASPMMU :                        0 - |
 HEXSS :                        5CE C |  IBUFFE :                       590 C |
 IBUFFS :                       490 C |  ICLIM :                        5E7 C |
 IMODE :                        5E0 C |  INGET :                       27B4 C |
*INIVEC :                         0 C | *INSUPMODE :                      1 - |
 ITEMP :                        42A C |  KEY_ABS :                     33D0 C |
 KEY_AND :                     33D4 C |  KEY_ASC :                     33D7 C |
 KEY_ATN :                     33DB C |  KEY_BINS :                    33E0 C |
 KEY_BITCLR :                  33E5 C |  KEY_BITSET :                  33EB C |
 KEY_BITTST :                  33F1 C |  KEY_CALL :                    33F9 C |
 KEY_CHRS :                    33FD C |  KEY_CLEAR :                   3402 C |
 KEY_CONT :                    3407 C |  KEY_COS :                     340B C |
 KEY_DATA :                    3410 C |  KEY_DEC :                     3414 C |
 KEY_DEEK :                    3417 C |  KEY_DEF :                     341C C |
 KEY_DIM :                     341F C |  KEY_DIV :                     33C2 C |
 KEY_DO :                      3426 C |  KEY_DOKE :                    3422 C |
 KEY_ELSE :                    3429 C |  KEY_END :                     342D C |
 KEY_EOR :                     3430 C |  KEY_EQUAL :                   33C8 C |
 KEY_EXP :                     3433 C |  KEY_FN :                      343B C |
 KEY_FOR :                     3438 C |  KEY_FRE :                     343D C |
 KEY_GET :                     3442 C |  KEY_GOSUB :                   3449 C |
 KEY_GOTO :                    3445 C |  KEY_GT :                      33CC C |
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 161 - 10/11/2023 21:18:52


 KEY_HEXS :                    344F C |  KEY_IF :                      3455 C |
 KEY_INC :                     3457 C |  KEY_INPUT :                   345A C |
 KEY_INT :                     345F C |  KEY_LCASES :                  3464 C |
 KEY_LEEK :                    346B C |  KEY_LEFTS :                   3470 C |
 KEY_LEN :                     3476 C |  KEY_LET :                     347A C |
 KEY_LIST :                    347D C |  KEY_LOAD :                    3481 C |
 KEY_LOG :                     3485 C |  KEY_LOKE :                    3489 C |
 KEY_LOOP :                    348D C |  KEY_LSHIFT :                  33C4 C |
 KEY_LT :                      33C6 C |  KEY_MAX :                     3492 C |
 KEY_MIDS :                    3496 C |  KEY_MIN :                     349B C |
 KEY_MINUS :                   33C0 C |  KEY_MULT :                    33BC C |
 KEY_NEW :                     34A0 C |  KEY_NEXT :                    34A3 C |
 KEY_NOT :                     34A7 C |  KEY_NULL :                    34AA C |
 KEY_ON :                      34AF C |  KEY_OR :                      34B1 C |
 KEY_PEEK :                    34B4 C |  KEY_PI :                      34B9 C |
 KEY_PLUS :                    33BE C |  KEY_POKE :                    34BB C |
 KEY_POS :                     34BF C |  KEY_POWER :                   3565 C |
 KEY_PRINT :                   34C3 C |  KEY_RAM :                     34C9 C |
 KEY_READ :                    34D0 C |  KEY_REM :                     34D4 C |
 KEY_RESTORE :                 34D7 C |  KEY_RETURN :                  34DE C |
 KEY_RIGHTS :                  34E4 C |  KEY_RND :                     34EB C |
 KEY_RSHIFT :                  33CA C |  KEY_RUN :                     34EF C |
 KEY_SADD :                    34F3 C |  KEY_SAVE :                    34F8 C |
 KEY_SGN :                     34FC C |  KEY_SIN :                     3500 C |
 KEY_SPC :                     3504 C |  KEY_SQR :                     3508 C |
 KEY_STEP :                    350C C |  KEY_STOP :                    3510 C |
 KEY_STRS :                    3514 C |  KEY_SWAP :                    3519 C |
 KEY_TAB :                     351E C |  KEY_TAN :                     3522 C |
 KEY_THEN :                    3526 C |  KEY_TO :                      352A C |
 KEY_TWOPI :                   352C C |  KEY_UCASES :                  3532 C |
 KEY_UNTIL :                   3539 C |  KEY_USINGS :                  353E C |
 KEY_USR :                     3545 C |  KEY_VAL :                     354A C |
 KEY_VPTR :                    354E C |  KEY_WAIT :                    3556 C |
 KEY_WHILE :                   355A C |  KEY_WIDTH :                   355F C |
 KFCTSEED :                26A3D110 - |  LAB_11A5 :                     C52 C |
 LAB_11A6 :                     C54 C |  LAB_11BD :                     C60 C |
 LAB_1269 :                     23C C |  LAB_1274 :                     24A C |
 LAB_127D :                     252 C |  LAB_127E :                     260 C |
 LAB_1295 :                     274 C |  LAB_12AE :                     296 C |
 LAB_12B0 :                     298 C |  LAB_12E6 :                     2B8 C |
 LAB_12FF :                     2EA C |  LAB_1301 :                     2EC C |
 LAB_1303 :                     30A C |  LAB_1325 :                     322 C |
 LAB_132E :                     312 C |  LAB_1330 :                     314 C |
 LAB_134B :                     330 C |  LAB_1357 :                     34E C |
 LAB_1359 :                     354 C |  LAB_1374 :                     374 C |
 LAB_1378 :                     37A C |  LAB_137F :                     386 C |
 LAB_138E :                     38C C |  LAB_1392 :                     390 C |
 LAB_13A6 :                     3C4 C |  LAB_13AC :                     3CC C |
 LAB_13C6 :                     3F6 C |  LAB_13CC :                     3FC C |
 LAB_13D6 :                     41E C |  LAB_13D8 :                     424 C |
 LAB_13EA :                     430 C |  LAB_13EC :                     432 C |
 LAB_13FF :                     44A C |  LAB_1401 :                     44E C |
 LAB_1408 :                     45A C |  LAB_1410 :                     466 C |
 LAB_1417 :                     470 C |  LAB_141B :                     472 C |
 LAB_141F :                     482 C |  LAB_142A :                     488 C |
 LAB_142C :                     494 C |  LAB_145E :                     4AE C |
 LAB_145F :                     4A0 C |  LAB_1463 :                     4B6 C |
 LAB_1477 :                     4C2 C |  LAB_147A :                     4C8 C |
*LAB_1480 :                     4E2 C |  LAB_1491 :                     4EC C |
 LAB_14BD :                     51E C |  LAB_14C0 :                     522 C |
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 162 - 10/11/2023 21:18:52


 LAB_14D4 :                     542 C | *LAB_14E2 :                     55E C |
 LAB_150C :                     56C C |  LAB_1519 :                     57C C |
 LAB_152E :                     588 C |  LAB_1540 :                     5B4 C |
 LAB_15B3 :                     614 C |  LAB_15C2 :                     63E C |
 LAB_15D1 :                     64A C |  LAB_15DC :                     626 C |
 LAB_15F6 :                     638 C |  LAB_15FF :                     658 C |
 LAB_1602 :                     65C C |  LAB_1624 :                     6E0 C |
 LAB_1629 :                     680 C |  LAB_1636 :                     684 C |
 LAB_1639 :                     68A C |  LAB_163B :                     696 C |
 LAB_1647 :                     6A2 C |  LAB_164F :                     6A8 C |
 LAB_16B0 :                     740 C |  LAB_16D0 :                     764 C |
 LAB_1723 :                     7FE C |  LAB_1725 :                     802 C |
 LAB_172C :                     7EE C |  LAB_172D :                     7F6 C |
 LAB_174B :                     82A C |  LAB_174E :                     84E C |
 LAB_1750 :                     85A C |  LAB_1752 :                     866 C |
 LAB_1754 :                     87E C | *LAB_1756 :                     86A C |
 LAB_176C :                     89C C |  LAB_1773 :                     8A6 C |
 LAB_1785 :                     8C2 C |  LAB_1786 :                     8EE C |
 LAB_17B7 :                     904 C |  LAB_17B8 :                     900 C |
 LAB_17D5 :                     980 C |  LAB_17D6 :                     984 C |
*LAB_1810 :                     996 C |  LAB_1811 :                     9A6 C |
 LAB_1813 :                     9AC C |  LAB_1829 :                     9E4 C |
 LAB_182C :                     9E8 C |  LAB_1831 :                     9EE C |
 LAB_185E :                     A2E C |  LAB_1866 :                     A32 C |
 LAB_1880 :                     AF4 C |  LAB_1886 :                     AFE C |
 LAB_188A :                     B02 C |  LAB_188B :                     A40 C |
 LAB_1898 :                     A4E C |  LAB_18A2 :                     A58 C |
 LAB_18B7 :                     A7A C |  LAB_18B8 :                     A86 C |
 LAB_18BD :                     A8C C |  LAB_18C3 :                     A96 C |
 LAB_18C6 :                     A9A C |  LAB_18CD :                     AA4 C |
 LAB_18E3 :                     AAE C |  LAB_18F0 :                     ACE C |
 LAB_18F7 :                     ADC C |  LAB_18F9 :                     AE0 C |
 LAB_1904 :                     B06 C |  LAB_1913 :                     B18 C |
 LAB_1934 :                     B3E C |  LAB_1953 :                     B52 C |
 LAB_195B :                     B5A C | *LAB_1961 :                     B64 C |
 LAB_1984 :                     B84 C |  LAB_1985 :                     B88 C |
 LAB_1986 :                     B8C C |  LAB_1999 :                     BA0 C |
 LAB_19B0 :                     BB2 C |  LAB_19B6 :                     BC2 C |
 LAB_19C2 :                     BD2 C |  LAB_19DD :                     BE6 C |
 LAB_19F6 :                     C06 C |  LAB_1A03 :                     C14 C |
 LAB_1A0E :                     C24 C |  LAB_1A1B :                     C2A C |
 LAB_1A46 :                     C44 C |  LAB_1A90 :                     CC2 C |
 LAB_1A9B :                     CD0 C |  LAB_1ABA :                     CFA C |
 LAB_1ACD :                     D26 C |  LAB_1ADB :                     D32 C |
 LAB_1ADE :                     D36 C |  LAB_1AE0 :                     D4C C |
 LAB_1AFA :                     D66 C |  LAB_1B0B :                     D7C C |
 LAB_1B13 :                     D84 C |  LAB_1B1C :                     D94 C |
 LAB_1B1D :                     D96 C |  LAB_1B2A :                     DA8 C |
 LAB_1B3C :                     DC4 C |  LAB_1B43 :                     D0A C |
 LAB_1B78 :                     DD0 C |  LAB_1B7B :                     DD4 C |
 LAB_1B7D :                     DD6 C |  LAB_1B84 :                     DE0 C |
 LAB_1B86 :                     DE4 C |  LAB_1B9D :                     E08 C |
 LAB_1BC1 :                     E38 C |  LAB_1BD0 :                     EA8 C |
 LAB_1BE7 :                     EC2 C |  LAB_1BF3 :                     E44 C |
 LAB_1BF7 :                     E4A C |  LAB_1BFB :                     E4E C |
 LAB_1C01 :                     E56 C |  LAB_1C11 :                     E80 C |
 LAB_1C13 :                     E86 C |  LAB_1C18 :                     E8E C |
 LAB_1C19 :                     E92 C |  LAB_1C1A :                     EA2 C |
 LAB_1C2A :                     F00 C |  LAB_1CAE :                     FA8 C |
 LAB_1CB5 :                     FC6 C |  LAB_1CD4 :                     FD0 C |
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 163 - 10/11/2023 21:18:52


 LAB_1CD5 :                     FD6 C |  LAB_1CD6 :                     FD8 C |
 LAB_1CDB :                     FE8 C |  LAB_1CE6 :                     FDA C |
 LAB_1CF2 :                     FEA C |  LAB_1CFE :                    1000 C |
 LAB_1D10 :                    1078 C |  LAB_1D12 :                    107C C |
 LAB_1D2D :                    108E C |  LAB_1D2E :                    109A C |
 LAB_1D44 :                    10B6 C |  LAB_1D45 :                    10C6 C |
 LAB_1D48 :                    10DA C |  LAB_1D49 :                    10E2 C |
 LAB_1D4A :                    10E6 C |  LAB_1D4B :                    10F6 C |
 LAB_1D5D :                    10FE C |  LAB_1D5E :                    1104 C |
 LAB_1D83 :                    1068 C |  LAB_1D8A :                    1062 C |
 LAB_1D94 :                    1118 C | *LAB_1D96 :                    2E66 C |
*LAB_1D98 :                    1122 C |  LAB_1DAC :                    113C C |
 LAB_1DAE :                    113E C |  LAB_1DAF :                    114A C |
 LAB_1DB0 :                    1158 C |  LAB_1DB1 :                    115C C |
 LAB_1DB2 :                    1160 C |  LAB_1DD7 :                    1178 C |
 LAB_1DE6 :                    1192 C |  LAB_1E17 :                    11D4 C |
 LAB_1E1F :                    11DA C |  LAB_1E5C :                    1214 C |
 LAB_1E8D :                    1230 C |  LAB_1EA1 :                    124C C |
 LAB_1EC0 :                    1274 C |  LAB_1ED6 :                    12A0 C |
 LAB_1ED8 :                    12AE C |  LAB_1EDF :                    1268 C |
 LAB_1F07 :                    12C0 C |  LAB_1F28 :                    12DA C |
 LAB_1F2C :                    12E0 C |  LAB_1F5A :                    12EE C |
 LAB_1F6A :                    1316 C |  LAB_1F6B :                    1322 C |
 LAB_1F7C :                    1328 C |  LAB_1FB4 :                    1356 C |
 LAB_1FD0 :                    1382 C |  LAB_201E :                    13DC C |
 LAB_2043 :                    142A C |  LAB_2044 :                    145C C |
 LAB_2045 :                    1466 C |  LAB_204S :                    142C C |
 LAB_204T :                    145A C |  LAB_20AE :                    1478 C |
 LAB_20B4 :                    147C C |  LAB_20BE :                    1482 C |
 LAB_20C9 :                    14A6 C |  LAB_20CB :                    1492 C |
 LAB_20D0 :                    149A C |  LAB_20D8 :                    14B0 C |
 LAB_20E0 :                    14B8 C |  LAB_2115 :                    14D8 C |
 LAB_2117 :                    14F0 C |  LAB_2128 :                    150A C |
 LAB_2137 :                    150E C |  LAB_214B :                    152E C |
 LAB_2161 :                    1544 C |  LAB_2176 :                    154C C |
 LAB_217E :                    155A C |  LAB_2183 :                    1574 C |
 LAB_218B :                    157C C |  LAB_218F :                    157E C |
 LAB_21C2 :                    158A C |  LAB_21C4 :                    1590 C |
 LAB_21D1 :                    15C4 C |  LAB_2206 :                    15CA C |
 LAB_2212 :                    15F2 C |  LAB_2216 :                    15B4 C |
 LAB_2240 :                    15BC C |  LAB_224D :                    15F8 C |
 LAB_224E :                    160E C |  LAB_229E :                    1652 C |
 LAB_22A0 :                    165E C |  LAB_22B6 :                    166C C |
 LAB_22BA :                    1670 C |  LAB_22BD :                    167A C |
 LAB_22E6 :                    1694 C | *LAB_2316 :                    16D4 C |
 LAB_2317 :                    16D6 C |  LAB_231C :                    16DA C |
 LAB_2358 :                    170E C |  LAB_2368 :                    172E C |
 LAB_2441 :                    1922 C |  LAB_2445 :                    1926 C |
 LAB_2467 :                    1976 C |  LAB_2468 :                    197A C |
 LAB_249C :                    1968 C |  LAB_24A8 :                    197E C |
 LAB_24B4 :                    19A8 C |  LAB_24D0 :                    19B4 C |
 LAB_24D5 :                    19C0 C |  LAB_24D6 :                    19DA C |
 LAB_24D7 :                    19E8 C |  LAB_24D8 :                    19EE C |
 LAB_24D9 :                    19CE C |  LAB_24DA :                    19F4 C |
 LAB_24F7 :                    1998 C |  LAB_24F8 :                    199E C |
 LAB_2778 :                    1C5C C |  LAB_277C :                    1C5E C |
 LAB_279B :                    1C82 C |  LAB_27BA :                    1C90 C |
 LAB_27C3 :                    1CAC C |  LAB_27C4 :                    1CB6 C |
 LAB_27CA :                    1CBC C |  LAB_27CE :                    1CC4 C |
 LAB_27D0 :                    1CC8 C |  LAB_27DB :                    1CD6 C |
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 164 - 10/11/2023 21:18:52


 LAB_27F0 :                    1F9A C |  LAB_27F1 :                    1FB0 C |
 LAB_27F2 :                    1FB6 C |  LAB_27F3 :                    1FB8 C |
 LAB_27FA :                    1CEE C |  LAB_2828 :                    1D0E C |
*LAB_282E :                    1D14 C |  LAB_282F :                    1D16 C |
 LAB_2831 :                    1D1A C |  LAB_284G :                    1D3E C |
 LAB_284H :                    1D50 C |  LAB_284J :                    1D52 C |
 LAB_284L :                    1D46 C |  LAB_2887 :                    295E C |
 LAB_289A :                    2988 C |  LAB_289C :                    298E C |
 LAB_289D :                    2994 C |  LAB_28FD :                    29B0 C |
 LAB_28FE :                    29B6 C |  LAB_28FF :                    29BC C |
 LAB_2900 :                    29CA C |  LAB_2901 :                    29D0 C |
 LAB_2902 :                    2A22 C |  LAB_2903 :                    2A2A C |
 LAB_2904 :                    2A2C C |  LAB_2953 :                    1D74 C |
 LAB_295E :                    1D80 C |  LAB_2967 :                    1D8C C |
 LAB_2968 :                    1D94 C |  LAB_2969 :                    1DA6 C |
 LAB_296A :                    1DB0 C |  LAB_2970 :                    1DC6 C |
 LAB_2978 :                    1DD6 C |  LAB_2989 :                    1DE6 C |
 LAB_299C :                    1E3A C |  LAB_29A7 :                    1E62 C |
 LAB_29B7 :                    1E7A C |  LAB_29B9 :                    1E12 C |
 LAB_29C0 :                    1E88 C |  LAB_29C3 :                    1EA0 C |
 LAB_29D9 :                    1EBC C |  LAB_29E4 :                    1ECE C |
 LAB_29F7 :                    1EE2 C |  LAB_29FB :                    1EE6 C |
 LAB_29FD :                    1EEE C |  LAB_2A18 :                    1EFE C |
 LAB_2A1A :                    1F00 C |  LAB_2A21 :                    1F08 C |
 LAB_2A3B :                    1F2A C |  LAB_2A4B :                    1F38 C |
 LAB_2A58 :                    1F4C C |  LAB_2A68 :                    1F64 C |
 LAB_2A74 :                    1F70 C |  LAB_2A89 :                    1F8C C |
 LAB_2A8C :                    1F90 C |  LAB_2A91 :                    1F96 C |
 LAB_2A9A :                    300A C |  LAB_2A9B :                    3026 C |
 LAB_2X01 :                    29E8 C |  LAB_2X02 :                    29F0 C |
 LAB_2X03 :                    29FE C |  LAB_2X04 :                    2A04 C |
 LAB_2X05 :                    2A1A C |  LAB_2Y01 :                    2A3A C |
 LAB_2Y02 :                    2A42 C |  LAB_2Y03 :                    2A4E C |
 LAB_2Y04 :                    2A54 C |  LAB_3216 :                    1BF6 C |
 LAB_32_16 :                   1BF4 C |  LAB_ABER :                     1FE C |
 LAB_ABS :                     1CE6 C |  LAB_AD :                      339D C |
 LAB_ADD :                     1944 C |  LAB_ADER :                     1CA C |
 LAB_AND :                      F7C C |  LAB_ASC :                     17B8 C |
 LAB_ATCD :                    233A C |  LAB_ATGO :                    22F6 C |
 LAB_ATLE :                    2314 C |  LAB_ATN :                     22D8 C |
 LAB_ATNP :                    2334 C |  LAB_AYFC :                    1362 C |
 LAB_BAER :                    3224 C |  LAB_BHCB :                     F62 C |
 LAB_BHSS :                     F3C C |  LAB_BINS :                    2712 C |
 LAB_BITCLR :                  239C C |  LAB_BITSET :                  238C C |
 LAB_BMSG :                    3567 C |  LAB_BS :                      32C6 C |
 LAB_BTST :                    23AC C |  LAB_CALL :                    1902 C |
 LAB_CASC :                    1052 C |  LAB_CATN :                    2340 C |
*LAB_CAUC :                    1058 C |  LAB_CBIN :                    2B0E C |
 LAB_CBX1 :                    2B28 C |  LAB_CBXN :                    2B16 C |
 LAB_CCER :                     1E2 C |  LAB_CHEX :                    2AAC C |
 LAB_CHRS :                    169E C |  LAB_CHX1 :                    2AD2 C |
 LAB_CHX2 :                    2AF6 C |  LAB_CHX3 :                    2AEE C |
 LAB_CHXX :                    2AB4 C |  LAB_CKRN :                    138A C |
 LAB_CKTM :                     CEC C |  LAB_CLEAR :                    506 C |
 LAB_CN :                      3333 C |  LAB_COLD :                     112 C |
 LAB_CONT :                     6F2 C |  LAB_CORD :                    226A C |
 LAB_COS :                     21FA C |  LAB_CRLF :                     A38 C |
 LAB_CTBL :                    2EEE C |  LAB_CTNM :                     CEA C |
 LAB_D0 :                      32E4 C |  LAB_D002 :                    2676 C |
 LAB_D00A :                    2686 C |  LAB_D00E :                    2696 C |
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 165 - 10/11/2023 21:18:52


 LAB_DATA :                     7E0 C |  LAB_DD :                      32D3 C |
 LAB_DDER :                     1FA C |  LAB_DEC :                      8F4 C |
 LAB_DECI :                     954 C |  LAB_DEEK :                    1880 C |
 LAB_DEF :                     1394 C |  LAB_DIM :                     1004 C |
 LAB_DIV0 :                    1BEE C |  LAB_DIVIDE :                  1B74 C |
 LAB_DIVX :                    1BC4 C |  LAB_DO :                       724 C |
 LAB_DOKE :                    18AA C |  LAB_DUPFMT :                  265E C |
 LAB_DZER :                     1F6 C |  LAB_EMSG :                    356F C |
 LAB_END :                      68C C |  LAB_EOR :                      F6C C |
 LAB_EQUAL :                    F92 C |  LAB_ESML :                    2110 C |
 LAB_EVBY :                    17D0 C |  LAB_EVEX :                     D00 C |
 LAB_EVEZ :                     D02 C |  LAB_EVIN :                    119E C |
 LAB_EVIR :                    11AE C |  LAB_EVNM :                     CE8 C |
 LAB_EVPI :                    11A6 C |  LAB_EX1 :                     2048 C |
 LAB_EXAD :                    219A C |  LAB_EXCC :                    2180 C |
 LAB_EXCM :                    20B2 C |  LAB_EXNN :                    216C C |
 LAB_EXOF :                    206C C |  LAB_EXOL :                    2082 C |
 LAB_EXOU :                    2058 C |  LAB_EXP :                     208C C |
 LAB_EXPL :                    2166 C |  LAB_EXPS :                    20C4 C |
 LAB_EXRN :                    2172 C |  LAB_EXXF :                    2AFC C |
 LAB_FB95 :                    27C4 C |  LAB_FBA0 :                    27A8 C |
 LAB_FC :                      328D C |  LAB_FCER :                     20E C |
 LAB_FO :                      33A5 C |  LAB_FOER :                     1C6 C |
 LAB_FOR :                      5C0 C |  LAB_FRE :                     134C C |
 LAB_FTBL :                    2F8A C |  LAB_FTPP :                    2F3E C |
 LAB_FVAR :                    1070 C |  LAB_GADB :                    1824 C |
 LAB_GADW :                    1838 C |  LAB_GARB :                    1524 C |
 LAB_GBYT :                     E62 C |  LAB_GEAD :                    1858 C |
 LAB_GET :                      9B2 C |  LAB_GETS :                     9CC C |
 LAB_GFPN :                     8B6 C |  LAB_GOSUB :                    736 C |
 LAB_GOTO :                     748 C |  LAB_GOTS :                     758 C |
 LAB_GSCH :                     6D8 C |  LAB_GTBY :                    17CC C |
 LAB_GTHAN :                   203A C |  LAB_GTWO :                    17E2 C |
 LAB_GVAL :                     E0E C |  LAB_GVAR :                    1072 C |
 LAB_HEXS :                    2764 C |  LAB_ID :                      32F3 C |
 LAB_IDER :                     1F2 C |  LAB_IF :                       808 C |
 LAB_IGBY :                     E60 C |  LAB_IMSG :                    3580 C |
 LAB_INC :                      8FA C |  LAB_INCI :                     94A C |
 LAB_INCT :                     93C C |  LAB_INLN :                     344 C |
 LAB_INPUT :                    B26 C |  LAB_INT :                     1D58 C |
 LAB_IRTS :                    1D72 C |  LAB_ISHN :                    2ACE C |
 LAB_KEYT :                    3090 C |  LAB_LAAD :                    1A6E C |
 LAB_LCASE :                   1736 C |  LAB_LD :                      3355 C |
 LAB_LDER :                     1DA C |  LAB_LEEK :                    1896 C |
 LAB_LEFT :                    16AE C |  LAB_LENS :                    17B0 C |
 LAB_LET :                      958 C |  LAB_LIST :                     50A C |
 LAB_LMSG :                    3576 C |  LAB_LOAD :                    18FA C |
 LAB_LOCC :                    1A74 C |  LAB_LOCX :                    1A90 C |
 LAB_LOG :                     19F6 C |  LAB_LOKE :                    18B0 C |
 LAB_LOLP :                    1A7E C |  LAB_LONE :                    1AAC C |
 LAB_LONN :                    1A94 C |  LAB_LOOP :                     776 C |
 LAB_LOWZ :                    1AE6 C |  LAB_LOXO :                    1AB2 C |
 LAB_LOXP :                    1AA2 C |  LAB_LRMS :                     F1A C |
 LAB_LS :                      3310 C |  LAB_LSHIFT :                  1010 C |
 LAB_LTHAN :                    F9C C |  LAB_LTPF :                    227A C |
 LAB_LTPT :                    228A C |  LAB_LT_1 :                    1C02 C |
 LAB_MADD :                    1B14 C |  LAB_MAN1 :                    1BE8 C |
 LAB_MAX :                     27D0 C |  LAB_MAXN :                    27DC C |
 LAB_MIDS :                    16F2 C |  LAB_MIN :                     27E6 C |
 LAB_MINN :                    27F2 C | *LAB_MKCHR :                   16A2 C |
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 166 - 10/11/2023 21:18:52


 LAB_MMEC :                    27FC C |  LAB_MNOC :                    1B0E C |
 LAB_MUEX :                    1B62 C | *LAB_MUF1 :                    1B3E C |
 LAB_MUF2 :                    1B48 C |  LAB_MUF3 :                    1B5E C |
 LAB_MULTIPLY :                1AE8 C |  LAB_MUUF :                    1B68 C |
 LAB_NB1T :                    1C3A C |  LAB_NEW :                      4B4 C |
 LAB_NEXT :                     C32 C |  LAB_NF :                      3254 C |
 LAB_NFER :                     21E C |  LAB_NI :                      33AC C |
 LAB_NOST :                     9DE C |  LAB_NSTT :                    2862 C |
 LAB_NULL :                     6E8 C |  LAB_OD :                      3281 C |
 LAB_ODER :                     212 C |  LAB_OFER :                     20A C |
 LAB_OM :                      32A4 C |  LAB_OMER :                     206 C |
 LAB_ON :                       882 C |  LAB_OPPT :                    2FD6 C |
 LAB_OR :                       F74 C |  LAB_OV :                      329B C |
 LAB_P004 :                    26B4 C |  LAB_P008 :                    26CA C |
 LAB_P00C :                    26D2 C |  LAB_P00E :                    26DE C |
 LAB_P010 :                    26E2 C |  LAB_P018 :                    26FC C |
 LAB_P01A :                    2700 C |  LAB_P01E :                    2708 C |
 LAB_PEEK :                    186E C |  LAB_PFAC :                    1C44 C |
 LAB_PHFA :                    280C C |  LAB_PI :                      293E C |
 LAB_POKE :                    187A C |  LAB_POON :                    1FBA C |
 LAB_POS :                     137E C |  LAB_POWER :                   1FD6 C |
 LAB_POWP :                    2008 C |  LAB_POZE :                    1FCA C |
 LAB_PPBI :                     F10 C |  LAB_PPFN :                     F02 C |
 LAB_PPFS :                     EF4 C |  LAB_PRINT :                    9EC C |
 LAB_PRNA :                     AB0 C |  LAB_PROCFO :                  269C C |
 LAB_P_10 :                    2C80 C |  LAB_RAM :                     2934 C |
 LAB_READ :                     B4C C |  LAB_REDO :                    3590 C |
 LAB_REM :                      87A C |  LAB_REMM :                    1C1A C |
 LAB_RESS :                     6CC C |  LAB_RESTORE :                  6BA C |
 LAB_RET0 :                    2A9A C |  LAB_RETURN :                   7CC C |
 LAB_RG :                      326C C |  LAB_RGER :                     216 C |
 LAB_RIGHT :                   16C2 C |  LAB_RMSG :                    35A2 C |
 LAB_RND :                     21A6 C |  LAB_RSED :                    2B98 C |
 LAB_RSHIFT :                  1020 C |  LAB_RTN0 :                    2A9C C |
 LAB_RTST :                    14BE C |  LAB_RUN :                      710 C |
 LAB_RUNN :                     71E C |  LAB_SADD :                    1798 C |
 LAB_SAVE :                    18FE C |  LAB_SCCA :                     E58 C |
 LAB_SCER :                     1E6 C |  LAB_SCGB :                     E52 C |
 LAB_SCL0 :                    2260 C |  LAB_SCLN :                     4A2 C |
 LAB_SCZE :                    2252 C |  LAB_SET1 :                    1BCC C |
 LAB_SGBY :                    17C8 C |  LAB_SGN :                     1CD4 C |
 LAB_SIN :                     2212 C |  LAB_SLER :                     1EA C |
 LAB_SMSG :                    35AC C |  LAB_SN :                      3265 C |
 LAB_SNBS :                     7E6 C |  LAB_SNER :                     21A C |
 LAB_SQE1 :                    28E6 C |  LAB_SQE2 :                    28EC C |
 LAB_SQNA :                    2914 C |  LAB_SQNS :                    28FE C |
 LAB_SQR :                     28C2 C |  LAB_SSLN :                     49A C |
 LAB_ST :                      3320 C |  LAB_STOP :                     694 C |
 LAB_STRS :                    1474 C |  LAB_SUBTRACT :                1930 C |
 LAB_SVAR :                    106E C |  LAB_SVTB :                    2894 C |
 LAB_SWAP :                    18C4 C |  LAB_TAN :                     21D8 C |
 LAB_TBSZ :                    2874 C |  LAB_TM :                      3302 C |
 LAB_TMER :                     1EE C |  LAB_TWOPI :                   294E C |
 LAB_U002 :                    2404 C |  LAB_U004 :                    245A C |
 LAB_U005 :                    246A C |  LAB_U006 :                    246C C |
 LAB_U008 :                    2480 C |  LAB_U009 :                    24A2 C |
 LAB_U00A :                    24AA C |  LAB_U00B :                    24B4 C |
 LAB_U00C :                    24C8 C |  LAB_U00D :                    24CC C |
 LAB_U00E :                    24DE C |  LAB_U00F :                    24EA C |
 LAB_U010 :                    24EE C |  LAB_U014 :                    24F4 C |
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 167 - 10/11/2023 21:18:52


 LAB_U018 :                    24FC C |  LAB_U01C :                    2512 C |
 LAB_U020 :                    251E C |  LAB_U022 :                    2524 C |
 LAB_U026 :                    2534 C |  LAB_U02A :                    253E C |
 LAB_U02B :                    2556 C |  LAB_U02C :                    255C C |
 LAB_U02E :                    256E C |  LAB_U030 :                    2572 C |
 LAB_U034 :                    2588 C |  LAB_U036 :                    258E C |
 LAB_U038 :                    2596 C |  LAB_U03C :                    259E C |
 LAB_U03E :                    25A4 C |  LAB_U040 :                    25BC C |
 LAB_U044 :                    25CC C |  LAB_U046 :                    25F4 C |
 LAB_U048 :                    25F6 C |  LAB_U04A :                    2600 C |
 LAB_U04C :                    2632 C |  LAB_UA :                      3378 C |
 LAB_UCASE :                   1766 C |  LAB_UDER :                     1D2 C |
 LAB_UF :                      3342 C |  LAB_UFAC :                    1C28 C |
 LAB_UFER :                     1DE C |  LAB_US :                      32B2 C |
 LAB_USER :                     202 C |  LAB_USINGS :                  23DA C |
 LAB_USR :                     18F2 C |  LAB_UV :                      3365 C |
 LAB_UVER :                     1D6 C |  LAB_VAL :                     17F6 C |
 LAB_VALZ :                    181E C | *LAB_VARCALL :                 2926 C |
 LAB_VARPTR :                  2924 C |  LAB_WAIT :                    190C C |
 LAB_WARM :                     400 C |  LAB_WD :                      338C C |
 LAB_WDER :                     1CE C |  LAB_WDLP :                    28A8 C |
 LAB_WDTH :                    2842 C |  LAB_XDIV :                    1BDC C |
 LAB_XERR :                     220 C |  LAB_XGADW :                   1852 C |
 LC_LOOP :                     174C C | *LISTON :                         1 - |
 LOOPALWAYS :                   7B2 C |  LOOPDONE :                     7C6 C |
 LVARPL :                       472 C |  L_DDIV :                      1C22 C |
 L_DIVRND :                    1BD0 C | *MACEXP :                         7 - |
 MAINLOOP :                    22A2 C | *MOMCPU :                     68000 - |
*MOMCPUNAME :               "68000" - | *N :                              2 - |
*NESTMAX :                      100 - |  NEXTA :                       22B4 C |
 NEXTB1 :                      2722 C |  NEXTB2 :                      2748 C |
 NEXTH1 :                      2774 C |  NEXTPRN :                     21B4 C |
 NINC0 :                       21BC C |  NINC1 :                       21C2 C |
*NOBRK :                          0 - |  NOCHR :                         F4 C |
 NOLCASE :                     178E C |  NOSHIFT :                     101C C |
 NOSTRING :                    1794 C |  NOT2BIG :                     1034 C |
 NOUCASE :                     175E C | *NOVAR :                          0 - |
 NULLCT :                       5E4 C |  NUMEXP :                       5AC - |
 OFCHR :                        '#' - |  OQUOTE :                       5DD C |
 OUTLOOP :                     22C2 C | *PADDING :                        1 - |
 PRG_STRT :                     5EC C |  PRNLWORD :                     5A0 C |
 PRSTK :                        5D8 C |  RAM_ADDR :                    8000 - |
 RAM_BASE :                     400 C |  RAM_SIZE :                    2000 - |
*RAM_STRT :                       0 C |  RDPTRL :                       466 C |
*RELAXED :                        0 - |  RTS_001 :                      E7E C |
 RTS_005 :                      504 C |  RTS_006 :                      6E6 C |
 RTS_007 :                      7E4 C |  RTS_007A :                     7FA C |
*RTS_008 :                      9B0 C |  RTS_009 :                      AAC C |
 RTS_011 :                     1326 C |  RTS_012 :                     15F6 C |
 RTS_013 :                     166A C |  RTS_015 :                     18C2 C |
 RTS_016 :                     199C C |  RTS_017 :                     1CBA C |
 RTS_020 :                     2046 C |  RTS_021 :                     238A C |
 RTS_022 :                     27B2 C |  RTS_023 :                     28C0 C |
 RTS_024 :                     2B0C C |  RTS_025 :                     2B6E C |
 SARRYL :                       43E C |  SFNCL :                        432 C |
 SMEML :                        42E C |  SSTORL :                       446 C |
 SSTRL :                        43A C |  SUBEXIT :                     22CC C |
 SUBLOOP :                     229A C |  SUFNXF :                       5DF C |
 SUTILL :                       44E C |  SVARL :                        436 C |
 TABSIZ :                       5E2 C |  TAB_ASCA :                    33D0 C |
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 168 - 10/11/2023 21:18:52


 TAB_ASCB :                    33E0 C |  TAB_ASCC :                    33F9 C |
 TAB_ASCD :                    3410 C |  TAB_ASCE :                    3429 C |
 TAB_ASCF :                    3438 C |  TAB_ASCG :                    3442 C |
 TAB_ASCH :                    344F C |  TAB_ASCI :                    3455 C |
 TAB_ASCL :                    3464 C |  TAB_ASCM :                    3492 C |
 TAB_ASCN :                    34A0 C |  TAB_ASCO :                    34AF C |
 TAB_ASCP :                    34B4 C |  TAB_ASCR :                    34C9 C |
 TAB_ASCS :                    34F3 C |  TAB_ASCT :                    351E C |
 TAB_ASCU :                    3532 C |  TAB_ASCV :                    354A C |
 TAB_ASCW :                    3556 C |  TAB_ATNC :                    2DEE C |
 TAB_CHRT :                    3026 C |  TAB_EQUL :                    33C8 C |
 TAB_HTHET :                   2E6E C |  TAB_LESS :                    33C4 C |
 TAB_MNUS :                    33C0 C |  TAB_MORE :                    33CA C |
 TAB_PLUS :                    33BE C |  TAB_POWR :                    3565 C |
 TAB_QEST :                    33CE C |  TAB_SLAS :                    33C2 C |
 TAB_SNCO :                    2D6E C |  TAB_STAR :                    33BC C |
*TIME :                  "21:18:52" - |  TK_ABS :                        C1 - |
 TK_AND :                        B7 - |  TK_ASC :                        D3 - |
 TK_ATN :                        CC - |  TK_BINS :                       D8 - |
 TK_BITCLR :                     A7 - |  TK_BITSET :                     A6 - |
 TK_BITTST :                     D9 - |  TK_CALL :                       9B - |
 TK_CHRS :                       D6 - |  TK_CLEAR :                      A1 - |
 TK_CONT :                       9F - |  TK_COS :                        C9 - |
 TK_DATA :                       83 - |  TK_DEC :                        88 - |
 TK_DEEK :                       CE - |  TK_DEF :                        97 - |
 TK_DIM :                        85 - |  TK_DIV :                        B5 - |
 TK_DO :                         9C - |  TK_DOKE :                       99 - |
 TK_ELSE :                       A9 - |  TK_END :                        80 - |
 TK_EOR :                        B8 - |  TK_EQUAL :                      BD - |
 TK_EXP :                        C8 - |  TK_FN :                         AB - |
 TK_FOR :                        81 - |  TK_FRE :                        C3 - |
 TK_GET :                        A4 - |  TK_GOSUB :                      8D - |
 TK_GOTO :                       89 - |  TK_GT :                         BC - |
 TK_HEXS :                       D7 - |  TK_IF :                         8B - |
 TK_INC :                        93 - |  TK_INPUT :                      84 - |
 TK_INT :                        C0 - |  TK_LCASES :                     D5 - |
 TK_LEEK :                       CF - |  TK_LEFTS :                      E1 - |
 TK_LEN :                        D0 - |  TK_LET :                        87 - |
 TK_LIST :                       A0 - |  TK_LOAD :                       95 - |
 TK_LOG :                        C7 - |  TK_LOKE :                       9A - |
 TK_LOOP :                       9D - |  TK_LSHIFT :                     BB - |
 TK_LT :                         BE - |  TK_MAX :                        DA - |
 TK_MIDS :                       E3 - |  TK_MIN :                        DB - |
 TK_MINUS :                      B3 - |  TK_MULT :                       B4 - |
 TK_NEW :                        A2 - |  TK_NEXT :                       82 - |
 TK_NOT :                        AE - |  TK_NULL :                       92 - |
 TK_ON :                         91 - |  TK_OR :                         B9 - |
 TK_PEEK :                       CD - |  TK_PI :                         DD - |
 TK_PLUS :                       B2 - |  TK_POKE :                       98 - |
 TK_POS :                        C4 - |  TK_POWER :                      B6 - |
 TK_PRINT :                      9E - |  TK_RAM :                        DC - |
 TK_READ :                       86 - |  TK_REM :                        8F - |
 TK_RESTORE :                    8C - |  TK_RETURN :                     8E - |
 TK_RIGHTS :                     E2 - |  TK_RND :                        C6 - |
 TK_RSHIFT :                     BA - |  TK_RUN :                        8A - |
 TK_SADD :                       E0 - |  TK_SAVE :                       96 - |
 TK_SGN :                        BF - |  TK_SIN :                        CA - |
 TK_SPC :                        AC - |  TK_SQR :                        C5 - |
 TK_STEP :                       AF - |  TK_STOP :                       90 - |
 TK_STRS :                       D1 - |  TK_SWAP :                       A5 - |
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 169 - 10/11/2023 21:18:52


 TK_TAB :                        A8 - |  TK_TAN :                        CB - |
 TK_THEN :                       AD - |  TK_TO :                         AA - |
 TK_TWOPI :                      DE - |  TK_UCASES :                     D4 - |
 TK_UNTIL :                      B0 - |  TK_USINGS :                     E4 - |
 TK_USR :                        C2 - |  TK_VAL :                        D2 - |
 TK_VPTR :                       DF - |  TK_WAIT :                       94 - |
 TK_WHILE :                      B1 - |  TK_WIDTH :                      A3 - |
 TOOBIG :                      103A C |  TPOS :                         5E5 C |
 TPOWER :                       5D9 C | *TRUE :                           1 - |
 TWIDTH :                       5E6 C |  UC_LOOP :                     177C C |
 USDSS :                        5CC C |  USRJMP :                       406 C |
*USRJPV :                       408 C | *UT1_PL :                       5A4 C |
 VARNAME :                      46A C |  VEC_CC :                      278E C |
 VEC_IN :                        D8 C |  VEC_LD :                        FA C |
 VEC_OUT :                       C0 C |  VEC_SV :                       100 C |
*VERSION :                     142F - |  V_CTLC :                       424 C |
*V_CTLCV :                      426 C |  V_INPT :                       40C C |
*V_INPTV :                      40E C |  V_LOAD :                       418 C |
*V_LOADV :                      41A C |  V_OUTP :                       412 C |
*V_OUTPV :                      414 C |  V_SAVE :                       41E C |
*V_SAVEV :                      420 C |  WEXIT :                       2898 C |
 WRMJPV :                       402 C |

   1115 symbols
     48 unused symbols

 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 170 - 10/11/2023 21:18:52


  Code Pages:
  ----------

STANDARD (0 changed characters)

1 code page

0.41 seconds assembly time

   9425 lines source file
      6 passes
      0 errors
      0 warnings
