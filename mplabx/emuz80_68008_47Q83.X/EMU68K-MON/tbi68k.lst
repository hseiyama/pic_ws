 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 1 - 12/13/2023 15:59:15


    1/       0 :                        ;*****************************************************************
    2/       0 :                        ;								 *
    3/       0 :                        ;		Tiny BASIC for the Motorola MC68000		 *
    4/       0 :                        ;								 *
    5/       0 :                        ; Derived from Palo Alto Tiny BASIC as published in the May 1976 *
    6/       0 :                        ; issue of Dr. Dobb's Journal.  Adapted to the 68000 by:	 *
    7/       0 :                        ;	Gordon Brandly						 *
    8/       0 :                        ;	R.R. 2							 *
    9/       0 :                        ;	Fort Sask., Alberta, CANADA				 *
   10/       0 :                        ;	T8L 2N8							 *
   11/       0 :                        ;								 *
   12/       0 :                        ;								 *
   13/       0 :                        ; This version is for MEX68KECB Educational Computer Board I/O.	 *
   14/       0 :                        ;								 *
   15/       0 :                        ;*****************************************************************
   16/       0 :                        ;    Copyright (C) 1984 by Gordon Brandly. This program may be	 *
   17/       0 :                        ;    freely distributed for personal use only. All commercial	 *
   18/       0 :                        ;                      rights are reserved.			 *
   19/       0 :                        ;*****************************************************************
   20/       0 :                        
   21/       0 :                        ; Vers.	1.0  1984/7/17  - Original version by Gordon Brandly
   22/       0 :                        ;	1.1  1984/12/9  - Addition of '$' print term by Marvin Lipford
   23/       0 :                        ;	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
   24/       0 :                        
   25/       0 :                        ;
   26/       0 :                        ; Tiny BASIC for MEZ68008
   27/       0 :                        ;	2022/10/21	- Modified by Satoshi Okue
   28/       0 :                        ;
   29/       0 :                        ; ROM address 0x0000-0x3fff
   30/       0 :                        ; RAM address 0x8000-
   31/       0 :                        ;
   32/       0 :                        
   33/       0 :                        	CPU	68000
   34/       0 :                        
   35/       0 :                        	SUPMODE	ON
   36/       0 :                        
   37/       0 : =$6600                 TBSC_CS	EQU	$00006600	; Tiny BASIC cold start
   38/       0 :                        
   39/       0 :                        ;	ORG	$00000000
   40/       0 :                        ;
   41/       0 :                        ;INIVEC:
   42/       0 :                        ;	;; 0-7
   43/       0 :                        ;	DC.L	ENDRAM		; Reset: Initial SSP
   44/       0 :                        ;	DC.L	CSTART		; Reset: Initial PC
   45/       0 :                        
   46/       0 :                        
   47/       0 : =$D                    CR	EQU	$0D		; ASCII equates
   48/       0 : =$A                    LF	EQU	$0A
   49/       0 : =$9                    TAB	EQU	$09
   50/       0 : =$3                    CTRLC	EQU	$03
   51/       0 : =$8                    CTRLH	EQU	$08
   52/       0 : =$13                   CTRLS	EQU	$13
   53/       0 : =$18                   CTRLX	EQU	$18
   54/       0 :                        
   55/       0 : =$50                   BUFLEN	EQU	80		; length of keyboard input buffer
   56/       0 :                        
   57/       0 : =$E001                 ACIAC:	EQU	$0000E001
   58/       0 : =$E000                 ACIAD:	EQU	$0000E000
   59/       0 :                        
   60/       0 : =$8000                 TOPRAM	EQU	$8000
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 2 - 12/13/2023 15:59:15


   61/       0 : =$A000                 ENDRAM	EQU	TOPRAM+$2000
   62/       0 :                        
   63/    6600 :                        	ORG	TBSC_CS		; first free address using Tutor
   64/    6600 :                        
   65/    6600 : 2E7C 0000 A000         	MOVE.L	#(ENDRAM),A7	; Reset: Initial SSP
   66/    6606 : 207C 0000 6632         	MOVE.L	#CSTART,A0	; Reset: Initial PC
   67/    660C : 4ED0                   	JMP	(A0)
   68/    660E :                        
   69/    660E :                        ;
   70/    660E :                        ; Standard jump table. You can change these addresses if you are
   71/    660E :                        ; customizing this interpreter for a different environment.
   72/    660E :                        ;
   73/    660E : 6000 0022              START	BRA.L	CSTART		; Cold Start entry point
   74/    6612 : 6000 0058              GOWARM	BRA.L	WSTART		; Warm Start entry point
   75/    6616 : 6000 0B80              GOOUT	BRA.L	OUTC		; Jump to character-out routine
   76/    661A : 6000 0B8E              GOIN	BRA.L	INC		; Jump to character-in routine
   77/    661E : 6000 0BA0              GOAUXO	BRA.L	AUXOUT		; Jump to auxiliary-out routine
   78/    6622 : 6000 0B9E              GOAUXI	BRA.L	AUXIN		; Jump to auxiliary-in routine
   79/    6626 : 6000 0B9C              GOBYE	BRA.L	BYEBYE		; Jump to monitor, DOS, etc.
   80/    662A :                        ;
   81/    662A :                        ; Modifiable system constants:
   82/    662A :                        ;
   83/    662A : 0000 8080              TXTBGN	DC.L	TXT		; beginning of program memory
   84/    662E : 0000 A000              ENDMEM	DC.L	ENDRAM		; end of available memory
   85/    6632 :                        ;
   86/    6632 :                        ; The main interpreter starts here:
   87/    6632 :                        ;
   88/    6632 : 2E78 662E              CSTART	MOVE.L	ENDMEM,SP	; initialize stack pointer
   89/    6636 : 4DF8 71C6              	LEA	INITMSG,A6	; tell who we are
   90/    663A : 6100 0B50              	BSR.L	PRMESG
   91/    663E : 23F8 662A 0000 8024    	MOVE.L	TXTBGN,TXTUNF	; init. end-of-program pointer
   92/    6646 : 2038 662E              	MOVE.L	ENDMEM,D0	; get address of end of memory
   93/    664A : 0480 0000 0800         	SUBI.L	#2048,D0	; reserve 2K for the stack
   94/    6650 : 23C0 0000 802C         	MOVE.L	D0,STKLMT
   95/    6656 : 0480 0000 006C         	SUBI.L	#108,D0		; reserve variable area (27 long words)
   96/    665C : 23C0 0000 8028         	MOVE.L	D0,VARBGN
   97/    6662 : 23FC 0000 660E 0000    	MOVE.L	#START,RANPNT
          666A : 8000                  
   98/    666C : 4280                   WSTART	CLR.L	D0		; initialize internal variables
   99/    666E : 23C0 0000 8010         	MOVE.L	D0,LOPVAR
  100/    6674 : 23C0 0000 8008         	MOVE.L	D0,STKGOS
  101/    667A : 23C0 0000 8004         	MOVE.L	D0,CURRNT	; current line number pointer = 0
  102/    6680 : 2E78 662E              	MOVE.L	ENDMEM,SP	; init S.P. again, just in case
  103/    6684 : 4DF8 71EC              	LEA	OKMSG,A6	; display "OK"
  104/    6688 : 6100 0B02              	BSR.L	PRMESG
  105/    668C : 103C 003E              ST3	MOVE.B	#'>',D0		; Prompt with a '>' and
  106/    6690 : 6100 0818              	BSR.L	GETLN		; read a line.
  107/    6694 : 6100 0A94              	BSR.L	TOUPBUF		; convert to upper case
  108/    6698 : 2848                   	MOVE.L	A0,A4		; save pointer to end of line
  109/    669A : 41F9 0000 8030         	LEA	BUFFER,A0	; point to the beginning of line
  110/    66A0 : 6100 0A46              	BSR.L	TSTNUM		; is there a number there?
  111/    66A4 : 6100 0A78              	BSR.L	IGNBLK		; skip trailing blanks
  112/    66A8 : 4A41                   	TST	D1		; does line no. exist? (or nonzero?)
  113/    66AA : 6700 0124              	BEQ.L	DIRECT		; if not, it's a direct statement
  114/    66AE : 0C81 0000 FFFF         	CMPI.L	#$FFFF,D1	; see if line no. is <= 16 bits
  115/    66B4 : 6400 07EC              	BCC.L	QHOW		; if not, we've overflowed
  116/    66B8 : 1101                   	MOVE.B	D1,-(A0)	; store the binary line no.
  117/    66BA : E059                   	ROR	#8,D1		; (Kludge to store a word on a
  118/    66BC : 1101                   	MOVE.B	D1,-(A0)	; possible byte boundary)
  119/    66BE : E159                   	ROL	#8,D1
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 3 - 12/13/2023 15:59:15


  120/    66C0 : 6100 088C              	BSR.L	FNDLN		; find this line in save area
  121/    66C4 : 2A49                   	MOVE.L	A1,A5		; save possible line pointer
  122/    66C6 : 6616                   	BNE	ST4		; if not found, insert
  123/    66C8 : 6100 08AC              	BSR.L	FNDNXT		; find the next line (into A1)
  124/    66CC : 244D                   	MOVE.L	A5,A2		; pointer to line to be deleted
  125/    66CE : 2679 0000 8024         	MOVE.L	TXTUNF,A3	; points to top of save area
  126/    66D4 : 6100 08AA              	BSR.L	MVUP		; move up to delete
  127/    66D8 : 23CA 0000 8024         	MOVE.L	A2,TXTUNF	; update the end pointer
  128/    66DE : 200C                   ST4	MOVE.L	A4,D0		; calculate the length of new line
  129/    66E0 : 9088                   	SUB.L	A0,D0
  130/    66E2 : 0C80 0000 0003         	CMPI.L	#3,D0		; is it just a line no. & CR?
  131/    66E8 : 67A2                   	BEQ	ST3		; if so, it was just a delete
  132/    66EA : 2679 0000 8024         	MOVE.L	TXTUNF,A3	; compute new end
  133/    66F0 : 2C4B                   	MOVE.L	A3,A6
  134/    66F2 : D7C0                   	ADD.L	D0,A3
  135/    66F4 : 2039 0000 8028         	MOVE.L	VARBGN,D0	; see if there's enough room
  136/    66FA : B08B                   	CMP.L	A3,D0
  137/    66FC : 6300 079C              	BLS.L	QSORRY		; if not, say so
  138/    6700 : 23CB 0000 8024         	MOVE.L	A3,TXTUNF	; if so, store new end position
  139/    6706 : 224E                   	MOVE.L	A6,A1		; points to old unfilled area
  140/    6708 : 244D                   	MOVE.L	A5,A2		; points to beginning of move area
  141/    670A : 6100 087E              	BSR.L	MVDOWN		; move things out of the way
  142/    670E : 2248                   	MOVE.L	A0,A1		; set up to do the insertion
  143/    6710 : 244D                   	MOVE.L	A5,A2
  144/    6712 : 264C                   	MOVE.L	A4,A3
  145/    6714 : 6100 086A              	BSR.L	MVUP		; do it
  146/    6718 : 6000 FF72              	BRA	ST3		; go back and get another line
  147/    671C :                        
  148/    671C :                        ;
  149/    671C :                        ;******************************************************************
  150/    671C :                        ;
  151/    671C :                        ; *** Tables *** DIRECT *** EXEC ***
  152/    671C :                        ;
  153/    671C :                        ; This section of the code tests a string against a table. When
  154/    671C :                        ; a match is found, control is transferred to the section of
  155/    671C :                        ; code according to the table.
  156/    671C :                        ;
  157/    671C :                        ; At 'EXEC', A0 should point to the string, A1 should point to
  158/    671C :                        ; the character table, and A2 should point to the execution
  159/    671C :                        ; table. At 'DIRECT', A0 should point to the string, A1 and
  160/    671C :                        ; A2 will be set up to point to TAB1 and TAB1_1, which are
  161/    671C :                        ; the tables of all direct and statement commands.
  162/    671C :                        ;
  163/    671C :                        ; A '.' in the string will terminate the test and the partial
  164/    671C :                        ; match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
  165/    671C :                        ; 'PRIN.', or 'PRINT' will all match 'PRINT'.
  166/    671C :                        ;
  167/    671C :                        ; There are two tables: the character table and the execution
  168/    671C :                        ; table. The character table consists of any number of text items.
  169/    671C :                        ; Each item is a string of characters with the last character's
  170/    671C :                        ; high bit set to one. The execution table holds a 16-bit
  171/    671C :                        ; execution addresses that correspond to each entry in the
  172/    671C :                        ; character table.
  173/    671C :                        ;
  174/    671C :                        ; The end of the character table is a 0 byte which corresponds
  175/    671C :                        ; to the default routine in the execution table, which is
  176/    671C :                        ; executed if none of the other table items are matched.
  177/    671C :                        ;
  178/    671C :                        ; Character-matching tables:
  179/    671C : 4C49 53D4              TAB1	DC.B	'LIS',('T'+$80)		; Direct commands
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 4 - 12/13/2023 15:59:15


  180/    6720 : 4C4F 41C4              	DC.B	'LOA',('D'+$80)
  181/    6724 : 4E45 D7                	DC.B	'NE',('W'+$80)
  182/    6727 : 5255 CE                	DC.B	'RU',('N'+$80)
  183/    672A : 5341 56C5              	DC.B	'SAV',('E'+$80)
  184/    672E : 4E45 58D4              TAB2	DC.B	'NEX',('T'+$80)		; Direct / statement
  185/    6732 : 4C45 D4                	DC.B	'LE',('T'+$80)
  186/    6735 : 49C6                   	DC.B	'I',('F'+$80)
  187/    6737 : 474F 54CF              	DC.B	'GOT',('O'+$80)
  188/    673B : 474F 5355 C2           	DC.B	'GOSU',('B'+$80)
  189/    6740 : 5245 5455 52CE         	DC.B	'RETUR',('N'+$80)
  190/    6746 : 5245 CD                	DC.B	'RE',('M'+$80)
  191/    6749 : 464F D2                	DC.B	'FO',('R'+$80)
  192/    674C : 494E 5055 D4           	DC.B	'INPU',('T'+$80)
  193/    6751 : 5052 494E D4           	DC.B	'PRIN',('T'+$80)
  194/    6756 : 504F 4BC5              	DC.B	'POK',('E'+$80)
  195/    675A : 5354 4FD0              	DC.B	'STO',('P'+$80)
  196/    675E : 4259 C5                	DC.B	'BY',('E'+$80)
  197/    6761 : 4341 4CCC              	DC.B	'CAL',('L'+$80)
  198/    6765 : 00                     	DC.B	0
  199/    6766 : 5045 45CB              TAB4	DC.B	'PEE',('K'+$80)		; Functions
  200/    676A : 524E C4                	DC.B	'RN',('D'+$80)
  201/    676D : 4142 D3                	DC.B	'AB',('S'+$80)
  202/    6770 : 5349 5AC5              	DC.B	'SIZ',('E'+$80)
  203/    6774 : 00                     	DC.B	0
  204/    6775 : 54CF                   TAB5	DC.B	'T',('O'+$80)		; "TO" in "FOR"
  205/    6777 : 00                     	DC.B	0
  206/    6778 : 5354 45D0              TAB6	DC.B	'STE',('P'+$80)		; "STEP" in "FOR"
  207/    677C : 00                     	DC.B	0
  208/    677D : 3EBD                   TAB8	DC.B	'>',('='+$80)		; Relational operators
  209/    677F : 3CBE                   	DC.B	'<',('>'+$80)
  210/    6781 : BE                     	DC.B	('>'+$80)
  211/    6782 : BD                     	DC.B	('='+$80)
  212/    6783 : 3CBD                   	DC.B	'<',('='+$80)
  213/    6785 : BC                     	DC.B	('<'+$80)
  214/    6786 : 00                     	DC.B	0
  215/    6787 : 00                     	DC.B	0	; <- for aligning on a word boundary
  216/    6788 :                        
  217/    6788 :                        ; Execution address tables:
  218/    6788 : 687C                   TAB1_1	DC.W	LIST			; Direct commands
  219/    678A : 6AF0                   	DC.W	LOAD
  220/    678C : 6816                   	DC.W	NEW
  221/    678E : 682A                   	DC.W	RUN
  222/    6790 : 6B50                   	DC.W	SAVE
  223/    6792 : 69E0                   TAB2_1	DC.W	NEXT			; Direct / statement
  224/    6794 : 6AE0                   	DC.W	LET
  225/    6796 : 6A3E                   	DC.W	IF
  226/    6798 : 6868                   	DC.W	GOTO
  227/    679A : 6914                   	DC.W	GOSUB
  228/    679C : 6944                   	DC.W	RETURN
  229/    679E : 6A3C                   	DC.W	REM
  230/    67A0 : 6968                   	DC.W	FOR
  231/    67A2 : 6A68                   	DC.W	INPUT
  232/    67A4 : 68A8                   	DC.W	PRINT
  233/    67A6 : 6BD0                   	DC.W	POKE
  234/    67A8 : 6822                   	DC.W	STOP
  235/    67AA : 6626                   	DC.W	GOBYE
  236/    67AC : 6BE8                   	DC.W	CALL
  237/    67AE : 6ADA                   	DC.W	DEFLT
  238/    67B0 : 6DB6                   TAB4_1	DC.W	PEEK			; Functions
  239/    67B2 : 6DC2                   	DC.W	RND
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 5 - 12/13/2023 15:59:15


  240/    67B4 : 6DF8                   	DC.W	ABS
  241/    67B6 : 6E08                   	DC.W	SIZE
  242/    67B8 : 6CBA                   	DC.W	XP40
  243/    67BA : 6982                   TAB5_1	DC.W	FR1			; "TO" in "FOR"
  244/    67BC : 6E56                   	DC.W	QWHAT
  245/    67BE : 6998                   TAB6_1	DC.W	FR2			; "STEP" in "FOR"
  246/    67C0 : 699E                   	DC.W	FR3
  247/    67C2 : 6C0C                   TAB8_1	DC.W	XP11	; >=		; Relational operators
  248/    67C4 : 6C12                   	DC.W	XP12	; <>
  249/    67C6 : 6C18                   	DC.W	XP13	; >
  250/    67C8 : 6C24                   	DC.W	XP15	; =
  251/    67CA : 6C1E                   	DC.W	XP14	; <=
  252/    67CC : 6C2C                   	DC.W	XP16	; <
  253/    67CE : 6C3C                   	DC.W	XP17
  254/    67D0 :                        ;
  255/    67D0 : 43F8 671C              DIRECT	LEA	TAB1,A1
  256/    67D4 : 45F8 6788              	LEA	TAB1_1,A2
  257/    67D8 : 6100 0944              EXEC	BSR.L	IGNBLK		; ignore leading blanks
  258/    67DC : 2648                   	MOVE.L	A0,A3		; save the pointer
  259/    67DE : 4202                   	CLR.B	D2		; clear match flag
  260/    67E0 : 1018                   EXLP	MOVE.B	(A0)+,D0	; get the program character
  261/    67E2 : 1211                   	MOVE.B	(A1),D1		; get the table character
  262/    67E4 : 6604                   	BNE	EXNGO		; If end of table,
  263/    67E6 : 204B                   	MOVE.L	A3,A0		; restore the text pointer and...
  264/    67E8 : 6024                   	BRA	EXGO		; execute the default.
  265/    67EA : 1600                   EXNGO	MOVE.B	D0,D3		; Else check for period...
  266/    67EC : C602                   	AND.B	D2,D3		; and a match.
  267/    67EE : 0C03 002E              	CMPI.B	#'.',D3
  268/    67F2 : 671A                   	BEQ	EXGO		; if so, execute
  269/    67F4 : 0201 007F              	ANDI.B	#$7F,D1		; ignore the table's high bit
  270/    67F8 : B200                   	CMP.B	D0,D1		; is there a match?
  271/    67FA : 670C                   	BEQ	EXMAT
  272/    67FC : 548A                   	ADDQ.L	#2,A2		; if not, try the next entry
  273/    67FE : 204B                   	MOVE.L	A3,A0		; reset the program pointer
  274/    6800 : 4202                   	CLR.B	D2		; sorry, no match
  275/    6802 : 4A19                   EX1	TST.B	(A1)+		; get to the end of the entry
  276/    6804 : 6AFC                   	BPL	EX1
  277/    6806 : 60D8                   	BRA	EXLP		; back for more matching
  278/    6808 : 74FF                   EXMAT	MOVEQ	#-1,D2		; we've got a match so far
  279/    680A : 4A19                   	TST.B	(A1)+		; end of table entry?
  280/    680C : 6AD2                   	BPL	EXLP		; if not, go back for more
  281/    680E : 47F8 0000              EXGO	LEA	0,A3		; execute the appropriate routine
  282/    6812 : 3652                   	MOVE	(A2),A3
  283/    6814 : 4ED3                   	JMP	(A3)
  284/    6816 :                        ;
  285/    6816 :                        ;******************************************************************
  286/    6816 :                        ;
  287/    6816 :                        ; What follows is the code to execute direct and statement
  288/    6816 :                        ; commands. Control is transferred to these points via the command
  289/    6816 :                        ; table lookup code of 'DIRECT' and 'EXEC' in the last section.
  290/    6816 :                        ; After the command is executed, control is transferred to other
  291/    6816 :                        ; sections as follows:
  292/    6816 :                        ;
  293/    6816 :                        ; For 'LIST', 'NEW', and 'STOP': go back to the warm start point.
  294/    6816 :                        ; For 'RUN': go execute the first stored line if any; else go
  295/    6816 :                        ; back to the warm start point.
  296/    6816 :                        ; For 'GOTO' and 'GOSUB': go execute the target line.
  297/    6816 :                        ; For 'RETURN' and 'NEXT'; go back to saved return line.
  298/    6816 :                        ; For all others: if 'CURRNT' is 0, go to warm start; else go
  299/    6816 :                        ; execute next command. (This is done in 'FINISH'.)
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 6 - 12/13/2023 15:59:15


  300/    6816 :                        ;
  301/    6816 :                        ;******************************************************************
  302/    6816 :                        ;
  303/    6816 :                        ; *** NEW *** STOP *** RUN (& friends) *** GOTO ***
  304/    6816 :                        ;
  305/    6816 :                        ; 'NEW<CR>' sets TXTUNF to point to TXTBGN
  306/    6816 :                        ;
  307/    6816 :                        ; 'STOP<CR>' goes back to WSTART
  308/    6816 :                        ;
  309/    6816 :                        ; 'RUN<CR>' finds the first stored line, stores its address
  310/    6816 :                        ; in CURRNT, and starts executing it. Note that only those
  311/    6816 :                        ; commands in TAB2 are legal for a stored program.
  312/    6816 :                        ;
  313/    6816 :                        ; There are 3 more entries in 'RUN':
  314/    6816 :                        ; 'RUNNXL' finds next line, stores it's address and executes it.
  315/    6816 :                        ; 'RUNTSL' stores the address of this line and executes it.
  316/    6816 :                        ; 'RUNSML' continues the execution on same line.
  317/    6816 :                        ;
  318/    6816 :                        ; 'GOTO expr<CR>' evaluates the expression, finds the target
  319/    6816 :                        ; line, and jumps to 'RUNTSL' to do it.
  320/    6816 :                        ;
  321/    6816 : 6100 0632              NEW	BSR.L	ENDCHK
  322/    681A : 23F8 662A 0000 8024    	MOVE.L	TXTBGN,TXTUNF	; set the end pointer
  323/    6822 :                        
  324/    6822 : 6100 0626              STOP	BSR.L	ENDCHK
  325/    6826 : 6000 FE44              	BRA	WSTART
  326/    682A :                        
  327/    682A : 6100 061E              RUN	BSR.L	ENDCHK
  328/    682E : 2078 662A              	MOVE.L	TXTBGN,A0	; set pointer to beginning
  329/    6832 : 23C8 0000 8004         	MOVE.L	A0,CURRNT
  330/    6838 :                        
  331/    6838 : 4AB9 0000 8004         RUNNXL	TST.L	CURRNT		; executing a program?
  332/    683E : 6700 FE2C              	BEQ.L	WSTART		; if not, we've finished a direct stat.
  333/    6842 : 4281                   	CLR.L	D1		; else find the next line number
  334/    6844 : 2248                   	MOVE.L	A0,A1
  335/    6846 : 6100 0714              	BSR.L	FNDLNP
  336/    684A : 6500 FE20              	BCS	WSTART		; if we've fallen off the end, stop
  337/    684E :                        
  338/    684E : 23C9 0000 8004         RUNTSL	MOVE.L	A1,CURRNT	; set CURRNT to point to the line no.
  339/    6854 : 2049                   	MOVE.L	A1,A0		; set the text pointer to
  340/    6856 : 5488                   	ADDQ.L	#2,A0		; the start of the line text
  341/    6858 :                        
  342/    6858 : 6100 091C              RUNSML	BSR.L	CHKIO		; see if a control-C was pressed
  343/    685C : 43F8 672E              	LEA	TAB2,A1		; find command in TAB2
  344/    6860 : 45F8 6792              	LEA	TAB2_1,A2
  345/    6864 : 6000 FF72              	BRA	EXEC		; and execute it
  346/    6868 :                        
  347/    6868 : 6100 0392              GOTO	BSR.L	EXPR		; evaluate the following expression
  348/    686C : 6100 05DC              	BSR.L	ENDCHK		; must find end of line
  349/    6870 : 2200                   	MOVE.L	D0,D1
  350/    6872 : 6100 06DA              	BSR.L	FNDLN		; find the target line
  351/    6876 : 6600 062A              	BNE.L	QHOW		; no such line no.
  352/    687A : 60D2                   	BRA	RUNTSL		; go do it
  353/    687C :                        
  354/    687C :                        ;
  355/    687C :                        ;******************************************************************
  356/    687C :                        ;
  357/    687C :                        ; *** LIST *** PRINT ***
  358/    687C :                        ;
  359/    687C :                        ; LIST has two forms:
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 7 - 12/13/2023 15:59:15


  360/    687C :                        ; 'LIST<CR>' lists all saved lines
  361/    687C :                        ; 'LIST #<CR>' starts listing at the line #
  362/    687C :                        ; Control-S pauses the listing, control-C stops it.
  363/    687C :                        ;
  364/    687C :                        ; PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
  365/    687C :                        ; where '....' is a list of expressions, formats, back-arrows,
  366/    687C :                        ; and strings.  These items a separated by commas.
  367/    687C :                        ;
  368/    687C :                        ; A format is a pound sign followed by a number.  It controls
  369/    687C :                        ; the number of spaces the value of an expression is going to
  370/    687C :                        ; be printed in.  It stays effective for the rest of the print
  371/    687C :                        ; command unless changed by another format.  If no format is
  372/    687C :                        ; specified, 11 positions will be used.
  373/    687C :                        ;
  374/    687C :                        ; A string is quoted in a pair of single- or double-quotes.
  375/    687C :                        ;
  376/    687C :                        ; An underline (back-arrow) means generate a <CR> without a <LF>
  377/    687C :                        ;
  378/    687C :                        ; A <CR LF> is generated after the entire list has been printed
  379/    687C :                        ; or if the list is empty.  If the list ends with a semicolon,
  380/    687C :                        ; however, no <CR LF> is generated.
  381/    687C :                        ;
  382/    687C :                        
  383/    687C : 6100 086A              LIST	BSR.L	TSTNUM		; see if there's a line no.
  384/    6880 : 6100 05C8              	BSR.L	ENDCHK		; if not, we get a zero
  385/    6884 : 6100 06C8              	BSR.L	FNDLN		; find this or next line
  386/    6888 : 6500 FDE2              LS1	BCS	WSTART		; warm start if we passed the end
  387/    688C : 6100 0828              	BSR.L	PRTLN		; print the line
  388/    6890 : 6100 08E4              	BSR.L	CHKIO		; check for listing halt request
  389/    6894 : 670C                   	BEQ	LS3
  390/    6896 : 0C00 0013              	CMPI.B	#CTRLS,D0	; pause the listing?
  391/    689A : 6606                   	BNE	LS3
  392/    689C : 6100 08D8              LS2	BSR.L	CHKIO		; if so, wait for another keypress
  393/    68A0 : 67FA                   	BEQ	LS2
  394/    68A2 : 6100 06B8              LS3	BSR.L	FNDLNP		; find the next line
  395/    68A6 : 60E0                   	BRA	LS1
  396/    68A8 :                        
  397/    68A8 : 383C 000B              PRINT	MOVE	#11,D4		; D4 = number of print spaces
  398/    68AC : 6100 0822              	BSR.L	TSTC		; if null list and ":"
  399/    68B0 : 3A07                   	DC.B	':',PR2-1-*
  400/    68B2 : 6100 08D4              	BSR.L	CRLF		; give CR-LF and continue
  401/    68B6 : 60A0                   	BRA	RUNSML		; execution on the same line
  402/    68B8 : 6100 0816              PR2	BSR.L	TSTC		; if null list and <CR>
  403/    68BC : 0D09                   	DC.B	CR,PR0-1-*
  404/    68BE : 6100 08C8              	BSR.L	CRLF		; also give CR-LF and
  405/    68C2 : 6000 FF74              	BRA	RUNNXL		; execute the next line
  406/    68C6 : 6100 0808              PR0	BSR.L	TSTC		; else is it a format?
  407/    68CA : 2309                   	DC.B	'#',PR1-1-*
  408/    68CC : 6100 032E              	BSR.L	EXPR		; yes, evaluate expression
  409/    68D0 : 3800                   	MOVE	D0,D4		; and save it as print width
  410/    68D2 : 6016                   	BRA	PR3		; look for more to print
  411/    68D4 : 6100 07FA              PR1	BSR.L	TSTC		; is character expression? (MRL)
  412/    68D8 : 240B                   	DC.B	'$',PR4-1-*
  413/    68DA : 6100 0320              	BSR.L	EXPR		; yep. Evaluate expression (MRL)
  414/    68DE : 6100 FD36              	BSR	GOOUT		; print low byte (MRL)
  415/    68E2 : 6006                   	BRA	PR3		; look for more. (MRL)
  416/    68E4 : 6100 071E              PR4	BSR.L	QTSTG		; is it a string?
  417/    68E8 : 6012                   	BRA.S	PR8		; if not, must be an expression
  418/    68EA : 6100 07E4              PR3	BSR.L	TSTC		; if ",", go find next
  419/    68EE : 2C07                   	DC.B	',',PR6-1-*
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 8 - 12/13/2023 15:59:15


  420/    68F0 : 6100 053E              	BSR.L	FIN		; in the list.
  421/    68F4 : 60D0                   	BRA	PR0
  422/    68F6 : 6100 0890              PR6	BSR.L	CRLF		; list ends here
  423/    68FA : 6010                   	BRA	FINISH
  424/    68FC : 3F04                   PR8	MOVE	D4,-(SP)	; save the width value
  425/    68FE : 6100 02FC              	BSR.L	EXPR		; evaluate the expression
  426/    6902 : 381F                   	MOVE	(SP)+,D4	; restore the width
  427/    6904 : 2200                   	MOVE.L	D0,D1
  428/    6906 : 6100 073A              	BSR.L	PRTNUM		; print its value
  429/    690A : 60DE                   	BRA	PR3		; more to print?
  430/    690C :                        
  431/    690C : 6100 0522              FINISH	BSR.L	FIN		; Check end of command
  432/    6910 : 6000 0544              	BRA.L	QWHAT		; print "What?" if wrong
  433/    6914 :                        
  434/    6914 :                        ;
  435/    6914 :                        ;******************************************************************
  436/    6914 :                        ;
  437/    6914 :                        ; *** GOSUB *** & RETURN ***
  438/    6914 :                        ;
  439/    6914 :                        ; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
  440/    6914 :                        ; except that the current text pointer, stack pointer, etc. are
  441/    6914 :                        ; saved so that execution can be continued after the subroutine
  442/    6914 :                        ; 'RETURN's.  In order that 'GOSUB' can be nested (and even
  443/    6914 :                        ; recursive), the save area must be stacked.  The stack pointer
  444/    6914 :                        ; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
  445/    6914 :                        ; If we are in the main routine, 'STKGOS' is zero (this was done
  446/    6914 :                        ; in the initialization section of the interpreter), but we still
  447/    6914 :                        ; save it as a flag for no further 'RETURN's.
  448/    6914 :                        ;
  449/    6914 :                        ; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
  450/    6914 :                        ; returns the execution to the command after the most recent
  451/    6914 :                        ; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
  452/    6914 :                        ; a 'GOSUB' and is thus an error.
  453/    6914 :                        ;
  454/    6914 : 6100 06A0              GOSUB	BSR.L	PUSHA		; save the current 'FOR' parameters
  455/    6918 : 6100 02E2              	BSR.L	EXPR		; get line number
  456/    691C : 2F08                   	MOVE.L	A0,-(SP)	; save text pointer
  457/    691E : 2200                   	MOVE.L	D0,D1
  458/    6920 : 6100 062C              	BSR.L	FNDLN		; find the target line
  459/    6924 : 6600 057E              	BNE.L	AHOW		; if not there, say "How?"
  460/    6928 : 2F39 0000 8004         	MOVE.L	CURRNT,-(SP)	; found it, save old 'CURRNT'...
  461/    692E : 2F39 0000 8008         	MOVE.L	STKGOS,-(SP)	; and 'STKGOS'
  462/    6934 : 42B9 0000 8010         	CLR.L	LOPVAR		; load new values
  463/    693A : 23CF 0000 8008         	MOVE.L	SP,STKGOS
  464/    6940 : 6000 FF0C              	BRA	RUNTSL
  465/    6944 :                        
  466/    6944 : 6100 0504              RETURN	BSR.L	ENDCHK		; there should be just a <CR>
  467/    6948 : 2239 0000 8008         	MOVE.L	STKGOS,D1	; get old stack pointer
  468/    694E : 6700 0506              	BEQ.L	QWHAT		; if zero, it doesn't exist
  469/    6952 : 2E41                   	MOVE.L	D1,SP		; else restore it
  470/    6954 : 23DF 0000 8008         	MOVE.L	(SP)+,STKGOS	; and the old 'STKGOS'
  471/    695A : 23DF 0000 8004         	MOVE.L	(SP)+,CURRNT	; and the old 'CURRNT'
  472/    6960 : 205F                   	MOVE.L	(SP)+,A0	; and the old text pointer
  473/    6962 : 6100 062E              	BSR.L	POPA		; and the old 'FOR' parameters
  474/    6966 : 60A4                   	BRA	FINISH		; and we are back home
  475/    6968 :                        
  476/    6968 :                        ;
  477/    6968 :                        ;******************************************************************
  478/    6968 :                        ;
  479/    6968 :                        ; *** FOR *** & NEXT ***
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 9 - 12/13/2023 15:59:15


  480/    6968 :                        ;
  481/    6968 :                        ; 'FOR' has two forms:
  482/    6968 :                        ; 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
  483/    6968 :                        ; The second form means the same thing as the first form with a
  484/    6968 :                        ; STEP of positive 1.  The interpreter will find the variable 'var'
  485/    6968 :                        ; and set its value to the current value of 'exp1'.  It also
  486/    6968 :                        ; evaluates 'exp2' and 'exp1' and saves all these together with
  487/    6968 :                        ; the text pointer, etc. in the 'FOR' save area, which consisits of
  488/    6968 :                        ; 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
  489/    6968 :                        ; already something in the save area (indicated by a non-zero
  490/    6968 :                        ; 'LOPVAR'), then the old save area is saved on the stack before
  491/    6968 :                        ; the new values are stored.  The interpreter will then dig in the
  492/    6968 :                        ; stack and find out if this same variable was used in another
  493/    6968 :                        ; currently active 'FOR' loop.  If that is the case, then the old
  494/    6968 :                        ; 'FOR' loop is deactivated. (i.e. purged from the stack)
  495/    6968 :                        ;
  496/    6968 :                        ; 'NEXT var' serves as the logical (not necessarily physical) end
  497/    6968 :                        ; of the 'FOR' loop.  The control variable 'var' is checked with
  498/    6968 :                        ; the 'LOPVAR'.  If they are not the same, the interpreter digs in
  499/    6968 :                        ; the stack to find the right one and purges all those that didn't
  500/    6968 :                        ; match.  Either way, it then adds the 'STEP' to that variable and
  501/    6968 :                        ; checks the result with against the limit value.  If it is within
  502/    6968 :                        ; the limit, control loops back to the command following the
  503/    6968 :                        ; 'FOR'.  If it's outside the limit, the save area is purged and
  504/    6968 :                        ; execution continues.
  505/    6968 :                        ;
  506/    6968 : 6100 064C              FOR	BSR.L	PUSHA		; save the old 'FOR' save area
  507/    696C : 6100 04A8              	BSR.L	SETVAL		; set the control variable
  508/    6970 : 23CE 0000 8010         	MOVE.L	A6,LOPVAR	; save its address
  509/    6976 : 43F8 6775              	LEA	TAB5,A1		; use 'EXEC' to test for 'TO'
  510/    697A : 45F8 67BA              	LEA	TAB5_1,A2
  511/    697E : 6000 FE58              	BRA	EXEC
  512/    6982 : 6100 0278              FR1	BSR.L	EXPR		; evaluate the limit
  513/    6986 : 23C0 0000 8018         	MOVE.L	D0,LOPLMT	; save that
  514/    698C : 43F8 6778              	LEA	TAB6,A1		; use 'EXEC' to look for the
  515/    6990 : 45F8 67BE              	LEA	TAB6_1,A2	; word 'STEP'
  516/    6994 : 6000 FE42              	BRA	EXEC
  517/    6998 : 6100 0262              FR2	BSR.L	EXPR		; found it, get the step value
  518/    699C : 6002                   	BRA	FR4
  519/    699E : 7001                   FR3	MOVEQ	#1,D0		; not found, step defaults to 1
  520/    69A0 : 23C0 0000 8014         FR4	MOVE.L	D0,LOPINC	; save that too
  521/    69A6 : 23F9 0000 8004 0000    FR5	MOVE.L	CURRNT,LOPLN	; save address of current line number
          69AE : 801C                  
  522/    69B0 : 23C8 0000 8020         	MOVE.L	A0,LOPPT	; and text pointer
  523/    69B6 : 2C4F                   	MOVE.L	SP,A6		; dig into the stack to find 'LOPVAR'
  524/    69B8 : 6006                   	BRA	FR7
  525/    69BA : DDFC 0000 0014         FR6	ADD.L	#20,A6		; look at next stack frame
  526/    69C0 : 2016                   FR7	MOVE.L	(A6),D0		; is it zero?
  527/    69C2 : 6718                   	BEQ	FR8		; if so, we're done
  528/    69C4 : B0B9 0000 8010         	CMP.L	LOPVAR,D0	; same as current LOPVAR?
  529/    69CA : 66EE                   	BNE	FR6		; nope, look some more
  530/    69CC : 244F                   	MOVE.L	SP,A2		; Else remove 5 long words from...
  531/    69CE : 224E                   	MOVE.L	A6,A1		; inside the stack.
  532/    69D0 : 47F8 0014              	LEA	20,A3
  533/    69D4 : D7C9                   	ADD.L	A1,A3
  534/    69D6 : 6100 05B2              	BSR.L	MVDOWN
  535/    69DA : 2E4B                   	MOVE.L	A3,SP		; set the SP 5 long words up
  536/    69DC : 6000 FF2E              FR8	BRA	FINISH		; and continue execution
  537/    69E0 :                        
  538/    69E0 : 6100 0304              NEXT	BSR.L	TSTV		; get address of variable
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 10 - 12/13/2023 15:59:15


  539/    69E4 : 6500 0470              	BCS.L	QWHAT		; if no variable, say "What?"
  540/    69E8 : 2240                   	MOVE.L	D0,A1		; save variable's address
  541/    69EA : 2039 0000 8010         NX0	MOVE.L	LOPVAR,D0	; If 'LOPVAR' is zero, we never...
  542/    69F0 : 6700 0464              	BEQ.L	QWHAT		; had a FOR loop, so say "What?"
  543/    69F4 : B3C0                   	CMP.L	D0,A1		; else we check them
  544/    69F6 : 6706                   	BEQ	NX3		; OK, they agree
  545/    69F8 : 6100 0598              	BSR.L	POPA		; nope, let's see the next frame
  546/    69FC : 60EC                   	BRA	NX0
  547/    69FE : 2011                   NX3	MOVE.L	(A1),D0		; get control variable's value
  548/    6A00 : D0B9 0000 8014         	ADD.L	LOPINC,D0	; add in loop increment
  549/    6A06 : 6900 049A              	BVS.L	QHOW		; say "How?" for 32-bit overflow
  550/    6A0A : 2280                   	MOVE.L	D0,(A1)		; save control variable's new value
  551/    6A0C : 2239 0000 8018         	MOVE.L	LOPLMT,D1	; get loop's limit value
  552/    6A12 : 4AB9 0000 8014         	TST.L	LOPINC
  553/    6A18 : 6A02                   	BPL	NX1		; branch if loop increment is positive
  554/    6A1A : C141                   	EXG	D0,D1
  555/    6A1C : B280                   NX1	CMP.L	D0,D1		; test against limit
  556/    6A1E : 6D14                   	BLT	NX2		; branch if outside limit
  557/    6A20 : 23F9 0000 801C 0000    	MOVE.L	LOPLN,CURRNT	; Within limit, go back to the...
          6A28 : 8004                  
  558/    6A2A : 2079 0000 8020         	MOVE.L	LOPPT,A0	; saved 'CURRNT' and text pointer.
  559/    6A30 : 6000 FEDA              	BRA	FINISH
  560/    6A34 : 6100 055C              NX2	BSR.L	POPA		; purge this loop
  561/    6A38 : 6000 FED2              	BRA	FINISH
  562/    6A3C :                        
  563/    6A3C :                        ;
  564/    6A3C :                        ;******************************************************************
  565/    6A3C :                        ;
  566/    6A3C :                        ; *** REM *** IF *** INPUT *** LET (& DEFLT) ***
  567/    6A3C :                        ;
  568/    6A3C :                        ; 'REM' can be followed by anything and is ignored by the
  569/    6A3C :                        ; interpreter.
  570/    6A3C :                        ;
  571/    6A3C :                        ; 'IF' is followed by an expression, as a condition and one or
  572/    6A3C :                        ; more commands (including other 'IF's) separated by colons.
  573/    6A3C :                        ; Note that the word 'THEN' is not used.  The interpreter evaluates
  574/    6A3C :                        ; the expression.  If it is non-zero, execution continues.  If it
  575/    6A3C :                        ; is zero, the commands that follow are ignored and execution
  576/    6A3C :                        ; continues on the next line.
  577/    6A3C :                        ;
  578/    6A3C :                        ; 'INPUT' is like the 'PRINT' command, and is followed by a list
  579/    6A3C :                        ; of items.  If the item is a string in single or double quotes,
  580/    6A3C :                        ; or is an underline (back arrow), it has the same effect as in
  581/    6A3C :                        ; 'PRINT'.  If an item is a variable, this variable name is
  582/    6A3C :                        ; printed out followed by a colon, then the interpreter waits for
  583/    6A3C :                        ; an expression to be typed in.  The variable is then set to the
  584/    6A3C :                        ; value of this expression.  If the variable is preceeded by a
  585/    6A3C :                        ; string (again in single or double quotes), the string will be
  586/    6A3C :                        ; displayed followed by a colon.  The interpreter the waits for an
  587/    6A3C :                        ; expression to be entered and sets the variable equal to the
  588/    6A3C :                        ; expression's value.  If the input expression is invalid, the
  589/    6A3C :                        ; interpreter will print "What?", "How?", or "Sorry" and reprint
  590/    6A3C :                        ; the prompt and redo the input.  The execution will not terminate
  591/    6A3C :                        ; unless you press control-C.  This is handled in 'INPERR'.
  592/    6A3C :                        ;
  593/    6A3C :                        ; 'LET' is followed by a list of items separated by commas.
  594/    6A3C :                        ; Each item consists of a variable, an equals sign, and an
  595/    6A3C :                        ; expression.  The interpreter evaluates the expression and sets
  596/    6A3C :                        ; the variable to that value.  The interpreter will also handle
  597/    6A3C :                        ; 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 11 - 12/13/2023 15:59:15


  598/    6A3C :                        ;
  599/    6A3C : 600A                   REM	BRA	IF2		; skip the rest of the line
  600/    6A3E :                        
  601/    6A3E : 6100 01BC              IF	BSR.L	EXPR		; evaluate the expression
  602/    6A42 : 4A80                   IF1	TST.L	D0		; is it zero?
  603/    6A44 : 6600 FE12              	BNE	RUNSML		; if not, continue
  604/    6A48 : 2248                   IF2	MOVE.L	A0,A1
  605/    6A4A : 4281                   	CLR.L	D1
  606/    6A4C : 6100 052A              	BSR.L	FNDSKP		; if so, skip the rest of the line
  607/    6A50 : 6400 FDFC              	BCC	RUNTSL		; and run the next line
  608/    6A54 : 6000 FC16              	BRA.L	WSTART		; if no next line, do a warm start
  609/    6A58 :                        
  610/    6A58 : 2E79 0000 800C         INPERR	MOVE.L	STKINP,SP	; restore the old stack pointer
  611/    6A5E : 23DF 0000 8004         	MOVE.L	(SP)+,CURRNT	; and old 'CURRNT'
  612/    6A64 : 588F                   	ADDQ.L	#4,SP
  613/    6A66 : 205F                   	MOVE.L	(SP)+,A0	; and old text pointer
  614/    6A68 :                        
  615/    6A68 : 2F08                   INPUT	MOVE.L	A0,-(SP)	; save in case of error
  616/    6A6A : 6100 0598              	BSR.L	QTSTG		; is next item a string?
  617/    6A6E : 600A                   	BRA.S	IP2		; nope
  618/    6A70 : 6100 0274              	BSR.L	TSTV		; yes, but is it followed by a variable?
  619/    6A74 : 6556                   	BCS	IP4		; if not, branch
  620/    6A76 : 2440                   	MOVE.L	D0,A2		; put away the variable's address
  621/    6A78 : 601A                   	BRA	IP3		; if so, input to variable
  622/    6A7A : 2F08                   IP2	MOVE.L	A0,-(SP)	; save for 'PRTSTG'
  623/    6A7C : 6100 0268              	BSR.L	TSTV		; must be a variable now
  624/    6A80 : 6500 03D4              	BCS.L	QWHAT		; "What?" it isn't?
  625/    6A84 : 2440                   	MOVE.L	D0,A2		; put away the variable's address
  626/    6A86 : 1410                   	MOVE.B	(A0),D2		; get ready for 'PRTSTG'
  627/    6A88 : 4200                   	CLR.B	D0
  628/    6A8A : 1080                   	MOVE.B	D0,(A0)
  629/    6A8C : 225F                   	MOVE.L	(SP)+,A1
  630/    6A8E : 6100 0558              	BSR.L	PRTSTG		; print string as prompt
  631/    6A92 : 1082                   	MOVE.B	D2,(A0)		; restore text
  632/    6A94 : 2F08                   IP3	MOVE.L	A0,-(SP)	; save in case of error
  633/    6A96 : 2F39 0000 8004         	MOVE.L	CURRNT,-(SP)	; also save 'CURRNT'
  634/    6A9C : 23FC FFFF FFFF 0000    	MOVE.L	#-1,CURRNT	; flag that we are in INPUT
          6AA4 : 8004                  
  635/    6AA6 : 23CF 0000 800C         	MOVE.L	SP,STKINP	; save the stack pointer too
  636/    6AAC : 2F0A                   	MOVE.L	A2,-(SP)	; save the variable address
  637/    6AAE : 103C 003A              	MOVE.B	#':',D0		; print a colon first
  638/    6AB2 : 6100 03F6              	BSR.L	GETLN		; then get an input line
  639/    6AB6 : 41F9 0000 8030         	LEA	BUFFER,A0	; point to the buffer
  640/    6ABC : 6100 013E              	BSR.L	EXPR		; evaluate the input
  641/    6AC0 : 245F                   	MOVE.L	(SP)+,A2	; restore the variable address
  642/    6AC2 : 2480                   	MOVE.L	D0,(A2)		; save value in variable
  643/    6AC4 : 23DF 0000 8004         	MOVE.L	(SP)+,CURRNT	; restore old 'CURRNT'
  644/    6ACA : 205F                   	MOVE.L	(SP)+,A0	; and the old text pointer
  645/    6ACC : 588F                   IP4	ADDQ.L	#4,SP		; clean up the stack
  646/    6ACE : 6100 0600              	BSR.L	TSTC		; is the next thing a comma?
  647/    6AD2 : 2C03                   	DC.B	',',IP5-1-*
  648/    6AD4 : 6092                   	BRA	INPUT		; yes, more items
  649/    6AD6 : 6000 FE34              IP5	BRA	FINISH
  650/    6ADA :                        
  651/    6ADA : 0C10 000D              DEFLT	CMPI.B	#CR,(A0)	; empty line is OK
  652/    6ADE : 670C                   	BEQ	LT1		; else it is 'LET'
  653/    6AE0 :                        
  654/    6AE0 : 6100 0334              LET	BSR.L	SETVAL		; do the assignment
  655/    6AE4 : 6100 05EA              	BSR.L	TSTC		; check for more 'LET' items
  656/    6AE8 : 2C03                   	DC.B	',',LT1-1-*
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 12 - 12/13/2023 15:59:15


  657/    6AEA : 60F4                   	BRA	LET
  658/    6AEC : 6000 FE1E              LT1	BRA	FINISH		; until we are finished.
  659/    6AF0 :                        
  660/    6AF0 :                        ;
  661/    6AF0 :                        ;******************************************************************
  662/    6AF0 :                        ;
  663/    6AF0 :                        ; *** LOAD *** & SAVE ***
  664/    6AF0 :                        ;
  665/    6AF0 :                        ; These two commands transfer a program to/from an auxiliary
  666/    6AF0 :                        ; device such as a cassette, another computer, etc.  The program
  667/    6AF0 :                        ; is converted to an easily-stored format: each line starts with
  668/    6AF0 :                        ; a colon, the line no. as 4 hex digits, and the rest of the line.
  669/    6AF0 :                        ; At the end, a line starting with an '@' sign is sent.  This
  670/    6AF0 :                        ; format can be read back with a minimum of processing time by
  671/    6AF0 :                        ; the 68000.
  672/    6AF0 :                        ;
  673/    6AF0 : 2078 662A              LOAD	MOVE.L	TXTBGN,A0	; set pointer to start of prog. area
  674/    6AF4 : 103C 000D              	MOVE.B	#CR,D0		; For a CP/M host, tell it we're ready...
  675/    6AF8 : 6100 FB24              	BSR	GOAUXO		; by sending a CR to finish PIP command.
  676/    6AFC : 6100 FB24              LOD1	BSR	GOAUXI		; look for start of line
  677/    6B00 : 67FA                   	BEQ	LOD1
  678/    6B02 : 0C00 0040              	CMPI.B	#'@',D0		; end of program?
  679/    6B06 : 671E                   	BEQ	LODEND
  680/    6B08 : 0C00 003A              	CMPI.B	#':',D0		; if not, is it start of line?
  681/    6B0C : 66EE                   	BNE	LOD1		; if not, wait for it
  682/    6B0E : 6120                   	BSR	GBYTE		; get first byte of line no.
  683/    6B10 : 10C1                   	MOVE.B	D1,(A0)+	; store it
  684/    6B12 : 611C                   	BSR	GBYTE		; get 2nd bye of line no.
  685/    6B14 : 10C1                   	MOVE.B	D1,(A0)+	; store that, too
  686/    6B16 : 6100 FB0A              LOD2	BSR	GOAUXI		; get another text char.
  687/    6B1A : 67FA                   	BEQ	LOD2
  688/    6B1C : 10C0                   	MOVE.B	D0,(A0)+	; store it
  689/    6B1E : 0C00 000D              	CMPI.B	#CR,D0		; is it the end of the line?
  690/    6B22 : 66F2                   	BNE	LOD2		; if not, go back for more
  691/    6B24 : 60D6                   	BRA	LOD1		; if so, start a new line
  692/    6B26 : 23C8 0000 8024         LODEND	MOVE.L	A0,TXTUNF	; set end-of program pointer
  693/    6B2C : 6000 FB3E              	BRA	WSTART		; back to direct mode
  694/    6B30 :                        
  695/    6B30 : 7401                   GBYTE	MOVEQ	#1,D2		; get two hex characters from auxiliary
  696/    6B32 : 4241                   	CLR	D1		; and store them as a byte in D1
  697/    6B34 : 6100 FAEC              GBYTE1	BSR	GOAUXI		; get a char.
  698/    6B38 : 67FA                   	BEQ	GBYTE1
  699/    6B3A : 0C00 0041              	CMPI.B	#'A',D0
  700/    6B3E : 6502                   	BCS	GBYTE2
  701/    6B40 : 5F00                   	SUBQ.B	#7,D0		; if greater than 9, adjust
  702/    6B42 : 0200 000F              GBYTE2	ANDI.B	#$F,D0		; strip ASCII
  703/    6B46 : E909                   	LSL.B	#4,D1		; put nybble into the result
  704/    6B48 : 8200                   	OR.B	D0,D1
  705/    6B4A : 51CA FFE8              	DBRA	D2,GBYTE1	; get another char.
  706/    6B4E : 4E75                   	RTS
  707/    6B50 :                        
  708/    6B50 : 2078 662A              SAVE	MOVE.L	TXTBGN,A0	; set pointer to start of prog. area
  709/    6B54 : 2279 0000 8024         	MOVE.L	TXTUNF,A1	; set pointer to end of prog. area
  710/    6B5A : 103C 000D              SAVE1	MOVE.B	#CR,D0		; send out a CR & LF (CP/M likes this)
  711/    6B5E : 6100 FABE              	BSR	GOAUXO
  712/    6B62 : 103C 000A              	MOVE.B	#LF,D0
  713/    6B66 : 6100 FAB6              	BSR	GOAUXO
  714/    6B6A : B3C8                   	CMP.L	A0,A1		; are we finished?
  715/    6B6C : 631E                   	BLS	SAVEND
  716/    6B6E : 103C 003A              	MOVE.B	#':',D0		; if not, start a line
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 13 - 12/13/2023 15:59:15


  717/    6B72 : 6100 FAAA              	BSR	GOAUXO
  718/    6B76 : 1218                   	MOVE.B	(A0)+,D1	; send first half of line no.
  719/    6B78 : 6136                   	BSR	PBYTE
  720/    6B7A : 1218                   	MOVE.B	(A0)+,D1	; and send 2nd half
  721/    6B7C : 6132                   	BSR	PBYTE
  722/    6B7E : 1018                   SAVE2	MOVE.B	(A0)+,D0	; get a text char.
  723/    6B80 : 0C00 000D              	CMPI.B	#CR,D0		; is it the end of the line?
  724/    6B84 : 67D4                   	BEQ	SAVE1		; if so, send CR & LF and start new line
  725/    6B86 : 6100 FA96              	BSR	GOAUXO		; send it out
  726/    6B8A : 60F2                   	BRA	SAVE2		; go back for more text
  727/    6B8C : 103C 0040              SAVEND	MOVE.B	#'@',D0		; send end-of-program indicator
  728/    6B90 : 6100 FA8C              	BSR	GOAUXO
  729/    6B94 : 103C 000D              	MOVE.B	#CR,D0		; followed by a CR & LF
  730/    6B98 : 6100 FA84              	BSR	GOAUXO
  731/    6B9C : 103C 000A              	MOVE.B	#LF,D0
  732/    6BA0 : 6100 FA7C              	BSR	GOAUXO
  733/    6BA4 : 103C 001A              	MOVE.B	#$1A,D0		; and a control-Z to end the CP/M file
  734/    6BA8 : 6100 FA74              	BSR	GOAUXO
  735/    6BAC : 6000 FABE              	BRA	WSTART		; then go do a warm start
  736/    6BB0 :                        
  737/    6BB0 : 7401                   PBYTE	MOVEQ	#1,D2		; send two hex characters from D1's low byte
  738/    6BB2 : E919                   PBYTE1	ROL.B	#4,D1		; get the next nybble
  739/    6BB4 : 1001                   	MOVE.B	D1,D0
  740/    6BB6 : 0200 000F              	ANDI.B	#$F,D0		; strip off garbage
  741/    6BBA : 0600 0030              	ADDI.B	#'0',D0		; make it into ASCII
  742/    6BBE : 0C00 0039              	CMPI.B	#'9',D0
  743/    6BC2 : 6302                   	BLS	PBYTE2
  744/    6BC4 : 5E00                   	ADDQ.B	#7,D0		; adjust if greater than 9
  745/    6BC6 : 6100 FA56              PBYTE2	BSR	GOAUXO		; send it out
  746/    6BCA : 51CA FFE6              	DBRA	D2,PBYTE1	; then send the next nybble
  747/    6BCE : 4E75                   	RTS
  748/    6BD0 :                        
  749/    6BD0 :                        ;
  750/    6BD0 :                        ;******************************************************************
  751/    6BD0 :                        ;
  752/    6BD0 :                        ; *** POKE *** & CALL ***
  753/    6BD0 :                        ;
  754/    6BD0 :                        ; 'POKE expr1,expr2' stores the byte from 'expr2' into the memory
  755/    6BD0 :                        ; address specified by 'expr1'.
  756/    6BD0 :                        ;
  757/    6BD0 :                        ; 'CALL expr' jumps to the machine language subroutine whose
  758/    6BD0 :                        ; starting address is specified by 'expr'.  The subroutine can use
  759/    6BD0 :                        ; all registers but must leave the stack the way it found it.
  760/    6BD0 :                        ; The subroutine returns to the interpreter by executing an RTS.
  761/    6BD0 :                        ;
  762/    6BD0 : 612A                   POKE	BSR	EXPR		; get the memory address
  763/    6BD2 : 6100 04FC              	BSR.L	TSTC		; it must be followed by a comma
  764/    6BD6 : 2C0D                   	DC.B	',',PKER-1-*
  765/    6BD8 : 2F00                   	MOVE.L	D0,-(SP)	; save the address
  766/    6BDA : 6120                   	BSR	EXPR		; get the byte to be POKE'd
  767/    6BDC : 225F                   	MOVE.L	(SP)+,A1	; get the address back
  768/    6BDE : 1280                   	MOVE.B	D0,(A1)		; store the byte in memory
  769/    6BE0 : 6000 FD2A              	BRA	FINISH
  770/    6BE4 : 6000 0270              PKER	BRA.L	QWHAT		; if no comma, say "What?"
  771/    6BE8 :                        
  772/    6BE8 : 6112                   CALL	BSR	EXPR		; get the subroutine's address
  773/    6BEA : 4A80                   	TST.L	D0		; make sure we got a valid address
  774/    6BEC : 6700 02B4              	BEQ.L	QHOW		; if not, say "How?"
  775/    6BF0 : 2F08                   	MOVE.L	A0,-(SP)	; save the text pointer
  776/    6BF2 : 2240                   	MOVE.L	D0,A1
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 14 - 12/13/2023 15:59:15


  777/    6BF4 : 4E91                   	JSR	(A1)		; jump to the subroutine
  778/    6BF6 : 205F                   	MOVE.L	(SP)+,A0	; restore the text pointer
  779/    6BF8 : 6000 FD12              	BRA	FINISH
  780/    6BFC :                        ;
  781/    6BFC :                        ;******************************************************************
  782/    6BFC :                        ;
  783/    6BFC :                        ; *** EXPR ***
  784/    6BFC :                        ;
  785/    6BFC :                        ; 'EXPR' evaluates arithmetical or logical expressions.
  786/    6BFC :                        ; <EXPR>::=<EXPR2>
  787/    6BFC :                        ;	   <EXPR2><rel.op.><EXPR2>
  788/    6BFC :                        ; where <rel.op.> is one of the operators in TAB8 and the result
  789/    6BFC :                        ; of these operations is 1 if true and 0 if false.
  790/    6BFC :                        ; <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
  791/    6BFC :                        ; where () are optional and (... are optional repeats.
  792/    6BFC :                        ; <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
  793/    6BFC :                        ; <EXPR4>::=<variable>
  794/    6BFC :                        ;	    <function>
  795/    6BFC :                        ;	    (<EXPR>)
  796/    6BFC :                        ; <EXPR> is recursive so that the variable '@' can have an <EXPR>
  797/    6BFC :                        ; as an index, functions can have an <EXPR> as arguments, and
  798/    6BFC :                        ; <EXPR4> can be an <EXPR> in parenthesis.
  799/    6BFC :                        ;
  800/    6BFC : 6152                   EXPR	BSR	EXPR2
  801/    6BFE : 2F00                   	MOVE.L	D0,-(SP)	; save <EXPR2> value
  802/    6C00 : 43F8 677D              	LEA	TAB8,A1		; look up a relational operator
  803/    6C04 : 45F8 67C2              	LEA	TAB8_1,A2
  804/    6C08 : 6000 FBCE              	BRA	EXEC		; go do it
  805/    6C0C :                        
  806/    6C0C : 6132                   XP11	BSR	XP18		; is it ">="?
  807/    6C0E : 6D24                   	BLT	XPRT0		; no, return D0=0
  808/    6C10 : 6026                   	BRA	XPRT1		; else return D0=1
  809/    6C12 :                        
  810/    6C12 : 612C                   XP12	BSR	XP18		; is it "<>"?
  811/    6C14 : 671E                   	BEQ	XPRT0		; no, return D0=0
  812/    6C16 : 6020                   	BRA	XPRT1		; else return D0=1
  813/    6C18 :                        
  814/    6C18 : 6126                   XP13	BSR	XP18		; is it ">"?
  815/    6C1A : 6F18                   	BLE	XPRT0		; no, return D0=0
  816/    6C1C : 601A                   	BRA	XPRT1		; else return D0=1
  817/    6C1E :                        
  818/    6C1E : 6120                   XP14	BSR	XP18		; is it "<="?
  819/    6C20 : 6E12                   	BGT	XPRT0		; no, return D0=0
  820/    6C22 : 6014                   	BRA	XPRT1		; else return D0=1
  821/    6C24 :                        
  822/    6C24 : 611A                   XP15	BSR	XP18		; is it "="?
  823/    6C26 : 660C                   	BNE	XPRT0		; if not, return D0=0
  824/    6C28 : 600E                   	BRA	XPRT1		; else return D0=1
  825/    6C2A : 4E75                   XP15RT	RTS
  826/    6C2C :                        
  827/    6C2C : 6112                   XP16	BSR	XP18		; is it "<"?
  828/    6C2E : 6C04                   	BGE	XPRT0		; if not, return D0=0
  829/    6C30 : 6006                   	BRA	XPRT1		; else return D0=1
  830/    6C32 : 4E75                   XP16RT	RTS
  831/    6C34 :                        
  832/    6C34 : 4280                   XPRT0	CLR.L	D0		; return D0=0 (false)
  833/    6C36 : 4E75                   	RTS
  834/    6C38 :                        
  835/    6C38 : 7001                   XPRT1	MOVEQ	#1,D0		; return D0=1 (true)
  836/    6C3A : 4E75                   	RTS
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 15 - 12/13/2023 15:59:15


  837/    6C3C :                        
  838/    6C3C : 201F                   XP17	MOVE.L	(SP)+,D0	; it's not a rel. operator
  839/    6C3E : 4E75                   	RTS			; return D0=<EXPR2>
  840/    6C40 :                        
  841/    6C40 : 201F                   XP18	MOVE.L	(SP)+,D0	; reverse the top two stack items
  842/    6C42 : 221F                   	MOVE.L	(SP)+,D1
  843/    6C44 : 2F00                   	MOVE.L	D0,-(SP)
  844/    6C46 : 2F01                   	MOVE.L	D1,-(SP)
  845/    6C48 : 6106                   	BSR	EXPR2		; do second <EXPR2>
  846/    6C4A : 221F                   	MOVE.L	(SP)+,D1
  847/    6C4C : B280                   	CMP.L	D0,D1		; compare with the first result
  848/    6C4E : 4E75                   	RTS			; return the result
  849/    6C50 :                        
  850/    6C50 : 6100 047E              EXPR2	BSR.L	TSTC		; negative sign?
  851/    6C54 : 2D05                   	DC.B	'-',XP21-1-*
  852/    6C56 : 4280                   	CLR.L	D0		; yes, fake '0-'
  853/    6C58 : 6022                   	BRA	XP26
  854/    6C5A : 6100 0474              XP21	BSR.L	TSTC		; positive sign? ignore it
  855/    6C5E : 2B01                   	DC.B	'+',XP22-1-*
  856/    6C60 : 6124                   XP22	BSR	EXPR3		; first <EXPR3>
  857/    6C62 : 6100 046C              XP23	BSR.L	TSTC		; add?
  858/    6C66 : 2B0F                   	DC.B	'+',XP25-1-*
  859/    6C68 : 2F00                   	MOVE.L	D0,-(SP)	; yes, save the value
  860/    6C6A : 611A                   	BSR	EXPR3		; get the second <EXPR3>
  861/    6C6C : 221F                   XP24	MOVE.L	(SP)+,D1
  862/    6C6E : D081                   	ADD.L	D1,D0		; add it to the first <EXPR3>
  863/    6C70 : 6900 0230              	BVS.L	QHOW		; branch if there's an overflow
  864/    6C74 : 60EC                   	BRA	XP23		; else go back for more operations
  865/    6C76 : 6100 0458              XP25	BSR.L	TSTC		; subtract?
  866/    6C7A : 2D65                   	DC.B	'-',XP42-1-*
  867/    6C7C : 2F00                   XP26	MOVE.L	D0,-(SP)	; yes, save the result of 1st <EXPR3>
  868/    6C7E : 6106                   	BSR	EXPR3		; get second <EXPR3>
  869/    6C80 : 4480                   	NEG.L	D0		; change its sign
  870/    6C82 : 4EF8 6C6C              	JMP	XP24		; and do an addition
  871/    6C86 :                        
  872/    6C86 : 6126                   EXPR3	BSR	EXPR4		; get first <EXPR4>
  873/    6C88 : 6100 0446              XP31	BSR.L	TSTC		; multiply?
  874/    6C8C : 2A0D                   	DC.B	'*',XP34-1-*
  875/    6C8E : 2F00                   	MOVE.L	D0,-(SP)	; yes, save that first result
  876/    6C90 : 611C                   	BSR	EXPR4		; get second <EXPR4>
  877/    6C92 : 221F                   	MOVE.L	(SP)+,D1
  878/    6C94 : 6100 00A2              	BSR.L	MULT32		; multiply the two
  879/    6C98 : 60EE                   	BRA	XP31		; then look for more terms
  880/    6C9A : 6100 0434              XP34	BSR.L	TSTC		; divide?
  881/    6C9E : 2F41                   	DC.B	'/',XP42-1-*
  882/    6CA0 : 2F00                   	MOVE.L	D0,-(SP)	; save result of 1st <EXPR4>
  883/    6CA2 : 610A                   	BSR	EXPR4		; get second <EXPR4>
  884/    6CA4 : 221F                   	MOVE.L	(SP)+,D1
  885/    6CA6 : C141                   	EXG	D0,D1
  886/    6CA8 : 6100 00D0              	BSR.L	DIV32		; do the division
  887/    6CAC : 60DA                   	BRA	XP31		; go back for any more terms
  888/    6CAE :                        
  889/    6CAE : 43F8 6766              EXPR4	LEA	TAB4,A1		; find possible function
  890/    6CB2 : 45F8 67B0              	LEA	TAB4_1,A2
  891/    6CB6 : 6000 FB20              	BRA	EXEC
  892/    6CBA : 612A                   XP40	BSR	TSTV		; nope, not a function
  893/    6CBC : 6508                   	BCS	XP41		; nor a variable
  894/    6CBE : 2240                   	MOVE.L	D0,A1
  895/    6CC0 : 4280                   	CLR.L	D0
  896/    6CC2 : 2011                   	MOVE.L	(A1),D0		; if a variable, return its value in D0
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 16 - 12/13/2023 15:59:15


  897/    6CC4 : 4E75                   EXP4RT	RTS
  898/    6CC6 : 6100 0420              XP41	BSR.L	TSTNUM		; or is it a number?
  899/    6CCA : 2001                   	MOVE.L	D1,D0
  900/    6CCC : 4A42                   	TST	D2		; (if not, # of digits will be zero)
  901/    6CCE : 66F4                   	BNE	EXP4RT		; if so, return it in D0
  902/    6CD0 : 6100 03FE              PARN	BSR.L	TSTC		; else look for ( EXPR )
  903/    6CD4 : 280D                   	DC.B	'(',XP43-1-*
  904/    6CD6 : 6100 FF24              	BSR	EXPR
  905/    6CDA : 6100 03F4              	BSR.L	TSTC
  906/    6CDE : 2903                   	DC.B	')',XP43-1-*
  907/    6CE0 : 4E75                   XP42	RTS
  908/    6CE2 : 6000 0172              XP43	BRA.L	QWHAT		; else say "What?"
  909/    6CE6 :                        
  910/    6CE6 :                        ;
  911/    6CE6 :                        ; =====	Test for a valid variable name.  Returns Carry=1 if not
  912/    6CE6 :                        ;	found, else returns Carry=0 and the address of the
  913/    6CE6 :                        ;	variable in D0.
  914/    6CE6 :                        
  915/    6CE6 : 6100 0436              TSTV	BSR.L	IGNBLK
  916/    6CEA : 4280                   	CLR.L	D0
  917/    6CEC : 1010                   	MOVE.B	(A0),D0		; look at the program text
  918/    6CEE : 0400 0040              	SUBI.B	#'@',D0
  919/    6CF2 : 6542                   	BCS	TSTVRT		; C=1: not a variable
  920/    6CF4 : 6628                   	BNE	TV1		; branch if not "@" array
  921/    6CF6 : 5248                   	ADDQ	#1,A0		; If it is, it should be
  922/    6CF8 : 61D6                   	BSR	PARN		; followed by (EXPR) as its index.
  923/    6CFA : D080                   	ADD.L	D0,D0
  924/    6CFC : 6500 01A4              	BCS.L	QHOW		; say "How?" if index is too big
  925/    6D00 : D080                   	ADD.L	D0,D0
  926/    6D02 : 6500 019E              	BCS.L	QHOW
  927/    6D06 : 2F00                   	MOVE.L	D0,-(SP)	; save the index
  928/    6D08 : 6100 00FE              	BSR.L	SIZE		; get amount of free memory
  929/    6D0C : 221F                   	MOVE.L	(SP)+,D1	; get back the index
  930/    6D0E : B081                   	CMP.L	D1,D0		; see if there's enough memory
  931/    6D10 : 6300 0188              	BLS.L	QSORRY		; if not, say "Sorry"
  932/    6D14 : 2039 0000 8028         	MOVE.L	VARBGN,D0	; put address of array element...
  933/    6D1A : 9081                   	SUB.L	D1,D0		; into D0
  934/    6D1C : 4E75                   	RTS
  935/    6D1E : 0C00 001B              TV1	CMPI.B	#27,D0		; if not @, is it A through Z?
  936/    6D22 : 0A3C 0001              	EOR	#1,CCR
  937/    6D26 : 650E                   	BCS	TSTVRT		; if not, set Carry and return
  938/    6D28 : 5248                   	ADDQ	#1,A0		; else bump the text pointer
  939/    6D2A : D040                   	ADD	D0,D0		; compute the variable's address
  940/    6D2C : D040                   	ADD	D0,D0
  941/    6D2E : 2239 0000 8028         	MOVE.L	VARBGN,D1
  942/    6D34 : D041                   	ADD	D1,D0		; and return it in D0 with Carry=0
  943/    6D36 : 4E75                   TSTVRT	RTS
  944/    6D38 :                        
  945/    6D38 :                        ;
  946/    6D38 :                        ; =====	Multiplies the 32 bit values in D0 and D1, returning
  947/    6D38 :                        ;	the 32 bit result in D0.
  948/    6D38 :                        ;
  949/    6D38 : 2801                   MULT32	MOVE.L	D1,D4
  950/    6D3A : B184                   	EOR.L	D0,D4		; see if the signs are the same
  951/    6D3C : 4A80                   	TST.L	D0		; take absolute value of D0
  952/    6D3E : 6A02                   	BPL	MLT1
  953/    6D40 : 4480                   	NEG.L	D0
  954/    6D42 : 4A81                   MLT1	TST.L	D1		; take absolute value of D1
  955/    6D44 : 6A02                   	BPL	MLT2
  956/    6D46 : 4481                   	NEG.L	D1
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 17 - 12/13/2023 15:59:15


  957/    6D48 : 0C81 0000 FFFF         MLT2	CMPI.L	#$FFFF,D1	; is second argument <= 16 bits?
  958/    6D4E : 630C                   	BLS	MLT3		; OK, let it through
  959/    6D50 : C141                   	EXG	D0,D1		; else swap the two arguments
  960/    6D52 : 0C81 0000 FFFF         	CMPI.L	#$FFFF,D1	; and check 2nd argument again
  961/    6D58 : 6200 0148              	BHI.L	QHOW		; one of them MUST be 16 bits
  962/    6D5C : 3400                   MLT3	MOVE	D0,D2		; prepare for 32 bit X 16 bit multiply
  963/    6D5E : C4C1                   	MULU	D1,D2		; multiply low word
  964/    6D60 : 4840                   	SWAP	D0
  965/    6D62 : C0C1                   	MULU	D1,D0		; multiply high word
  966/    6D64 : 4840                   	SWAP	D0
  967/    6D66 :                        ;** Rick Murray's bug correction follows:
  968/    6D66 : 4A40                   	TST	D0		; if lower word not 0, then overflow
  969/    6D68 : 6600 0138              	BNE.L	QHOW		; if overflow, say "How?"
  970/    6D6C : D082                   	ADD.L	D2,D0		; D0 now holds the product
  971/    6D6E : 6B00 0132              	BMI.L	QHOW		; if sign bit set, it's an overflow
  972/    6D72 : 4A84                   	TST.L	D4		; were the signs the same?
  973/    6D74 : 6A02                   	BPL	MLTRET
  974/    6D76 : 4480                   	NEG.L	D0		; if not, make the result negative
  975/    6D78 : 4E75                   MLTRET	RTS
  976/    6D7A :                        
  977/    6D7A :                        ;
  978/    6D7A :                        ; ===== Divide the 32 bit value in D0 by the 32 bit value in D1.
  979/    6D7A :                        ;	Returns the 32 bit quotient in D0, remainder in D1.
  980/    6D7A :                        ;
  981/    6D7A : 4A81                   DIV32	TST.L	D1		; check for divide-by-zero
  982/    6D7C : 6700 0124              	BEQ.L	QHOW		; if so, say "How?"
  983/    6D80 : 2401                   	MOVE.L	D1,D2
  984/    6D82 : 2801                    	MOVE.L	D1,D4
  985/    6D84 : B184                   	EOR.L	D0,D4		; see if the signs are the same
  986/    6D86 : 4A80                   	TST.L	D0		; take absolute value of D0
  987/    6D88 : 6A02                   	BPL	DIV1
  988/    6D8A : 4480                   	NEG.L	D0
  989/    6D8C : 4A81                   DIV1	TST.L	D1		; take absolute value of D1
  990/    6D8E : 6A02                   	BPL	DIV2
  991/    6D90 : 4481                   	NEG.L	D1
  992/    6D92 : 761F                   DIV2	MOVEQ	#31,D3		; iteration count for 32 bits
  993/    6D94 : 2200                   	MOVE.L	D0,D1
  994/    6D96 : 4280                   	CLR.L	D0
  995/    6D98 : D281                   DIV3	ADD.L	D1,D1		; (This algorithm was translated from
  996/    6D9A : D180                   	ADDX.L	D0,D0		; the divide routine in Ron Cain's
  997/    6D9C : 6708                   	BEQ	DIV4		; Small-C run time library.)
  998/    6D9E : B082                   	CMP.L	D2,D0
  999/    6DA0 : 6B04                   	BMI	DIV4
 1000/    6DA2 : 5281                   	ADDQ.L	#1,D1
 1001/    6DA4 : 9082                   	SUB.L	D2,D0
 1002/    6DA6 : 51CB FFF0              DIV4	DBRA	D3,DIV3
 1003/    6DAA : C141                   	EXG	D0,D1		; put rem. & quot. in proper registers
 1004/    6DAC : 4A84                   	TST.L	D4		; were the signs the same?
 1005/    6DAE : 6A04                   	BPL	DIVRT
 1006/    6DB0 : 4480                   	NEG.L	D0		; if not, results are negative
 1007/    6DB2 : 4481                   	NEG.L	D1
 1008/    6DB4 : 4E75                   DIVRT	RTS
 1009/    6DB6 :                        
 1010/    6DB6 :                        ;
 1011/    6DB6 :                        ; =====	The PEEK function returns the byte stored at the address
 1012/    6DB6 :                        ;	contained in the following expression.
 1013/    6DB6 :                        ;
 1014/    6DB6 : 6100 FF18              PEEK	BSR	PARN		; get the memory address
 1015/    6DBA : 2240                   	MOVE.L	D0,A1
 1016/    6DBC : 4280                   	CLR.L	D0		; upper 3 bytes will be zero
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 18 - 12/13/2023 15:59:15


 1017/    6DBE : 1011                   	MOVE.B	(A1),D0		; get the addressed byte
 1018/    6DC0 : 4E75                   	RTS			; and return it
 1019/    6DC2 :                        
 1020/    6DC2 :                        ;
 1021/    6DC2 :                        ; =====	The RND function returns a random number from 1 to
 1022/    6DC2 :                        ;	the value of the following expression in D0.
 1023/    6DC2 :                        ;
 1024/    6DC2 : 6100 FF0C              RND	BSR	PARN		; get the upper limit
 1025/    6DC6 : 4A80                   	TST.L	D0		; it must be positive and non-zero
 1026/    6DC8 : 6700 00D8              	BEQ.L	QHOW
 1027/    6DCC : 6B00 00D4              	BMI.L	QHOW
 1028/    6DD0 : 2200                   	MOVE.L	D0,D1
 1029/    6DD2 : 2279 0000 8000         	MOVE.L	RANPNT,A1	; get memory as a random number
 1030/    6DD8 : B3FC 0000 720C         	CMP.L	#LSTROM,A1
 1031/    6DDE : 6504                   	BCS	RA1
 1032/    6DE0 : 43F8 660E              	LEA	START,A1	; wrap around if end of program
 1033/    6DE4 : 2019                   RA1	MOVE.L	(A1)+,D0	; get the slightly random number
 1034/    6DE6 : 0880 001F              	BCLR	#31,D0		; make sure it's positive
 1035/    6DEA : 23C9 0000 8000         	MOVE.L	A1,RANPNT	; (even I can do better than this!)
 1036/    6DF0 : 6188                   	BSR	DIV32		; RND(n)=MOD(number,n)+1
 1037/    6DF2 : 2001                   	MOVE.L	D1,D0		; MOD is the remainder of the div.
 1038/    6DF4 : 5280                   	ADDQ.L	#1,D0
 1039/    6DF6 : 4E75                   	RTS
 1040/    6DF8 :                        
 1041/    6DF8 :                        ;
 1042/    6DF8 :                        ; =====	The ABS function returns an absolute value in D0.
 1043/    6DF8 :                        ;
 1044/    6DF8 : 6100 FED6              ABS	BSR	PARN		; get the following expr.'s value
 1045/    6DFC : 4A80                   	TST.L	D0
 1046/    6DFE : 6A06                   	BPL	ABSRT
 1047/    6E00 : 4480                   	NEG.L	D0		; if negative, complement it
 1048/    6E02 : 6B00 009E              	BMI.L	QHOW		; if still negative, it was too big
 1049/    6E06 : 4E75                   ABSRT	RTS
 1050/    6E08 :                        
 1051/    6E08 :                        ;
 1052/    6E08 :                        ; ===== The SIZE function returns the size of free memory in D0.
 1053/    6E08 :                        ;
 1054/    6E08 : 2039 0000 8028         SIZE	MOVE.L	VARBGN,D0	; get the number of free bytes...
 1055/    6E0E : 90B9 0000 8024         	SUB.L	TXTUNF,D0	; between 'TXTUNF' and 'VARBGN'
 1056/    6E14 : 4E75                   	RTS			; return the number in D0
 1057/    6E16 :                        
 1058/    6E16 :                        ;
 1059/    6E16 :                        ;******************************************************************
 1060/    6E16 :                        ;
 1061/    6E16 :                        ; *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
 1062/    6E16 :                        ;
 1063/    6E16 :                        ; 'SETVAL' expects a variable, followed by an equal sign and then
 1064/    6E16 :                        ; an expression.  It evaluates the expression and sets the variable
 1065/    6E16 :                        ; to that value.
 1066/    6E16 :                        ;
 1067/    6E16 :                        ; 'FIN' checks the end of a command.  If it ended with ":",
 1068/    6E16 :                        ; execution continues.  If it ended with a CR, it finds the
 1069/    6E16 :                        ; the next line and continues from there.
 1070/    6E16 :                        ;
 1071/    6E16 :                        ; 'ENDCHK' checks if a command is ended with a CR. This is
 1072/    6E16 :                        ; required in certain commands, such as GOTO, RETURN, STOP, etc.
 1073/    6E16 :                        ;
 1074/    6E16 :                        ; 'ERROR' prints the string pointed to by A0. It then prints the
 1075/    6E16 :                        ; line pointed to by CURRNT with a "?" inserted at where the
 1076/    6E16 :                        ; old text pointer (should be on top of the stack) points to.
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 19 - 12/13/2023 15:59:15


 1077/    6E16 :                        ; Execution of Tiny BASIC is stopped and a warm start is done.
 1078/    6E16 :                        ; If CURRNT is zero (indicating a direct command), the direct
 1079/    6E16 :                        ; command is not printed. If CURRNT is -1 (indicating
 1080/    6E16 :                        ; 'INPUT' command in progress), the input line is not printed
 1081/    6E16 :                        ; and execution is not terminated but continues at 'INPERR'.
 1082/    6E16 :                        ;
 1083/    6E16 :                        ; Related to 'ERROR' are the following:
 1084/    6E16 :                        ; 'QWHAT' saves text pointer on stack and gets "What?" message.
 1085/    6E16 :                        ; 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
 1086/    6E16 :                        ; 'QSORRY' and 'ASORRY' do the same kind of thing.
 1087/    6E16 :                        ; 'QHOW' and 'AHOW' also do this for "How?".
 1088/    6E16 :                        ;
 1089/    6E16 : 6100 FECE              SETVAL	BSR	TSTV		; variable name?
 1090/    6E1A : 653A                   	BCS	QWHAT		; if not, say "What?"
 1091/    6E1C : 2F00                   	MOVE.L	D0,-(SP)	; save the variable's address
 1092/    6E1E : 6100 02B0              	BSR.L	TSTC		; get past the "=" sign
 1093/    6E22 : 3D0B                   	DC.B	'=',SV1-1-*
 1094/    6E24 : 6100 FDD6              	BSR	EXPR		; evaluate the expression
 1095/    6E28 : 2C5F                   	MOVE.L	(SP)+,A6
 1096/    6E2A : 2C80                   	MOVE.L	D0,(A6)		; and save its value in the variable
 1097/    6E2C : 4E75                   	RTS
 1098/    6E2E : 6026                   SV1	BRA	QWHAT		; if no "=" sign
 1099/    6E30 :                        
 1100/    6E30 : 6100 029E              FIN	BSR.L	TSTC		; *** FIN ***
 1101/    6E34 : 3A07                   	DC.B	':',FI1-1-*
 1102/    6E36 : 588F                   	ADDQ.L	#4,SP		; if ":", discard return address
 1103/    6E38 : 6000 FA1E              	BRA	RUNSML		; continue on the same line
 1104/    6E3C : 6100 0292              FI1	BSR.L	TSTC		; not ":", is it a CR?
 1105/    6E40 : 0D07                   	DC.B	CR,FI2-1-*
 1106/    6E42 : 588F                   	ADDQ.L	#4,SP		; yes, purge return address
 1107/    6E44 : 6000 F9F2              	BRA	RUNNXL		; execute the next line
 1108/    6E48 : 4E75                   FI2	RTS			; else return to the caller
 1109/    6E4A :                        
 1110/    6E4A : 6100 02D2              ENDCHK	BSR.L	IGNBLK
 1111/    6E4E : 0C10 000D              	CMPI.B	#CR,(A0)	; does it end with a CR?
 1112/    6E52 : 6602                   	BNE	QWHAT		; if not, say "WHAT?"
 1113/    6E54 : 4E75                   	RTS
 1114/    6E56 :                        
 1115/    6E56 : 2F08                   QWHAT	MOVE.L	A0,-(SP)
 1116/    6E58 : 4DF8 71FA              AWHAT	LEA	WHTMSG,A6
 1117/    6E5C : 6100 032E              ERROR	BSR.L	PRMESG		; display the error message
 1118/    6E60 : 205F                   	MOVE.L	(SP)+,A0	; restore the text pointer
 1119/    6E62 : 2039 0000 8004         	MOVE.L	CURRNT,D0	; get the current line number
 1120/    6E68 : 6700 F802              	BEQ	WSTART		; if zero, do a warm start
 1121/    6E6C : 0C80 FFFF FFFF         	CMPI.L	#-1,D0		; is the line no. pointer = -1?
 1122/    6E72 : 6700 FBE4              	BEQ	INPERR		; if so, redo input
 1123/    6E76 : 1F10                   	MOVE.B	(A0),-(SP)	; save the char. pointed to
 1124/    6E78 : 4210                   	CLR.B	(A0)		; put a zero where the error is
 1125/    6E7A : 2279 0000 8004         	MOVE.L	CURRNT,A1	; point to start of current line
 1126/    6E80 : 6100 0234              	BSR.L	PRTLN		; display the line in error up to the 0
 1127/    6E84 : 109F                   	MOVE.B	(SP)+,(A0)	; restore the character
 1128/    6E86 : 103C 003F              	MOVE.B	#'?',D0		; display a "?"
 1129/    6E8A : 6100 F78A              	BSR	GOOUT
 1130/    6E8E : 4240                   	CLR	D0
 1131/    6E90 : 5389                   	SUBQ.L	#1,A1		; point back to the error char.
 1132/    6E92 : 6100 0154              	BSR.L	PRTSTG		; display the rest of the line
 1133/    6E96 : 6000 F7D4              	BRA	WSTART		; and do a warm start
 1134/    6E9A : 2F08                   QSORRY	MOVE.L	A0,-(SP)
 1135/    6E9C : 4DF8 7202              ASORRY	LEA	SRYMSG,A6
 1136/    6EA0 : 60BA                   	BRA	ERROR
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 20 - 12/13/2023 15:59:15


 1137/    6EA2 : 2F08                   QHOW	MOVE.L	A0,-(SP)	; Error: "How?"
 1138/    6EA4 : 4DF8 71F3              AHOW	LEA	HOWMSG,A6
 1139/    6EA8 : 60B2                   	BRA	ERROR
 1140/    6EAA :                        ;
 1141/    6EAA :                        ;******************************************************************
 1142/    6EAA :                        ;
 1143/    6EAA :                        ; *** GETLN *** FNDLN (& friends) ***
 1144/    6EAA :                        ;
 1145/    6EAA :                        ; 'GETLN' reads in input line into 'BUFFER'. It first prompts with
 1146/    6EAA :                        ; the character in D0 (given by the caller), then it fills the
 1147/    6EAA :                        ; buffer and echos. It ignores LF's but still echos
 1148/    6EAA :                        ; them back. Control-H is used to delete the last character
 1149/    6EAA :                        ; entered (if there is one), and control-X is used to delete the
 1150/    6EAA :                        ; whole line and start over again. CR signals the end of a line,
 1151/    6EAA :                        ; and causes 'GETLN' to return.
 1152/    6EAA :                        ;
 1153/    6EAA :                        ; 'FNDLN' finds a line with a given line no. (in D1) in the
 1154/    6EAA :                        ; text save area.  A1 is used as the text pointer. If the line
 1155/    6EAA :                        ; is found, A1 will point to the beginning of that line
 1156/    6EAA :                        ; (i.e. the high byte of the line no.), and flags are NC & Z.
 1157/    6EAA :                        ; If that line is not there and a line with a higher line no.
 1158/    6EAA :                        ; is found, A1 points there and flags are NC & NZ. If we reached
 1159/    6EAA :                        ; the end of the text save area and cannot find the line, flags
 1160/    6EAA :                        ; are C & NZ.
 1161/    6EAA :                        ; 'FNDLN' will initialize A1 to the beginning of the text save
 1162/    6EAA :                        ; area to start the search. Some other entries of this routine
 1163/    6EAA :                        ; will not initialize A1 and do the search.
 1164/    6EAA :                        ; 'FNDLNP' will start with A1 and search for the line no.
 1165/    6EAA :                        ; 'FNDNXT' will bump A1 by 2, find a CR and then start search.
 1166/    6EAA :                        ; 'FNDSKP' uses A1 to find a CR, and then starts the search.
 1167/    6EAA :                        ;
 1168/    6EAA : 6100 F76A              GETLN	BSR	GOOUT		; display the prompt
 1169/    6EAE : 103C 0020              	MOVE.B	#' ',D0		; and a space
 1170/    6EB2 : 6100 F762              	BSR	GOOUT
 1171/    6EB6 : 41F9 0000 8030         	LEA	BUFFER,A0	; A0 is the buffer pointer
 1172/    6EBC : 6100 02B8              GL1	BSR.L	CHKIO		; check keyboard
 1173/    6EC0 : 67FA                   	BEQ	GL1		; wait for a char. to come in
 1174/    6EC2 : 0C00 0008              	CMPI.B	#CTRLH,D0	; delete last character?
 1175/    6EC6 : 6726                   	BEQ	GL3		; if so
 1176/    6EC8 : 0C00 0018              	CMPI.B	#CTRLX,D0	; delete the whole line?
 1177/    6ECC : 6744                   	BEQ	GL4		; if so
 1178/    6ECE : 0C00 000D              	CMPI.B	#CR,D0		; accept a CR
 1179/    6ED2 : 6706                   	BEQ	GL2
 1180/    6ED4 : 0C00 0020              	CMPI.B	#' ',D0		; if other control char., discard it
 1181/    6ED8 : 65E2                   	BCS	GL1
 1182/    6EDA : 10C0                   GL2	MOVE.B	D0,(A0)+	; save the char.
 1183/    6EDC : 6100 F738              	BSR	GOOUT		; echo the char back out
 1184/    6EE0 : 0C00 000D              	CMPI.B	#CR,D0		; if it's a CR, end the line
 1185/    6EE4 : 675E                   	BEQ	GL7
 1186/    6EE6 : B1FC 0000 807F         	CMP.L	#(BUFFER+BUFLEN-1),A0	; any more room?
 1187/    6EEC : 65CE                   	BCS	GL1		; yes: get some more, else delete last char.
 1188/    6EEE : 103C 0008              GL3	MOVE.B	#CTRLH,D0	; delete a char. if possible
 1189/    6EF2 : 6100 F722              	BSR	GOOUT
 1190/    6EF6 : 103C 0020              	MOVE.B	#' ',D0
 1191/    6EFA : 6100 F71A              	BSR	GOOUT
 1192/    6EFE : B1FC 0000 8030         	CMP.L	#BUFFER,A0	; any char.'s left?
 1193/    6F04 : 63B6                   	BLS	GL1		; if not
 1194/    6F06 : 103C 0008              	MOVE.B	#CTRLH,D0	; if so, finish the BS-space-BS sequence
 1195/    6F0A : 6100 F70A              	BSR	GOOUT
 1196/    6F0E : 5388                   	SUBQ.L	#1,A0		; decrement the text pointer
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 21 - 12/13/2023 15:59:15


 1197/    6F10 : 60AA                   	BRA	GL1		; back for more	
 1198/    6F12 : 2208                   GL4	MOVE.L	A0,D1		; delete the whole line
 1199/    6F14 : 0481 0000 8030         	SUBI.L	#BUFFER,D1	; figure out how many backspaces we need
 1200/    6F1A : 671E                   	BEQ	GL6		; if none needed, branch
 1201/    6F1C : 5341                   	SUBQ	#1,D1		; adjust for DBRA
 1202/    6F1E : 103C 0008              GL5	MOVE.B	#CTRLH,D0	; and display BS-space-BS sequences
 1203/    6F22 : 6100 F6F2              	BSR	GOOUT
 1204/    6F26 : 103C 0020              	MOVE.B	#' ',D0
 1205/    6F2A : 6100 F6EA              	BSR	GOOUT
 1206/    6F2E : 103C 0008              	MOVE.B	#CTRLH,D0
 1207/    6F32 : 6100 F6E2              	BSR	GOOUT
 1208/    6F36 : 51C9 FFE6              	DBRA	D1,GL5
 1209/    6F3A : 41F9 0000 8030         GL6	LEA	BUFFER,A0	; reinitialize the text pointer
 1210/    6F40 : 6000 FF7A              	BRA	GL1		; and go back for more
 1211/    6F44 : 103C 000A              GL7	MOVE.B	#LF,D0		; echo a LF for the CR
 1212/    6F48 : 6100 F6CC              	BSR	GOOUT
 1213/    6F4C : 4E75                   	RTS
 1214/    6F4E :                        
 1215/    6F4E : 0C81 0000 FFFF         FNDLN	CMPI.L	#$FFFF,D1	; line no. must be < 65535
 1216/    6F54 : 6400 FF4C              	BCC	QHOW
 1217/    6F58 : 2278 662A              	MOVE.L	TXTBGN,A1	; init. the text save pointer
 1218/    6F5C :                        
 1219/    6F5C : 2479 0000 8024         FNDLNP	MOVE.L	TXTUNF,A2	; check if we passed the end
 1220/    6F62 : 538A                   	SUBQ.L	#1,A2
 1221/    6F64 : B5C9                   	CMP.L	A1,A2
 1222/    6F66 : 650C                   	BCS	FNDRET		; if so, return with Z=0 & C=1
 1223/    6F68 : 1419                   	MOVE.B	(A1)+,D2	; if not, get a line no.
 1224/    6F6A : E14A                   	LSL	#8,D2
 1225/    6F6C : 1411                   	MOVE.B	(A1),D2
 1226/    6F6E : 5389                   	SUBQ.L	#1,A1
 1227/    6F70 : B441                   	CMP.W	D1,D2		; is this the line we want?
 1228/    6F72 : 6502                   	BCS	FNDNXT		; no, not there yet
 1229/    6F74 : 4E75                   FNDRET	RTS			; return the cond. codes
 1230/    6F76 :                        
 1231/    6F76 : 5489                   FNDNXT	ADDQ.L	#2,A1		; find the next line
 1232/    6F78 :                        
 1233/    6F78 : 0C19 000D              FNDSKP	CMP.B	#CR,(A1)+	; try to find a CR
 1234/    6F7C : 66FA                   	BNE	FNDSKP		; keep looking
 1235/    6F7E : 60DC                   	BRA	FNDLNP		; check if end of text
 1236/    6F80 :                        
 1237/    6F80 :                        ;
 1238/    6F80 :                        ;******************************************************************
 1239/    6F80 :                        ;
 1240/    6F80 :                        ; *** MVUP *** MVDOWN *** POPA *** PUSHA ***
 1241/    6F80 :                        ;
 1242/    6F80 :                        ; 'MVUP' moves a block up from where A1 points to where A2 points
 1243/    6F80 :                        ; until A1=A3
 1244/    6F80 :                        ;
 1245/    6F80 :                        ; 'MVDOWN' moves a block down from where A1 points to where A3
 1246/    6F80 :                        ; points until A1=A2
 1247/    6F80 :                        ;
 1248/    6F80 :                        ; 'POPA' restores the 'FOR' loop variable save area from the stack
 1249/    6F80 :                        ;
 1250/    6F80 :                        ; 'PUSHA' stacks for 'FOR' loop variable save area onto the stack
 1251/    6F80 :                        ;
 1252/    6F80 : B7C9                   MVUP	CMP.L	A1,A3		; see the above description
 1253/    6F82 : 6704                   	BEQ	MVRET
 1254/    6F84 : 14D9                   	MOVE.B	(A1)+,(A2)+
 1255/    6F86 : 60F8                   	BRA	MVUP
 1256/    6F88 : 4E75                   MVRET	RTS
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 22 - 12/13/2023 15:59:15


 1257/    6F8A :                        
 1258/    6F8A : B5C9                   MVDOWN	CMP.L	A1,A2		; see the above description
 1259/    6F8C : 67FA                   	BEQ	MVRET
 1260/    6F8E : 1721                   	MOVE.B	-(A1),-(A3)
 1261/    6F90 : 60F8                   	BRA	MVDOWN
 1262/    6F92 :                        
 1263/    6F92 : 2C5F                   POPA	MOVE.L	(SP)+,A6	; A6 = return address
 1264/    6F94 : 23DF 0000 8010         	MOVE.L	(SP)+,LOPVAR	; restore LOPVAR, but zero means no more
 1265/    6F9A : 6718                   	BEQ	PP1
 1266/    6F9C : 23DF 0000 8014         	MOVE.L	(SP)+,LOPINC	; if not zero, restore the rest
 1267/    6FA2 : 23DF 0000 8018         	MOVE.L	(SP)+,LOPLMT
 1268/    6FA8 : 23DF 0000 801C         	MOVE.L	(SP)+,LOPLN
 1269/    6FAE : 23DF 0000 8020         	MOVE.L	(SP)+,LOPPT
 1270/    6FB4 : 4ED6                   PP1	JMP	(A6)		; return
 1271/    6FB6 :                        
 1272/    6FB6 : 2239 0000 802C         PUSHA	MOVE.L	STKLMT,D1	; Are we running out of stack room?
 1273/    6FBC : 928F                   	SUB.L	SP,D1
 1274/    6FBE : 6400 FEDA              	BCC	QSORRY		; if so, say we're sorry
 1275/    6FC2 : 2C5F                   	MOVE.L	(SP)+,A6	; else get the return address
 1276/    6FC4 : 2239 0000 8010         	MOVE.L	LOPVAR,D1	; save loop variables
 1277/    6FCA : 6718                   	BEQ	PU1		; if LOPVAR is zero, that's all
 1278/    6FCC : 2F39 0000 8020         	MOVE.L	LOPPT,-(SP)	; else save all the others
 1279/    6FD2 : 2F39 0000 801C         	MOVE.L	LOPLN,-(SP)
 1280/    6FD8 : 2F39 0000 8018         	MOVE.L	LOPLMT,-(SP)
 1281/    6FDE : 2F39 0000 8014         	MOVE.L	LOPINC,-(SP)
 1282/    6FE4 : 2F01                   PU1	MOVE.L	D1,-(SP)
 1283/    6FE6 : 4ED6                   	JMP	(A6)		; return
 1284/    6FE8 :                        
 1285/    6FE8 :                        ;
 1286/    6FE8 :                        ;******************************************************************
 1287/    6FE8 :                        ;
 1288/    6FE8 :                        ; *** PRTSTG *** QTSTG *** PRTNUM *** PRTLN ***
 1289/    6FE8 :                        ;
 1290/    6FE8 :                        ; 'PRTSTG' prints a string pointed to by A1. It stops printing
 1291/    6FE8 :                        ; and returns to the caller when either a CR is printed or when
 1292/    6FE8 :                        ; the next byte is the same as what was passed in D0 by the
 1293/    6FE8 :                        ; caller.
 1294/    6FE8 :                        ;
 1295/    6FE8 :                        ; 'QTSTG' looks for an underline (back-arrow on some systems),
 1296/    6FE8 :                        ; single-quote, or double-quote.  If none of these are found, returns
 1297/    6FE8 :                        ; to the caller.  If underline, outputs a CR without a LF.  If single
 1298/    6FE8 :                        ; or double quote, prints the quoted string and demands a matching
 1299/    6FE8 :                        ; end quote.  After the printing, the next 2 bytes of the caller are
 1300/    6FE8 :                        ; skipped over (usually a short branch instruction).
 1301/    6FE8 :                        ;
 1302/    6FE8 :                        ; 'PRTNUM' prints the 32 bit number in D1, leading blanks are added if
 1303/    6FE8 :                        ; needed to pad the number of spaces to the number in D4.
 1304/    6FE8 :                        ; However, if the number of digits is larger than the no. in
 1305/    6FE8 :                        ; D4, all digits are printed anyway. Negative sign is also
 1306/    6FE8 :                        ; printed and counted in, positive sign is not.
 1307/    6FE8 :                        ;
 1308/    6FE8 :                        ; 'PRTLN' prints the saved text line pointed to by A1
 1309/    6FE8 :                        ; with line no. and all.
 1310/    6FE8 :                        ;
 1311/    6FE8 : 1200                   PRTSTG	MOVE.B	D0,D1		; save the stop character
 1312/    6FEA : 1019                   PS1	MOVE.B	(A1)+,D0	; get a text character
 1313/    6FEC : B200                   	CMP.B	D0,D1		; same as stop character?
 1314/    6FEE : 6712                   	BEQ	PRTRET		; if so, return
 1315/    6FF0 : 6100 F624              	BSR	GOOUT		; display the char.
 1316/    6FF4 : 0C00 000D              	CMPI.B	#CR,D0		; is it a C.R.?
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 23 - 12/13/2023 15:59:15


 1317/    6FF8 : 66F0                   	BNE	PS1		; no, go back for more
 1318/    6FFA : 103C 000A              	MOVE.B	#LF,D0		; yes, add a L.F.
 1319/    6FFE : 6100 F616              	BSR	GOOUT
 1320/    7002 : 4E75                   PRTRET	RTS			; then return
 1321/    7004 :                        
 1322/    7004 : 6100 00CA              QTSTG	BSR.L	TSTC		; *** QTSTG ***
 1323/    7008 : 2219                   	DC.B	'"',QT3-1-*
 1324/    700A : 103C 0022              	MOVE.B	#'"',D0		; it is a "
 1325/    700E : 2248                   QT1	MOVE.L	A0,A1
 1326/    7010 : 61D6                   	BSR	PRTSTG		; print until another
 1327/    7012 : 2049                   	MOVE.L	A1,A0
 1328/    7014 : 225F                   	MOVE.L	(SP)+,A1	; pop return address
 1329/    7016 : 0C00 000A              	CMPI.B	#LF,D0		; was last one a CR?
 1330/    701A : 6700 F81C              	BEQ	RUNNXL		; if so, run next line
 1331/    701E : 5489                   QT2	ADDQ.L	#2,A1		; skip 2 bytes on return
 1332/    7020 : 4ED1                   	JMP	(A1)		; return
 1333/    7022 : 6100 00AC              QT3	BSR.L	TSTC		; is it a single quote?
 1334/    7026 : 2707                   	DC.B	"'",QT4-1-*
 1335/    7028 : 103C 0027              	MOVE.B	#"'",D0		; if so, do same as above
 1336/    702C : 60E0                   	BRA	QT1
 1337/    702E : 6100 00A0              QT4	BSR.L	TSTC		; is it an underline?
 1338/    7032 : 5F0D                   	DC.B	'_',QT5-1-*
 1339/    7034 : 103C 000D              	MOVE.B	#CR,D0		; if so, output a CR without LF
 1340/    7038 : 6100 F5DC              	BSR.L	GOOUT
 1341/    703C : 225F                   	MOVE.L	(SP)+,A1	; pop return address
 1342/    703E : 60DE                   	BRA	QT2
 1343/    7040 : 4E75                   QT5	RTS			; none of the above
 1344/    7042 :                        
 1345/    7042 : 2601                   PRTNUM	MOVE.L	D1,D3		; save the number for later
 1346/    7044 : 3F04                   	MOVE	D4,-(SP)	; save the width value
 1347/    7046 : 1F3C 00FF              	MOVE.B	#$FF,-(SP)	; flag for end of digit string
 1348/    704A : 4A81                   	TST.L	D1		; is it negative?
 1349/    704C : 6A04                   	BPL	PN1		; if not
 1350/    704E : 4481                   	NEG.L	D1		; else make it positive
 1351/    7050 : 5344                   	SUBQ	#1,D4		; one less for width count
 1352/    7052 : 82FC 000A              PN1	DIVU	#10,D1		; get the next digit
 1353/    7056 : 690A                   	BVS	PNOV		; overflow flag set?
 1354/    7058 : 2001                   	MOVE.L	D1,D0		; if not, save remainder
 1355/    705A : 0281 0000 FFFF         	ANDI.L	#$FFFF,D1	; strip the remainder
 1356/    7060 : 601A                   	BRA	TOASCII		; skip the overflow stuff
 1357/    7062 : 3001                   PNOV	MOVE	D1,D0		; prepare for long word division
 1358/    7064 : 4241                   	CLR.W	D1		; zero out low word
 1359/    7066 : 4841                   	SWAP	D1		; high word into low
 1360/    7068 : 82FC 000A              	DIVU	#10,D1		; divide high word
 1361/    706C : 3401                   	MOVE	D1,D2		; save quotient
 1362/    706E : 3200                   	MOVE	D0,D1		; low word into low
 1363/    7070 : 82FC 000A              	DIVU	#10,D1		; divide low word
 1364/    7074 : 2001                   	MOVE.L	D1,D0		; D0 = remainder
 1365/    7076 : 4841                   	SWAP	D1		; R/Q becomes Q/R
 1366/    7078 : 3202                   	MOVE	D2,D1		; D1 is low/high
 1367/    707A : 4841                   	SWAP	D1		; D1 is finally high/low
 1368/    707C : 4840                   TOASCII	SWAP	D0		; get remainder
 1369/    707E : 1F00                   	MOVE.B	D0,-(SP)	; stack it as a digit
 1370/    7080 : 4840                   	SWAP	D0
 1371/    7082 : 5344                   	SUBQ	#1,D4		; decrement width count
 1372/    7084 : 4A81                   	TST.L	D1		; if quotient is zero, we're done
 1373/    7086 : 66CA                   	BNE	PN1
 1374/    7088 : 5344                   	SUBQ	#1,D4		; adjust padding count for DBRA
 1375/    708A : 6B0C                   	BMI	PN4		; skip padding if not needed
 1376/    708C : 103C 0020              PN3	MOVE.B	#' ',D0		; display the required leading spaces
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 24 - 12/13/2023 15:59:15


 1377/    7090 : 6100 F584              	BSR	GOOUT
 1378/    7094 : 51CC FFF6              	DBRA	D4,PN3
 1379/    7098 : 4A83                   PN4	TST.L	D3		; is number negative?
 1380/    709A : 6A08                   	BPL	PN5
 1381/    709C : 103C 002D              	MOVE.B	#'-',D0		; if so, display the sign
 1382/    70A0 : 6100 F574              	BSR	GOOUT
 1383/    70A4 : 101F                   PN5	MOVE.B	(SP)+,D0	; now unstack the digits and display
 1384/    70A6 : 6B0A                   	BMI	PNRET		; until the flag code is reached
 1385/    70A8 : 0600 0030              	ADDI.B	#'0',D0		; make into ASCII
 1386/    70AC : 6100 F568              	BSR	GOOUT
 1387/    70B0 : 60F2                   	BRA	PN5
 1388/    70B2 : 381F                   PNRET	MOVE	(SP)+,D4	; restore width value
 1389/    70B4 : 4E75                   	RTS
 1390/    70B6 :                        
 1391/    70B6 : 4281                   PRTLN	CLR.L	D1
 1392/    70B8 : 1219                   	MOVE.B	(A1)+,D1	; get the binary line number
 1393/    70BA : E149                   	LSL	#8,D1
 1394/    70BC : 1219                   	MOVE.B	(A1)+,D1
 1395/    70BE : 7805                   	MOVEQ	#5,D4		; display a 5 digit line no.
 1396/    70C0 : 6180                   	BSR	PRTNUM
 1397/    70C2 : 103C 0020              	MOVE.B	#' ',D0		; followed by a blank
 1398/    70C6 : 6100 F54E              	BSR	GOOUT
 1399/    70CA : 4240                   	CLR	D0		; stop char. is a zero
 1400/    70CC : 6000 FF1A              	BRA	PRTSTG		; display the rest of the line
 1401/    70D0 :                        
 1402/    70D0 :                        ;
 1403/    70D0 :                        ; ===== Test text byte following the call to this subroutine. If it
 1404/    70D0 :                        ;	equals the byte pointed to by A0, return to the code following
 1405/    70D0 :                        ;	the call. If they are not equal, branch to the point
 1406/    70D0 :                        ;	indicated by the offset byte following the text byte.
 1407/    70D0 :                        ;
 1408/    70D0 : 614C                   TSTC	BSR	IGNBLK		; ignore leading blanks
 1409/    70D2 : 225F                   	MOVE.L	(SP)+,A1	; get the return address
 1410/    70D4 : 1219                   	MOVE.B	(A1)+,D1	; get the byte to compare
 1411/    70D6 : B210                   	CMP.B	(A0),D1		; is it = to what A0 points to?
 1412/    70D8 : 6708                   	BEQ	TC1		; if so
 1413/    70DA : 4281                   	CLR.L	D1		; If not, add the second
 1414/    70DC : 1211                   	MOVE.B	(A1),D1		; byte following the call to
 1415/    70DE : D3C1                   	ADD.L	D1,A1		; the return address.
 1416/    70E0 : 4ED1                   	JMP	(A1)		; jump to the routine
 1417/    70E2 : 5288                   TC1	ADDQ.L	#1,A0		; if equal, bump text pointer
 1418/    70E4 : 5289                   	ADDQ.L	#1,A1		; Skip the 2 bytes following
 1419/    70E6 : 4ED1                   	JMP	(A1)		; the call and continue.
 1420/    70E8 :                        
 1421/    70E8 :                        ;
 1422/    70E8 :                        ; ===== See if the text pointed to by A0 is a number. If so,
 1423/    70E8 :                        ;	return the number in D1 and the number of digits in D2,
 1424/    70E8 :                        ;	else return zero in D1 and D2.
 1425/    70E8 :                        ;
 1426/    70E8 : 4281                   TSTNUM	CLR.L	D1		; initialize return parameters
 1427/    70EA : 4242                   	CLR	D2
 1428/    70EC : 6130                   	BSR	IGNBLK		; skip over blanks
 1429/    70EE : 0C10 0030              TN1	CMPI.B	#'0',(A0)	; is it less than zero?
 1430/    70F2 : 6528                   	BCS	TSNMRET		; if so, that's all
 1431/    70F4 : 0C10 0039              	CMPI.B	#'9',(A0)	; is it greater than nine?
 1432/    70F8 : 6222                   	BHI	TSNMRET		; if so, return
 1433/    70FA : 0C81 0CCC CCCC         	CMPI.L	#214748364,D1	; see if there's room for new digit
 1434/    7100 : 6400 FDA0              	BCC	QHOW		; if not, we've overflowd
 1435/    7104 : 2001                   	MOVE.L	D1,D0		; quickly multiply result by 10
 1436/    7106 : D281                   	ADD.L	D1,D1
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 25 - 12/13/2023 15:59:15


 1437/    7108 : D281                   	ADD.L	D1,D1
 1438/    710A : D280                   	ADD.L	D0,D1
 1439/    710C : D281                   	ADD.L	D1,D1
 1440/    710E : 1018                   	MOVE.B	(A0)+,D0	; add in the new digit
 1441/    7110 : 0280 0000 000F         	ANDI.L	#$F,D0
 1442/    7116 : D280                   	ADD.L	D0,D1
 1443/    7118 : 5242                   	ADDQ	#1,D2		; increment the no. of digits
 1444/    711A : 60D2                   	BRA	TN1
 1445/    711C : 4E75                   TSNMRET	RTS
 1446/    711E :                        
 1447/    711E :                        ;
 1448/    711E :                        ; ===== Skip over blanks in the text pointed to by A0.
 1449/    711E :                        ;
 1450/    711E : 0C10 0020              IGNBLK	CMPI.B	#' ',(A0)	; see if it's a space
 1451/    7122 : 6604                   	BNE	IGBRET		; if so, swallow it
 1452/    7124 : 5288                   IGB1	ADDQ.L	#1,A0		; increment the text pointer
 1453/    7126 : 60F6                   	BRA	IGNBLK
 1454/    7128 : 4E75                   IGBRET	RTS
 1455/    712A :                        
 1456/    712A :                        ;
 1457/    712A :                        ; =====	Convert the line of text in the input buffer to upper
 1458/    712A :                        ;	case (except for stuff between quotes).
 1459/    712A :                        ;
 1460/    712A : 41F9 0000 8030         TOUPBUF	LEA	BUFFER,A0	; set up text pointer
 1461/    7130 : 4201                   	CLR.B	D1		; clear quote flag
 1462/    7132 : 1018                   TOUPB1	MOVE.B	(A0)+,D0	; get the next text char.
 1463/    7134 : 0C00 000D              	CMPI.B	#CR,D0		; is it end of line?
 1464/    7138 : 6718                   	BEQ	TOUPBRT		; if so, return
 1465/    713A : 0C00 0022              	CMPI.B	#'"',D0		; a double quote?
 1466/    713E : 6714                   	BEQ	DOQUO
 1467/    7140 : 0C00 0027              	CMPI.B	#"'",D0		; or a single quote?
 1468/    7144 : 670E                   	BEQ	DOQUO
 1469/    7146 : 4A01                   	TST.B	D1		; inside quotes?
 1470/    7148 : 66E8                   	BNE	TOUPB1		; if so, do the next one
 1471/    714A : 6118                   	BSR	TOUPPER		; convert to upper case
 1472/    714C : 1100                   	MOVE.B	D0,-(A0)	; store it
 1473/    714E : 5288                   	ADDQ.L	#1,A0
 1474/    7150 : 60E0                   	BRA	TOUPB1		; and go back for more
 1475/    7152 : 4E75                   TOUPBRT	RTS
 1476/    7154 :                        
 1477/    7154 : 4A01                   DOQUO	TST.B	D1		; are we inside quotes?
 1478/    7156 : 6604                   	BNE	DOQUO1
 1479/    7158 : 1200                   	MOVE.B	D0,D1		; if not, toggle inside-quotes flag
 1480/    715A : 60D6                   	BRA	TOUPB1
 1481/    715C : B200                   DOQUO1	CMP.B	D0,D1		; make sure we're ending proper quote
 1482/    715E : 66D2                   	BNE	TOUPB1		; if not, ignore it
 1483/    7160 : 4201                   	CLR.B	D1		; else clear quote flag
 1484/    7162 : 60CE                   	BRA	TOUPB1
 1485/    7164 :                        
 1486/    7164 :                        ;
 1487/    7164 :                        ; ===== Convert the character in D0 to upper case
 1488/    7164 :                        ;
 1489/    7164 : 0C00 0061              TOUPPER	CMPI.B	#'a',D0		; is it < 'a'?
 1490/    7168 : 650A                   	BCS	TOUPRET
 1491/    716A : 0C00 007A              	CMPI.B	#'z',D0		; or > 'z'?
 1492/    716E : 6204                   	BHI	TOUPRET
 1493/    7170 : 0400 0020              	SUBI.B	#32,D0		; if not, make it upper case
 1494/    7174 : 4E75                   TOUPRET	RTS
 1495/    7176 :                        
 1496/    7176 :                        ;
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 26 - 12/13/2023 15:59:15


 1497/    7176 :                        ; 'CHKIO' checks the input. If there's no input, it will return
 1498/    7176 :                        ; to the caller with the Z flag set. If there is input, the Z
 1499/    7176 :                        ; flag is cleared and the input byte is in D0. However, if a
 1500/    7176 :                        ; control-C is read, 'CHKIO' will warm-start BASIC and will not
 1501/    7176 :                        ; return to the caller.
 1502/    7176 :                        ;
 1503/    7176 : 6100 F4A2              CHKIO	BSR.L	GOIN		; get input if possible
 1504/    717A : 670A                   	BEQ	CHKRET		; if Zero, no input
 1505/    717C : 0C00 0003              	CMPI.B	#CTRLC,D0	; is it control-C?
 1506/    7180 : 6604                   	BNE	CHKRET		; if not
 1507/    7182 : 6000 F4E8              	BRA.L	WSTART		; if so, do a warm start
 1508/    7186 : 4E75                   CHKRET	RTS
 1509/    7188 :                        
 1510/    7188 :                        ;
 1511/    7188 :                        ; ===== Display a CR-LF sequence
 1512/    7188 :                        ;
 1513/    7188 : 4DF8 7208              CRLF	LEA	CLMSG,A6
 1514/    718C :                        
 1515/    718C :                        ;
 1516/    718C :                        ; =====	Display a zero-ended string pointed to by register A6
 1517/    718C :                        ;
 1518/    718C : 101E                   PRMESG	MOVE.B	(A6)+,D0	; get the char.
 1519/    718E : 6706                   	BEQ	PRMRET		; if it's zero, we're done
 1520/    7190 : 6100 F484              	BSR	GOOUT		; else display it
 1521/    7194 : 60F6                   	BRA	PRMESG
 1522/    7196 : 4E75                   PRMRET	RTS
 1523/    7198 :                        
 1524/    7198 :                        ;*****************************************************
 1525/    7198 :                        ; The following routines are the only ones that need *
 1526/    7198 :                        ; to be changed for a different I/O environment.     *
 1527/    7198 :                        ;*****************************************************
 1528/    7198 :                        
 1529/    7198 :                        ;
 1530/    7198 :                        ; ===== Output character to the console (Port 1) from register D0
 1531/    7198 :                        ;	(Preserves all registers.)
 1532/    7198 :                        ;
 1533/    7198 : 0839 0001 0000 E001    OUTC	BTST	#1,ACIAC	; is port 1 ready for a character?
 1534/    71A0 : 67F6                   	BEQ	OUTC		; if not, wait for it
 1535/    71A2 : 13C0 0000 E000         	MOVE.B	D0,ACIAD	; out it goes.
 1536/    71A8 : 4E75                   	RTS
 1537/    71AA :                        
 1538/    71AA :                        ;
 1539/    71AA :                        ; ===== Input a character from the console into register D0 (or
 1540/    71AA :                        ;	return Zero status if there's no character available).
 1541/    71AA :                        ;
 1542/    71AA : 0839 0000 0000 E001    INC	BTST	#0,ACIAC	; is character ready?
 1543/    71B2 : 670A                   	BEQ	INCRET		; if not, return Zero status
 1544/    71B4 : 1039 0000 E000         	MOVE.B	ACIAD,D0	; else get the character
 1545/    71BA : 0200 007F              	ANDI.B	#$7F,D0		; zero out the high bit
 1546/    71BE : 4E75                   INCRET	RTS
 1547/    71C0 :                        
 1548/    71C0 :                        ;
 1549/    71C0 :                        ; ===== Output character to the host (Port 2) from register D0
 1550/    71C0 :                        ;	(Preserves all registers.)
 1551/    71C0 :                        ;
 1552/    71C0 : 4E75                   AUXOUT	RTS
 1553/    71C2 :                        
 1554/    71C2 :                        ;
 1555/    71C2 :                        ; ===== Input a character from the host into register D0 (or
 1556/    71C2 :                        ;	return Zero status if there's no character available).
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 27 - 12/13/2023 15:59:15


 1557/    71C2 :                        ;
 1558/    71C2 : 4E75                   AUXIN	RTS
 1559/    71C4 :                        
 1560/    71C4 :                        ;
 1561/    71C4 :                        ; =====	Return to the resident monitor, operating system, etc.
 1562/    71C4 :                        ;
 1563/    71C4 : 4E75                   BYEBYE	RTS
 1564/    71C6 :                        
 1565/    71C6 :                        
 1566/    71C6 : 0D0A 476F 7264 6F27    INITMSG	DC.B	CR,LF,"Gordo's MC68000 Tiny BASIC, v1.2",CR,LF,LF,0
          71CE : 7320 4D43 3638 3030
          71D6 : 3020 5469 6E79 2042
          71DE : 4153 4943 2C20 7631
          71E6 : 2E32 0D0A 0A00      
 1567/    71EC : 0D0A 4F4B 0D0A 00      OKMSG	DC.B	CR,LF,'OK',CR,LF,0
 1568/    71F3 : 486F 773F 0D0A 00      HOWMSG	DC.B	'How?',CR,LF,0
 1569/    71FA : 5768 6174 3F0D 0A00    WHTMSG	DC.B	'What?',CR,LF,0
 1570/    7202 : 536F 7272 792E         SRYMSG	DC.B	'Sorry.'
 1571/    7208 : 0D0A 00                CLMSG	DC.B	CR,LF,0
 1572/    720B :                        
 1573/    720B :                        	ALIGN	2
 1574/    720C :                        	
 1575/    720C : =$720C                 LSTROM	EQU	*		; end of possible ROM area
 1576/    720C :                        
 1577/    720C : FFFF FFFF FFFF FFFF    	DC.B	[(*+$100)&$FFFFFF00-*]$FF
          7214 : FFFF FFFF FFFF FFFF
          721C : FFFF FFFF FFFF FFFF
          7224 : FFFF FFFF FFFF FFFF
          722C : FFFF FFFF FFFF FFFF
          7234 : FFFF FFFF FFFF FFFF
          723C : FFFF FFFF FFFF FFFF
          7244 : FFFF FFFF FFFF FFFF
          724C : FFFF FFFF FFFF FFFF
          7254 : FFFF FFFF FFFF FFFF
          725C : FFFF FFFF FFFF FFFF
          7264 : FFFF FFFF FFFF FFFF
          726C : FFFF FFFF FFFF FFFF
          7274 : FFFF FFFF FFFF FFFF
          727C : FFFF FFFF FFFF FFFF
          7284 : FFFF FFFF FFFF FFFF
          728C : FFFF FFFF FFFF FFFF
          7294 : FFFF FFFF FFFF FFFF
          729C : FFFF FFFF FFFF FFFF
          72A4 : FFFF FFFF FFFF FFFF
          72AC : FFFF FFFF FFFF FFFF
          72B4 : FFFF FFFF FFFF FFFF
          72BC : FFFF FFFF FFFF FFFF
          72C4 : FFFF FFFF FFFF FFFF
          72CC : FFFF FFFF FFFF FFFF
          72D4 : FFFF FFFF FFFF FFFF
          72DC : FFFF FFFF FFFF FFFF
          72E4 : FFFF FFFF FFFF FFFF
          72EC : FFFF FFFF FFFF FFFF
          72F4 : FFFF FFFF FFFF FFFF
          72FC : FFFF FFFF            
 1578/    7300 :                        
 1579/    7300 :                        ;
 1580/    7300 :                        ; Internal variables follow:
 1581/    7300 :                        ;
 1582/    8000 :                        	ORG	TOPRAM
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 28 - 12/13/2023 15:59:15


 1583/    8000 :                        
 1584/    8000 :                        ;RANPNT	DC.L	START		; random number pointer
 1585/    8000 :                        RANPNT	DS.L	1		; random number pointer
 1586/    8004 :                        CURRNT	DS.L	1		; Current line pointer
 1587/    8008 :                        STKGOS	DS.L	1		; Saves stack pointer in 'GOSUB'
 1588/    800C :                        STKINP	DS.L	1		; Saves stack pointer during 'INPUT'
 1589/    8010 :                        LOPVAR	DS.L	1		; 'FOR' loop save area
 1590/    8014 :                        LOPINC	DS.L	1		; increment
 1591/    8018 :                        LOPLMT	DS.L	1		; limit
 1592/    801C :                        LOPLN	DS.L	1		; line number
 1593/    8020 :                        LOPPT	DS.L	1		; text pointer
 1594/    8024 :                        TXTUNF	DS.L	1		; points to unfilled text area
 1595/    8028 :                        VARBGN	DS.L	1		; points to variable area
 1596/    802C :                        STKLMT	DS.L	1		; holds lower limit for stack growth
 1597/    8030 :                        BUFFER	DS.B	BUFLEN		; Keyboard input buffer
 1598/    8080 : =$8080                 TXT	EQU	*
 1599/    8080 :                        
 1600/    8080 :                        	END
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 29 - 12/13/2023 15:59:15


  Symbol Table (* = unused):
  --------------------------

 ABS :                         6DF8 C |  ABSRT :                       6E06 C |
 ACIAC :                       E001 - |  ACIAD :                       E000 - |
 AHOW :                        6EA4 C |
*ARCHITECTURE :                                        "i386-unknown-win32" - |
*ASORRY :                      6E9C C |  AUXIN :                       71C2 C |
 AUXOUT :                      71C0 C | *AWHAT :                       6E58 C |
 BUFFER :                      8030 C |  BUFLEN :                        50 - |
 BYEBYE :                      71C4 C |  CALL :                        6BE8 C |
*CASESENSITIVE :                  0 - |  CHKIO :                       7176 C |
 CHKRET :                      7186 C |  CLMSG :                       7208 C |
*CONSTPI :        3.141592653589793 - |  CR :                             D - |
 CRLF :                        7188 C |  CSTART :                      6632 C |
 CTRLC :                          3 - |  CTRLH :                          8 - |
 CTRLS :                         13 - |  CTRLX :                         18 - |
 CURRNT :                      8004 C | *DATE :                "12/13/2023" - |
 DEFLT :                       6ADA C |  DIRECT :                      67D0 C |
 DIV1 :                        6D8C C |  DIV2 :                        6D92 C |
 DIV3 :                        6D98 C |  DIV32 :                       6D7A C |
 DIV4 :                        6DA6 C |  DIVRT :                       6DB4 C |
 DOQUO :                       7154 C |  DOQUO1 :                      715C C |
 ENDCHK :                      6E4A C |  ENDMEM :                      662E C |
 ENDRAM :                      A000 - |  ERROR :                       6E5C C |
 EX1 :                         6802 C |  EXEC :                        67D8 C |
 EXGO :                        680E C |  EXLP :                        67E0 C |
 EXMAT :                       6808 C |  EXNGO :                       67EA C |
 EXP4RT :                      6CC4 C |  EXPR :                        6BFC C |
 EXPR2 :                       6C50 C |  EXPR3 :                       6C86 C |
 EXPR4 :                       6CAE C | *FALSE :                          0 - |
 FI1 :                         6E3C C |  FI2 :                         6E48 C |
 FIN :                         6E30 C |  FINISH :                      690C C |
 FNDLN :                       6F4E C |  FNDLNP :                      6F5C C |
 FNDNXT :                      6F76 C |  FNDRET :                      6F74 C |
 FNDSKP :                      6F78 C |  FOR :                         6968 C |
 FR1 :                         6982 C |  FR2 :                         6998 C |
 FR3 :                         699E C |  FR4 :                         69A0 C |
*FR5 :                         69A6 C |  FR6 :                         69BA C |
 FR7 :                         69C0 C |  FR8 :                         69DC C |
*FULLPMMU :                       1 - |  GBYTE :                       6B30 C |
 GBYTE1 :                      6B34 C |  GBYTE2 :                      6B42 C |
 GETLN :                       6EAA C |  GL1 :                         6EBC C |
 GL2 :                         6EDA C |  GL3 :                         6EEE C |
 GL4 :                         6F12 C |  GL5 :                         6F1E C |
 GL6 :                         6F3A C |  GL7 :                         6F44 C |
 GOAUXI :                      6622 C |  GOAUXO :                      661E C |
 GOBYE :                       6626 C |  GOIN :                        661A C |
 GOOUT :                       6616 C |  GOSUB :                       6914 C |
 GOTO :                        6868 C | *GOWARM :                      6612 C |
*HAS64 :                          0 - | *HASFPU :                         0 - |
*HASPMMU :                        0 - |  HOWMSG :                      71F3 C |
 IF :                          6A3E C | *IF1 :                         6A42 C |
 IF2 :                         6A48 C | *IGB1 :                        7124 C |
 IGBRET :                      7128 C |  IGNBLK :                      711E C |
 INC :                         71AA C |  INCRET :                      71BE C |
 INITMSG :                     71C6 C |  INPERR :                      6A58 C |
 INPUT :                       6A68 C | *INSUPMODE :                      1 - |
 IP2 :                         6A7A C |  IP3 :                         6A94 C |
 IP4 :                         6ACC C |  IP5 :                         6AD6 C |
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 30 - 12/13/2023 15:59:15


 LET :                         6AE0 C |  LF :                             A - |
 LIST :                        687C C | *LISTON :                         1 - |
 LOAD :                        6AF0 C |  LOD1 :                        6AFC C |
 LOD2 :                        6B16 C |  LODEND :                      6B26 C |
 LOPINC :                      8014 C |  LOPLMT :                      8018 C |
 LOPLN :                       801C C |  LOPPT :                       8020 C |
 LOPVAR :                      8010 C |  LS1 :                         6888 C |
 LS2 :                         689C C |  LS3 :                         68A2 C |
 LSTROM :                      720C - |  LT1 :                         6AEC C |
*MACEXP :                         7 - |  MLT1 :                        6D42 C |
 MLT2 :                        6D48 C |  MLT3 :                        6D5C C |
 MLTRET :                      6D78 C | *MOMCPU :                     68000 - |
*MOMCPUNAME :               "68000" - |  MULT32 :                      6D38 C |
 MVDOWN :                      6F8A C |  MVRET :                       6F88 C |
 MVUP :                        6F80 C | *NESTMAX :                      100 - |
 NEW :                         6816 C |  NEXT :                        69E0 C |
 NX0 :                         69EA C |  NX1 :                         6A1C C |
 NX2 :                         6A34 C |  NX3 :                         69FE C |
 OKMSG :                       71EC C |  OUTC :                        7198 C |
*PADDING :                        1 - |  PARN :                        6CD0 C |
 PBYTE :                       6BB0 C |  PBYTE1 :                      6BB2 C |
 PBYTE2 :                      6BC6 C |  PEEK :                        6DB6 C |
 PKER :                        6BE4 C |  PN1 :                         7052 C |
 PN3 :                         708C C |  PN4 :                         7098 C |
 PN5 :                         70A4 C |  PNOV :                        7062 C |
 PNRET :                       70B2 C |  POKE :                        6BD0 C |
 POPA :                        6F92 C |  PP1 :                         6FB4 C |
 PR0 :                         68C6 C |  PR1 :                         68D4 C |
 PR2 :                         68B8 C |  PR3 :                         68EA C |
 PR4 :                         68E4 C |  PR6 :                         68F6 C |
 PR8 :                         68FC C |  PRINT :                       68A8 C |
 PRMESG :                      718C C |  PRMRET :                      7196 C |
 PRTLN :                       70B6 C |  PRTNUM :                      7042 C |
 PRTRET :                      7002 C |  PRTSTG :                      6FE8 C |
 PS1 :                         6FEA C |  PU1 :                         6FE4 C |
 PUSHA :                       6FB6 C |  QHOW :                        6EA2 C |
 QSORRY :                      6E9A C |  QT1 :                         700E C |
 QT2 :                         701E C |  QT3 :                         7022 C |
 QT4 :                         702E C |  QT5 :                         7040 C |
 QTSTG :                       7004 C |  QWHAT :                       6E56 C |
 RA1 :                         6DE4 C |  RANPNT :                      8000 C |
*RELAXED :                        0 - |  REM :                         6A3C C |
 RETURN :                      6944 C |  RND :                         6DC2 C |
 RUN :                         682A C |  RUNNXL :                      6838 C |
 RUNSML :                      6858 C |  RUNTSL :                      684E C |
 SAVE :                        6B50 C |  SAVE1 :                       6B5A C |
 SAVE2 :                       6B7E C |  SAVEND :                      6B8C C |
 SETVAL :                      6E16 C |  SIZE :                        6E08 C |
 SRYMSG :                      7202 C |  ST3 :                         668C C |
 ST4 :                         66DE C |  START :                       660E C |
 STKGOS :                      8008 C |  STKINP :                      800C C |
 STKLMT :                      802C C |  STOP :                        6822 C |
 SV1 :                         6E2E C | *TAB :                            9 - |
 TAB1 :                        671C C |  TAB1_1 :                      6788 C |
 TAB2 :                        672E C |  TAB2_1 :                      6792 C |
 TAB4 :                        6766 C |  TAB4_1 :                      67B0 C |
 TAB5 :                        6775 C |  TAB5_1 :                      67BA C |
 TAB6 :                        6778 C |  TAB6_1 :                      67BE C |
 TAB8 :                        677D C |  TAB8_1 :                      67C2 C |
 TBSC_CS :                     6600 - |  TC1 :                         70E2 C |
 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 31 - 12/13/2023 15:59:15


*TIME :                  "15:59:15" - |  TN1 :                         70EE C |
 TOASCII :                     707C C |  TOPRAM :                      8000 - |
 TOUPB1 :                      7132 C |  TOUPBRT :                     7152 C |
 TOUPBUF :                     712A C |  TOUPPER :                     7164 C |
 TOUPRET :                     7174 C | *TRUE :                           1 - |
 TSNMRET :                     711C C |  TSTC :                        70D0 C |
 TSTNUM :                      70E8 C |  TSTV :                        6CE6 C |
 TSTVRT :                      6D36 C |  TV1 :                         6D1E C |
 TXT :                         8080 - |  TXTBGN :                      662A C |
 TXTUNF :                      8024 C |  VARBGN :                      8028 C |
*VERSION :                     142F - |  WHTMSG :                      71FA C |
 WSTART :                      666C C |  XP11 :                        6C0C C |
 XP12 :                        6C12 C |  XP13 :                        6C18 C |
 XP14 :                        6C1E C |  XP15 :                        6C24 C |
*XP15RT :                      6C2A C |  XP16 :                        6C2C C |
*XP16RT :                      6C32 C |  XP17 :                        6C3C C |
 XP18 :                        6C40 C |  XP21 :                        6C5A C |
 XP22 :                        6C60 C |  XP23 :                        6C62 C |
 XP24 :                        6C6C C |  XP25 :                        6C76 C |
 XP26 :                        6C7C C |  XP31 :                        6C88 C |
 XP34 :                        6C9A C |  XP40 :                        6CBA C |
 XP41 :                        6CC6 C |  XP42 :                        6CE0 C |
 XP43 :                        6CE2 C |  XPRT0 :                       6C34 C |
 XPRT1 :                       6C38 C |

    279 symbols
     29 unused symbols

 AS V1.42 Beta [Bld 254] - Source File tbi68k.asm - Page 32 - 12/13/2023 15:59:15


  Code Pages:
  ----------

STANDARD (0 changed characters)

1 code page

0.08 seconds assembly time

   1601 lines source file
      4 passes
      0 errors
      0 warnings
