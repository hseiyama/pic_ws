 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 1 - 11/4/2023 8:40:20


       1/       0 :                     ;************************************************************************************
       2/       0 :                     ;										    										*
       3/       0 :                     ;	Enhanced BASIC for the Motorola MC680xx					    					*
       4/       0 :                     ;										    										*
       5/       0 :                     ;	This version is for the TS2 single board computer.		            			*
       6/       0 :                     ;	Jeff Tranter (tranter@pobox.com)					    						*
       7/       0 :                     ;										    										*
       8/       0 :                     ;************************************************************************************
       9/       0 :                     ;										    										*
      10/       0 :                     ;	Copyright(C) 2002-12 by Lee Davison. This program may be freely distributed 	*
      11/       0 :                     ;	for personal use only. All commercial rights are reserved.		    			*
      12/       0 :                     ;										    										*
      13/       0 :                     ;	More 68000 and other projects can be found on my website at ..		    		*
      14/       0 :                     ;										    										*
      15/       0 :                     ;	 http://mycorner.no-ip.org/index.html					    					*
      16/       0 :                     ;										    										*
      17/       0 :                     ;	mail : leeedavison@googlemail.com					    						*
      18/       0 :                     ;										    										*
      19/       0 :                     ;************************************************************************************
      20/       0 :                     
      21/       0 :                     ; Ver 3.54
      22/       0 :                     
      23/       0 :                     ; Ver 3.54 adds experimental support for LOAD/SAVE using Hobbytronics
      24/       0 :                     ; USB Flash Drive Host Board
      25/       0 :                     ; Ver 3.53 fixes math error that affected exponentiation ("^") and
      26/       0 :                     ;  EXP() function. Thanks to joelang for fix.
      27/       0 :                     ; Ver 3.52 stops USING$() from reading beyond the end of the format string
      28/       0 :                     ; Ver 3.51 fixes the UCASE$() and LCASE$() functions for null strings
      29/       0 :                     ; Ver 3.50 unary minus in concatenate generates a type mismatch error
      30/       0 :                     ; Ver 3.49 doesn't tokenise 'DEF' or 'DEC' within a hex value
      31/       0 :                     ; Ver 3.48 allows scientific notation underflow in the USING$() function
      32/       0 :                     ; Ver 3.47 traps the use of array elements as the FOR loop variable
      33/       0 :                     ; Ver 3.46 updates function and function variable handling
      34/       0 :                     
      35/       0 :                     ;************************************************************************************
      36/       0 :                     ;
      37/       0 :                     ; Ver 3.45 makes the handling of non existant variables consistent and gives the
      38/       0 :                     ; option of not returning an error for a non existant variable. If this is the
      39/       0 :                     ; behaviour you want just change novar to some non zero value
      40/       0 :                     
      41/       0 : =$0                 novar		EQU	0					; non existant variables cause errors
      42/       0 :                     
      43/       0 :                     ; Set the symbol FLASH_SUPPORT to 1 if you want to enable experimental
      44/       0 :                     ; support for LOAD/SAVE using a Hobbytronics USB Flash Drive Host
      45/       0 :                     ; Board.
      46/       0 :                     
      47/       0 : =$0                 FLASH_SUPPORT   EQU     0
      48/       0 :                     
      49/       0 :                     ;************************************************************************************
      50/       0 :                     
      51/       0 :                     ; Ver 3.44 adds overflow indication to the USING$() function
      52/       0 :                     ; Ver 3.43 removes an undocumented feature of concatenating null strings
      53/       0 :                     ; Ver 3.42 reimplements backspace so that characters are overwritten with [SPACE]
      54/       0 :                     ; Ver 3.41 removes undocumented features of the USING$() function
      55/       0 :                     ; Ver 3.40 adds the USING$() function
      56/       0 :                     ; Ver 3.33 adds the file requester to LOAD and SAVE
      57/       0 :                     ; Ver 3.32 adds the optional ELSE clause to IF .. THEN
      58/       0 :                     
      59/       0 :                     ;************************************************************************************
      60/       0 :                     ;
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 2 - 11/4/2023 8:40:20


      61/       0 :                     ; Version 3.25 adds the option to change the behaviour of INPUT so that a null
      62/       0 :                     ; response does not cause a program break. If this is the behaviour you want just
      63/       0 :                     ; change nobrk to some non zero value.
      64/       0 :                     
      65/       0 : =$0                 nobrk		EQU	0					; null response to INPUT causes a break
      66/       0 :                     
      67/       0 :                     
      68/       0 :                     ;************************************************************************************
      69/       0 :                     ;
      70/       0 :                     ; Version 3.xx replaces the fixed RAM addressing from previous versions with a RAM
      71/       0 :                     ; pointer in a3. this means that this could now be run as a task on a multitasking
      72/       0 :                     ; system where memory resources may change.
      73/       0 :                     
      74/       0 :                     
      75/       0 :                     ;************************************************************************************
      76/       0 :                     
      77/       0 :                     
      78/       0 :                     	CPU	68000
      79/       0 :                     	SUPMODE	ON
      80/       0 :                     
      81/       0 : =$2000              EBSC_CS	EQU	$00002000	; Enhanced BASIC cold start
      82/       0 : =$6000              TBSC_CS	EQU	$00006000	; Tiny BASIC cold start
      83/       0 :                     
      84/       0 :                     ;	ORG	$00000000
      85/       0 :                     ;
      86/       0 :                     ;INIVEC:
      87/       0 :                     ;	;; 0-7
      88/       0 :                     ;	DC.L	ram_addr+ram_base	; Reset: Initial SSP
      89/       0 :                     ;	DC.L	code_start			; Reset: Initial PC
      90/       0 :                     
      91/       0 :                     
      92/       0 :                     	INCLUDE	"basic68k.inc"
(1)    1/       0 :                     
(1)    2/       0 :                     ; This lot is in RAM
(1)    3/       0 :                     
(1)    4/       0 :                         		ORG     $0000			; start of RAM
(1)    5/       0 :                      
(1)    6/       0 :                     ram_strt	ds.l	$100		; allow 1K for the stack, this should be plenty
(1)    7/     400 :                     								; for any BASIC program that doesn't do something
(1)    8/     400 :                     								; silly, it could even be much less.
(1)    9/     400 :                     ram_base
(1)   10/     400 :                     LAB_WARM	ds.w	1			; BASIC warm start entry point
(1)   11/     402 :                     Wrmjpv		ds.l	1			; BASIC warm start jump vector
(1)   12/     406 :                     
(1)   13/     406 :                     Usrjmp		ds.w	1			; USR function JMP address
(1)   14/     408 :                     Usrjpv		ds.l	1			; USR function JMP vector
(1)   15/     40C :                     
(1)   16/     40C :                     ; system dependant i/o vectors
(1)   17/     40C :                     ; these are in RAM and are set at start-up
(1)   18/     40C :                     
(1)   19/     40C :                     V_INPT		ds.w	1			; non halting scan input device entry point
(1)   20/     40E :                     V_INPTv		ds.l	1			; non halting scan input device jump vector
(1)   21/     412 :                     
(1)   22/     412 :                     V_OUTP		ds.w	1			; send byte to output device entry point
(1)   23/     414 :                     V_OUTPv		ds.l	1			; send byte to output device jump vector
(1)   24/     418 :                     
(1)   25/     418 :                     V_LOAD		ds.w	1			; load BASIC program entry point
(1)   26/     41A :                     V_LOADv		ds.l	1			; load BASIC program jump vector
(1)   27/     41E :                     
(1)   28/     41E :                     V_SAVE		ds.w	1			; save BASIC program entry point
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm(basic68k.inc) - Page 3 - 11/4/2023 8:40:20


(1)   29/     420 :                     V_SAVEv		ds.l	1			; save BASIC program jump vector
(1)   30/     424 :                     
(1)   31/     424 :                     V_CTLC		ds.w	1			; save CTRL-C check entry point
(1)   32/     426 :                     V_CTLCv		ds.l	1			; save CTRL-C check jump vector
(1)   33/     42A :                     
(1)   34/     42A :                     Itemp		ds.l	1			; temporary integer	(for GOTO etc)
(1)   35/     42E :                     
(1)   36/     42E :                     Smeml		ds.l	1			; start of memory		(start of program)
(1)   37/     432 :                     
(1)   38/     432 :                     ; the program is stored as a series of lines each line having the following format
(1)   39/     432 :                     ;
(1)   40/     432 :                     ;		ds.l	1			; pointer to the next line or $00000000 if [EOT]
(1)   41/     432 :                     ;		ds.l	1			; line number
(1)   42/     432 :                     ;		ds.b	n			; program bytes
(1)   43/     432 :                     ;		dc.b	$00			; [EOL] marker, there will be a second $00 byte, if
(1)   44/     432 :                     ;						; needed, to pad the line to an even number of bytes
(1)   45/     432 :                     
(1)   46/     432 :                     Sfncl		ds.l	1			; start of functions	(end of Program)
(1)   47/     436 :                     
(1)   48/     436 :                     ; the functions are stored as function name, function execute pointer and function
(1)   49/     436 :                     ; variable name
(1)   50/     436 :                     ;
(1)   51/     436 :                     ;		ds.l	1			; name
(1)   52/     436 :                     ;		ds.l	1			; execute pointer
(1)   53/     436 :                     ;		ds.l	1			; function variable
(1)   54/     436 :                     
(1)   55/     436 :                     Svarl		ds.l	1			; start of variables	(end of functions)
(1)   56/     43A :                     
(1)   57/     43A :                     ; the variables are stored as variable name, variable value
(1)   58/     43A :                     ;
(1)   59/     43A :                     ;		ds.l	1			; name
(1)   60/     43A :                     ;		ds.l	1			; packed float or integer value
(1)   61/     43A :                     
(1)   62/     43A :                     Sstrl		ds.l	1			; start of strings	(end of variables)
(1)   63/     43E :                     
(1)   64/     43E :                     ; the strings are stored as string name, string pointer and string length
(1)   65/     43E :                     ;
(1)   66/     43E :                     ;		ds.l	1			; name
(1)   67/     43E :                     ;		ds.l	1			; string pointer
(1)   68/     43E :                     ;		ds.w	1			; string length
(1)   69/     43E :                     
(1)   70/     43E :                     Sarryl		ds.l	1			; start of arrays		(end of strings)
(1)   71/     442 :                     
(1)   72/     442 :                     ; the arrays are stored as array name, array size, array dimensions count, array
(1)   73/     442 :                     ; dimensions upper bounds and array elements
(1)   74/     442 :                     ;
(1)   75/     442 :                     ;		ds.l	1			; name
(1)   76/     442 :                     ;		ds.l	1			; size including this header
(1)   77/     442 :                     ;		ds.w	1			; dimensions count
(1)   78/     442 :                     ;		ds.w	1			; 1st dimension upper bound
(1)   79/     442 :                     ;		ds.w	1			; 2nd dimension upper bound
(1)   80/     442 :                     ;		...				; ...
(1)   81/     442 :                     ;		ds.w	1			; nth dimension upper bound
(1)   82/     442 :                     ;
(1)   83/     442 :                     ; then (i1+1)*(i2+1)...*(in+1) of either ..
(1)   84/     442 :                     ;
(1)   85/     442 :                     ;		ds.l	1			; packed float or integer value
(1)   86/     442 :                     ;
(1)   87/     442 :                     ; .. if float or integer, or ..
(1)   88/     442 :                     ;
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm(basic68k.inc) - Page 4 - 11/4/2023 8:40:20


(1)   89/     442 :                     ;		ds.l	1			; string pointer
(1)   90/     442 :                     ;		ds.w	1			; string length
(1)   91/     442 :                     ;
(1)   92/     442 :                     ; .. if string
(1)   93/     442 :                     
(1)   94/     442 :                     Earryl		ds.l	1			; end of arrays		(start of free mem)
(1)   95/     446 :                     Sstorl		ds.l	1			; string storage		(moving down)
(1)   96/     44A :                     Ememl		ds.l	1			; end of memory		(upper bound of RAM)
(1)   97/     44E :                     Sutill		ds.l	1			; string utility ptr
(1)   98/     452 :                     Clinel		ds.l	1			; current line		(Basic line number)
(1)   99/     456 :                     Blinel		ds.l	1			; break line		(Basic line number)
(1)  100/     45A :                     
(1)  101/     45A :                     Cpntrl		ds.l	1			; continue pointer
(1)  102/     45E :                     Dlinel		ds.l	1			; current DATA line
(1)  103/     462 :                     Dptrl		ds.l	1			; DATA pointer
(1)  104/     466 :                     Rdptrl		ds.l	1			; read pointer
(1)  105/     46A :                     Varname		ds.l	1			; current var name
(1)  106/     46E :                     Cvaral		ds.l	1			; current var address
(1)  107/     472 :                     Lvarpl		ds.l	1			; variable pointer for LET and FOR/NEXT
(1)  108/     476 :                     
(1)  109/     476 :                     des_sk_e	ds.l	6			; descriptor stack end address
(1)  110/     48E :                     des_sk							; descriptor stack start address
(1)  111/     48E :                     								; use a4 for the descriptor pointer
(1)  112/     48E :                     			ds.w	1			
(1)  113/     490 :                     Ibuffs		ds.l	$40			; start of input buffer
(1)  114/     590 :                     Ibuffe
(1)  115/     590 :                     								; end of input buffer
(1)  116/     590 :                     
(1)  117/     590 :                     FAC1_m		ds.l	1			; FAC1 mantissa1
(1)  118/     594 :                     FAC1_e		ds.w	1			; FAC1 exponent
(1)  119/     596 : =$595               FAC1_s		EQU	FAC1_e+1		; FAC1 sign (b7)
(1)  120/     596 :                     			ds.w	1			
(1)  121/     598 :                     
(1)  122/     598 :                     FAC2_m		ds.l	1			; FAC2 mantissa1
(1)  123/     59C :                     FAC2_e		ds.l	1			; FAC2 exponent
(1)  124/     5A0 : =$59D               FAC2_s		EQU	FAC2_e+1		; FAC2 sign (b7)
(1)  125/     5A0 : =$59E               FAC_sc		EQU	FAC2_e+2		; FAC sign comparison, Acc#1 vs #2
(1)  126/     5A0 : =$59F               flag		EQU	FAC2_e+3		; flag byte for divide routine
(1)  127/     5A0 :                     
(1)  128/     5A0 :                     PRNlword	ds.l	1			; PRNG seed long word
(1)  129/     5A4 :                     
(1)  130/     5A4 :                     ut1_pl		ds.l	1			; utility pointer 1
(1)  131/     5A8 :                     
(1)  132/     5A8 :                     Asptl		ds.l	1			; array size/pointer
(1)  133/     5AC :                     Astrtl		ds.l	1			; array start pointer
(1)  134/     5B0 :                     
(1)  135/     5B0 : =$5AC               numexp		EQU	Astrtl			; string to float number exponent count
(1)  136/     5B0 : =$5AD               expcnt		EQU	Astrtl+1		; string to float exponent count
(1)  137/     5B0 :                     
(1)  138/     5B0 : =$5AF               expneg		EQU	Astrtl+3		; string to float eval exponent -ve flag
(1)  139/     5B0 :                     
(1)  140/     5B0 :                     func_l		ds.l	1			; function pointer
(1)  141/     5B4 :                     
(1)  142/     5B4 :                     
(1)  143/     5B4 :                     								; these two need to be a word aligned pair !
(1)  144/     5B4 :                     Defdim		ds.w	1			; default DIM flag
(1)  145/     5B6 : =$5B4               cosout		EQU	Defdim			; flag which CORDIC output (re-use byte)
(1)  146/     5B6 : =$5B5               Dtypef		EQU	Defdim+1		; data type flag, $80=string, $40=integer, $00=float
(1)  147/     5B6 :                     
(1)  148/     5B6 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm(basic68k.inc) - Page 5 - 11/4/2023 8:40:20


(1)  149/     5B6 :                     Binss		ds.l	4			; number to bin string start (32 chrs)
(1)  150/     5C6 :                     
(1)  151/     5C6 :                     Decss		ds.l	1			; number to decimal string start (16 chrs)
(1)  152/     5CA :                     			ds.w	1
(1)  153/     5CC :                     Usdss		ds.w	1			; unsigned decimal string start (10 chrs)
(1)  154/     5CE :                     
(1)  155/     5CE :                     Hexss		ds.l	2			; number to hex string start (8 chrs)
(1)  156/     5D6 :                     
(1)  157/     5D6 :                     BHsend		ds.w	1			; bin/decimal/hex string end
(1)  158/     5D8 :                     
(1)  159/     5D8 :                     
(1)  160/     5D8 :                     prstk		ds.b	1			; stacked function index
(1)  161/     5D9 :                     
(1)  162/     5D9 :                     tpower		ds.b	1			; remember CORDIC power
(1)  163/     5DA :                     
(1)  164/     5DA :                     Asrch		ds.b	1			; scan-between-quotes flag, alt search character
(1)  165/     5DB :                     
(1)  166/     5DB :                     Dimcnt		ds.b	1			; # of dimensions
(1)  167/     5DC :                     
(1)  168/     5DC :                     Breakf		ds.b	1			; break flag, $00=END else=break
(1)  169/     5DD :                     Oquote		ds.b	1			; open quote flag (Flag: DATA; LIST; memory)
(1)  170/     5DE :                     Gclctd		ds.b	1			; garbage collected flag
(1)  171/     5DF :                     Sufnxf		ds.b	1			; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
(1)  172/     5E0 :                     Imode		ds.b	1			; input mode flag, $00=INPUT, $98=READ
(1)  173/     5E1 :                     
(1)  174/     5E1 :                     Cflag		ds.b	1			; comparison evaluation flag
(1)  175/     5E2 :                     
(1)  176/     5E2 :                     TabSiz		ds.b	1			; TAB step size
(1)  177/     5E3 :                     
(1)  178/     5E3 :                     comp_f		ds.b	1			; compare function flag, bits 0,1 and 2 used
(1)  179/     5E4 :                     								; bit 2 set if >
(1)  180/     5E4 :                     								; bit 1 set if =
(1)  181/     5E4 :                     								; bit 0 set if <
(1)  182/     5E4 :                     
(1)  183/     5E4 :                     Nullct		ds.b	1			; nulls output after each line
(1)  184/     5E5 :                     TPos		ds.b	1			; BASIC terminal position byte
(1)  185/     5E6 :                     TWidth		ds.b	1			; BASIC terminal width byte
(1)  186/     5E7 :                     Iclim		ds.b	1			; input column limit
(1)  187/     5E8 :                     ccflag		ds.b	1			; CTRL-C check flag
(1)  188/     5E9 :                     ccbyte		ds.b	1			; CTRL-C last received byte
(1)  189/     5EA :                     ccnull		ds.b	1			; CTRL-C last received byte 'life' timer
(1)  190/     5EB :                     
(1)  191/     5EB :                     	ALIGN	2
(1)  192/     5EC :                     
(1)  193/     5EC :                     ; these variables for load/save routines
(1)  194/     5EC :                     
(1)  195/     5EC :                     ; ifne   FLASH_SUPPORT
(1)  196/     5EC :                     ;
(1)  197/     5EC :                     ;load_first      ds.b    1               ; Boolean indicating if first byte read
(1)  198/     5EC :                     ;load_filename   ds.b    13              ; Hold LOAD/SAVE filename (DOS 8.3 format plus terminating null)
(1)  199/     5EC :                     ;
(1)  200/     5EC :                     ; endc
(1)  201/     5EC :                     ;
(1)  202/     5EC :                     ;		even			; dummy even value and zero pad byte
(1)  203/     5EC :                     
(1)  204/     5EC :                     prg_strt
(1)  205/     5EC :                     
(1)  206/     5EC :                     ; Use these two lines when running from ROM
(1)  207/     5EC : =$8000              ram_addr	EQU	$08000		; RAM start address
(1)  208/     5EC : =$2000              ram_size	EQU	$02000		; RAM size
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm(basic68k.inc) - Page 6 - 11/4/2023 8:40:20


(1)  209/     5EC :                     
(1)  210/     5EC :                     ; Use these two lines when running from RAM
(1)  211/     5EC :                     ;ram_addr	EQU	$04000		; RAM start address
(1)  212/     5EC :                     ;ram_size	EQU	$04000		; RAM size
(1)  213/     5EC :                     
      93/     5EC :                     								; RAM offset definitions
      94/     5EC :                     
      95/     5EC :                     ; Use this value to run out of ROM
      96/     5EC :                     ;	ORG		$00C000				; past the vectors in a real system
      97/     5EC :                     ; Use this value to run out of RAM
      98/    2000 :                     	ORG		EBSC_CS				; past the vectors in a real system
      99/    2000 :                     
     100/    2000 : 2E7C 0000 8400      	MOVE.L	#(ram_addr+ram_base),A7	; Reset: Initial SSP
     101/    2006 : 207C 0000 2054      	MOVE.L	#code_start,A0		; Reset: Initial PC
     102/    200C : 4ED0                	JMP	(A0)
     103/    200E :                     
     104/    200E : =$E001              ACIAC:	EQU	$0000E001
     105/    200E : =$E000              ACIAD:	EQU	$0000E000
     106/    200E :                     
     107/    200E :                     ;************************************************************************************
     108/    200E :                     ;
     109/    200E :                     ; the following code is simulator specific, change to suit your system
     110/    200E :                     ; Output character to the console from register d0.b
     111/    200E :                     
     112/    200E :                     VEC_OUT
     113/    200E : 4840                	SWAP	D0
     114/    2010 :                     CO0:
     115/    2010 : 1039 0000 E001      	MOVE.B	ACIAC,D0
     116/    2016 : C03C 0002           	AND.B	#$02,D0
     117/    201A : 67F4                	BEQ	CO0
     118/    201C : 4840                	SWAP	D0
     119/    201E : 13C0 0000 E000      	MOVE.B	D0,ACIAD
     120/    2024 : 4E75                	RTS
     121/    2026 :                     
     122/    2026 :                     ;************************************************************************************
     123/    2026 :                     ;
     124/    2026 :                     ; input a character from the console into register d0
     125/    2026 :                     ; else return Cb=0 if there's no character available
     126/    2026 :                     
     127/    2026 :                     VEC_IN
     128/    2026 : 1039 0000 E001      	MOVE.B	ACIAC,D0
     129/    202C : C03C 0001           	AND.B	#$01,D0
     130/    2030 : 6710                	BEQ     NOCHR
     131/    2032 : 1039 0000 E000      	MOVE.B	ACIAD,D0
     132/    2038 : 0000 0000           	ORI.b	#$00,d0		; set z flag on received byte
     133/    203C : 003C 0001           	ORI.b	#1,CCR		; set carry, flag we got a byte
     134/    2040 : 4E75                	RTS
     135/    2042 :                     NOCHR
     136/    2042 : 0000 0000           	ORI.b   #$00,d0
     137/    2046 : 4E75                	RTS
     138/    2048 :                     
     139/    2048 :                     ;************************************************************************************
     140/    2048 :                     ;
     141/    2048 :                     ; LOAD routine for the TS2 computer (not implemented)
     142/    2048 :                     
     143/    2048 :                     VEC_LD
     144/    2048 : 7E2E                       MOVEQ           #$2E,d7                        ; error code $2E "Not implemented" error
     145/    204A : 6000 0122                  BRA             LAB_XERR                       ; do error #d7, then warm start
     146/    204E :                     
     147/    204E :                     ;************************************************************************************
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 7 - 11/4/2023 8:40:20


     148/    204E :                     ;
     149/    204E :                     ; SAVE routine for the TS2 computer (not implemented)
     150/    204E :                     
     151/    204E :                     VEC_SV
     152/    204E : 7E2E                       MOVEQ           #$2E,d7                        ; error code $2E "Not implemented" error
     153/    2050 : 6000 011C                  BRA             LAB_XERR                       ; do error #d7, then warm start
     154/    2054 :                     
     155/    2054 :                     
     156/    2054 :                     ;************************************************************************************
     157/    2054 :                     
     158/    2054 :                     code_start
     159/    2054 :                     ;                               ; Set up ACIA parameters
     160/    2054 :                     ;        LEA.L   ACIA_1,A0      ; A0 points to console ACIA
     161/    2054 :                     ;        MOVE.B  #$15,(A0)      ; Set up ACIA1 constants (no IRQ,
     162/    2054 :                     ;                               ; RTS* low, 8 bit, no parity, 1 stop)
     163/    2054 :                     ;        LEA.L   ACIA_2,A0      ; A0 points to aux. ACIA
     164/    2054 :                     ;        MOVE.B  #$15,(A0)      ; Set up ACIA2 constants (no IRQ,
     165/    2054 :                     ;                               ; RTS* low, 8 bit, no parity, 1 stop)
     166/    2054 :                     
     167/    2054 :                     ; to tell EhBASIC where and how much RAM it has pass the address in a0 and the size
     168/    2054 :                     ; in d0. these values are at the end of the .inc file
     169/    2054 :                     
     170/    2054 : 207C 0000 8000      	MOVEA.l	#ram_addr,a0			; tell BASIC where RAM starts
     171/    205A : 203C 0000 2000      	MOVE.l	#ram_size,d0			; tell BASIC how big RAM is
     172/    2060 :                     
     173/    2060 :                     ; end of simulator specific code
     174/    2060 :                     
     175/    2060 :                     
     176/    2060 :                     ;************************************************************************************
     177/    2060 :                     ;************************************************************************************
     178/    2060 :                     ;************************************************************************************
     179/    2060 :                     ;************************************************************************************
     180/    2060 :                     ;
     181/    2060 :                     ; Register use :- (must improve this !!)
     182/    2060 :                     ;
     183/    2060 :                     ;	a6 -	temp Bpntr					; temporary BASIC execute pointer
     184/    2060 :                     ;	a5 -	Bpntr						; BASIC execute (get byte) pointer
     185/    2060 :                     ;	a4 -	des_sk				       ; descriptor stack pointer
     186/    2060 :                     ;	a3 -	ram_strt					; start of RAM. all RAM references are offsets
     187/    2060 :                     ;								; from this value
     188/    2060 :                     ;
     189/    2060 :                     
     190/    2060 :                     ;************************************************************************************
     191/    2060 :                     ;
     192/    2060 :                     ; BASIC cold start entry point. assume entry with RAM address in a0 and RAM length
     193/    2060 :                     ; in d0
     194/    2060 :                     
     195/    2060 :                     LAB_COLD
     196/    2060 :                     ;	CMP.l		#$4000,d0			; compare size with 16k
     197/    2060 :                     ;	BGE.s		LAB_sizok			; branch if >= 16k
     198/    2060 :                     ;
     199/    2060 :                     ;	MOVEQ	#5,d0					; error 5 - not enough RAM
     200/    2060 :                     ;	move.b	#228,D7					; Go to TUTOR function
     201/    2060 :                     ;	trap	#14						; Call TRAP14 handler
     202/    2060 :                     ;
     203/    2060 :                     ;LAB_sizok
     204/    2060 : 2648                	MOVEA.l	a0,a3					; copy RAM base to a3
     205/    2062 : D1C0                	ADDA.l	d0,a0					; a0 is top of RAM
     206/    2064 : 2748 044A           	MOVE.l	a0,Ememl(a3)			; set end of mem
     207/    2068 : 2E7C 0000 8400      	MOVE.l	#ram_addr+ram_base,sp	; set stack to RAM start + 1k
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 8 - 11/4/2023 8:40:20


     208/    206E :                     
     209/    206E : 303C 4EF9           	MOVE.w	#$4EF9,d0				; JMP opcode
     210/    2072 : 204F                	MOVEA.l	sp,a0					; point to start of vector table
     211/    2074 :                     
     212/    2074 : 30C0                	MOVE.w	d0,(a0)+				; LAB_WARM
     213/    2076 : 43FA FFE8           	LEA		LAB_COLD(pc),a1			; initial warm start vector
     214/    207A : 20C9                	MOVE.l	a1,(a0)+				; set vector
     215/    207C :                     
     216/    207C : 30C0                	MOVE.w	d0,(a0)+				; Usrjmp
     217/    207E : 43FA 00DC           	LEA		LAB_FCER(pc),a1			; initial user function vector
     218/    2082 :                     									; "Function call" error
     219/    2082 : 20C9                	MOVE.l	a1,(a0)+				; set vector
     220/    2084 :                     
     221/    2084 : 30C0                	MOVE.w	d0,(a0)+				; V_INPT JMP opcode
     222/    2086 : 43FA FF9E           	LEA		VEC_IN(pc),a1			; get byte from input device vector
     223/    208A : 20C9                	MOVE.l	a1,(a0)+				; set vector
     224/    208C :                     
     225/    208C : 30C0                	MOVE.w	d0,(a0)+				; V_OUTP JMP opcode
     226/    208E : 43FA FF7E           	LEA		VEC_OUT(pc),a1			; send byte to output device vector
     227/    2092 : 20C9                	MOVE.l	a1,(a0)+				; set vector
     228/    2094 :                     
     229/    2094 : 30C0                	MOVE.w	d0,(a0)+				; V_LOAD JMP opcode
     230/    2096 : 43FA FFB0           	LEA		VEC_LD(pc),a1			; load BASIC program vector
     231/    209A : 20C9                	MOVE.l	a1,(a0)+				; set vector
     232/    209C :                     
     233/    209C : 30C0                	MOVE.w	d0,(a0)+				; V_SAVE JMP opcode
     234/    209E : 43FA FFAE           	LEA		VEC_SV(pc),a1			; save BASIC program vector
     235/    20A2 : 20C9                	MOVE.l	a1,(a0)+				; set vector
     236/    20A4 :                     
     237/    20A4 : 30C0                	MOVE.w	d0,(a0)+				; V_CTLC JMP opcode
     238/    20A6 : 43FA 2634           	LEA		VEC_CC(pc),a1			; save CTRL-C check vector
     239/    20AA : 20C9                	MOVE.l	a1,(a0)+				; set vector
     240/    20AC :                     
     241/    20AC :                     ; set-up start values
     242/    20AC :                     
     243/    20AC :                     ;##LAB_GMEM
     244/    20AC : 7000                	MOVEQ	#$00,d0					; clear d0
     245/    20AE : 1740 05E4           	MOVE.b	d0,Nullct(a3)			; default NULL count
     246/    20B2 : 1740 05E5           	MOVE.b	d0,TPos(a3)				; clear terminal position
     247/    20B6 : 1740 05E8           	MOVE.b	d0,ccflag(a3)			; allow CTRL-C check
     248/    20BA : 3740 05EA           	MOVE.w	d0,prg_strt-2(a3)			; clear start word
     249/    20BE : 3740 05D6           	MOVE.w	d0,BHsend(a3)			; clear value to string end word
     250/    20C2 :                     
     251/    20C2 : 177C 0050 05E6      	MOVE.b	#$50,TWidth(a3)			; default terminal width byte for simulator
     252/    20C8 : 177C 000E 05E2      	MOVE.b	#$0E,TabSiz(a3)			; save default tab size = 14
     253/    20CE :                     
     254/    20CE : 177C 0038 05E7      	MOVE.b	#$38,Iclim(a3)			; default limit for TAB = 14 for simulator
     255/    20D4 :                     
     256/    20D4 : 49EB 048E           	LEA		des_sk(a3),a4			; set descriptor stack start
     257/    20D8 :                     
     258/    20D8 : 41EB 05EC           	LEA		prg_strt(a3),a0			; get start of mem
     259/    20DC : 2748 042E           	MOVE.l	a0,Smeml(a3)			; save start of mem
     260/    20E0 :                     
     261/    20E0 : 6100 0322           	BSR		LAB_1463				; do "NEW" and "CLEAR"
     262/    20E4 : 6100 08A0           	BSR		LAB_CRLF				; print CR/LF
     263/    20E8 : 202B 044A           	MOVE.l	Ememl(a3),d0			; get end of mem
     264/    20EC : 90AB 042E           	SUB.l		Smeml(a3),d0			; subtract start of mem
     265/    20F0 :                     
     266/    20F0 : 6100 1BDC           	BSR		LAB_295E				; print d0 as unsigned integer (bytes free)
     267/    20F4 : 41FA 3404           	LEA		LAB_SMSG(pc),a0			; point to start message
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 9 - 11/4/2023 8:40:20


     268/    20F8 : 6100 08EA           	BSR		LAB_18C3				; print null terminated string from memory
     269/    20FC :                     
     270/    20FC : 41FA 29E8           	LEA		LAB_RSED(pc),a0			; get pointer to value
     271/    2100 : 6100 1A74           	BSR		LAB_UFAC				; unpack memory (a0) into FAC1
     272/    2104 :                     
     273/    2104 : 41FA 0092           	LEA		LAB_1274(pc),a0			; get warm start vector
     274/    2108 : 2748 0402           	MOVE.l	a0,Wrmjpv(a3)			; set warm start vector
     275/    210C : 6100 1FE6           	BSR		LAB_RND					; initialise
     276/    2110 : 4EEB 0400           	JMP		LAB_WARM(a3)			; go do warm start
     277/    2114 :                     
     278/    2114 :                     
     279/    2114 :                     ;************************************************************************************
     280/    2114 :                     ;
     281/    2114 :                     ; do format error
     282/    2114 :                     
     283/    2114 :                     LAB_FOER
     284/    2114 : 7E2C                	MOVEQ		#$2C,d7				; error code $2C "Format" error
     285/    2116 : 6056                	BRA.s		LAB_XERR				; do error #d7, then warm start
     286/    2118 :                     
     287/    2118 :                     
     288/    2118 :                     ;************************************************************************************
     289/    2118 :                     ;
     290/    2118 :                     ; do address error
     291/    2118 :                     
     292/    2118 :                     LAB_ADER
     293/    2118 : 7E2A                	MOVEQ		#$2A,d7				; error code $2A "Address" error
     294/    211A : 6052                	BRA.s		LAB_XERR				; do error #d7, then warm start
     295/    211C :                     
     296/    211C :                     
     297/    211C :                     ;************************************************************************************
     298/    211C :                     ;
     299/    211C :                     ; do wrong dimensions error
     300/    211C :                     
     301/    211C :                     LAB_WDER
     302/    211C : 7E28                	MOVEQ		#$28,d7				; error code $28 "Wrong dimensions" error
     303/    211E : 604E                	BRA.s		LAB_XERR				; do error #d7, then warm start
     304/    2120 :                     
     305/    2120 :                     
     306/    2120 :                     ;************************************************************************************
     307/    2120 :                     ;
     308/    2120 :                     ; do undimensioned array error
     309/    2120 :                     
     310/    2120 :                     LAB_UDER
     311/    2120 : 7E26                	MOVEQ		#$26,d7				; error code $26 "undimensioned array" error
     312/    2122 : 604A                	BRA.s		LAB_XERR				; do error #d7, then warm start
     313/    2124 :                     
     314/    2124 :                     
     315/    2124 :                     ;************************************************************************************
     316/    2124 :                     ;
     317/    2124 :                     ; do undefined variable error
     318/    2124 :                     
     319/    2124 :                     LAB_UVER
     320/    2124 :                     
     321/    2124 : 7E24                	MOVEQ		#$24,d7				; error code $24 "undefined variable" error
     322/    2126 : 6046                	BRA.s		LAB_XERR				; do error #d7, then warm start
     323/    2128 :                     
     324/    2128 :                     
     325/    2128 :                     ;************************************************************************************
     326/    2128 :                     ;
     327/    2128 :                     ; do loop without do error
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 10 - 11/4/2023 8:40:20


     328/    2128 :                     
     329/    2128 :                     LAB_LDER
     330/    2128 : 7E22                	MOVEQ		#$22,d7				; error code $22 "LOOP without DO" error
     331/    212A : 6042                	BRA.s		LAB_XERR				; do error #d7, then warm start
     332/    212C :                     
     333/    212C :                     
     334/    212C :                     ;************************************************************************************
     335/    212C :                     ;
     336/    212C :                     ; do undefined function error
     337/    212C :                     
     338/    212C :                     LAB_UFER
     339/    212C : 7E20                	MOVEQ		#$20,d7				; error code $20 "Undefined function" error
     340/    212E : 603E                	BRA.s		LAB_XERR				; do error #d7, then warm start
     341/    2130 :                     
     342/    2130 :                     
     343/    2130 :                     ;************************************************************************************
     344/    2130 :                     ;
     345/    2130 :                     ; do can't continue error
     346/    2130 :                     
     347/    2130 :                     LAB_CCER
     348/    2130 : 7E1E                	MOVEQ		#$1E,d7				; error code $1E "Can't continue" error
     349/    2132 : 603A                	BRA.s		LAB_XERR				; do error #d7, then warm start
     350/    2134 :                     
     351/    2134 :                     
     352/    2134 :                     ;************************************************************************************
     353/    2134 :                     ;
     354/    2134 :                     ; do string too complex error
     355/    2134 :                     
     356/    2134 :                     LAB_SCER
     357/    2134 : 7E1C                	MOVEQ		#$1C,d7				; error code $1C "String too complex" error
     358/    2136 : 6036                	BRA.s		LAB_XERR				; do error #d7, then warm start
     359/    2138 :                     
     360/    2138 :                     
     361/    2138 :                     ;************************************************************************************
     362/    2138 :                     ;
     363/    2138 :                     ; do string too long error
     364/    2138 :                     
     365/    2138 :                     LAB_SLER
     366/    2138 : 7E1A                	MOVEQ		#$1A,d7				; error code $1A "String too long" error
     367/    213A : 6032                	BRA.s		LAB_XERR				; do error #d7, then warm start
     368/    213C :                     
     369/    213C :                     
     370/    213C :                     ;************************************************************************************
     371/    213C :                     ;
     372/    213C :                     ; do type missmatch error
     373/    213C :                     
     374/    213C :                     LAB_TMER
     375/    213C : 7E18                	MOVEQ		#$18,d7				; error code $18 "Type mismatch" error
     376/    213E : 602E                	BRA.s		LAB_XERR				; do error #d7, then warm start
     377/    2140 :                     
     378/    2140 :                     
     379/    2140 :                     ;************************************************************************************
     380/    2140 :                     ;
     381/    2140 :                     ; do illegal direct error
     382/    2140 :                     
     383/    2140 :                     LAB_IDER
     384/    2140 : 7E16                	MOVEQ		#$16,d7				; error code $16 "Illegal direct" error
     385/    2142 : 602A                	BRA.s		LAB_XERR				; do error #d7, then warm start
     386/    2144 :                     
     387/    2144 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 11 - 11/4/2023 8:40:20


     388/    2144 :                     ;************************************************************************************
     389/    2144 :                     ;
     390/    2144 :                     ; do divide by zero error
     391/    2144 :                     
     392/    2144 :                     LAB_DZER
     393/    2144 : 7E14                	MOVEQ		#$14,d7				; error code $14 "Divide by zero" error
     394/    2146 : 6026                	BRA.s		LAB_XERR				; do error #d7, then warm start
     395/    2148 :                     
     396/    2148 :                     
     397/    2148 :                     ;************************************************************************************
     398/    2148 :                     ;
     399/    2148 :                     ; do double dimension error
     400/    2148 :                     
     401/    2148 :                     LAB_DDER
     402/    2148 : 7E12                	MOVEQ		#$12,d7				; error code $12 "Double dimension" error
     403/    214A : 6022                	BRA.s		LAB_XERR				; do error #d7, then warm start
     404/    214C :                     
     405/    214C :                     
     406/    214C :                     ;************************************************************************************
     407/    214C :                     ;
     408/    214C :                     ; do array bounds error
     409/    214C :                     
     410/    214C :                     LAB_ABER
     411/    214C : 7E10                	MOVEQ		#$10,d7				; error code $10 "Array bounds" error
     412/    214E : 601E                	BRA.s		LAB_XERR				; do error #d7, then warm start
     413/    2150 :                     
     414/    2150 :                     
     415/    2150 :                     ;************************************************************************************
     416/    2150 :                     ;
     417/    2150 :                     ; do undefined satement error
     418/    2150 :                     
     419/    2150 :                     LAB_USER
     420/    2150 : 7E0E                	MOVEQ		#$0E,d7				; error code $0E "Undefined statement" error
     421/    2152 : 601A                	BRA.s		LAB_XERR				; do error #d7, then warm start
     422/    2154 :                     
     423/    2154 :                     
     424/    2154 :                     ;************************************************************************************
     425/    2154 :                     ;
     426/    2154 :                     ; do out of memory error
     427/    2154 :                     
     428/    2154 :                     LAB_OMER
     429/    2154 : 7E0C                	MOVEQ		#$0C,d7				; error code $0C "Out of memory" error
     430/    2156 : 6016                	BRA.s		LAB_XERR				; do error #d7, then warm start
     431/    2158 :                     
     432/    2158 :                     
     433/    2158 :                     ;************************************************************************************
     434/    2158 :                     ;
     435/    2158 :                     ; do overflow error
     436/    2158 :                     
     437/    2158 :                     LAB_OFER
     438/    2158 : 7E0A                	MOVEQ		#$0A,d7				; error code $0A "Overflow" error
     439/    215A : 6012                	BRA.s		LAB_XERR				; do error #d7, then warm start
     440/    215C :                     
     441/    215C :                     
     442/    215C :                     ;************************************************************************************
     443/    215C :                     ;
     444/    215C :                     ; do function call error
     445/    215C :                     
     446/    215C :                     LAB_FCER
     447/    215C : 7E08                	MOVEQ		#$08,d7				; error code $08 "Function call" error
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 12 - 11/4/2023 8:40:20


     448/    215E : 600E                	BRA.s		LAB_XERR				; do error #d7, then warm start
     449/    2160 :                     
     450/    2160 :                     
     451/    2160 :                     ;************************************************************************************
     452/    2160 :                     ;
     453/    2160 :                     ; do out of data error
     454/    2160 :                     
     455/    2160 :                     LAB_ODER
     456/    2160 : 7E06                	MOVEQ		#$06,d7				; error code $06 "Out of DATA" error
     457/    2162 : 600A                	BRA.s		LAB_XERR				; do error #d7, then warm start
     458/    2164 :                     
     459/    2164 :                     
     460/    2164 :                     ;************************************************************************************
     461/    2164 :                     ;
     462/    2164 :                     ; do return without gosub error
     463/    2164 :                     
     464/    2164 :                     LAB_RGER
     465/    2164 : 7E04                	MOVEQ		#$04,d7				; error code $04 "RETURN without GOSUB" error
     466/    2166 : 6006                	BRA.s		LAB_XERR				; do error #d7, then warm start
     467/    2168 :                     
     468/    2168 :                     
     469/    2168 :                     ;************************************************************************************
     470/    2168 :                     ;
     471/    2168 :                     ; do syntax error
     472/    2168 :                     
     473/    2168 :                     LAB_SNER
     474/    2168 : 7E02                	MOVEQ		#$02,d7				; error code $02 "Syntax" error
     475/    216A : 6002                	BRA.s		LAB_XERR				; do error #d7, then warm start
     476/    216C :                     
     477/    216C :                     
     478/    216C :                     ;************************************************************************************
     479/    216C :                     ;
     480/    216C :                     ; do next without for error
     481/    216C :                     
     482/    216C :                     LAB_NFER
     483/    216C : 7E00                	MOVEQ		#$00,d7				; error code $00 "NEXT without FOR" error
     484/    216E :                     
     485/    216E :                     
     486/    216E :                     ;************************************************************************************
     487/    216E :                     ;
     488/    216E :                     ; do error #d7, then warm start
     489/    216E :                     
     490/    216E :                     LAB_XERR
     491/    216E : 6100 02CA           	BSR		LAB_1491				; flush stack & clear continue flag
     492/    2172 : 6100 0812           	BSR		LAB_CRLF				; print CR/LF
     493/    2176 : 43FA 2FFA           	LEA		LAB_BAER(pc),a1			; start of error message pointer table
     494/    217A : 3E31 7000           	MOVE.w	(a1,d7.w),d7			; get error message offset
     495/    217E : 41F1 7000           	LEA		(a1,d7.w),a0			; get error message address
     496/    2182 : 6100 0860           	BSR		LAB_18C3				; print null terminated string from memory
     497/    2186 : 41FA 3335           	LEA		LAB_EMSG(pc),a0			; point to " Error" message
     498/    218A :                     LAB_1269
     499/    218A : 6100 0858           	BSR		LAB_18C3				; print null terminated string from memory
     500/    218E : 202B 0452           	MOVE.l	Clinel(a3),d0			; get current line
     501/    2192 : 6B04                	BMI.s	LAB_1274				; go do warm start if -ve # (was immediate mode)
     502/    2194 :                     
     503/    2194 :                     									; else print line number
     504/    2194 : 6100 1B2C           	BSR		LAB_2953				; print " in line [LINE #]"
     505/    2198 :                     
     506/    2198 :                     ; BASIC warm start entry point, wait for Basic command
     507/    2198 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 13 - 11/4/2023 8:40:20


     508/    2198 :                     LAB_1274
     509/    2198 : 41FA 3356           	LEA		LAB_RMSG(pc),a0			; point to "Ready" message
     510/    219C : 6100 0846           	BSR		LAB_18C3				; go do print string
     511/    21A0 :                     
     512/    21A0 :                     ; wait for Basic command - no "Ready"
     513/    21A0 :                     
     514/    21A0 :                     LAB_127D
     515/    21A0 : 72FF                	MOVEQ	#-1,d1					; set to -1
     516/    21A2 : 2741 0452           	MOVE.l	d1,Clinel(a3)			; set current line #
     517/    21A6 : 1741 05DC           	MOVE.b	d1,Breakf(a3)			; set break flag
     518/    21AA : 4BEB 0490           	LEA		Ibuffs(a3),a5			; set basic execute pointer ready for new line
     519/    21AE :                     LAB_127E
     520/    21AE : 6100 00EC           	BSR		LAB_1357				; call for BASIC input
     521/    21B2 : 6100 0BFC           	BSR		LAB_GBYT				; scan memory
     522/    21B6 : 67F6                	BEQ.s	LAB_127E				; loop while null
     523/    21B8 :                     
     524/    21B8 :                     ; got to interpret input line now ....
     525/    21B8 :                     
     526/    21B8 : 6508                	BCS.s	LAB_1295				; branch if numeric character, handle new
     527/    21BA :                     								; BASIC line
     528/    21BA :                     
     529/    21BA :                     								; no line number so do immediate mode, a5
     530/    21BA :                     								; points to the buffer start
     531/    21BA : 6100 0156           	BSR		LAB_13A6				; crunch keywords into Basic tokens
     532/    21BE :                     								; crunch from (a5), output to (a0)
     533/    21BE :                     								; returns ..
     534/    21BE :                     								; d2 is length, d1 trashed, d0 trashed,
     535/    21BE :                     								; a1 trashed
     536/    21BE : 6000 03C6           	BRA		LAB_15F6				; go scan & interpret code
     537/    21C2 :                     
     538/    21C2 :                     
     539/    21C2 :                     ;************************************************************************************
     540/    21C2 :                     ;
     541/    21C2 :                     ; handle a new BASIC line
     542/    21C2 :                     
     543/    21C2 :                     LAB_1295
     544/    21C2 : 6100 0640           	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
     545/    21C6 : 6100 014A           	BSR		LAB_13A6				; crunch keywords into Basic tokens
     546/    21CA :                     								; crunch from (a5), output to (a0)
     547/    21CA :                     								; returns .. d2 is length,
     548/    21CA :                     								; d1 trashed, d0 trashed, a1 trashed
     549/    21CA : 222B 042A           	MOVE.l	Itemp(a3),d1			; get required line #
     550/    21CE : 6100 0218           	BSR		LAB_SSLN				; search BASIC for d1 line number
     551/    21D2 :                     								; returns pointer in a0
     552/    21D2 : 6532                	BCS.s		LAB_12E6				; branch if not found
     553/    21D4 :                     
     554/    21D4 :                     								; aroooogah! line # already exists! delete it
     555/    21D4 : 2250                	MOVEA.l	(a0),a1				; get start of block (next line pointer)
     556/    21D6 : 202B 0432           	MOVE.l	Sfncl(a3),d0			; get end of block (start of functions)
     557/    21DA : 9089                	SUB.l		a1,d0					; subtract start of block ( = bytes to move)
     558/    21DC : E288                	LSR.l		#1,d0					; /2 (word move)
     559/    21DE : 5380                	SUBQ.l	#1,d0					; adjust for DBF loop
     560/    21E0 : 4840                	SWAP		d0					; swap high word to low word
     561/    21E2 : 2448                	MOVEA.l	a0,a2					; copy destination
     562/    21E4 :                     LAB_12AE
     563/    21E4 : 4840                	SWAP		d0					; swap high word to low word
     564/    21E6 :                     LAB_12B0
     565/    21E6 : 34D9                	MOVE.w	(a1)+,(a2)+				; copy word
     566/    21E8 : 51C8 FFFC           	DBF		d0,LAB_12B0				; decrement low count and loop until done
     567/    21EC :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 14 - 11/4/2023 8:40:20


     568/    21EC : 4840                	SWAP		d0					; swap high word to low word
     569/    21EE : 51C8 FFF4           	DBF		d0,LAB_12AE				; decrement high count and loop until done
     570/    21F2 :                     
     571/    21F2 : 274A 0432           	MOVE.l	a2,Sfncl(a3)			; start of functions
     572/    21F6 : 274A 0436           	MOVE.l	a2,Svarl(a3)			; save start of variables
     573/    21FA : 274A 043A           	MOVE.l	a2,Sstrl(a3)			; start of strings
     574/    21FE : 274A 043E           	MOVE.l	a2,Sarryl(a3)			; save start of arrays
     575/    2202 : 274A 0442           	MOVE.l	a2,Earryl(a3)			; save end of arrays
     576/    2206 :                     
     577/    2206 :                     								; got new line in buffer and no existing same #
     578/    2206 :                     LAB_12E6
     579/    2206 : 102B 0490           	MOVE.b	Ibuffs(a3),d0			; get byte from start of input buffer
     580/    220A : 6764                	BEQ.s		LAB_1325				; if null line go do line chaining
     581/    220C :                     
     582/    220C :                     								; got new line and it isn't empty line
     583/    220C : 226B 0432           	MOVEA.l	Sfncl(a3),a1			; get start of functions (end of block to move)
     584/    2210 : 45F1 2008           	LEA		8(a1,d2),a2				; copy it, add line length and add room for
     585/    2214 :                     								; pointer and line number
     586/    2214 :                     
     587/    2214 : 274A 0432           	MOVE.l	a2,Sfncl(a3)			; start of functions
     588/    2218 : 274A 0436           	MOVE.l	a2,Svarl(a3)			; save start of variables
     589/    221C : 274A 043A           	MOVE.l	a2,Sstrl(a3)			; start of strings
     590/    2220 : 274A 043E           	MOVE.l	a2,Sarryl(a3)			; save start of arrays
     591/    2224 : 274A 0442           	MOVE.l	a2,Earryl(a3)			; save end of arrays
     592/    2228 : 276B 044A 0446      	MOVE.l	Ememl(a3),Sstorl(a3)		; copy end of mem to start of strings, clear
     593/    222E :                     								; strings
     594/    222E :                     
     595/    222E : 2209                	MOVE.l	a1,d1					; copy end of block to move
     596/    2230 : 9288                	SUB.l		a0,d1					; subtract start of block to move
     597/    2232 : E289                	LSR.l		#1,d1					; /2 (word copy)
     598/    2234 : 5381                	SUBQ.l	#1,d1					; correct for loop end on -1
     599/    2236 : 4841                	SWAP		d1					; swap high word to low word
     600/    2238 :                     LAB_12FF
     601/    2238 : 4841                	SWAP		d1					; swap high word to low word
     602/    223A :                     LAB_1301
     603/    223A : 3521                	MOVE.w	-(a1),-(a2)				; decrement pointers and copy word
     604/    223C : 51C9 FFFC           	DBF		d1,LAB_1301				; decrement & loop
     605/    2240 :                     
     606/    2240 : 4841                	SWAP		d1					; swap high word to low word
     607/    2242 : 51C9 FFF4           	DBF		d1,LAB_12FF				; decrement high count and loop until done
     608/    2246 :                     
     609/    2246 :                     ; space is opened up, now copy the crunched line from the input buffer into the space
     610/    2246 :                     
     611/    2246 : 43EB 0490           	LEA		Ibuffs(a3),a1			; source is input buffer
     612/    224A : 2448                	MOVEA.l	a0,a2					; copy destination
     613/    224C : 72FF                	MOVEQ		#-1,d1				; set to allow re-chaining
     614/    224E : 24C1                	MOVE.l	d1,(a2)+				; set next line pointer (allow re-chaining)
     615/    2250 : 24EB 042A           	MOVE.l	Itemp(a3),(a2)+			; save line number
     616/    2254 : E24A                	LSR.w		#1,d2					; /2 (word copy)
     617/    2256 : 5342                	SUBQ.w	#1,d2					; correct for loop end on -1
     618/    2258 :                     LAB_1303
     619/    2258 : 34D9                	MOVE.w	(a1)+,(a2)+				; copy word
     620/    225A : 51CA FFFC           	DBF		d2,LAB_1303				; decrement & loop
     621/    225E :                     
     622/    225E : 6010                	BRA.s		LAB_1325				; go test for end of prog
     623/    2260 :                     
     624/    2260 :                     ; rebuild chaining of BASIC lines
     625/    2260 :                     
     626/    2260 :                     LAB_132E
     627/    2260 : 5048                	ADDQ.w	#8,a0					; point to first code byte of line, there is
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 15 - 11/4/2023 8:40:20


     628/    2262 :                     								; always 1 byte + [EOL] as null entries are
     629/    2262 :                     								; deleted
     630/    2262 :                     LAB_1330
     631/    2262 : 4A18                	TST.b		(a0)+					; test byte	
     632/    2264 : 66FC                	BNE.s		LAB_1330				; loop if not [EOL]
     633/    2266 :                     
     634/    2266 :                     								; was [EOL] so get next line start
     635/    2266 : 3208                	MOVE.w	a0,d1					; past pad byte(s)
     636/    2268 : 0241 0001           	ANDI.w	#1,d1					; mask odd bit
     637/    226C : D0C1                	ADD.w		d1,a0					; add back to ensure even
     638/    226E : 2288                	MOVE.l	a0,(a1)				; save next line pointer to current line
     639/    2270 :                     LAB_1325
     640/    2270 : 2248                	MOVEA.l	a0,a1					; copy pointer for this line
     641/    2272 : 4A90                	TST.l		(a0)					; test pointer to next line
     642/    2274 : 66EA                	BNE.s		LAB_132E				; not end of program yet so we must
     643/    2276 :                     								; go and fix the pointers
     644/    2276 :                     
     645/    2276 : 6100 0198           	BSR		LAB_1477				; reset execution to start, clear variables
     646/    227A :                     								; and flush stack
     647/    227A : 6000 FF24           	BRA		LAB_127D				; now we just wait for Basic command, no "Ready"
     648/    227E :                     
     649/    227E :                     
     650/    227E :                     ;************************************************************************************
     651/    227E :                     ;
     652/    227E :                     ; receive a line from the keyboard
     653/    227E :                     								; character $08 as delete key, BACKSPACE on
     654/    227E :                     								; standard keyboard
     655/    227E :                     LAB_134B
     656/    227E : 6100 077E           	BSR		LAB_PRNA				; go print the character
     657/    2282 : 7020                	MOVEQ		#' ',d0				; load [SPACE]
     658/    2284 : 6100 0778           	BSR		LAB_PRNA				; go print
     659/    2288 : 7008                	MOVEQ		#$08,d0				; load [BACKSPACE]
     660/    228A : 6100 0772           	BSR		LAB_PRNA				; go print
     661/    228E : 5341                	SUBQ.w	#$01,d1				; decrement the buffer index (delete)
     662/    2290 : 6010                	BRA.s		LAB_1359				; re-enter loop
     663/    2292 :                     
     664/    2292 :                     ; print "? " and get BASIC input
     665/    2292 :                     ; return a0 pointing to the buffer start
     666/    2292 :                     
     667/    2292 :                     LAB_INLN
     668/    2292 : 6100 0768           	BSR		LAB_18E3				; print "?" character
     669/    2296 : 7020                	MOVEQ		#' ',d0				; load " "
     670/    2298 : 6100 0764           	BSR		LAB_PRNA				; go print
     671/    229C :                     
     672/    229C :                     ; call for BASIC input (main entry point)
     673/    229C :                     ; return a0 pointing to the buffer start
     674/    229C :                     
     675/    229C :                     LAB_1357
     676/    229C : 7200                	MOVEQ		#$00,d1				; clear buffer index
     677/    229E : 41EB 0490           	LEA		Ibuffs(a3),a0			; set buffer base pointer
     678/    22A2 :                     LAB_1359
     679/    22A2 : 4EAB 040C           	JSR		V_INPT(a3)				; call scan input device
     680/    22A6 : 64FA                	BCC.s		LAB_1359				; loop if no byte
     681/    22A8 :                     
     682/    22A8 : 67F8                	BEQ.s		LAB_1359				; loop if null byte
     683/    22AA :                     
     684/    22AA : B03C 0007           	CMP.b		#$07,d0				; compare with [BELL]
     685/    22AE : 6718                	BEQ.s		LAB_1378				; branch if [BELL]
     686/    22B0 :                     
     687/    22B0 : B03C 000D           	CMP.b		#$0D,d0				; compare with [CR]
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 16 - 11/4/2023 8:40:20


     688/    22B4 : 6700 06CA           	BEQ		LAB_1866				; do CR/LF exit if [CR]
     689/    22B8 :                     
     690/    22B8 : 4A41                	TST.w		d1					; set flags on buffer index
     691/    22BA : 6606                	BNE.s		LAB_1374				; branch if not empty
     692/    22BC :                     
     693/    22BC :                     ; the next two lines ignore any non printing character and [SPACE] if the input buffer
     694/    22BC :                     ; is empty
     695/    22BC :                     
     696/    22BC : B03C 0020           	CMP.b		#' ',d0				; compare with [SP]+1
     697/    22C0 : 63E0                	BLS.s		LAB_1359				; if < ignore character
     698/    22C2 :                     
     699/    22C2 :                     ;##	CMP.b		#' '+1,d0				; compare with [SP]+1
     700/    22C2 :                     ;##	BCS.s		LAB_1359				; if < ignore character
     701/    22C2 :                     
     702/    22C2 :                     LAB_1374
     703/    22C2 : B03C 0008           	CMP.b		#$08,d0				; compare with [BACKSPACE]
     704/    22C6 : 67B6                	BEQ.s		LAB_134B				; go delete last character
     705/    22C8 :                     
     706/    22C8 :                     LAB_1378
     707/    22C8 : B27C 00FF           	CMP.w		#(Ibuffe-Ibuffs-1),d1		; compare character count with max-1
     708/    22CC : 640C                	BCC.s		LAB_138E				; skip store & do [BELL] if buffer full
     709/    22CE :                     
     710/    22CE : 1180 1000           	MOVE.b	d0,(a0,d1.w)			; else store in buffer
     711/    22D2 : 5241                	ADDQ.w	#$01,d1				; increment index
     712/    22D4 :                     LAB_137F
     713/    22D4 : 6100 0728           	BSR		LAB_PRNA				; go print the character
     714/    22D8 : 60C8                	BRA.s		LAB_1359				; always loop for next character
     715/    22DA :                     
     716/    22DA :                     ; announce buffer full
     717/    22DA :                     
     718/    22DA :                     LAB_138E
     719/    22DA : 7007                	MOVEQ		#$07,d0				; [BELL] character into d0
     720/    22DC : 60F6                	BRA.s		LAB_137F				; go print the [BELL] but ignore input character
     721/    22DE :                     
     722/    22DE :                     
     723/    22DE :                     ;************************************************************************************
     724/    22DE :                     ;
     725/    22DE :                     ; copy a hex value without crunching
     726/    22DE :                     
     727/    22DE :                     LAB_1392
     728/    22DE : 1180 2000           	MOVE.b	d0,(a0,d2.w)			; save the byte to the output
     729/    22E2 : 5242                	ADDQ.w	#1,d2					; increment the buffer save index
     730/    22E4 :                     
     731/    22E4 : 5241                	ADDQ.w	#1,d1					; increment the buffer read index
     732/    22E6 : 1035 1000           	MOVE.b	(a5,d1.w),d0			; get a byte from the input buffer
     733/    22EA : 6700 0094           	BEQ		LAB_13EC				; if [EOL] go save it without crunching
     734/    22EE :                     
     735/    22EE : B03C 0020           	CMP.b		#' ',d0				; compare the character with " "
     736/    22F2 : 67EA                	BEQ.s		LAB_1392				; if [SPACE] just go save it and get another
     737/    22F4 :                     
     738/    22F4 : B03C 0030           	CMP.b		#'0',d0				; compare the character with "0"
     739/    22F8 : 654A                	BCS.s		LAB_13C6				; if < "0" quit the hex save loop
     740/    22FA :                     
     741/    22FA : B03C 0039           	CMP.b		#'9',d0				; compare with "9"
     742/    22FE : 63DE                	BLS.s		LAB_1392				; if it is "0" to "9" save it and get another
     743/    2300 :                     
     744/    2300 : 7ADF                	MOVEQ		#-33,d5				; mask xx0x xxxx, ASCII upper case
     745/    2302 : CA00                	AND.b		d0,d5					; mask the character
     746/    2304 :                     
     747/    2304 : BA3C 0041           	CMP.b		#'A',d5				; compare with "A"
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 17 - 11/4/2023 8:40:20


     748/    2308 : 6540                	BCS.s		LAB_13CC				; if < "A" quit the hex save loop
     749/    230A :                     
     750/    230A : BA3C 0046           	CMP.b		#'F',d5				; compare with "F"
     751/    230E : 63CE                	BLS.s		LAB_1392				; if it is "A" to "F" save it and get another
     752/    2310 :                     
     753/    2310 : 6038                	BRA.s		LAB_13CC				; else continue crunching
     754/    2312 :                     
     755/    2312 :                     ; crunch keywords into Basic tokens
     756/    2312 :                     ; crunch from (a5), output to (a0)
     757/    2312 :                     ; returns ..
     758/    2312 :                     ; d4 trashed
     759/    2312 :                     ; d3 trashed
     760/    2312 :                     ; d2 is length
     761/    2312 :                     ; d1 trashed
     762/    2312 :                     ; d0 trashed
     763/    2312 :                     ; a1 trashed
     764/    2312 :                     
     765/    2312 :                     ; this is the improved BASIC crunch routine and is 10 to 100 times faster than the
     766/    2312 :                     ; old list search
     767/    2312 :                     
     768/    2312 :                     LAB_13A6
     769/    2312 : 7200                	MOVEQ		#0,d1					; clear the read index
     770/    2314 : 2401                	MOVE.l	d1,d2					; clear the save index
     771/    2316 : 1741 05DD           	MOVE.b	d1,Oquote(a3)			; clear the open quote/DATA flag
     772/    231A :                     LAB_13AC
     773/    231A : 7000                	MOVEQ		#0,d0					; clear word
     774/    231C : 1035 1000           	MOVE.b	(a5,d1.w),d0			; get byte from input buffer
     775/    2320 : 675E                	BEQ.s		LAB_13EC				; if null save byte then continue crunching
     776/    2322 :                     
     777/    2322 : B03C 005F           	CMP.b		#'_',d0				; compare with "_"
     778/    2326 : 6458                	BCC.s		LAB_13EC				; if >= "_" save byte then continue crunching
     779/    2328 :                     
     780/    2328 : B03C 003C           	CMP.b		#'<',d0				; compare with "<"
     781/    232C : 641C                	BCC.s		LAB_13CC				; if >= "<" go crunch
     782/    232E :                     
     783/    232E : B03C 0030           	CMP.b		#'0',d0				; compare with "0"
     784/    2332 : 644C                	BCC.s		LAB_13EC				; if >= "0" save byte then continue crunching
     785/    2334 :                     
     786/    2334 : 1740 05DA           	MOVE.b	d0,Asrch(a3)			; save buffer byte as search character
     787/    2338 : B03C 0022           	CMP.b		#$22,d0				; is it quote character?
     788/    233C : 6776                	BEQ.s		LAB_1410				; branch if so (copy quoted string)
     789/    233E :                     
     790/    233E : B03C 0024           	CMP.b		#'$',d0				; is it the hex value character?
     791/    2342 : 679A                	BEQ.s		LAB_1392				; if so go copy a hex value
     792/    2344 :                     
     793/    2344 :                     LAB_13C6
     794/    2344 : B03C 002A           	CMP.b		#'*',d0				; compare with "*"
     795/    2348 : 6536                	BCS.s		LAB_13EC				; if <= "*" save byte then continue crunching
     796/    234A :                     
     797/    234A :                     								; crunch rest
     798/    234A :                     LAB_13CC
     799/    234A : 082B 0006 05DD      	BTST.b	#6,Oquote(a3)			; test open quote/DATA token flag
     800/    2350 : 662E                	BNE.s		LAB_13EC				; branch if b6 of Oquote set (was DATA)
     801/    2352 :                     								; go save byte then continue crunching
     802/    2352 :                     
     803/    2352 : 903C 002A           	SUB.b		#$2A,d0				; normalise byte
     804/    2356 : D040                	ADD.w		d0,d0					; *2 makes word offset (high byte=$00)
     805/    2358 : 43FA 2C1A           	LEA		TAB_CHRT(pc),a1			; get keyword offset table address
     806/    235C : 3031 0000           	MOVE.w	(a1,d0.w),d0			; get offset into keyword table
     807/    2360 : 6B6E                	BMI.s		LAB_141F				; branch if no keywords for character
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 18 - 11/4/2023 8:40:20


     808/    2362 :                     
     809/    2362 : 43FA 2FA6           	LEA		TAB_STAR(pc),a1			; get keyword table address
     810/    2366 : D2C0                	ADDA.w	d0,a1					; add keyword offset
     811/    2368 : 76FF                	MOVEQ		#-1,d3				; clear index
     812/    236A : 3801                	MOVE.w	d1,d4					; copy read index
     813/    236C :                     LAB_13D6
     814/    236C : 5243                	ADDQ.w	#1,d3					; increment table index
     815/    236E : 1031 3000           	MOVE.b	(a1,d3.w),d0			; get byte from table
     816/    2372 :                     LAB_13D8
     817/    2372 : 6B0A                	BMI.s		LAB_13EA				; branch if token, save token and continue
     818/    2374 :                     								; crunching
     819/    2374 :                     
     820/    2374 : 5244                	ADDQ.w	#1,d4					; increment read index
     821/    2376 : B035 4000           	CMP.b		(a5,d4.w),d0			; compare byte from input buffer
     822/    237A : 67F0                	BEQ.s		LAB_13D6				; loop if character match
     823/    237C :                     
     824/    237C : 6040                	BRA.s		LAB_1417				; branch if no match
     825/    237E :                     
     826/    237E :                     LAB_13EA
     827/    237E : 3204                	MOVE.w	d4,d1					; update read index
     828/    2380 :                     LAB_13EC
     829/    2380 : 1180 2000           	MOVE.b	d0,(a0,d2.w)			; save byte to output
     830/    2384 : 5242                	ADDQ.w	#1,d2					; increment buffer save index
     831/    2386 : 5241                	ADDQ.w	#1,d1					; increment buffer read index
     832/    2388 : 4A00                	TST.b		d0					; set flags
     833/    238A : 674A                	BEQ.s		LAB_142A				; branch if was null [EOL]
     834/    238C :                     
     835/    238C :                     								; d0 holds token or byte here
     836/    238C : 903C 003A           	SUB.b		#$3A,d0				; subtract ":"
     837/    2390 : 6706                	BEQ.s		LAB_13FF				; branch if it was ":" (is now $00)
     838/    2392 :                     
     839/    2392 :                     								; d0 now holds token-$3A
     840/    2392 : B03C 0049           	CMP.b		#(TK_DATA-$3A),d0			; compare with DATA token - $3A
     841/    2396 : 6604                	BNE.s		LAB_1401				; branch if not DATA
     842/    2398 :                     
     843/    2398 :                     								; token was : or DATA
     844/    2398 :                     LAB_13FF
     845/    2398 : 1740 05DD           	MOVE.b	d0,Oquote(a3)			; save token-$3A ($00 for ":", TK_DATA-$3A for
     846/    239C :                     								; DATA)
     847/    239C :                     LAB_1401
     848/    239C : 903C 0055           	SUB.b		#(TK_REM-$3A),d0			; subtract REM token offset
     849/    23A0 : 6600 FF78           	BNE		LAB_13AC				; If wasn't REM then go crunch rest of line
     850/    23A4 :                     
     851/    23A4 : 1740 05DA           	MOVE.b	d0,Asrch(a3)			; else was REM so set search for [EOL]
     852/    23A8 :                     
     853/    23A8 :                     								; loop for REM, "..." etc.
     854/    23A8 :                     LAB_1408
     855/    23A8 : 1035 1000           	MOVE.b	(a5,d1.w),d0			; get byte from input buffer
     856/    23AC : 67D2                	BEQ.s		LAB_13EC				; branch if null [EOL]
     857/    23AE :                     
     858/    23AE : B02B 05DA           	CMP.b		Asrch(a3),d0			; compare with stored character
     859/    23B2 : 67CC                	BEQ.s		LAB_13EC				; branch if match (end quote, REM, :, or DATA)
     860/    23B4 :                     
     861/    23B4 :                     								; entry for copy string in quotes, don't crunch
     862/    23B4 :                     LAB_1410
     863/    23B4 : 1180 2000           	MOVE.b	d0,(a0,d2.w)			; save byte to output
     864/    23B8 : 5242                	ADDQ.w	#1,d2					; increment buffer save index
     865/    23BA : 5241                	ADDQ.w	#1,d1					; increment buffer read index
     866/    23BC : 60EA                	BRA.s		LAB_1408				; loop
     867/    23BE :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 19 - 11/4/2023 8:40:20


     868/    23BE :                     ; not found keyword this go so find the end of this word in the table
     869/    23BE :                     
     870/    23BE :                     LAB_1417
     871/    23BE : 3801                	MOVE.w	d1,d4					; reset read pointer
     872/    23C0 :                     LAB_141B
     873/    23C0 : 5243                	ADDQ.w	#1,d3					; increment keyword table pointer, flag
     874/    23C2 :                     								; unchanged
     875/    23C2 : 1031 3000           	MOVE.b	(a1,d3.w),d0			; get keyword table byte
     876/    23C6 : 6AF8                	BPL.s		LAB_141B				; if not end of keyword go do next byte
     877/    23C8 :                     
     878/    23C8 : 5243                	ADDQ.w	#1,d3					; increment keyword table pointer flag
     879/    23CA :                     								; unchanged
     880/    23CA : 1031 3000           	MOVE.b	(a1,d3.w),d0			; get keyword table byte
     881/    23CE : 66A2                	BNE.s		LAB_13D8				; go test next word if not zero byte (table end)
     882/    23D0 :                     
     883/    23D0 :                     								; reached end of table with no match
     884/    23D0 :                     LAB_141F
     885/    23D0 : 1035 1000           	MOVE.b	(a5,d1.w),d0			; restore byte from input buffer
     886/    23D4 : 60AA                	BRA.s		LAB_13EC				; go save byte in output and continue crunching
     887/    23D6 :                     
     888/    23D6 :                     								; reached [EOL]
     889/    23D6 :                     LAB_142A
     890/    23D6 : 7000                	MOVEQ		#0,d0					; ensure longword clear
     891/    23D8 : 0102                	BTST		d0,d2					; test odd bit (fastest)
     892/    23DA : 6706                	BEQ.s		LAB_142C				; branch if no bytes to fill
     893/    23DC :                     
     894/    23DC : 1180 2000           	MOVE.b	d0,(a0,d2.w)			; clear next byte
     895/    23E0 : 5242                	ADDQ.w	#1,d2					; increment buffer save index
     896/    23E2 :                     LAB_142C
     897/    23E2 : 2180 2000           	MOVE.l	d0,(a0,d2.w)			; clear next line pointer, EOT in immediate mode
     898/    23E6 : 4E75                	RTS
     899/    23E8 :                     
     900/    23E8 :                     
     901/    23E8 :                     ;************************************************************************************
     902/    23E8 :                     ;
     903/    23E8 :                     ; search Basic for d1 line number from start of mem
     904/    23E8 :                     
     905/    23E8 :                     LAB_SSLN
     906/    23E8 : 206B 042E           	MOVEA.l	Smeml(a3),a0			; get start of program mem
     907/    23EC : 6002                	BRA.s		LAB_SCLN				; go search for required line from a0
     908/    23EE :                     
     909/    23EE :                     LAB_145F
     910/    23EE : 2040                	MOVEA.l	d0,a0					; copy next line pointer
     911/    23F0 :                     
     912/    23F0 :                     ; search Basic for d1 line number from a0
     913/    23F0 :                     ; returns Cb=0 if found
     914/    23F0 :                     ; returns a0 pointer to found or next higher (not found) line
     915/    23F0 :                     
     916/    23F0 :                     LAB_SCLN
     917/    23F0 : 2018                	MOVE.l	(a0)+,d0				; get next line pointer and point to line #
     918/    23F2 : 6708                	BEQ.s		LAB_145E				; is end marker so we're done, do 'no line' exit
     919/    23F4 :                     
     920/    23F4 : B290                	CMP.l		(a0),d1				; compare this line # with required line #
     921/    23F6 : 6EF6                	BGT.s		LAB_145F				; loop if required # > this #
     922/    23F8 :                     
     923/    23F8 : 5948                	SUBQ.w	#4,a0					; adjust pointer, flags not changed
     924/    23FA : 4E75                	RTS
     925/    23FC :                     
     926/    23FC :                     LAB_145E
     927/    23FC : 5948                	SUBQ.w	#4,a0					; adjust pointer, flags not changed
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 20 - 11/4/2023 8:40:20


     928/    23FE : 5380                	SUBQ.l	#1,d0					; make end program found = -1, set carry
     929/    2400 : 4E75                	RTS
     930/    2402 :                     
     931/    2402 :                     
     932/    2402 :                     ;************************************************************************************
     933/    2402 :                     ;
     934/    2402 :                     ; perform NEW
     935/    2402 :                     
     936/    2402 :                     LAB_NEW
     937/    2402 : 664E                	BNE.s		RTS_005				; exit if not end of statement (do syntax error)
     938/    2404 :                     
     939/    2404 :                     LAB_1463
     940/    2404 : 206B 042E           	MOVEA.l	Smeml(a3),a0			; point to start of program memory
     941/    2408 : 7000                	MOVEQ		#0,d0					; clear longword
     942/    240A : 20C0                	MOVE.l	d0,(a0)+				; clear first line, next line pointer
     943/    240C : 2748 0432           	MOVE.l	a0,Sfncl(a3)			; set start of functions
     944/    2410 :                     
     945/    2410 :                     ; reset execution to start, clear variables and flush stack
     946/    2410 :                     
     947/    2410 :                     LAB_1477
     948/    2410 : 2A6B 042E           	MOVEA.l	Smeml(a3),a5			; reset BASIC execute pointer
     949/    2414 : 534D                	SUBQ.w	#1,a5					; -1 (as end of previous line)
     950/    2416 :                     
     951/    2416 :                     ; "CLEAR" command gets here
     952/    2416 :                     
     953/    2416 :                     LAB_147A
     954/    2416 : 276B 044A 0446      	MOVE.l	Ememl(a3),Sstorl(a3)		; save end of mem as bottom of string space
     955/    241C : 202B 0432           	MOVE.l	Sfncl(a3),d0			; get start of functions
     956/    2420 : 2740 0436           	MOVE.l	d0,Svarl(a3)			; start of variables
     957/    2424 : 2740 043A           	MOVE.l	d0,Sstrl(a3)			; start of strings
     958/    2428 : 2740 043E           	MOVE.l	d0,Sarryl(a3)			; set start of arrays
     959/    242C : 2740 0442           	MOVE.l	d0,Earryl(a3)			; set end of arrays
     960/    2430 :                     LAB_1480
     961/    2430 : 7000                	MOVEQ		#0,d0					; set Zb
     962/    2432 : 1740 05EA           	MOVE.b	d0,ccnull(a3)			; clear get byte countdown
     963/    2436 : 6100 01D0           	BSR		LAB_RESTORE				; perform RESTORE command
     964/    243A :                     
     965/    243A :                     ; flush stack & clear continue flag
     966/    243A :                     
     967/    243A :                     LAB_1491
     968/    243A : 49EB 048E           	LEA		des_sk(a3),a4			; reset descriptor stack pointer
     969/    243E :                     
     970/    243E : 201F                	MOVE.l	(sp)+,d0				; pull return address
     971/    2440 : 2E7C 0000 8400      	MOVE.l	#ram_addr+ram_base,sp	; set stack to RAM start + 1k, flush stack
     972/    2446 : 2F00                	MOVE.l	d0,-(sp)				; restore return address
     973/    2448 :                     
     974/    2448 : 7000                	MOVEQ		#0,d0					; clear longword
     975/    244A : 2740 045A           	MOVE.l	d0,Cpntrl(a3)			; clear continue pointer
     976/    244E : 1740 05DF           	MOVE.b	d0,Sufnxf(a3)			; clear subscript/FNX flag
     977/    2452 :                     RTS_005
     978/    2452 : 4E75                	RTS
     979/    2454 :                     
     980/    2454 :                     
     981/    2454 :                     ;************************************************************************************
     982/    2454 :                     ;
     983/    2454 :                     ; perform CLEAR
     984/    2454 :                     
     985/    2454 :                     LAB_CLEAR
     986/    2454 : 67C0                	BEQ.s		LAB_147A				; if no following byte go do "CLEAR"
     987/    2456 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 21 - 11/4/2023 8:40:20


     988/    2456 : 4E75                	RTS							; was following byte (go do syntax error)
     989/    2458 :                     
     990/    2458 :                     
     991/    2458 :                     ;************************************************************************************
     992/    2458 :                     ;
     993/    2458 :                     ; perform LIST [n][-m]
     994/    2458 :                     
     995/    2458 :                     LAB_LIST
     996/    2458 : 6512                	BCS.s		LAB_14BD				; branch if next character numeric (LIST n...)
     997/    245A :                     
     998/    245A : 72FF                	MOVEQ		#-1,d1				; set end to $FFFFFFFF
     999/    245C : 2741 042A           	MOVE.l	d1,Itemp(a3)			; save to Itemp
    1000/    2460 :                     
    1001/    2460 : 7200                	MOVEQ		#0,d1					; set start to $00000000
    1002/    2462 : 4A00                	TST.b		d0					; test next byte
    1003/    2464 : 670A                	BEQ.s		LAB_14C0				; branch if next character [NULL] (LIST)
    1004/    2466 :                     
    1005/    2466 : B03C 00B3           	CMP.b		#TK_MINUS,d0			; compare with token for -
    1006/    246A : 66E6                	BNE.s		RTS_005				; exit if not - (LIST -m)
    1007/    246C :                     
    1008/    246C :                     								; LIST [[n]-[m]] this sets the n, if present,
    1009/    246C :                     								; as the start and end
    1010/    246C :                     LAB_14BD
    1011/    246C : 6100 0396           	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
    1012/    2470 :                     LAB_14C0
    1013/    2470 : 6100 FF76           	BSR		LAB_SSLN				; search BASIC for d1 line number
    1014/    2474 :                     								; (pointer in a0)
    1015/    2474 : 6100 093A           	BSR		LAB_GBYT				; scan memory
    1016/    2478 : 6716                	BEQ.s		LAB_14D4				; branch if no more characters
    1017/    247A :                     
    1018/    247A :                     								; this bit checks the - is present
    1019/    247A : B03C 00B3           	CMP.b		#TK_MINUS,d0			; compare with token for -
    1020/    247E : 66D2                	BNE.s		RTS_005				; return if not "-" (will be Syntax error)
    1021/    2480 :                     
    1022/    2480 : 72FF                	MOVEQ		#-1,d1				; set end to $FFFFFFFF
    1023/    2482 : 2741 042A           	MOVE.l	d1,Itemp(a3)			; save Itemp
    1024/    2486 :                     
    1025/    2486 :                     								; LIST [n]-[m] the - was there so see if
    1026/    2486 :                     								; there is an m to set as the end value
    1027/    2486 : 6100 0926           	BSR		LAB_IGBY				; increment & scan memory
    1028/    248A : 6704                	BEQ.s		LAB_14D4				; branch if was [NULL] (LIST n-)
    1029/    248C :                     
    1030/    248C : 6100 0376           	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
    1031/    2490 :                     LAB_14D4
    1032/    2490 : 177C 0000 05DD      	MOVE.b	#$00,Oquote(a3)			; clear open quote flag
    1033/    2496 : 6100 04EE           	BSR		LAB_CRLF				; print CR/LF
    1034/    249A : 2018                	MOVE.l	(a0)+,d0				; get next line pointer
    1035/    249C : 67B4                	BEQ.s		RTS_005				; if null all done so exit
    1036/    249E :                     
    1037/    249E : 2240                	MOVEA.l	d0,a1					; copy next line pointer
    1038/    24A0 : 6100 012C           	BSR		LAB_1629				; do CRTL-C check vector
    1039/    24A4 :                     
    1040/    24A4 : 2018                	MOVE.l	(a0)+,d0				; get this line #
    1041/    24A6 : B0AB 042A           	CMP.l		Itemp(a3),d0			; compare end line # with this line #
    1042/    24AA : 62A6                	BHI.s		RTS_005				; if this line greater all done so exit
    1043/    24AC :                     
    1044/    24AC :                     LAB_14E2
    1045/    24AC : 48E7 00C0           	MOVEM.l	a0-a1,-(sp)				; save registers
    1046/    24B0 : 6100 181C           	BSR		LAB_295E				; print d0 as unsigned integer
    1047/    24B4 : 4CDF 0300           	MOVEM.l	(sp)+,a0-a1				; restore registers
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 22 - 11/4/2023 8:40:20


    1048/    24B8 : 7020                	MOVEQ		#$20,d0				; space is the next character
    1049/    24BA :                     LAB_150C
    1050/    24BA : 6100 0542           	BSR		LAB_PRNA				; go print the character
    1051/    24BE : B03C 0022           	CMP.b		#$22,d0				; was it " character
    1052/    24C2 : 6606                	BNE.s		LAB_1519				; branch if not
    1053/    24C4 :                     
    1054/    24C4 :                     								; we're either entering or leaving quotes
    1055/    24C4 : 0A2B 00FF 05DD      	EOR.b		#$FF,Oquote(a3)			; toggle open quote flag
    1056/    24CA :                     LAB_1519
    1057/    24CA : 1018                	MOVE.b	(a0)+,d0				; get byte and increment pointer
    1058/    24CC : 6608                	BNE.s		LAB_152E				; branch if not [EOL] (go print)
    1059/    24CE :                     
    1060/    24CE :                     								; was [EOL]
    1061/    24CE : 2049                	MOVEA.l	a1,a0					; copy next line pointer
    1062/    24D0 : 2008                	MOVE.l	a0,d0					; copy to set flags
    1063/    24D2 : 66BC                	BNE.s		LAB_14D4				; go do next line if not [EOT]
    1064/    24D4 :                     
    1065/    24D4 : 4E75                	RTS
    1066/    24D6 :                     
    1067/    24D6 :                     LAB_152E
    1068/    24D6 : 6AE2                	BPL.s		LAB_150C				; just go print it if not token byte
    1069/    24D8 :                     
    1070/    24D8 :                     								; else it was a token byte so maybe uncrunch it
    1071/    24D8 : 4A2B 05DD           	TST.b		Oquote(a3)				; test the open quote flag
    1072/    24DC : 6BDC                	BMI.s		LAB_150C				; just go print character if open quote set
    1073/    24DE :                     
    1074/    24DE :                     								; else uncrunch BASIC token
    1075/    24DE : 45FA 2AFE           	LEA		LAB_KEYT(pc),a2			; get keyword table address
    1076/    24E2 : 727F                	MOVEQ		#$7F,d1				; mask into d1
    1077/    24E4 : C200                	AND.b		d0,d1					; copy and mask token
    1078/    24E6 : E549                	LSL.w		#2,d1					; *4
    1079/    24E8 : 45F2 1000           	LEA		(a2,d1.w),a2			; get keyword entry address
    1080/    24EC : 101A                	MOVE.b	(a2)+,d0				; get byte from keyword table
    1081/    24EE : 6100 050E           	BSR		LAB_PRNA				; go print the first character
    1082/    24F2 : 7200                	MOVEQ		#0,d1					; clear d1
    1083/    24F4 : 121A                	MOVE.b	(a2)+,d1				; get remaining length byte from keyword table
    1084/    24F6 : 6BD2                	BMI.s		LAB_1519				; if -ve done so go get next byte
    1085/    24F8 :                     
    1086/    24F8 : 3012                	MOVE.w	(a2),d0				; get offset to rest
    1087/    24FA : 45FA 2E0E           	LEA		TAB_STAR(pc),a2			; get keyword table address
    1088/    24FE : 45F2 0000           	LEA		(a2,d0.w),a2			; get address of rest
    1089/    2502 :                     LAB_1540
    1090/    2502 : 101A                	MOVE.b	(a2)+,d0				; get byte from keyword table
    1091/    2504 : 6100 04F8           	BSR		LAB_PRNA				; go print the character
    1092/    2508 : 51C9 FFF8           	DBF		d1,LAB_1540				; decrement and loop if more to do
    1093/    250C :                     
    1094/    250C : 60BC                	BRA.s		LAB_1519				; go get next byte
    1095/    250E :                     
    1096/    250E :                     
    1097/    250E :                     ;************************************************************************************
    1098/    250E :                     ;
    1099/    250E :                     ; perform FOR
    1100/    250E :                     
    1101/    250E :                     LAB_FOR
    1102/    250E : 6100 0396           	BSR		LAB_LET				; go do LET
    1103/    2512 :                     
    1104/    2512 : 202B 0472           	MOVE.l	Lvarpl(a3),d0			; get the loop variable pointer
    1105/    2516 : B0AB 043A           	CMP.l		Sstrl(a3),d0			; compare it with the end of vars memory
    1106/    251A : 6C00 FC20           	BGE		LAB_TMER				; if greater go do type mismatch error
    1107/    251E :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 23 - 11/4/2023 8:40:20


    1108/    251E :                     ; test for not less than the start of variables memory if needed
    1109/    251E :                     ;
    1110/    251E :                     ;	CMP.l		Svarl(a3),d0			; compare it with the start of variables memory
    1111/    251E :                     ;	BLT		LAB_TMER				; if not variables memory do type mismatch error
    1112/    251E :                     
    1113/    251E :                     ;	MOVEQ		#28,d0				; we need 28 bytes !
    1114/    251E :                     ;	BSR.s		LAB_1212				; check room on stack for d0 bytes
    1115/    251E :                     
    1116/    251E : 6100 0214           	BSR		LAB_SNBS				; scan for next BASIC statement ([:] or [EOL])
    1117/    2522 :                     								; returns a0 as pointer to [:] or [EOL]
    1118/    2522 : 2E88                	MOVE.l	a0,(sp)				; push onto stack (and dump the return address)
    1119/    2524 : 2F2B 0452           	MOVE.l	Clinel(a3),-(sp)			; push current line onto stack
    1120/    2528 :                     
    1121/    2528 : 70AA                	MOVEQ		#TK_TO-$100,d0			; set "TO" token
    1122/    252A : 6100 087A           	BSR		LAB_SCCA				; scan for CHR$(d0) else syntax error/warm start
    1123/    252E : 6100 0708           	BSR		LAB_CTNM				; check if source is numeric, else type mismatch
    1124/    2532 : 1F2B 05B5           	MOVE.b	Dtypef(a3),-(sp)			; push the FOR variable data type onto stack
    1125/    2536 : 6100 06FE           	BSR		LAB_EVNM				; evaluate expression and check is numeric else
    1126/    253A :                     								; do type mismatch
    1127/    253A :                     
    1128/    253A : 2F2B 0590           	MOVE.l	FAC1_m(a3),-(sp)			; push TO value mantissa
    1129/    253E : 3F2B 0594           	MOVE.w	FAC1_e(a3),-(sp)			; push TO value exponent and sign
    1130/    2542 :                     
    1131/    2542 : 277C 8000 0000      	MOVE.l	#$80000000,FAC1_m(a3)		; set default STEP size mantissa
             2548 : 0590             
    1132/    254A : 377C 8100 0594      	MOVE.w	#$8100,FAC1_e(a3)			; set default STEP size exponent and sign
    1133/    2550 :                     
    1134/    2550 : 6100 085E           	BSR		LAB_GBYT				; scan memory
    1135/    2554 : B03C 00AF           	CMP.b		#TK_STEP,d0				; compare with STEP token
    1136/    2558 : 6608                	BNE.s		LAB_15B3				; jump if not "STEP"
    1137/    255A :                     
    1138/    255A :                     								; was STEP token so ....
    1139/    255A : 6100 0852           	BSR		LAB_IGBY				; increment & scan memory
    1140/    255E : 6100 06D6           	BSR		LAB_EVNM				; evaluate expression & check is numeric
    1141/    2562 :                     								; else do type mismatch
    1142/    2562 :                     LAB_15B3
    1143/    2562 : 2F2B 0590           	MOVE.l	FAC1_m(a3),-(sp)			; push STEP value mantissa
    1144/    2566 : 3F2B 0594           	MOVE.w	FAC1_e(a3),-(sp)			; push STEP value exponent and sign
    1145/    256A :                     
    1146/    256A : 2F2B 0472           	MOVE.l	Lvarpl(a3),-(sp)			; push variable pointer for FOR/NEXT
    1147/    256E : 3F3C 0081           	MOVE.w	#TK_FOR,-(sp)			; push FOR token on stack
    1148/    2572 :                     
    1149/    2572 : 6018                	BRA.s		LAB_15C2				; go do interpreter inner loop
    1150/    2574 :                     
    1151/    2574 :                     LAB_15DC							; have reached [EOL]+1
    1152/    2574 : 300D                	MOVE.w	a5,d0					; copy BASIC execute pointer
    1153/    2576 : C07C 0001           	AND.w		#1,d0					; and make line start address even
    1154/    257A : DAC0                	ADD.w		d0,a5					; add to BASIC execute pointer
    1155/    257C : 201D                	MOVE.l	(a5)+,d0				; get next line pointer
    1156/    257E : 6700 FC18           	BEQ		LAB_1274				; if null go to immediate mode, no "BREAK"
    1157/    2582 :                     								; message (was immediate or [EOT] marker)
    1158/    2582 :                     
    1159/    2582 : 275D 0452           	MOVE.l	(a5)+,Clinel(a3)			; save (new) current line #
    1160/    2586 :                     LAB_15F6
    1161/    2586 : 6100 0828           	BSR		LAB_GBYT				; get BASIC byte
    1162/    258A : 611A                	BSR.s		LAB_15FF				; go interpret BASIC code from (a5)
    1163/    258C :                     
    1164/    258C :                     ; interpreter inner loop (re)entry point
    1165/    258C :                     
    1166/    258C :                     LAB_15C2
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 24 - 11/4/2023 8:40:20


    1167/    258C : 6140                	BSR.s		LAB_1629				; do CRTL-C check vector
    1168/    258E : 4A2B 0452           	TST.b		Clinel(a3)				; test current line #, is -ve for immediate mode
    1169/    2592 : 6B04                	BMI.s		LAB_15D1				; branch if immediate mode
    1170/    2594 :                     
    1171/    2594 : 274D 045A           	MOVE.l	a5,Cpntrl(a3)			; save BASIC execute pointer as continue pointer
    1172/    2598 :                     LAB_15D1
    1173/    2598 : 101D                	MOVE.b	(a5)+,d0				; get this byte & increment pointer
    1174/    259A : 67D8                	BEQ.s		LAB_15DC				; loop if [EOL]
    1175/    259C :                     
    1176/    259C : B03C 003A           	CMP.b		#$3A,d0				; compare with ":"
    1177/    25A0 : 67E4                	BEQ.s		LAB_15F6				; loop if was statement separator
    1178/    25A2 :                     
    1179/    25A2 : 6000 FBC4           	BRA		LAB_SNER				; else syntax error, then warm start
    1180/    25A6 :                     
    1181/    25A6 :                     
    1182/    25A6 :                     ;************************************************************************************
    1183/    25A6 :                     ;
    1184/    25A6 :                     ; interpret BASIC code from (a5)
    1185/    25A6 :                     
    1186/    25A6 :                     LAB_15FF
    1187/    25A6 : 6700 008C           	BEQ		RTS_006				; exit if zero [EOL]
    1188/    25AA :                     
    1189/    25AA :                     LAB_1602
    1190/    25AA : 0A00 0080           	EORI.b	#$80,d0				; normalise token
    1191/    25AE : 6B00 02F6           	BMI		LAB_LET				; if not token, go do implied LET
    1192/    25B2 :                     
    1193/    25B2 : B03C 0028           	CMP.b		#(TK_TAB-$80),d0			; compare normalised token with TAB
    1194/    25B6 : 6400 FBB0           	BCC		LAB_SNER				; branch if d0>=TAB, syntax error/warm start
    1195/    25BA :                     								; only tokens before TAB can start a statement
    1196/    25BA :                     
    1197/    25BA : 4880                	EXT.w		d0					; byte to word (clear high byte)
    1198/    25BC : D040                	ADD.w		d0,d0					; *2
    1199/    25BE : 41FA 287C           	LEA		LAB_CTBL(pc),a0			; get vector table base address
    1200/    25C2 : 3030 0000           	MOVE.w	(a0,d0.w),d0			; get offset to vector
    1201/    25C6 : 4870 0000           	PEA		(a0,d0.w)				; push vector
    1202/    25CA : 6000 07E2           	BRA		LAB_IGBY				; get following byte & execute vector
    1203/    25CE :                     
    1204/    25CE :                     
    1205/    25CE :                     ;************************************************************************************
    1206/    25CE :                     ;
    1207/    25CE :                     ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
    1208/    25CE :                     ; key press is detected.
    1209/    25CE :                     
    1210/    25CE :                     LAB_1629
    1211/    25CE : 4EEB 0424           	JMP		V_CTLC(a3)				; ctrl c check vector
    1212/    25D2 :                     
    1213/    25D2 :                     ; if there was a key press it gets back here .....
    1214/    25D2 :                     
    1215/    25D2 :                     LAB_1636
    1216/    25D2 : B03C 0003           	CMP.b		#$03,d0				; compare with CTRL-C
    1217/    25D6 : 670C                	BEQ.s		LAB_163B				; STOP if was CTRL-C
    1218/    25D8 :                     
    1219/    25D8 :                     LAB_1639
    1220/    25D8 : 4E75                	RTS
    1221/    25DA :                     
    1222/    25DA :                     
    1223/    25DA :                     ;************************************************************************************
    1224/    25DA :                     ;
    1225/    25DA :                     ; perform END
    1226/    25DA :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 25 - 11/4/2023 8:40:20


    1227/    25DA :                     LAB_END
    1228/    25DA : 66FC                	BNE.s		LAB_1639				; exit if something follows STOP
    1229/    25DC : 177C 0000 05DC      	MOVE.b	#0,Breakf(a3)			; clear break flag, indicate program end
    1230/    25E2 :                     
    1231/    25E2 :                     
    1232/    25E2 :                     ;************************************************************************************
    1233/    25E2 :                     ;
    1234/    25E2 :                     ; perform STOP
    1235/    25E2 :                     
    1236/    25E2 :                     LAB_STOP
    1237/    25E2 : 66F4                	BNE.s		LAB_1639				; exit if something follows STOP
    1238/    25E4 :                     
    1239/    25E4 :                     LAB_163B
    1240/    25E4 : 43EB 0590           	LEA		Ibuffe(a3),a1			; get buffer end
    1241/    25E8 : BBC9                	CMPA.l	a1,a5					; compare execute address with buffer end
    1242/    25EA : 650A                	BCS.s		LAB_164F				; branch if BASIC pointer is in buffer
    1243/    25EC :                     								; can't continue in immediate mode
    1244/    25EC :                     
    1245/    25EC :                     								; else...
    1246/    25EC : 274D 045A           	MOVE.l	a5,Cpntrl(a3)			; save BASIC execute pointer as continue pointer
    1247/    25F0 :                     LAB_1647
    1248/    25F0 : 276B 0452 0456      	MOVE.l	Clinel(a3),Blinel(a3)		; save break line
    1249/    25F6 :                     LAB_164F
    1250/    25F6 : 584F                	ADDQ.w	#4,sp					; dump return address, don't return to execute
    1251/    25F8 :                     								; loop
    1252/    25F8 : 102B 05DC           	MOVE.b	Breakf(a3),d0			; get break flag
    1253/    25FC : 6700 FB9A           	BEQ		LAB_1274				; go do warm start if was program end
    1254/    2600 :                     
    1255/    2600 : 41FA 2EB3           	LEA		LAB_BMSG(pc),a0			; point to "Break"
    1256/    2604 : 6000 FB84           	BRA		LAB_1269				; print "Break" and do warm start
    1257/    2608 :                     
    1258/    2608 :                     
    1259/    2608 :                     ;************************************************************************************
    1260/    2608 :                     ;
    1261/    2608 :                     ; perform RESTORE
    1262/    2608 :                     
    1263/    2608 :                     LAB_RESTORE
    1264/    2608 : 206B 042E           	MOVEA.l	Smeml(a3),a0			; copy start of memory
    1265/    260C : 6720                	BEQ.s		LAB_1624				; branch if next character null (RESTORE)
    1266/    260E :                     
    1267/    260E : 6100 01F4           	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
    1268/    2612 : B2AB 0452           	CMP.l		Clinel(a3),d1			; compare current line # with required line #
    1269/    2616 : 630E                	BLS.s		LAB_GSCH				; branch if >= (start search from beginning)
    1270/    2618 :                     
    1271/    2618 : 204D                	MOVEA.l	a5,a0					; copy BASIC execute pointer
    1272/    261A :                     LAB_RESs
    1273/    261A : 4A18                	TST.b		(a0)+					; test next byte & increment pointer
    1274/    261C : 66FC                	BNE.s		LAB_RESs				; loop if not EOL
    1275/    261E :                     
    1276/    261E : 3008                	MOVE.w	a0,d0					; copy pointer
    1277/    2620 : C07C 0001           	AND.w		#1,d0					; mask odd bit
    1278/    2624 : D0C0                	ADD.w		d0,a0					; add pointer
    1279/    2626 :                     								; search for line in Itemp from (a0)
    1280/    2626 :                     LAB_GSCH
    1281/    2626 : 6100 FDC8           	BSR		LAB_SCLN				; search for d1 line number from a0
    1282/    262A :                     								; returns Cb=0 if found
    1283/    262A : 6500 FB24           	BCS		LAB_USER				; go do "Undefined statement" error if not found
    1284/    262E :                     
    1285/    262E :                     LAB_1624
    1286/    262E : 4A20                	TST.b		-(a0)					; decrement pointer (faster)
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 26 - 11/4/2023 8:40:20


    1287/    2630 : 2748 0462           	MOVE.l	a0,Dptrl(a3)			; save DATA pointer
    1288/    2634 :                     RTS_006
    1289/    2634 : 4E75                	RTS
    1290/    2636 :                     
    1291/    2636 :                     
    1292/    2636 :                     ;************************************************************************************
    1293/    2636 :                     ;
    1294/    2636 :                     ; perform NULL
    1295/    2636 :                     
    1296/    2636 :                     LAB_NULL
    1297/    2636 : 6100 10E2           	BSR		LAB_GTBY				; get byte parameter, result in d0 and Itemp
    1298/    263A : 1740 05E4           	MOVE.b	d0,Nullct(a3)			; save new NULL count
    1299/    263E : 4E75                	RTS
    1300/    2640 :                     
    1301/    2640 :                     
    1302/    2640 :                     ;************************************************************************************
    1303/    2640 :                     ;
    1304/    2640 :                     ; perform CONT
    1305/    2640 :                     
    1306/    2640 :                     LAB_CONT
    1307/    2640 : 6600 FB26           	BNE		LAB_SNER				; if following byte exit to do syntax error
    1308/    2644 :                     
    1309/    2644 : 4A2B 0452           	TST.b		Clinel(a3)				; test current line #, is -ve for immediate mode
    1310/    2648 : 6A00 FAE6           	BPL		LAB_CCER				; if running go do can't continue error
    1311/    264C :                     
    1312/    264C : 202B 045A           	MOVE.l	Cpntrl(a3),d0			; get continue pointer
    1313/    2650 : 6700 FADE           	BEQ		LAB_CCER				; go do can't continue error if we can't
    1314/    2654 :                     
    1315/    2654 :                     								; we can continue so ...
    1316/    2654 : 2A40                	MOVEA.l	d0,a5					; save continue pointer as BASIC execute pointer
    1317/    2656 : 276B 0456 0452      	MOVE.l	Blinel(a3),Clinel(a3)		; set break line as current line
    1318/    265C : 4E75                	RTS
    1319/    265E :                     
    1320/    265E :                     
    1321/    265E :                     ;************************************************************************************
    1322/    265E :                     ;
    1323/    265E :                     ; perform RUN
    1324/    265E :                     
    1325/    265E :                     LAB_RUN
    1326/    265E : 660C                	BNE.s		LAB_RUNn				; if following byte do RUN n
    1327/    2660 :                     
    1328/    2660 : 6100 FDAE           	BSR		LAB_1477				; execution to start, clear vars & flush stack
    1329/    2664 : 274D 045A           	MOVE.l	a5,Cpntrl(a3)			; save as continue pointer
    1330/    2668 : 6000 FF22           	BRA		LAB_15C2				; go do interpreter inner loop
    1331/    266C :                     								; (can't RTS, we flushed the stack!)
    1332/    266C :                     
    1333/    266C :                     LAB_RUNn
    1334/    266C : 6100 FDA8           	BSR		LAB_147A				; go do "CLEAR"
    1335/    2670 : 601C                	BRA.s		LAB_16B0				; get n and do GOTO n
    1336/    2672 :                     
    1337/    2672 :                     
    1338/    2672 :                     ;************************************************************************************
    1339/    2672 :                     ;
    1340/    2672 :                     ; perform DO
    1341/    2672 :                     
    1342/    2672 :                     LAB_DO
    1343/    2672 :                     ;	MOVE.l	#$05,d0				; need 5 bytes for DO
    1344/    2672 :                     ;	BSR.s		LAB_1212				; check room on stack for A bytes
    1345/    2672 : 2F0D                	MOVE.l	a5,-(sp)				; push BASIC execute pointer on stack
    1346/    2674 : 2F2B 0452           	MOVE.l	Clinel(a3),-(sp)			; push current line on stack
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 27 - 11/4/2023 8:40:20


    1347/    2678 : 3F3C 009C           	MOVE.w	#TK_DO,-(sp)			; push token for DO on stack
    1348/    267C : 487A FF0E           	PEA		LAB_15C2(pc)			; set return address
    1349/    2680 : 6000 072E           	BRA		LAB_GBYT				; scan memory & return to interpreter inner loop
    1350/    2684 :                     
    1351/    2684 :                     
    1352/    2684 :                     ;************************************************************************************
    1353/    2684 :                     ;
    1354/    2684 :                     ; perform GOSUB
    1355/    2684 :                     
    1356/    2684 :                     LAB_GOSUB
    1357/    2684 :                     ;	MOVE.l	#10,d0				; need 10 bytes for GOSUB
    1358/    2684 :                     ;	BSR.s		LAB_1212				; check room on stack for d0 bytes
    1359/    2684 : 2F0D                	MOVE.l	a5,-(sp)				; push BASIC execute pointer
    1360/    2686 : 2F2B 0452           	MOVE.l	Clinel(a3),-(sp)			; push current line
    1361/    268A : 3F3C 008D           	MOVE.w	#TK_GOSUB,-(sp)			; push token for GOSUB
    1362/    268E :                     LAB_16B0
    1363/    268E : 6100 0720           	BSR		LAB_GBYT				; scan memory
    1364/    2692 : 487A FEF8           	PEA		LAB_15C2(pc)			; return to interpreter inner loop after GOTO n
    1365/    2696 :                     
    1366/    2696 :                     ; this PEA is needed because either we just cleared the stack and have nowhere to return
    1367/    2696 :                     ; to or, in the case of GOSUB, we have just dropped a load on the stack and the address
    1368/    2696 :                     ; we whould have returned to is buried. This burried return address will be unstacked by
    1369/    2696 :                     ; the corresponding RETURN command
    1370/    2696 :                     
    1371/    2696 :                     
    1372/    2696 :                     ;************************************************************************************
    1373/    2696 :                     ;
    1374/    2696 :                     ; perform GOTO
    1375/    2696 :                     
    1376/    2696 :                     LAB_GOTO
    1377/    2696 : 6100 016C           	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
    1378/    269A : 206B 042E           	MOVEA.l	Smeml(a3),a0			; get start of memory
    1379/    269E : B2AB 0452           	CMP.l		Clinel(a3),d1			; compare current line with wanted #
    1380/    26A2 : 630E                	BLS.s		LAB_16D0				; branch if current # => wanted #
    1381/    26A4 :                     
    1382/    26A4 : 204D                	MOVEA.l	a5,a0					; copy BASIC execute pointer
    1383/    26A6 :                     LAB_GOTs
    1384/    26A6 : 4A18                	TST.b		(a0)+					; test next byte & increment pointer
    1385/    26A8 : 66FC                	BNE.s		LAB_GOTs				; loop if not EOL
    1386/    26AA :                     
    1387/    26AA : 3008                	MOVE.w	a0,d0					; past pad byte(s)
    1388/    26AC : C07C 0001           	AND.w		#1,d0					; mask odd bit
    1389/    26B0 : D0C0                	ADD.w		d0,a0					; add to pointer
    1390/    26B2 :                     
    1391/    26B2 :                     LAB_16D0
    1392/    26B2 : 6100 FD3C           	BSR		LAB_SCLN				; search for d1 line number from a0
    1393/    26B6 :                     								; returns Cb=0 if found
    1394/    26B6 : 6500 FA98           	BCS		LAB_USER				; if carry set go do "Undefined statement" error
    1395/    26BA :                     
    1396/    26BA : 2A48                	MOVEA.l	a0,a5					; copy to basic execute pointer
    1397/    26BC : 534D                	SUBQ.w	#1,a5					; decrement pointer
    1398/    26BE : 274D 045A           	MOVE.l	a5,Cpntrl(a3)			; save as continue pointer
    1399/    26C2 : 4E75                	RTS
    1400/    26C4 :                     
    1401/    26C4 :                     
    1402/    26C4 :                     ;************************************************************************************
    1403/    26C4 :                     ;
    1404/    26C4 :                     ; perform LOOP
    1405/    26C4 :                     
    1406/    26C4 :                     LAB_LOOP
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 28 - 11/4/2023 8:40:20


    1407/    26C4 : 0C6F 009C 0004      	CMP.w		#TK_DO,4(sp)			; compare token on stack with DO token
    1408/    26CA : 6600 FA5C           	BNE		LAB_LDER				; branch if no matching DO
    1409/    26CE :                     
    1410/    26CE : 1E00                	MOVE.b	d0,d7					; copy following token (byte)
    1411/    26D0 : 672E                	BEQ.s		LoopAlways				; if no following token loop forever
    1412/    26D2 :                     
    1413/    26D2 : BE3C 003A           	CMP.b		#':',d7				; compare with ":"
    1414/    26D6 : 6728                	BEQ.s		LoopAlways				; if no following token loop forever
    1415/    26D8 :                     
    1416/    26D8 : 9E3C 00B0           	SUB.b		#TK_UNTIL,d7			; subtract token for UNTIL
    1417/    26DC : 6708                	BEQ.s		DoRest				; branch if was UNTIL
    1418/    26DE :                     
    1419/    26DE : 5307                	SUBQ.b	#1,d7					; decrement result
    1420/    26E0 : 6600 FA86           	BNE		LAB_SNER				; if not WHILE go do syntax error & warm start
    1421/    26E4 :                     								; only if the token was WHILE will this fail
    1422/    26E4 :                     
    1423/    26E4 : 7EFF                	MOVEQ		#-1,d7				; set invert result longword
    1424/    26E6 :                     DoRest
    1425/    26E6 : 6100 06C6           	BSR		LAB_IGBY				; increment & scan memory
    1426/    26EA : 6100 0562           	BSR		LAB_EVEX				; evaluate expression
    1427/    26EE : 4A2B 0594           	TST.b		FAC1_e(a3)				; test FAC1 exponent
    1428/    26F2 : 6706                	BEQ.s		DoCmp					; if = 0 go do straight compare
    1429/    26F4 :                     
    1430/    26F4 : 177C 00FF 0594      	MOVE.b	#$FF,FAC1_e(a3)			; else set all bits
    1431/    26FA :                     DoCmp
    1432/    26FA : BF2B 0594           	EOR.b		d7,FAC1_e(a3)			; EOR with invert byte
    1433/    26FE : 6614                	BNE.s		LoopDone				; if <> 0 clear stack & back to interpreter loop
    1434/    2700 :                     
    1435/    2700 :                     								; loop condition wasn't met so do it again
    1436/    2700 :                     LoopAlways
    1437/    2700 : 276F 0006 0452      	MOVE.l	6(sp),Clinel(a3)			; copy DO current line
    1438/    2706 : 2A6F 000A           	MOVE.l	10(sp),a5				; save BASIC execute pointer
    1439/    270A :                     
    1440/    270A : 41FA FE80           	LEA		LAB_15C2(pc),a0			; get return address
    1441/    270E : 2E88                	MOVE.l	a0,(sp)				; dump the call to this routine and set the
    1442/    2710 :                     								; return address
    1443/    2710 : 6000 069E           	BRA		LAB_GBYT				; scan memory and return to interpreter inner
    1444/    2714 :                     								; loop
    1445/    2714 :                     
    1446/    2714 :                     								; clear stack & back to interpreter loop
    1447/    2714 :                     LoopDone
    1448/    2714 : 4FEF 000E           	LEA		14(sp),sp				; dump structure and call from stack
    1449/    2718 : 6014                	BRA.s		LAB_DATA				; go perform DATA (find : or [EOL])
    1450/    271A :                     
    1451/    271A :                     
    1452/    271A :                     ;************************************************************************************
    1453/    271A :                     ;
    1454/    271A :                     ; perform RETURN
    1455/    271A :                     
    1456/    271A :                     LAB_RETURN
    1457/    271A : 6616                	BNE.s		RTS_007				; exit if following token to allow syntax error
    1458/    271C :                     
    1459/    271C : 0C6F 008D 0004      	CMP.w		#TK_GOSUB,4(sp)			; compare token from stack with GOSUB
    1460/    2722 : 6600 FA40           	BNE		LAB_RGER				; do RETURN without GOSUB error if no matching
    1461/    2726 :                     								; GOSUB
    1462/    2726 :                     
    1463/    2726 : 5C4F                	ADDQ.w	#6,sp					; dump calling address & token
    1464/    2728 : 275F 0452           	MOVE.l	(sp)+,Clinel(a3)			; pull current line
    1465/    272C : 2A5F                	MOVE.l	(sp)+,a5				; pull BASIC execute pointer
    1466/    272E :                     								; now do perform "DATA" statement as we could be
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 29 - 11/4/2023 8:40:20


    1467/    272E :                     								; returning into the middle of an ON <var> GOSUB
    1468/    272E :                     								; n,m,p,q line (the return address used by the
    1469/    272E :                     								; DATA statement is the one pushed before the
    1470/    272E :                     								; GOSUB was executed!)
    1471/    272E :                     
    1472/    272E :                     
    1473/    272E :                     ;************************************************************************************
    1474/    272E :                     ;
    1475/    272E :                     ; perform DATA
    1476/    272E :                     
    1477/    272E :                     LAB_DATA
    1478/    272E : 6104                	BSR.s		LAB_SNBS				; scan for next BASIC statement ([:] or [EOL])
    1479/    2730 :                     								; returns a0 as pointer to [:] or [EOL]
    1480/    2730 : 2A48                	MOVEA.l	a0,a5					; skip rest of statement
    1481/    2732 :                     RTS_007
    1482/    2732 : 4E75                	RTS
    1483/    2734 :                     
    1484/    2734 :                     
    1485/    2734 :                     ;************************************************************************************
    1486/    2734 :                     ;
    1487/    2734 :                     ; scan for next BASIC statement ([:] or [EOL])
    1488/    2734 :                     ; returns a0 as pointer to [:] or [EOL]
    1489/    2734 :                     
    1490/    2734 :                     LAB_SNBS
    1491/    2734 : 204D                	MOVEA.l	a5,a0					; copy BASIC execute pointer
    1492/    2736 : 7222                	MOVEQ		#$22,d1				; set string quote character
    1493/    2738 : 743A                	MOVEQ		#$3A,d2				; set look for character = ":"
    1494/    273A : 6008                	BRA.s		LAB_172D				; go do search
    1495/    273C :                     
    1496/    273C :                     LAB_172C
    1497/    273C : B400                	CMP.b		d0,d2					; compare with ":"
    1498/    273E : 6708                	BEQ.s		RTS_007a				; exit if found
    1499/    2740 :                     
    1500/    2740 : B200                	CMP.b		d0,d1					; compare with '"'
    1501/    2742 : 670C                	BEQ.s		LAB_1725				; if found go search for [EOL]
    1502/    2744 :                     
    1503/    2744 :                     LAB_172D
    1504/    2744 : 1018                	MOVE.b	(a0)+,d0				; get next byte
    1505/    2746 : 66F4                	BNE.s		LAB_172C				; loop if not null [EOL]
    1506/    2748 :                     
    1507/    2748 :                     RTS_007a
    1508/    2748 : 5348                	SUBQ.w	#1,a0					; correct pointer
    1509/    274A : 4E75                	RTS
    1510/    274C :                     
    1511/    274C :                     LAB_1723
    1512/    274C : B200                	CMP.b		d0,d1					; compare with '"'
    1513/    274E : 67F4                	BEQ.s		LAB_172D				; if found go search for ":" or [EOL]
    1514/    2750 :                     
    1515/    2750 :                     LAB_1725
    1516/    2750 : 1018                	MOVE.b	(a0)+,d0				; get next byte
    1517/    2752 : 66F8                	BNE.s		LAB_1723				; loop if not null [EOL]
    1518/    2754 :                     
    1519/    2754 : 60F2                	BRA.s		RTS_007a				; correct pointer & return
    1520/    2756 :                     
    1521/    2756 :                     
    1522/    2756 :                     ;************************************************************************************
    1523/    2756 :                     ;
    1524/    2756 :                     ; perform IF
    1525/    2756 :                     
    1526/    2756 :                     LAB_IF
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 30 - 11/4/2023 8:40:20


    1527/    2756 : 6100 04F6           	BSR		LAB_EVEX				; evaluate expression
    1528/    275A : 6100 0654           	BSR		LAB_GBYT				; scan memory
    1529/    275E : B03C 00AD           	CMP.b		#TK_THEN,d0				; compare with THEN token
    1530/    2762 : 6714                	BEQ.s		LAB_174B				; if it was THEN then continue
    1531/    2764 :                     
    1532/    2764 :                     								; wasn't IF .. THEN so must be IF .. GOTO
    1533/    2764 : B03C 0089           	CMP.b		#TK_GOTO,d0				; compare with GOTO token
    1534/    2768 : 6600 F9FE           	BNE		LAB_SNER				; if not GOTO token do syntax error/warm start
    1535/    276C :                     
    1536/    276C :                     								; was GOTO so check for GOTO <n>
    1537/    276C : 204D                	MOVE.l	a5,a0					; save the execute pointer
    1538/    276E : 6100 063E           	BSR		LAB_IGBY				; scan memory, test for a numeric character
    1539/    2772 : 2A48                	MOVE.l	a0,a5					; restore the execute pointer
    1540/    2774 : 6400 F9F2           	BCC		LAB_SNER				; if not numeric do syntax error/warm start
    1541/    2778 :                     
    1542/    2778 :                     LAB_174B
    1543/    2778 : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
    1544/    277C : 671E                	BEQ.s		LAB_174E				; if result was zero go look for an ELSE
    1545/    277E :                     
    1546/    277E : 6100 062E           	BSR		LAB_IGBY				; increment & scan memory
    1547/    2782 : 6500 FF12           	BCS		LAB_GOTO				; if numeric do GOTO n
    1548/    2786 :                     								; a GOTO <n> will never return to the IF
    1549/    2786 :                     								; statement so there is no need to return
    1550/    2786 :                     								; to this code
    1551/    2786 :                     
    1552/    2786 : B03C 008E           	CMP.b		#TK_RETURN,d0			; compare with RETURN token
    1553/    278A : 6700 FE1E           	BEQ		LAB_1602				; if RETURN then interpret BASIC code from (a5)
    1554/    278E :                     								; and don't return here
    1555/    278E :                     
    1556/    278E : 6100 FE16           	BSR		LAB_15FF				; else interpret BASIC code from (a5)
    1557/    2792 :                     
    1558/    2792 :                     ; the IF was executed and there may be a following ELSE so the code needs to return
    1559/    2792 :                     ; here to check and ignore the ELSE if present
    1560/    2792 :                     
    1561/    2792 : 1015                	MOVE.b	(a5),d0				; get the next basic byte
    1562/    2794 : B03C 00A9           	CMP.b		#TK_ELSE,d0				; compare it with the token for ELSE
    1563/    2798 : 6794                	BEQ		LAB_DATA				; if ELSE ignore the following statement
    1564/    279A :                     
    1565/    279A :                     ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
    1566/    279A :                     ; following ELSE will, correctly, cause a syntax error
    1567/    279A :                     
    1568/    279A : 4E75                	RTS							; else return to interpreter inner loop
    1569/    279C :                     
    1570/    279C :                     ; perform ELSE after IF
    1571/    279C :                     
    1572/    279C :                     LAB_174E
    1573/    279C : 101D                	MOVE.b	(a5)+,d0				; faster increment past THEN
    1574/    279E : 163C 00A9           	MOVE.b		#TK_ELSE,d3				; set search for ELSE token
    1575/    27A2 : 183C 008B           	MOVE.b		#TK_IF,d4				; set search for IF token
    1576/    27A6 : 7A00                	MOVEQ		#0,d5					; clear the nesting depth
    1577/    27A8 :                     LAB_1750
    1578/    27A8 : 101D                	MOVE.b	(a5)+,d0				; get next BASIC byte & increment ptr
    1579/    27AA : 6720                	BEQ.s		LAB_1754				; if EOL correct the pointer and return
    1580/    27AC :                     
    1581/    27AC : B004                	CMP.b		d4,d0					; compare with "IF" token
    1582/    27AE : 6604                	BNE.s		LAB_1752				; skip if not nested IF
    1583/    27B0 :                     
    1584/    27B0 : 5245                	ADDQ.w	#1,d5					; else increment the nesting depth ..
    1585/    27B2 : 60F4                	BRA.s		LAB_1750				; .. and continue looking
    1586/    27B4 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 31 - 11/4/2023 8:40:20


    1587/    27B4 :                     LAB_1752
    1588/    27B4 : B003                	CMP.b		d3,d0					; compare with ELSE token
    1589/    27B6 : 66F0                	BNE.s		LAB_1750				; if not ELSE continue looking
    1590/    27B8 :                     
    1591/    27B8 :                     LAB_1756
    1592/    27B8 : 51CD FFEE           	DBF		d5,LAB_1750				; loop if still nested
    1593/    27BC :                     
    1594/    27BC :                     ; found the matching ELSE, now do <{n|statement}>
    1595/    27BC :                     
    1596/    27BC : 6100 05F2           	BSR		LAB_GBYT				; scan memory
    1597/    27C0 : 6500 FED4           	BCS		LAB_GOTO				; if numeric do GOTO n
    1598/    27C4 :                     								; code will return to the interpreter loop
    1599/    27C4 :                     								; at the tail end of the GOTO <n>
    1600/    27C4 :                     
    1601/    27C4 : 6000 FDE0           	BRA		LAB_15FF				; else interpret BASIC code from (a5)
    1602/    27C8 :                     								; code will return to the interpreter loop
    1603/    27C8 :                     								; at the tail end of the <statement>
    1604/    27C8 :                     
    1605/    27C8 :                     
    1606/    27C8 :                     ;************************************************************************************
    1607/    27C8 :                     ;
    1608/    27C8 :                     ; perform REM, skip (rest of) line
    1609/    27C8 :                     
    1610/    27C8 :                     LAB_REM
    1611/    27C8 : 4A1D                	TST.b		(a5)+					; test byte & increment pointer
    1612/    27CA : 66FC                	BNE.s		LAB_REM				; loop if not EOL
    1613/    27CC :                     
    1614/    27CC :                     LAB_1754
    1615/    27CC : 534D                	SUBQ.w	#1,a5					; correct the execute pointer
    1616/    27CE : 4E75                	RTS
    1617/    27D0 :                     
    1618/    27D0 :                     
    1619/    27D0 :                     ;************************************************************************************
    1620/    27D0 :                     ;
    1621/    27D0 :                     ; perform ON
    1622/    27D0 :                     
    1623/    27D0 :                     LAB_ON
    1624/    27D0 : 6100 0F48           	BSR		LAB_GTBY				; get byte parameter, result in d0 and Itemp
    1625/    27D4 : 1400                	MOVE.b	d0,d2					; copy byte
    1626/    27D6 : 6100 05D8           	BSR		LAB_GBYT				; restore BASIC byte
    1627/    27DA : 3F00                	MOVE.w	d0,-(sp)				; push GOTO/GOSUB token
    1628/    27DC : B03C 008D           	CMP.b		#TK_GOSUB,d0			; compare with GOSUB token
    1629/    27E0 : 6708                	BEQ.s		LAB_176C				; branch if GOSUB
    1630/    27E2 :                     
    1631/    27E2 : B03C 0089           	CMP.b		#TK_GOTO,d0				; compare with GOTO token
    1632/    27E6 : 6600 F980           	BNE		LAB_SNER				; if not GOTO do syntax error, then warm start
    1633/    27EA :                     
    1634/    27EA :                     ; next character was GOTO or GOSUB
    1635/    27EA :                     
    1636/    27EA :                     LAB_176C
    1637/    27EA : 5302                	SUBQ.b	#1,d2					; decrement index (byte value)
    1638/    27EC : 6606                	BNE.s		LAB_1773				; branch if not zero
    1639/    27EE :                     
    1640/    27EE : 301F                	MOVE.w	(sp)+,d0				; pull GOTO/GOSUB token
    1641/    27F0 : 6000 FDB8           	BRA		LAB_1602				; go execute it
    1642/    27F4 :                     
    1643/    27F4 :                     LAB_1773
    1644/    27F4 : 6100 05B8           	BSR		LAB_IGBY				; increment & scan memory
    1645/    27F8 : 610A                	BSR.s		LAB_GFPN				; get fixed-point number into temp integer & d1
    1646/    27FA :                     								; (skip this n)
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 32 - 11/4/2023 8:40:20


    1647/    27FA : B03C 002C           	CMP.b		#$2C,d0				; compare next character with ","
    1648/    27FE : 67EA                	BEQ.s		LAB_176C				; loop if ","
    1649/    2800 :                     
    1650/    2800 : 301F                	MOVE.w	(sp)+,d0				; pull GOTO/GOSUB token (run out of options)
    1651/    2802 : 4E75                	RTS							; and exit
    1652/    2804 :                     
    1653/    2804 :                     
    1654/    2804 :                     ;************************************************************************************
    1655/    2804 :                     ;
    1656/    2804 :                     ; get fixed-point number into temp integer & d1
    1657/    2804 :                     ; interpret number from (a5), leave (a5) pointing to byte after #
    1658/    2804 :                     
    1659/    2804 :                     LAB_GFPN
    1660/    2804 : 7200                	MOVEQ		#$00,d1				; clear integer register
    1661/    2806 : 2001                	MOVE.l	d1,d0					; clear d0
    1662/    2808 : 6100 05A6           	BSR		LAB_GBYT				; scan memory, Cb=1 if "0"-"9", & get byte
    1663/    280C : 642E                	BCC.s		LAB_1786				; return if carry clear, chr was not "0"-"9"
    1664/    280E :                     
    1665/    280E : 2F02                	MOVE.l	d2,-(sp)				; save d2
    1666/    2810 :                     LAB_1785
    1667/    2810 : 2401                	MOVE.l	d1,d2					; copy integer register
    1668/    2812 : D281                	ADD.l		d1,d1					; *2
    1669/    2814 : 6500 F952           	BCS		LAB_SNER				; if overflow do syntax error, then warm start
    1670/    2818 :                     
    1671/    2818 : D281                	ADD.l		d1,d1					; *4
    1672/    281A : 6500 F94C           	BCS		LAB_SNER				; if overflow do syntax error, then warm start
    1673/    281E :                     
    1674/    281E : D282                	ADD.l		d2,d1					; *1 + *4
    1675/    2820 : 6500 F946           	BCS		LAB_SNER				; if overflow do syntax error, then warm start
    1676/    2824 :                     
    1677/    2824 : D281                	ADD.l		d1,d1					; *10
    1678/    2826 : 6500 F940           	BCS		LAB_SNER				; if overflow do syntax error, then warm start
    1679/    282A :                     
    1680/    282A : 903C 0030           	SUB.b		#$30,d0				; subtract $30 from byte
    1681/    282E : D280                	ADD.l		d0,d1					; add to integer register, the top 24 bits are
    1682/    2830 :                     								; always clear
    1683/    2830 : 6900 F936           	BVS		LAB_SNER				; if overflow do syntax error, then warm start
    1684/    2834 :                     								; this makes the maximum line number 2147483647
    1685/    2834 : 6100 0578           	BSR		LAB_IGBY				; increment & scan memory
    1686/    2838 : 65D6                	BCS.s		LAB_1785				; loop for next character if "0"-"9"
    1687/    283A :                     
    1688/    283A : 241F                	MOVE.l	(sp)+,d2				; restore d2
    1689/    283C :                     LAB_1786
    1690/    283C : 2741 042A           	MOVE.l	d1,Itemp(a3)			; save Itemp
    1691/    2840 : 4E75                	RTS
    1692/    2842 :                     
    1693/    2842 :                     
    1694/    2842 :                     ;************************************************************************************
    1695/    2842 :                     ;
    1696/    2842 :                     ; perform DEC
    1697/    2842 :                     
    1698/    2842 :                     LAB_DEC
    1699/    2842 : 3F3C 8180           	MOVE.w	#$8180,-(sp)			; set -1 sign/exponent
    1700/    2846 : 600A                	BRA.s		LAB_17B7				; go do DEC
    1701/    2848 :                     
    1702/    2848 :                     
    1703/    2848 :                     ;************************************************************************************
    1704/    2848 :                     ;
    1705/    2848 :                     ; perform INC
    1706/    2848 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 33 - 11/4/2023 8:40:20


    1707/    2848 :                     LAB_INC
    1708/    2848 : 3F3C 8100           	MOVE.w	#$8100,-(sp)			; set 1 sign/exponent
    1709/    284C : 6004                	BRA.s		LAB_17B7				; go do INC
    1710/    284E :                     
    1711/    284E :                     								; was "," so another INCR variable to do
    1712/    284E :                     LAB_17B8
    1713/    284E : 6100 055E           	BSR		LAB_IGBY				; increment and scan memory
    1714/    2852 :                     LAB_17B7
    1715/    2852 : 6100 076C           	BSR		LAB_GVAR				; get variable address in a0
    1716/    2856 :                     
    1717/    2856 : 6732                	BEQ.s		LAB_INCT				; if variable not found skip the inc/dec
    1718/    2858 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
    1719/    285C :                     								; $00=float
    1720/    285C : 6B00 F8DE           	BMI		LAB_TMER				; if string do "Type mismatch" error/warm start
    1721/    2860 :                     
    1722/    2860 : 6636                	BNE.s		LAB_INCI				; go do integer INC/DEC
    1723/    2862 :                     
    1724/    2862 : 2748 0472           	MOVE.l	a0,Lvarpl(a3)			; save var address
    1725/    2866 : 6100 130E           	BSR		LAB_UFAC				; unpack memory (a0) into FAC1
    1726/    286A : 277C 8000 0000      	MOVE.l	#$80000000,FAC2_m(a3)		; set FAC2 mantissa for 1
             2870 : 0598             
    1727/    2872 : 3017                	MOVE.w	(sp),d0				; move exponent & sign to d0
    1728/    2874 : 3740 059C           	MOVE.w	d0,FAC2_e(a3)			; move exponent & sign to FAC2
    1729/    2878 : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; make sign compare = FAC1 sign
    1730/    287E : B12B 059E           	EOR.b		d0,FAC_sc(a3)			; make sign compare (FAC1_s EOR FAC2_s)
    1731/    2882 : 6100 100E           	BSR		LAB_ADD				; add FAC2 to FAC1
    1732/    2886 : 6100 130A           	BSR		LAB_PFAC				; pack FAC1 into variable (Lvarpl)
    1733/    288A :                     LAB_INCT
    1734/    288A : 6100 0524           	BSR		LAB_GBYT				; scan memory
    1735/    288E : 0C00 002C           	CMPI.b	#$2C,d0				; compare with ","
    1736/    2892 : 67BA                	BEQ.s		LAB_17B8				; continue if "," (another variable to do)
    1737/    2894 :                     
    1738/    2894 : 544F                	ADDQ.w	#2,sp					; else dump sign & exponent
    1739/    2896 : 4E75                	RTS
    1740/    2898 :                     
    1741/    2898 :                     LAB_INCI
    1742/    2898 : 4A2F 0001           	TST.b		1(sp)					; test sign
    1743/    289C : 6604                	BNE.s		LAB_DECI				; branch if DEC
    1744/    289E :                     
    1745/    289E : 5290                	ADDQ.l	#1,(a0)				; increment variable
    1746/    28A0 : 60E8                	BRA.s		LAB_INCT				; go scan for more
    1747/    28A2 :                     
    1748/    28A2 :                     LAB_DECI
    1749/    28A2 : 5390                	SUBQ.l	#1,(a0)				; decrement variable
    1750/    28A4 : 60E4                	BRA.s		LAB_INCT				; go scan for more
    1751/    28A6 :                     
    1752/    28A6 :                     
    1753/    28A6 :                     ;************************************************************************************
    1754/    28A6 :                     ;
    1755/    28A6 :                     ; perform LET
    1756/    28A6 :                     
    1757/    28A6 :                     LAB_LET
    1758/    28A6 : 6100 0714           	BSR		LAB_SVAR				; search for or create a variable
    1759/    28AA :                     								; return the variable address in a0
    1760/    28AA : 2748 0472           	MOVE.l	a0,Lvarpl(a3)			; save variable address
    1761/    28AE : 1F2B 05B5           	MOVE.b	Dtypef(a3),-(sp)			; push var data type, $80=string, $40=integer,
    1762/    28B2 :                     								; $00=float
    1763/    28B2 : 70BD                	MOVEQ		#TK_EQUAL-$100,d0			; get = token
    1764/    28B4 : 6100 04F0           	BSR		LAB_SCCA				; scan for CHR$(d0), else do syntax error/warm
    1765/    28B8 :                     								; start
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 34 - 11/4/2023 8:40:20


    1766/    28B8 : 6100 0394           	BSR		LAB_EVEX				; evaluate expression
    1767/    28BC : 102B 05B5           	MOVE.b	Dtypef(a3),d0			; copy expression data type
    1768/    28C0 : 175F 05B5           	MOVE.b	(sp)+,Dtypef(a3)			; pop variable data type
    1769/    28C4 : E318                	ROL.b		#1,d0					; set carry if expression type = string
    1770/    28C6 : 6100 0372           	BSR		LAB_CKTM				; type match check, set C for string
    1771/    28CA : 6700 12C6           	BEQ		LAB_PFAC				; if number pack FAC1 into variable Lvarpl & RET
    1772/    28CE :                     
    1773/    28CE :                     ; string LET
    1774/    28CE :                     
    1775/    28CE :                     LAB_17D5
    1776/    28CE : 246B 0472           	MOVEA.l	Lvarpl(a3),a2			; get pointer to variable
    1777/    28D2 :                     LAB_17D6
    1778/    28D2 : 206B 0590           	MOVEA.l	FAC1_m(a3),a0			; get descriptor pointer
    1779/    28D6 : 2250                	MOVEA.l	(a0),a1				; get string pointer
    1780/    28D8 : B3EB 0446           	CMP.l		Sstorl(a3),a1			; compare string memory start with string
    1781/    28DC :                     								; pointer
    1782/    28DC : 6516                	BCS.s		LAB_1811				; if it was in program memory assign the value
    1783/    28DE :                     								; and exit
    1784/    28DE :                     
    1785/    28DE : B1EB 0432           	CMPA.l	Sfncl(a3),a0			; compare functions start with descriptor
    1786/    28E2 :                     								; pointer
    1787/    28E2 : 6510                	BCS.s		LAB_1811				; branch if >= (string is on stack)
    1788/    28E4 :                     
    1789/    28E4 :                     								; string is variable$ make space and copy string
    1790/    28E4 :                     LAB_1810
    1791/    28E4 : 7200                	MOVEQ		#0,d1					; clear length
    1792/    28E6 : 3228 0004           	MOVE.w	4(a0),d1				; get string length
    1793/    28EA : 2050                	MOVEA.l	(a0),a0				; get string pointer
    1794/    28EC : 6100 0B06           	BSR		LAB_20C9				; copy string
    1795/    28F0 : 206B 0590           	MOVEA.l	FAC1_m(a3),a0			; get descriptor pointer back
    1796/    28F4 :                     								; clean stack & assign value to string variable
    1797/    28F4 :                     LAB_1811
    1798/    28F4 : B9C8                	CMPA.l	a0,a4					; is string on the descriptor stack
    1799/    28F6 : 6602                	BNE.s		LAB_1813				; skip pop if not
    1800/    28F8 :                     
    1801/    28F8 : 5C4C                	ADDQ.w	#$06,a4				; else update stack pointer
    1802/    28FA :                     LAB_1813
    1803/    28FA : 24D8                	MOVE.l	(a0)+,(a2)+				; save pointer to variable
    1804/    28FC : 3490                	MOVE.w	(a0),(a2)				; save length to variable
    1805/    28FE :                     RTS_008
    1806/    28FE : 4E75                	RTS
    1807/    2900 :                     
    1808/    2900 :                     
    1809/    2900 :                     ;************************************************************************************
    1810/    2900 :                     ;
    1811/    2900 :                     ; perform GET
    1812/    2900 :                     
    1813/    2900 :                     LAB_GET
    1814/    2900 : 6100 06BA           	BSR		LAB_SVAR				; search for or create a variable
    1815/    2904 :                     								; return the variable address in a0
    1816/    2904 : 2748 0472           	MOVE.l	a0,Lvarpl(a3)			; save variable address as GET variable
    1817/    2908 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
    1818/    290C :                     								; $00=float
    1819/    290C : 6B0C                	BMI.s		LAB_GETS				; go get string character
    1820/    290E :                     
    1821/    290E :                     								; was numeric get
    1822/    290E : 6100 1DF2           	BSR		INGET					; get input byte
    1823/    2912 : 6100 09BC           	BSR		LAB_1FD0				; convert d0 to unsigned byte in FAC1
    1824/    2916 : 6000 127A           	BRA		LAB_PFAC				; pack FAC1 into variable (Lvarpl) & return
    1825/    291A :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 35 - 11/4/2023 8:40:20


    1826/    291A :                     LAB_GETS
    1827/    291A : 7200                	MOVEQ		#$00,d1				; assume no byte
    1828/    291C : 2041                	MOVE.l	d1,a0					; assume null string
    1829/    291E : 6100 1DE2           	BSR		INGET					; get input byte
    1830/    2922 : 6408                	BCC.s		LAB_NoSt				; branch if no byte received
    1831/    2924 :                     
    1832/    2924 : 7201                	MOVEQ		#$01,d1				; string is single byte
    1833/    2926 : 6100 0AFE           	BSR		LAB_2115				; make string space d1 bytes long
    1834/    292A :                     								; return a0 = pointer, other registers unchanged
    1835/    292A :                     
    1836/    292A : 1080                	MOVE.b	d0,(a0)				; save byte in string (byte IS string!)
    1837/    292C :                     LAB_NoSt
    1838/    292C : 6100 0ADE           	BSR		LAB_RTST				; push string on descriptor stack
    1839/    2930 :                     								; a0 = pointer, d1 = length
    1840/    2930 :                     
    1841/    2930 : 609C                	BRA.s		LAB_17D5				; do string LET & return
    1842/    2932 :                     
    1843/    2932 :                     
    1844/    2932 :                     ;************************************************************************************
    1845/    2932 :                     ;
    1846/    2932 :                     ; PRINT
    1847/    2932 :                     
    1848/    2932 :                     LAB_1829
    1849/    2932 : 6100 00B4           	BSR		LAB_18C6				; print string from stack
    1850/    2936 :                     LAB_182C
    1851/    2936 : 6100 0478           	BSR		LAB_GBYT				; scan memory
    1852/    293A :                     
    1853/    293A :                     ; perform PRINT
    1854/    293A :                     
    1855/    293A :                     LAB_PRINT
    1856/    293A : 674A                	BEQ.s		LAB_CRLF				; if nothing following just print CR/LF
    1857/    293C :                     
    1858/    293C :                     LAB_1831
    1859/    293C : B03C 00A8           	CMP.b		#TK_TAB,d0				; compare with TAB( token
    1860/    2940 : 6764                	BEQ.s		LAB_18A2				; go do TAB/SPC
    1861/    2942 :                     
    1862/    2942 : B03C 00AC           	CMP.b		#TK_SPC,d0				; compare with SPC( token
    1863/    2946 : 675E                	BEQ.s		LAB_18A2				; go do TAB/SPC
    1864/    2948 :                     
    1865/    2948 : B03C 002C           	CMP.b		#',',d0				; compare with ","
    1866/    294C : 6740                	BEQ.s		LAB_188B				; go do move to next TAB mark
    1867/    294E :                     
    1868/    294E : B03C 003B           	CMP.b		#';',d0				; compare with ";"
    1869/    2952 : 6700 0086           	BEQ		LAB_18BD				; if ";" continue with PRINT processing
    1870/    2956 :                     
    1871/    2956 : 6100 02F6           	BSR		LAB_EVEX				; evaluate expression
    1872/    295A : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
    1873/    295E :                     								; $00=float
    1874/    295E : 6BD2                	BMI.s		LAB_1829				; branch if string
    1875/    2960 :                     
    1876/    2960 :                     ; replace the two lines above with this code
    1877/    2960 :                     
    1878/    2960 :                     ;	MOVE.b	Dtypef(a3),d0			; get data type flag, $80=string, $00=numeric
    1879/    2960 :                     ;	BMI.s		LAB_1829				; branch if string
    1880/    2960 :                     
    1881/    2960 : 6100 13B2           	BSR		LAB_2970				; convert FAC1 to string
    1882/    2964 : 6100 0A60           	BSR		LAB_20AE				; print " terminated string to FAC1 stack
    1883/    2968 :                     
    1884/    2968 :                     ; don't check fit if terminal width byte is zero
    1885/    2968 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 36 - 11/4/2023 8:40:20


    1886/    2968 : 7000                	MOVEQ		#0,d0					; clear d0
    1887/    296A : 102B 05E6           	MOVE.b	TWidth(a3),d0			; get terminal width byte
    1888/    296E : 670C                	BEQ.s		LAB_185E				; skip check if zero
    1889/    2970 :                     
    1890/    2970 : 902C 0007           	SUB.b		7(a4),d0				; subtract string length
    1891/    2974 : 902B 05E5           	SUB.b		TPos(a3),d0				; subtract terminal position
    1892/    2978 : 6402                	BCC		LAB_185E				; branch if less than terminal width
    1893/    297A :                     
    1894/    297A : 610A                	BSR.s		LAB_CRLF				; else print CR/LF
    1895/    297C :                     LAB_185E
    1896/    297C : 616A                	BSR.s		LAB_18C6				; print string from stack
    1897/    297E : 60B6                	BRA.s		LAB_182C				; always go continue processing line
    1898/    2980 :                     
    1899/    2980 :                     
    1900/    2980 :                     ;************************************************************************************
    1901/    2980 :                     ;
    1902/    2980 :                     ; CR/LF return to BASIC from BASIC input handler
    1903/    2980 :                     ; leaves a0 pointing to the buffer start
    1904/    2980 :                     
    1905/    2980 :                     LAB_1866
    1906/    2980 : 11BC 0000 1000      	MOVE.b	#$00,(a0,d1.w)			; null terminate input
    1907/    2986 :                     
    1908/    2986 :                     ; print CR/LF
    1909/    2986 :                     
    1910/    2986 :                     LAB_CRLF
    1911/    2986 : 700D                	MOVEQ		#$0D,d0				; load [CR]
    1912/    2988 : 6174                	BSR.s		LAB_PRNA				; go print the character
    1913/    298A : 700A                	MOVEQ		#$0A,d0				; load [LF]
    1914/    298C : 6070                	BRA.s		LAB_PRNA				; go print the character & return
    1915/    298E :                     
    1916/    298E :                     LAB_188B
    1917/    298E : 142B 05E5           	MOVE.b	TPos(a3),d2				; get terminal position
    1918/    2992 : B42B 05E7           	CMP.b		Iclim(a3),d2			; compare with input column limit
    1919/    2996 : 6504                	BCS.s		LAB_1898				; branch if less than Iclim
    1920/    2998 :                     
    1921/    2998 : 61EC                	BSR.s		LAB_CRLF				; else print CR/LF (next line)
    1922/    299A : 603E                	BRA.s		LAB_18BD				; continue with PRINT processing
    1923/    299C :                     
    1924/    299C :                     LAB_1898
    1925/    299C : 942B 05E2           	SUB.b		TabSiz(a3),d2			; subtract TAB size
    1926/    29A0 : 64FA                	BCC.s		LAB_1898				; loop if result was >= 0
    1927/    29A2 :                     
    1928/    29A2 : 4402                	NEG.b		d2					; twos complement it
    1929/    29A4 : 6022                	BRA.s		LAB_18B7				; print d2 spaces
    1930/    29A6 :                     
    1931/    29A6 :                     								; do TAB/SPC
    1932/    29A6 :                     LAB_18A2
    1933/    29A6 : 3F00                	MOVE.w	d0,-(sp)				; save token
    1934/    29A8 : 6100 0D6C           	BSR		LAB_SGBY				; increment and get byte, result in d0 and Itemp
    1935/    29AC : 3400                	MOVE.w	d0,d2					; copy byte
    1936/    29AE : 6100 0400           	BSR		LAB_GBYT				; get basic byte back
    1937/    29B2 : B03C 0029           	CMP.b		#$29,d0				; is next character ")"
    1938/    29B6 : 6600 F7B0           	BNE		LAB_SNER				; if not do syntax error, then warm start
    1939/    29BA :                     
    1940/    29BA : 301F                	MOVE.w	(sp)+,d0				; get token back
    1941/    29BC : B03C 00A8           	CMP.b		#TK_TAB,d0				; was it TAB ?
    1942/    29C0 : 6606                	BNE.s		LAB_18B7				; branch if not (was SPC)
    1943/    29C2 :                     
    1944/    29C2 :                     								; calculate TAB offset
    1945/    29C2 : 942B 05E5           	SUB.b		TPos(a3),d2				; subtract terminal position
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 37 - 11/4/2023 8:40:20


    1946/    29C6 : 6312                	BLS.s		LAB_18BD				; branch if result was <= 0
    1947/    29C8 :                     								; can't TAB backwards or already there
    1948/    29C8 :                     
    1949/    29C8 :                     								; print d2.b spaces
    1950/    29C8 :                     LAB_18B7
    1951/    29C8 : 7000                	MOVEQ		#0,d0					; clear longword
    1952/    29CA : 5300                	SUBQ.b	#1,d0					; make d0 = $FF
    1953/    29CC : C480                	AND.l		d0,d2					; mask for byte only
    1954/    29CE : 670A                	BEQ.s		LAB_18BD				; branch if zero
    1955/    29D0 :                     
    1956/    29D0 : 7020                	MOVEQ		#$20,d0				; load " "
    1957/    29D2 : 5302                	SUBQ.b	#1,d2					; adjust for DBF loop
    1958/    29D4 :                     LAB_18B8
    1959/    29D4 : 6128                	BSR.s		LAB_PRNA				; go print
    1960/    29D6 : 51CA FFFC           	DBF		d2,LAB_18B8				; decrement count and loop if not all done
    1961/    29DA :                     
    1962/    29DA :                     								; continue with PRINT processing
    1963/    29DA :                     LAB_18BD
    1964/    29DA : 6100 03D2           	BSR		LAB_IGBY				; increment & scan memory
    1965/    29DE : 6600 FF5C           	BNE		LAB_1831				; if byte continue executing PRINT
    1966/    29E2 :                     
    1967/    29E2 : 4E75                	RTS							; exit if nothing more to print
    1968/    29E4 :                     
    1969/    29E4 :                     
    1970/    29E4 :                     ;************************************************************************************
    1971/    29E4 :                     ;
    1972/    29E4 :                     ; print null terminated string from a0
    1973/    29E4 :                     
    1974/    29E4 :                     LAB_18C3
    1975/    29E4 : 6100 09E0           	BSR		LAB_20AE				; print terminated string to FAC1/stack
    1976/    29E8 :                     
    1977/    29E8 :                     ; print string from stack
    1978/    29E8 :                     
    1979/    29E8 :                     LAB_18C6
    1980/    29E8 : 6100 0BD0           	BSR		LAB_22B6				; pop string off descriptor stack or from memory
    1981/    29EC :                     								; returns with d0 = length, a0 = pointer
    1982/    29EC : 670C                	BEQ.s		RTS_009				; exit (RTS) if null string
    1983/    29EE :                     
    1984/    29EE : 3200                	MOVE.w	d0,d1					; copy length & set Z flag
    1985/    29F0 : 5341                	SUBQ.w	#1,d1					; -1 for BF loop
    1986/    29F2 :                     LAB_18CD
    1987/    29F2 : 1018                	MOVE.b	(a0)+,d0				; get byte from string
    1988/    29F4 : 6108                	BSR.s		LAB_PRNA				; go print the character
    1989/    29F6 : 51C9 FFFA           	DBF		d1,LAB_18CD				; decrement count and loop if not done yet
    1990/    29FA :                     
    1991/    29FA :                     RTS_009
    1992/    29FA : 4E75                	RTS
    1993/    29FC :                     
    1994/    29FC :                     
    1995/    29FC :                     ;************************************************************************************
    1996/    29FC :                     ;
    1997/    29FC :                     ; print "?" character
    1998/    29FC :                     
    1999/    29FC :                     LAB_18E3
    2000/    29FC : 703F                	MOVEQ		#$3F,d0				; load "?" character
    2001/    29FE :                     
    2002/    29FE :                     
    2003/    29FE :                     ;************************************************************************************
    2004/    29FE :                     ;
    2005/    29FE :                     ; print character in d0, includes the null handler and infinite line length code
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 38 - 11/4/2023 8:40:20


    2006/    29FE :                     ; changes no registers
    2007/    29FE :                     
    2008/    29FE :                     LAB_PRNA
    2009/    29FE : 2F01                	MOVE.l	d1,-(sp)				; save d1
    2010/    2A00 : B03C 0020           	CMP.b		#$20,d0				; compare with " "
    2011/    2A04 : 6528                	BCS.s		LAB_18F9				; branch if less, non printing character
    2012/    2A06 :                     
    2013/    2A06 :                     								; don't check fit if terminal width byte is zero
    2014/    2A06 : 122B 05E6           	MOVE.b	TWidth(a3),d1			; get terminal width
    2015/    2A0A : 6610                	BNE.s		LAB_18F0				; branch if not zero (not infinite length)
    2016/    2A0C :                     
    2017/    2A0C :                     								; is "infinite line" so check TAB position
    2018/    2A0C : 122B 05E5           	MOVE.b	TPos(a3),d1				; get position
    2019/    2A10 : 922B 05E2           	SUB.b		TabSiz(a3),d1			; subtract TAB size
    2020/    2A14 : 6614                	BNE.s		LAB_18F7				; skip reset if different
    2021/    2A16 :                     
    2022/    2A16 : 1741 05E5           	MOVE.b	d1,TPos(a3)				; else reset position
    2023/    2A1A : 600E                	BRA.s		LAB_18F7				; go print character
    2024/    2A1C :                     
    2025/    2A1C :                     LAB_18F0
    2026/    2A1C : B22B 05E5           	CMP.b		TPos(a3),d1				; compare with terminal character position
    2027/    2A20 : 6608                	BNE.s		LAB_18F7				; branch if not at end of line
    2028/    2A22 :                     
    2029/    2A22 : 2F00                	MOVE.l	d0,-(sp)				; save d0
    2030/    2A24 : 6100 FF60           	BSR		LAB_CRLF				; else print CR/LF
    2031/    2A28 : 201F                	MOVE.l	(sp)+,d0				; restore d0
    2032/    2A2A :                     LAB_18F7
    2033/    2A2A : 522B 05E5           	ADDQ.b	#$01,TPos(a3)			; increment terminal position
    2034/    2A2E :                     LAB_18F9
    2035/    2A2E : 4EAB 0412           	JSR		V_OUTP(a3)				; output byte via output vector
    2036/    2A32 : B03C 000D           	CMP.b		#$0D,d0				; compare with [CR]
    2037/    2A36 : 6618                	BNE.s		LAB_188A				; branch if not [CR]
    2038/    2A38 :                     
    2039/    2A38 :                     								; else print nullct nulls after the [CR]
    2040/    2A38 : 7200                	MOVEQ		#$00,d1				; clear d1
    2041/    2A3A : 122B 05E4           	MOVE.b	Nullct(a3),d1			; get null count
    2042/    2A3E : 670C                	BEQ.s		LAB_1886				; branch if no nulls
    2043/    2A40 :                     
    2044/    2A40 : 7000                	MOVEQ		#$00,d0				; load [NULL]
    2045/    2A42 :                     LAB_1880
    2046/    2A42 : 4EAB 0412           	JSR		V_OUTP(a3)				; go print the character
    2047/    2A46 : 51C9 FFFA           	DBF		d1,LAB_1880				; decrement count and loop if not all done
    2048/    2A4A :                     
    2049/    2A4A : 700D                	MOVEQ		#$0D,d0				; restore the character
    2050/    2A4C :                     LAB_1886
    2051/    2A4C : 1741 05E5           	MOVE.b	d1,TPos(a3)				; clear terminal position
    2052/    2A50 :                     LAB_188A
    2053/    2A50 : 221F                	MOVE.l	(sp)+,d1				; restore d1
    2054/    2A52 : 4E75                	RTS
    2055/    2A54 :                     
    2056/    2A54 :                     
    2057/    2A54 :                     ;************************************************************************************
    2058/    2A54 :                     ;
    2059/    2A54 :                     ; handle bad input data
    2060/    2A54 :                     
    2061/    2A54 :                     LAB_1904
    2062/    2A54 : 2A5F                	MOVEA.l	(sp)+,a5				; restore execute pointer
    2063/    2A56 : 4A2B 05E0           	TST.b		Imode(a3)				; test input mode flag, $00=INPUT, $98=READ
    2064/    2A5A : 6A0A                	BPL.s		LAB_1913				; branch if INPUT (go do redo)
    2065/    2A5C :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 39 - 11/4/2023 8:40:20


    2066/    2A5C : 276B 045E 0452      	MOVE.l	Dlinel(a3),Clinel(a3)		; save DATA line as current line
    2067/    2A62 : 6000 F6D8           	BRA		LAB_TMER				; do type mismatch error, then warm start
    2068/    2A66 :                     
    2069/    2A66 :                     								; mode was INPUT
    2070/    2A66 :                     LAB_1913
    2071/    2A66 : 41FA 2A76           	LEA		LAB_REDO(pc),a0			; point to redo message
    2072/    2A6A : 6100 FF78           	BSR		LAB_18C3				; print null terminated string from memory
    2073/    2A6E : 2A6B 045A           	MOVEA.l	Cpntrl(a3),a5			; save continue pointer as BASIC execute pointer
    2074/    2A72 : 4E75                	RTS
    2075/    2A74 :                     
    2076/    2A74 :                     
    2077/    2A74 :                     ;************************************************************************************
    2078/    2A74 :                     ;
    2079/    2A74 :                     ; perform INPUT
    2080/    2A74 :                     
    2081/    2A74 :                     LAB_INPUT
    2082/    2A74 : 6100 0862           	BSR		LAB_CKRN				; check not direct (back here if ok)
    2083/    2A78 : B03C 0022           	CMP.b		#'"',d0				; compare the next byte with open quote
    2084/    2A7C : 660E                	BNE.s		LAB_1934				; if no prompt string just go get the input
    2085/    2A7E :                     
    2086/    2A7E : 6100 0306           	BSR		LAB_1BC1				; print "..." string
    2087/    2A82 : 703B                	MOVEQ		#';',d0				; set the search character to ";"
    2088/    2A84 : 6100 0320           	BSR		LAB_SCCA				; scan for CHR$(d0), else do syntax error/warm
    2089/    2A88 :                     								; start
    2090/    2A88 : 6100 FF5E           	BSR		LAB_18C6				; print string from Sutill/Sutilh
    2091/    2A8C :                     								; finished the prompt, now read the data
    2092/    2A8C :                     LAB_1934
    2093/    2A8C : 6100 F804           	BSR		LAB_INLN				; print "? " and get BASIC input
    2094/    2A90 :                     								; return a0 pointing to the buffer start
    2095/    2A90 : 7000                	MOVEQ		#0,d0					; flag INPUT
    2096/    2A92 : 4A10                	TST.b		(a0)					; test first byte from buffer
    2097/    2A94 : 660A                	BNE.s		LAB_1953				; branch if not null input
    2098/    2A96 :                     
    2099/    2A96 : 6000 FB58           	BRA		LAB_1647				; go do BREAK exit
    2100/    2A9A :                     
    2101/    2A9A :                     
    2102/    2A9A :                     ;************************************************************************************
    2103/    2A9A :                     ;
    2104/    2A9A :                     ; perform READ
    2105/    2A9A :                     
    2106/    2A9A :                     LAB_READ
    2107/    2A9A : 206B 0462           	MOVEA.l	Dptrl(a3),a0			; get the DATA pointer
    2108/    2A9E : 7098                	MOVEQ		#$98-$100,d0			; flag READ
    2109/    2AA0 :                     LAB_1953
    2110/    2AA0 : 1740 05E0           	MOVE.b	d0,Imode(a3)			; set input mode flag, $00=INPUT, $98=READ
    2111/    2AA4 : 2748 0466           	MOVE.l	a0,Rdptrl(a3)			; save READ pointer
    2112/    2AA8 :                     
    2113/    2AA8 :                     								; READ or INPUT the next variable from list
    2114/    2AA8 :                     LAB_195B
    2115/    2AA8 : 6100 0512           	BSR		LAB_SVAR				; search for or create a variable
    2116/    2AAC :                     								; return the variable address in a0
    2117/    2AAC : 2748 0472           	MOVE.l	a0,Lvarpl(a3)			; save variable address as LET variable
    2118/    2AB0 : 2F0D                	MOVE.l	a5,-(sp)				; save BASIC execute pointer
    2119/    2AB2 :                     LAB_1961
    2120/    2AB2 : 2A6B 0466           	MOVEA.l	Rdptrl(a3),a5			; set READ pointer as BASIC execute pointer
    2121/    2AB6 : 6100 02F8           	BSR		LAB_GBYT				; scan memory
    2122/    2ABA : 661E                	BNE.s		LAB_1986				; if not null go get the value
    2123/    2ABC :                     
    2124/    2ABC :                     								; the pointer was to a null entry
    2125/    2ABC : 4A2B 05E0           	TST.b		Imode(a3)				; test input mode flag, $00=INPUT, $98=READ
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 40 - 11/4/2023 8:40:20


    2126/    2AC0 : 6B72                	BMI.s		LAB_19DD				; branch if READ (go find the next statement)
    2127/    2AC2 :                     
    2128/    2AC2 :                     								; else the mode was INPUT so get more
    2129/    2AC2 : 6100 FF38           	BSR		LAB_18E3				; print a "?" character
    2130/    2AC6 : 6100 F7CA           	BSR		LAB_INLN				; print "? " and get BASIC input
    2131/    2ACA :                     								; return a0 pointing to the buffer start
    2132/    2ACA : 4A10                	TST.b		(a0)					; test the first byte from the buffer
    2133/    2ACC : 6604                	BNE.s		LAB_1984				; if not null input go handle it
    2134/    2ACE :                     
    2135/    2ACE : 6000 FB20           	BRA		LAB_1647				; else go do the BREAK exit
    2136/    2AD2 :                     
    2137/    2AD2 :                     LAB_1984
    2138/    2AD2 : 2A48                	MOVEA.l	a0,a5					; set the execute pointer to the buffer
    2139/    2AD4 : 534D                	SUBQ.w	#1,a5					; decrement the execute pointer
    2140/    2AD6 :                     
    2141/    2AD6 :                     LAB_1985
    2142/    2AD6 : 6100 02D6           	BSR		LAB_IGBY				; increment & scan memory
    2143/    2ADA :                     LAB_1986
    2144/    2ADA : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
    2145/    2ADE :                     								; $00=float
    2146/    2ADE : 6A20                	BPL.s		LAB_19B0				; branch if numeric
    2147/    2AE0 :                     
    2148/    2AE0 :                     								; else get string
    2149/    2AE0 : 1400                	MOVE.b	d0,d2					; save search character
    2150/    2AE2 : B03C 0022           	CMP.b		#$22,d0				; was it " ?
    2151/    2AE6 : 6706                	BEQ.s		LAB_1999				; branch if so
    2152/    2AE8 :                     
    2153/    2AE8 : 743A                	MOVEQ		#':',d2				; set new search character
    2154/    2AEA : 702C                	MOVEQ		#',',d0				; other search character is ","
    2155/    2AEC : 534D                	SUBQ.w	#1,a5					; decrement BASIC execute pointer
    2156/    2AEE :                     LAB_1999
    2157/    2AEE : 524D                	ADDQ.w	#1,a5					; increment BASIC execute pointer
    2158/    2AF0 : 1600                	MOVE.b	d0,d3					; set second search character
    2159/    2AF2 : 204D                	MOVEA.l	a5,a0					; BASIC execute pointer is source
    2160/    2AF4 :                     
    2161/    2AF4 : 6100 08D4           	BSR		LAB_20B4				; print d2/d3 terminated string to FAC1 stack
    2162/    2AF8 :                     								; d2 = Srchc, d3 = Asrch, a0 is source
    2163/    2AF8 : 2A4A                	MOVEA.l	a2,a5					; copy end of string to BASIC execute pointer
    2164/    2AFA : 6100 FDD2           	BSR		LAB_17D5				; go do string LET
    2165/    2AFE : 6010                	BRA.s		LAB_19B6				; go check string terminator
    2166/    2B00 :                     
    2167/    2B00 :                     								; get numeric INPUT
    2168/    2B00 :                     LAB_19B0
    2169/    2B00 : 1F2B 05B5           	MOVE.b	Dtypef(a3),-(sp)			; save variable data type
    2170/    2B04 : 6100 1DA6           	BSR		LAB_2887				; get FAC1 from string
    2171/    2B08 : 175F 05B5           	MOVE.b	(sp)+,Dtypef(a3)			; restore variable data type
    2172/    2B0C : 6100 1084           	BSR		LAB_PFAC				; pack FAC1 into (Lvarpl)
    2173/    2B10 :                     LAB_19B6
    2174/    2B10 : 6100 029E           	BSR		LAB_GBYT				; scan memory
    2175/    2B14 : 670A                	BEQ.s		LAB_19C2				; branch if null (last entry)
    2176/    2B16 :                     
    2177/    2B16 : B03C 002C           	CMP.b		#',',d0				; else compare with ","
    2178/    2B1A : 6600 FF38           	BNE		LAB_1904				; if not "," go handle bad input data
    2179/    2B1E :                     
    2180/    2B1E : 524D                	ADDQ.w	#1,a5					; else was "," so point to next chr
    2181/    2B20 :                     								; got good input data
    2182/    2B20 :                     LAB_19C2
    2183/    2B20 : 274D 0466           	MOVE.l	a5,Rdptrl(a3)			; save the read pointer for now
    2184/    2B24 : 2A5F                	MOVEA.l	(sp)+,a5				; restore the execute pointer
    2185/    2B26 : 6100 0288           	BSR		LAB_GBYT				; scan the memory
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 41 - 11/4/2023 8:40:20


    2186/    2B2A : 6736                	BEQ.s		LAB_1A03				; if null go do extra ignored message
    2187/    2B2C :                     
    2188/    2B2C : 487A FF7A           	PEA		LAB_195B(pc)			; set return address
    2189/    2B30 : 6000 0272           	BRA		LAB_1C01				; scan for "," else do syntax error/warm start
    2190/    2B34 :                     								; then go INPUT next variable from list
    2191/    2B34 :                     
    2192/    2B34 :                     								; find next DATA statement or do "Out of Data"
    2193/    2B34 :                     								; error
    2194/    2B34 :                     LAB_19DD
    2195/    2B34 : 6100 FBFE           	BSR		LAB_SNBS				; scan for next BASIC statement ([:] or [EOL])
    2196/    2B38 :                     								; returns a0 as pointer to [:] or [EOL]
    2197/    2B38 : 2A48                	MOVEA.l	a0,a5					; add index, now = pointer to [EOL]/[EOS]
    2198/    2B3A : 524D                	ADDQ.w	#1,a5					; pointer to next character
    2199/    2B3C : B03C 003A           	CMP.b		#':',d0				; was it statement end?
    2200/    2B40 : 6712                	BEQ.s		LAB_19F6				; branch if [:]
    2201/    2B42 :                     
    2202/    2B42 :                     								; was [EOL] so find next line
    2203/    2B42 :                     
    2204/    2B42 : 320D                	MOVE.w	a5,d1					; past pad byte(s)
    2205/    2B44 : C27C 0001           	AND.w		#1,d1					; mask odd bit
    2206/    2B48 : DAC1                	ADD.w		d1,a5					; add pointer
    2207/    2B4A : 241D                	MOVE.l	(a5)+,d2				; get next line pointer
    2208/    2B4C : 6700 F612           	BEQ		LAB_ODER				; branch if end of program
    2209/    2B50 :                     
    2210/    2B50 : 275D 045E           	MOVE.l	(a5)+,Dlinel(a3)			; save current DATA line
    2211/    2B54 :                     LAB_19F6
    2212/    2B54 : 6100 025A           	BSR		LAB_GBYT				; scan memory
    2213/    2B58 : B03C 0083           	CMP.b		#TK_DATA,d0				; compare with "DATA" token
    2214/    2B5C : 6700 FF78           	BEQ		LAB_1985				; was "DATA" so go do next READ
    2215/    2B60 :                     
    2216/    2B60 : 60D2                	BRA.s		LAB_19DD				; go find next statement if not "DATA"
    2217/    2B62 :                     
    2218/    2B62 :                     ; end of INPUT/READ routine
    2219/    2B62 :                     
    2220/    2B62 :                     LAB_1A03
    2221/    2B62 : 206B 0466           	MOVEA.l	Rdptrl(a3),a0			; get temp READ pointer
    2222/    2B66 : 4A2B 05E0           	TST.b		Imode(a3)				; get input mode flag, $00=INPUT, $98=READ
    2223/    2B6A : 6A06                	BPL.s		LAB_1A0E				; branch if INPUT
    2224/    2B6C :                     
    2225/    2B6C : 2748 0462           	MOVE.l	a0,Dptrl(a3)			; else save temp READ pointer as DATA pointer
    2226/    2B70 : 4E75                	RTS
    2227/    2B72 :                     
    2228/    2B72 :                     								; we were getting INPUT
    2229/    2B72 :                     LAB_1A0E
    2230/    2B72 : 4A10                	TST.b		(a0)					; test next byte
    2231/    2B74 : 6602                	BNE.s		LAB_1A1B				; error if not end of INPUT
    2232/    2B76 :                     
    2233/    2B76 : 4E75                	RTS
    2234/    2B78 :                     								; user typed too much
    2235/    2B78 :                     LAB_1A1B
    2236/    2B78 : 41FA 2954           	LEA		LAB_IMSG(pc),a0			; point to extra ignored message
    2237/    2B7C : 6000 FE66           	BRA		LAB_18C3				; print null terminated string from memory & RTS
    2238/    2B80 :                     
    2239/    2B80 :                     
    2240/    2B80 :                     ;************************************************************************************
    2241/    2B80 :                     ;
    2242/    2B80 :                     ; perform NEXT
    2243/    2B80 :                     
    2244/    2B80 :                     LAB_NEXT
    2245/    2B80 : 6610                	BNE.s		LAB_1A46				; branch if NEXT var
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 42 - 11/4/2023 8:40:20


    2246/    2B82 :                     
    2247/    2B82 : 584F                	ADDQ.w	#4,sp					; back past return address
    2248/    2B84 : 0C57 0081           	CMP.w		#TK_FOR,(sp)			; is FOR token on stack?
    2249/    2B88 : 6600 F5E2           	BNE		LAB_NFER				; if not do NEXT without FOR err/warm start
    2250/    2B8C :                     
    2251/    2B8C : 206F 0002           	MOVEA.l	2(sp),a0				; get stacked FOR variable pointer
    2252/    2B90 : 601C                	BRA.s		LAB_11BD				; branch always (no variable to search for)
    2253/    2B92 :                     
    2254/    2B92 :                     ; NEXT var
    2255/    2B92 :                     
    2256/    2B92 :                     LAB_1A46
    2257/    2B92 : 6100 042C           	BSR		LAB_GVAR				; get variable address in a0
    2258/    2B96 : 584F                	ADDQ.w	#4,sp					; back past return address
    2259/    2B98 : 303C 0081           	MOVE.w	#TK_FOR,d0				; set for FOR token
    2260/    2B9C : 721C                	MOVEQ		#$1C,d1				; set for FOR use size
    2261/    2B9E : 6002                	BRA.s		LAB_11A6				; enter loop for next variable search
    2262/    2BA0 :                     
    2263/    2BA0 :                     LAB_11A5
    2264/    2BA0 : DFC1                	ADDA.l	d1,sp					; add FOR stack use size
    2265/    2BA2 :                     LAB_11A6
    2266/    2BA2 : B057                	CMP.w		(sp),d0				; is FOR token on stack?
    2267/    2BA4 : 6600 F5C6           	BNE		LAB_NFER				; if not found do NEXT without FOR error and
    2268/    2BA8 :                     								; warm start
    2269/    2BA8 :                     
    2270/    2BA8 :                     								; was FOR token
    2271/    2BA8 : B1EF 0002           	CMPA.l	2(sp),a0				; compare var pointer with stacked var pointer
    2272/    2BAC : 66F2                	BNE.s		LAB_11A5				; loop if no match found
    2273/    2BAE :                     
    2274/    2BAE :                     LAB_11BD
    2275/    2BAE : 376F 0006 059C      	MOVE.w	6(sp),FAC2_e(a3)			; get STEP value exponent and sign
    2276/    2BB4 : 276F 0008 0598      	MOVE.l	8(sp),FAC2_m(a3)			; get STEP value mantissa
    2277/    2BBA :                     
    2278/    2BBA : 176F 0012 05B5      	MOVE.b	18(sp),Dtypef(a3)			; restore FOR variable data type
    2279/    2BC0 : 6100 021E           	BSR		LAB_1C19				; check type and unpack (a0)
    2280/    2BC4 :                     
    2281/    2BC4 : 176B 059D 059E      	MOVE.b	FAC2_s(a3),FAC_sc(a3)		; save FAC2 sign as sign compare
    2282/    2BCA : 102B 0595           	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
    2283/    2BCE : B12B 059E           	EOR.b		d0,FAC_sc(a3)			; EOR to create sign compare
    2284/    2BD2 :                     
    2285/    2BD2 : 2748 0472           	MOVE.l	a0,Lvarpl(a3)			; save variable pointer
    2286/    2BD6 : 6100 0CBA           	BSR		LAB_ADD				; add STEP value to FOR variable
    2287/    2BDA : 176F 0012 05B5      	MOVE.b	18(sp),Dtypef(a3)			; restore FOR variable data type (again)
    2288/    2BE0 : 6100 0FB0           	BSR		LAB_PFAC				; pack FAC1 into FOR variable (Lvarpl)
    2289/    2BE4 :                     
    2290/    2BE4 : 376F 000C 059C      	MOVE.w	12(sp),FAC2_e(a3)			; get TO value exponent and sign
    2291/    2BEA : 276F 000E 0598      	MOVE.l	14(sp),FAC2_m(a3)			; get TO value mantissa
    2292/    2BF0 :                     
    2293/    2BF0 : 176B 059D 059E      	MOVE.b	FAC2_s(a3),FAC_sc(a3)		; save FAC2 sign as sign compare
    2294/    2BF6 : 102B 0595           	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
    2295/    2BFA : B12B 059E           	EOR.b		d0,FAC_sc(a3)			; EOR to create sign compare
    2296/    2BFE :                     
    2297/    2BFE : 6100 103C           	BSR		LAB_27FA				; compare FAC1 with FAC2 (TO value)
    2298/    2C02 :                     								; returns d0=+1 if FAC1 > FAC2
    2299/    2C02 :                     								; returns d0= 0 if FAC1 = FAC2
    2300/    2C02 :                     								; returns d0=-1 if FAC1 < FAC2
    2301/    2C02 :                     
    2302/    2C02 : 322F 0006           	MOVE.w	6(sp),d1				; get STEP value exponent and sign
    2303/    2C06 : B141                	EOR.w		d0,d1					; EOR compare result with STEP exponent and sign
    2304/    2C08 :                     
    2305/    2C08 : 4A00                	TST.b		d0					; test for =
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 43 - 11/4/2023 8:40:20


    2306/    2C0A : 6704                	BEQ.s		LAB_1A90				; branch if = (loop INcomplete)
    2307/    2C0C :                     
    2308/    2C0C : 4A01                	TST.b		d1					; test result
    2309/    2C0E : 6A0E                	BPL.s		LAB_1A9B				; branch if > (loop complete)
    2310/    2C10 :                     
    2311/    2C10 :                     								; loop back and do it all again
    2312/    2C10 :                     LAB_1A90
    2313/    2C10 : 276F 0014 0452      	MOVE.l	20(sp),Clinel(a3)			; reset current line
    2314/    2C16 : 2A6F 0018           	MOVE.l	24(sp),a5				; reset BASIC execute pointer
    2315/    2C1A : 6000 F970           	BRA		LAB_15C2				; go do interpreter inner loop
    2316/    2C1E :                     
    2317/    2C1E :                     								; loop complete so carry on
    2318/    2C1E :                     LAB_1A9B
    2319/    2C1E : DEFC 001C           	ADDA.w	#28,sp				; add 28 to dump FOR structure
    2320/    2C22 : 6100 018C           	BSR		LAB_GBYT				; scan memory
    2321/    2C26 : B03C 002C           	CMP.b		#$2C,d0				; compare with ","
    2322/    2C2A : 6600 F960           	BNE		LAB_15C2				; if not "," go do interpreter inner loop
    2323/    2C2E :                     
    2324/    2C2E :                     								; was "," so another NEXT variable to do
    2325/    2C2E : 6100 017E           	BSR		LAB_IGBY				; else increment & scan memory
    2326/    2C32 : 6100 FF5E           	BSR		LAB_1A46				; do NEXT (var)
    2327/    2C36 :                     
    2328/    2C36 :                     
    2329/    2C36 :                     ;************************************************************************************
    2330/    2C36 :                     ;
    2331/    2C36 :                     ; evaluate expression & check is numeric, else do type mismatch
    2332/    2C36 :                     
    2333/    2C36 :                     LAB_EVNM
    2334/    2C36 : 6116                	BSR.s		LAB_EVEX				; evaluate expression
    2335/    2C38 :                     
    2336/    2C38 :                     
    2337/    2C38 :                     ;************************************************************************************
    2338/    2C38 :                     ;
    2339/    2C38 :                     ; check if source is numeric, else do type mismatch
    2340/    2C38 :                     
    2341/    2C38 :                     LAB_CTNM
    2342/    2C38 : B040                	CMP.w		d0,d0					; required type is numeric so clear carry
    2343/    2C3A :                     
    2344/    2C3A :                     
    2345/    2C3A :                     ;************************************************************************************
    2346/    2C3A :                     ;
    2347/    2C3A :                     ; type match check, set C for string, clear C for numeric
    2348/    2C3A :                     
    2349/    2C3A :                     LAB_CKTM
    2350/    2C3A : 082B 0007 05B5      	BTST.b	#7,Dtypef(a3)			; test data type flag, don't change carry
    2351/    2C40 : 6606                	BNE.s		LAB_1ABA				; branch if data type is string
    2352/    2C42 :                     
    2353/    2C42 :                     								; else data type was numeric
    2354/    2C42 : 6500 F4F8           	BCS		LAB_TMER				; if required type is string do type mismatch
    2355/    2C46 :                     								; error
    2356/    2C46 :                     
    2357/    2C46 : 4E75                	RTS
    2358/    2C48 :                     								; data type was string, now check required type
    2359/    2C48 :                     LAB_1ABA
    2360/    2C48 : 6400 F4F2           	BCC		LAB_TMER				; if required type is numeric do type mismatch
    2361/    2C4C :                     								; error
    2362/    2C4C : 4E75                	RTS
    2363/    2C4E :                     
    2364/    2C4E :                     
    2365/    2C4E :                     ;************************************************************************************
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 44 - 11/4/2023 8:40:20


    2366/    2C4E :                     ;
    2367/    2C4E :                     ; this routine evaluates any type of expression. first it pushes an end marker so
    2368/    2C4E :                     ; it knows when the expression has been evaluated, this is a precedence value of zero.
    2369/    2C4E :                     ; next the first value is evaluated, this can be an in line value, either numeric or
    2370/    2C4E :                     ; string, a variable or array element of any type, a function or even an expression
    2371/    2C4E :                     ; in parenthesis. this value is kept in FAC_1
    2372/    2C4E :                     ; after the value is evaluated a test is made on the next BASIC program byte, if it
    2373/    2C4E :                     ; is a comparrison operator i.e. "<", "=" or ">", then the corresponding bit is set
    2374/    2C4E :                     ; in the comparison evaluation flag. this test loops until no more comparrison operators
    2375/    2C4E :                     ; are found or more than one of any type is found. in the last case an error is generated
    2376/    2C4E :                     
    2377/    2C4E :                     ; evaluate expression
    2378/    2C4E :                     
    2379/    2C4E :                     LAB_EVEX
    2380/    2C4E : 534D                	SUBQ.w	#1,a5					; decrement BASIC execute pointer
    2381/    2C50 :                     LAB_EVEZ
    2382/    2C50 : 7200                	MOVEQ		#0,d1					; clear precedence word
    2383/    2C52 : 1741 05B5           	MOVE.b	d1,Dtypef(a3)			; clear the data type, $80=string, $40=integer,
    2384/    2C56 :                     								; $00=float
    2385/    2C56 : 601C                	BRA.s		LAB_1ACD				; enter loop
    2386/    2C58 :                     
    2387/    2C58 :                     ; get vector, set up operator then continue evaluation
    2388/    2C58 :                     
    2389/    2C58 :                     LAB_1B43
    2390/    2C58 : 41FA 22CA           	LEA		LAB_OPPT(pc),a0			; point to operator vector table
    2391/    2C5C : 3030 1002           	MOVE.w	2(a0,d1.w),d0			; get vector offset
    2392/    2C60 : 4870 0000           	PEA		(a0,d0.w)				; push vector
    2393/    2C64 :                     
    2394/    2C64 : 2F2B 0590           	MOVE.l	FAC1_m(a3),-(sp)			; push FAC1 mantissa
    2395/    2C68 : 3F2B 0594           	MOVE.w	FAC1_e(a3),-(sp)			; push sign and exponent
    2396/    2C6C : 1F2B 05E3           	MOVE.b	comp_f(a3),-(sp)			; push comparison evaluation flag
    2397/    2C70 :                     
    2398/    2C70 : 3230 1000           	MOVE.w	(a0,d1.w),d1			; get precedence value
    2399/    2C74 :                     LAB_1ACD
    2400/    2C74 : 3F01                	MOVE.w	d1,-(sp)				; push precedence value
    2401/    2C76 : 6100 00E4           	BSR		LAB_GVAL				; get value from line
    2402/    2C7A : 177C 0000 05E3      	MOVE.b	#$00,comp_f(a3)			; clear compare function flag
    2403/    2C80 :                     LAB_1ADB
    2404/    2C80 : 6100 012E           	BSR		LAB_GBYT				; scan memory
    2405/    2C84 :                     LAB_1ADE
    2406/    2C84 : 903C 00BC           	SUB.b		#TK_GT,d0				; subtract token for > (lowest compare function)
    2407/    2C88 : 652A                	BCS.s		LAB_1AFA				; branch if < TK_GT
    2408/    2C8A :                     
    2409/    2C8A : B03C 0003           	CMP.b		#$03,d0				; compare with ">" to "<" tokens
    2410/    2C8E : 650A                	BCS.s		LAB_1AE0				; branch if <= TK_SGN (is compare function)
    2411/    2C90 :                     
    2412/    2C90 : 4A2B 05E3           	TST.b		comp_f(a3)				; test compare function flag
    2413/    2C94 : 6660                	BNE.s		LAB_1B2A				; branch if compare function
    2414/    2C96 :                     
    2415/    2C96 : 6000 0086           	BRA		LAB_1B78				; go do functions
    2416/    2C9A :                     
    2417/    2C9A :                     								; was token for > = or < (d0 = 0, 1 or 2)
    2418/    2C9A :                     LAB_1AE0
    2419/    2C9A : 7201                	MOVEQ		#1,d1					; set to 0000 0001
    2420/    2C9C : E121                	ASL.b		d0,d1					; 1 if >, 2 if =, 4 if <
    2421/    2C9E : 102B 05E3           	MOVE.b	comp_f(a3),d0			; copy old compare function flag
    2422/    2CA2 : B32B 05E3           	EOR.b		d1,comp_f(a3)			; EOR in this compare function bit
    2423/    2CA6 : B02B 05E3           	CMP.b		comp_f(a3),d0			; compare old with new compare function flag
    2424/    2CAA : 6400 F4BC           	BCC		LAB_SNER				; if new <= old comp_f do syntax error and warm
    2425/    2CAE :                     								; start, there was more than one <, = or >
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 45 - 11/4/2023 8:40:20


    2426/    2CAE : 6100 00FE           	BSR		LAB_IGBY				; increment & scan memory
    2427/    2CB2 : 60D0                	BRA.s		LAB_1ADE				; go do next character
    2428/    2CB4 :                     
    2429/    2CB4 :                     								; token is < ">" or > "<" tokens
    2430/    2CB4 :                     LAB_1AFA
    2431/    2CB4 : 4A2B 05E3           	TST.b		comp_f(a3)				; test compare function flag
    2432/    2CB8 : 663C                	BNE.s		LAB_1B2A				; branch if compare function
    2433/    2CBA :                     
    2434/    2CBA :                     								; was < TK_GT so is operator or lower
    2435/    2CBA : D03C 000A           	ADD.b	#(TK_GT-TK_PLUS),d0			; add # of operators (+ -	; / ^ AND OR EOR)
    2436/    2CBE : 645E                	BCC.s		LAB_1B78				; branch if < + operator
    2437/    2CC0 :                     
    2438/    2CC0 : 6608                	BNE.s		LAB_1B0B				; branch if not + token
    2439/    2CC2 :                     
    2440/    2CC2 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
    2441/    2CC6 :                     								; $00=float
    2442/    2CC6 : 6B00 087E           	BMI		LAB_224D				; type is string & token was +
    2443/    2CCA :                     
    2444/    2CCA :                     LAB_1B0B
    2445/    2CCA : 7200                	MOVEQ		#0,d1					; clear longword
    2446/    2CCC : D000                	ADD.b		d0,d0					; *2
    2447/    2CCE : D000                	ADD.b		d0,d0					; *4
    2448/    2CD0 : 1200                	MOVE.b	d0,d1					; copy to index
    2449/    2CD2 :                     LAB_1B13
    2450/    2CD2 : 301F                	MOVE.w	(sp)+,d0				; pull previous precedence
    2451/    2CD4 : 41FA 224E           	LEA		LAB_OPPT(pc),a0			; set pointer to operator table
    2452/    2CD8 : B070 1000           	CMP.w		(a0,d1.w),d0			; compare with this opperator precedence
    2453/    2CDC : 6446                	BCC.s		LAB_1B7D				; branch if previous precedence (d0) >=
    2454/    2CDE :                     
    2455/    2CDE : 6100 FF58           	BSR		LAB_CTNM				; check if source is numeric, else type mismatch
    2456/    2CE2 :                     LAB_1B1C
    2457/    2CE2 : 3F00                	MOVE.w	d0,-(sp)				; save precedence
    2458/    2CE4 :                     LAB_1B1D
    2459/    2CE4 : 6100 FF72           	BSR		LAB_1B43				; get vector, set-up operator and continue
    2460/    2CE8 :                     								; evaluation
    2461/    2CE8 : 301F                	MOVE.w	(sp)+,d0				; restore precedence
    2462/    2CEA : 222B 05D8           	MOVE.l	prstk(a3),d1			; get stacked function pointer
    2463/    2CEE : 6A22                	BPL.s		LAB_1B3C				; branch if stacked values
    2464/    2CF0 :                     
    2465/    2CF0 : 3000                	MOVE.w	d0,d0					; copy precedence (set flags)
    2466/    2CF2 : 672E                	BEQ.s		LAB_1B7B				; exit if done
    2467/    2CF4 :                     
    2468/    2CF4 : 603C                	BRA.s		LAB_1B86				; else pop FAC2 & return (do function)
    2469/    2CF6 :                     
    2470/    2CF6 :                     								; was compare function (< = >)
    2471/    2CF6 :                     LAB_1B2A
    2472/    2CF6 : 102B 05B5           	MOVE.b	Dtypef(a3),d0			; get data type flag
    2473/    2CFA : 122B 05E3           	MOVE.b	comp_f(a3),d1			; get compare function flag
    2474/    2CFE : D000                	ADD.b		d0,d0					; string bit flag into X bit
    2475/    2D00 : D301                	ADDX.b	d1,d1					; shift compare function flag
    2476/    2D02 :                     
    2477/    2D02 : 177C 0000 05B5      	MOVE.b	#0,Dtypef(a3)			; clear data type flag, $00=float
    2478/    2D08 : 1741 05E3           	MOVE.b	d1,comp_f(a3)			; save new compare function flag
    2479/    2D0C : 534D                	SUBQ.w	#1,a5					; decrement BASIC execute pointer
    2480/    2D0E : 7230                	MOVEQ		#(TK_LT-TK_PLUS)*4,d1		; set offset to last operator entry
    2481/    2D10 : 60C0                	BRA.s		LAB_1B13				; branch always
    2482/    2D12 :                     
    2483/    2D12 :                     LAB_1B3C
    2484/    2D12 : 41FA 2210           	LEA		LAB_OPPT(pc),a0			; point to function vector table
    2485/    2D16 : B070 1000           	CMP.w		(a0,d1.w),d0			; compare with this opperator precedence
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 46 - 11/4/2023 8:40:20


    2486/    2D1A : 6416                	BCC.s		LAB_1B86				; branch if d0 >=, pop FAC2 & return
    2487/    2D1C :                     
    2488/    2D1C : 60C4                	BRA.s		LAB_1B1C				; branch always
    2489/    2D1E :                     
    2490/    2D1E :                     ; do functions
    2491/    2D1E :                     
    2492/    2D1E :                     LAB_1B78
    2493/    2D1E : 72FF                	MOVEQ		#-1,d1				; flag all done
    2494/    2D20 : 301F                	MOVE.w	(sp)+,d0				; pull precedence word
    2495/    2D22 :                     LAB_1B7B
    2496/    2D22 : 6732                	BEQ.s		LAB_1B9D				; exit if done
    2497/    2D24 :                     
    2498/    2D24 :                     LAB_1B7D
    2499/    2D24 : B07C 0064           	CMP.w		#$64,d0				; compare previous precedence with $64
    2500/    2D28 : 6704                	BEQ.s		LAB_1B84				; branch if was $64 (< function can be string)
    2501/    2D2A :                     
    2502/    2D2A : 6100 FF0C           	BSR		LAB_CTNM				; check if source is numeric, else type mismatch
    2503/    2D2E :                     LAB_1B84
    2504/    2D2E : 2741 05D8           	MOVE.l	d1,prstk(a3)			; save current operator index
    2505/    2D32 :                     
    2506/    2D32 :                     								; pop FAC2 & return
    2507/    2D32 :                     LAB_1B86
    2508/    2D32 : 101F                	MOVE.b	(sp)+,d0				; pop comparison evaluation flag
    2509/    2D34 : 1200                	MOVE.b	d0,d1					; copy comparison evaluation flag
    2510/    2D36 : E208                	LSR.b		#1,d0					; shift out comparison evaluation lowest bit
    2511/    2D38 : 1740 05E1           	MOVE.b	d0,Cflag(a3)			; save comparison evaluation flag
    2512/    2D3C : 375F 059C           	MOVE.w	(sp)+,FAC2_e(a3)			; pop exponent and sign
    2513/    2D40 : 275F 0598           	MOVE.l	(sp)+,FAC2_m(a3)			; pop mantissa
    2514/    2D44 : 176B 059D 059E      	MOVE.b	FAC2_s(a3),FAC_sc(a3)		; copy FAC2 sign
    2515/    2D4A : 102B 0595           	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
    2516/    2D4E : B12B 059E           	EOR.b		d0,FAC_sc(a3)			; EOR FAC1 sign and set sign compare
    2517/    2D52 :                     
    2518/    2D52 : E209                	LSR.b		#1,d1					; type bit into X and C
    2519/    2D54 : 4E75                	RTS
    2520/    2D56 :                     
    2521/    2D56 :                     LAB_1B9D
    2522/    2D56 : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
    2523/    2D5A : 4E75                	RTS
    2524/    2D5C :                     
    2525/    2D5C :                     
    2526/    2D5C :                     ;************************************************************************************
    2527/    2D5C :                     ;
    2528/    2D5C :                     ; get a value from the BASIC line
    2529/    2D5C :                     
    2530/    2D5C :                     LAB_GVAL
    2531/    2D5C : 6150                	BSR.s		LAB_IGBY				; increment & scan memory
    2532/    2D5E : 6500 1B4C           	BCS		LAB_2887				; if numeric get FAC1 from string & return
    2533/    2D62 :                     
    2534/    2D62 : 4A00                	TST.b		d0					; test byte
    2535/    2D64 : 6B00 0090           	BMI		LAB_1BD0				; if -ve go test token values
    2536/    2D68 :                     
    2537/    2D68 :                     								; else it is either a string, number, variable
    2538/    2D68 :                     								; or (<expr>)
    2539/    2D68 : B03C 0024           	CMP.b		#'$',d0				; compare with "$"
    2540/    2D6C : 6700 1B3E           	BEQ		LAB_2887				; if "$" get hex number from string & return
    2541/    2D70 :                     
    2542/    2D70 : B03C 0025           	CMP.b		#'%',d0				; else compare with "%"
    2543/    2D74 : 6700 1B36           	BEQ		LAB_2887				; if "%" get binary number from string & return
    2544/    2D78 :                     
    2545/    2D78 : B03C 002E           	CMP.b		#$2E,d0				; compare with "."
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 47 - 11/4/2023 8:40:20


    2546/    2D7C : 6700 1B2E           	BEQ		LAB_2887				; if so get FAC1 from string and return
    2547/    2D80 :                     								; (e.g. .123)
    2548/    2D80 :                     
    2549/    2D80 :                     								; wasn't a number so ...
    2550/    2D80 : B03C 0022           	CMP.b		#$22,d0				; compare with "
    2551/    2D84 : 660C                	BNE.s		LAB_1BF3				; if not open quote it must be a variable or
    2552/    2D86 :                     								; open bracket
    2553/    2D86 :                     
    2554/    2D86 :                     								; was open quote so get the enclosed string
    2555/    2D86 :                     
    2556/    2D86 :                     ; print "..." string to string stack
    2557/    2D86 :                     
    2558/    2D86 :                     LAB_1BC1
    2559/    2D86 : 101D                	MOVE.b	(a5)+,d0				; increment BASIC execute pointer (past ")
    2560/    2D88 :                     								; fastest/shortest method
    2561/    2D88 : 204D                	MOVEA.l	a5,a0					; copy basic execute pointer (string start)
    2562/    2D8A : 6100 063A           	BSR		LAB_20AE				; print " terminated string to stack
    2563/    2D8E : 2A4A                	MOVEA.l	a2,a5					; restore BASIC execute pointer from temp
    2564/    2D90 : 4E75                	RTS
    2565/    2D92 :                     
    2566/    2D92 :                     ; get value from line .. continued
    2567/    2D92 :                     								; wasn't any sort of number so ...
    2568/    2D92 :                     LAB_1BF3
    2569/    2D92 : B03C 0028           	CMP.b		#'(',d0				; compare with "("
    2570/    2D96 : 6644                	BNE.s		LAB_1C18				; if not "(" get (var) and return value in FAC1
    2571/    2D98 :                     								; and $ flag
    2572/    2D98 :                     
    2573/    2D98 :                     
    2574/    2D98 :                     ;************************************************************************************
    2575/    2D98 :                     ;
    2576/    2D98 :                     ; evaluate expression within parentheses
    2577/    2D98 :                     
    2578/    2D98 :                     LAB_1BF7
    2579/    2D98 : 6100 FEB6           	BSR		LAB_EVEZ				; evaluate expression (no decrement)
    2580/    2D9C :                     
    2581/    2D9C :                     
    2582/    2D9C :                     ;************************************************************************************
    2583/    2D9C :                     ;
    2584/    2D9C :                     ; all the 'scan for' routines return the character after the sought character
    2585/    2D9C :                     
    2586/    2D9C :                     ; scan for ")", else do syntax error, then warm start
    2587/    2D9C :                     
    2588/    2D9C :                     LAB_1BFB
    2589/    2D9C : 7029                	MOVEQ		#$29,d0				; load d0 with ")"
    2590/    2D9E : 6006                	BRA.s		LAB_SCCA
    2591/    2DA0 :                     
    2592/    2DA0 :                     
    2593/    2DA0 :                     ;************************************************************************************
    2594/    2DA0 :                     ;
    2595/    2DA0 :                     ; scan for "," and get byte, else do Syntax error then warm start
    2596/    2DA0 :                     
    2597/    2DA0 :                     LAB_SCGB
    2598/    2DA0 : 487A 0978           	PEA		LAB_GTBY(pc)			; return address is to get byte parameter
    2599/    2DA4 :                     
    2600/    2DA4 :                     
    2601/    2DA4 :                     ;************************************************************************************
    2602/    2DA4 :                     ;
    2603/    2DA4 :                     ; scan for ",", else do syntax error, then warm start
    2604/    2DA4 :                     
    2605/    2DA4 :                     LAB_1C01
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 48 - 11/4/2023 8:40:20


    2606/    2DA4 : 702C                	MOVEQ		#$2C,d0				; load d0 with ","
    2607/    2DA6 :                     
    2608/    2DA6 :                     
    2609/    2DA6 :                     ;************************************************************************************
    2610/    2DA6 :                     ;
    2611/    2DA6 :                     ; scan for CHR$(d0) , else do syntax error, then warm start
    2612/    2DA6 :                     
    2613/    2DA6 :                     LAB_SCCA
    2614/    2DA6 : B01D                	CMP.b		(a5)+,d0				; check next byte is = d0
    2615/    2DA8 : 6706                	BEQ.s		LAB_GBYT				; if so go get next
    2616/    2DAA :                     
    2617/    2DAA : 6000 F3BC           	BRA		LAB_SNER				; else do syntax error/warm start
    2618/    2DAE :                     
    2619/    2DAE :                     
    2620/    2DAE :                     ;************************************************************************************
    2621/    2DAE :                     ;
    2622/    2DAE :                     ; BASIC increment and scan memory routine
    2623/    2DAE :                     
    2624/    2DAE :                     LAB_IGBY
    2625/    2DAE : 101D                	MOVE.b	(a5)+,d0				; get byte & increment pointer
    2626/    2DB0 :                     
    2627/    2DB0 :                     ; scan memory routine, exit with Cb = 1 if numeric character
    2628/    2DB0 :                     ; also skips any spaces encountered
    2629/    2DB0 :                     
    2630/    2DB0 :                     LAB_GBYT
    2631/    2DB0 : 1015                	MOVE.b	(a5),d0				; get byte
    2632/    2DB2 :                     
    2633/    2DB2 : B03C 0020           	CMP.b		#$20,d0				; compare with " "
    2634/    2DB6 : 67F6                	BEQ.s		LAB_IGBY				; if " " go do next
    2635/    2DB8 :                     
    2636/    2DB8 :                     ; test current BASIC byte, exit with Cb = 1 if numeric character
    2637/    2DB8 :                     
    2638/    2DB8 : B03C 00A9           	CMP.b		#TK_ELSE,d0				; compare with the token for ELSE
    2639/    2DBC : 640E                	BCC.s		RTS_001				; exit if >= (not numeric, carry clear)
    2640/    2DBE :                     
    2641/    2DBE : B03C 003A           	CMP.b		#$3A,d0				; compare with ":"
    2642/    2DC2 : 6408                	BCC.s		RTS_001				; exit if >= (not numeric, carry clear)
    2643/    2DC4 :                     
    2644/    2DC4 : 1C3C 00D0           	MOVE.b		#$D0,d6				; set -"0"
    2645/    2DC8 : D006                	ADD.b		d6,d0					; add -"0"
    2646/    2DCA : 9006                	SUB.b		d6,d0					; subtract -"0"
    2647/    2DCC :                     RTS_001							; carry set if byte = "0"-"9"
    2648/    2DCC : 4E75                	RTS
    2649/    2DCE :                     
    2650/    2DCE :                     
    2651/    2DCE :                     ;************************************************************************************
    2652/    2DCE :                     ;
    2653/    2DCE :                     ; set-up for - operator
    2654/    2DCE :                     
    2655/    2DCE :                     LAB_1C11
    2656/    2DCE : 6100 FE68           	BSR		LAB_CTNM				; check if source is numeric, else type mismatch
    2657/    2DD2 : 7228                	MOVEQ	#(TK_GT-TK_PLUS)*4,d1			; set offset from base to - operator
    2658/    2DD4 :                     LAB_1C13
    2659/    2DD4 : 4FEF 0004           	LEA		4(sp),sp				; dump GVAL return address
    2660/    2DD8 : 6000 FF0A           	BRA		LAB_1B1D				; continue evaluating expression
    2661/    2DDC :                     
    2662/    2DDC :                     
    2663/    2DDC :                     ;************************************************************************************
    2664/    2DDC :                     ;
    2665/    2DDC :                     ; variable name set-up
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 49 - 11/4/2023 8:40:20


    2666/    2DDC :                     ; get (var), return value in FAC_1 & data type flag
    2667/    2DDC :                     
    2668/    2DDC :                     LAB_1C18
    2669/    2DDC : 6100 01E2           	BSR		LAB_GVAR				; get variable address in a0
    2670/    2DE0 :                     
    2671/    2DE0 :                     ; return existing variable value
    2672/    2DE0 :                     
    2673/    2DE0 :                     LAB_1C19
    2674/    2DE0 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
    2675/    2DE4 :                     								; $00=float
    2676/    2DE4 : 6700 0D90           	BEQ		LAB_UFAC				; if float unpack memory (a0) into FAC1 and
    2677/    2DE8 :                     								; return
    2678/    2DE8 :                     
    2679/    2DE8 : 6A06                	BPL.s		LAB_1C1A				; if integer unpack memory (a0) into FAC1
    2680/    2DEA :                     								; and return
    2681/    2DEA :                     
    2682/    2DEA : 2748 0590           	MOVE.l	a0,FAC1_m(a3)			; else save descriptor pointer in FAC1
    2683/    2DEE : 4E75                	RTS
    2684/    2DF0 :                     
    2685/    2DF0 :                     LAB_1C1A
    2686/    2DF0 : 2010                	MOVE.l	(a0),d0				; get integer value
    2687/    2DF2 : 6000 04BC           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
    2688/    2DF6 :                     
    2689/    2DF6 :                     
    2690/    2DF6 :                     ;************************************************************************************
    2691/    2DF6 :                     ;
    2692/    2DF6 :                     ; get value from line .. continued
    2693/    2DF6 :                     ; do tokens
    2694/    2DF6 :                     
    2695/    2DF6 :                     LAB_1BD0
    2696/    2DF6 : B03C 00B3           	CMP.b		#TK_MINUS,d0			; compare with token for -
    2697/    2DFA : 67D2                	BEQ.s		LAB_1C11				; branch if - token (do set-up for - operator)
    2698/    2DFC :                     
    2699/    2DFC :                     								; wasn't -123 so ...
    2700/    2DFC : B03C 00B2           	CMP.b		#TK_PLUS,d0				; compare with token for +
    2701/    2E00 : 6700 FF5A           	BEQ		LAB_GVAL				; branch if + token (+n = n so ignore leading +)
    2702/    2E04 :                     
    2703/    2E04 : B03C 00AE           	CMP.b		#TK_NOT,d0				; compare with token for NOT
    2704/    2E08 : 6606                	BNE.s		LAB_1BE7				; branch if not token for NOT
    2705/    2E0A :                     
    2706/    2E0A :                     								; was NOT token
    2707/    2E0A : 323C 002C           	MOVE.w	#(TK_EQUAL-TK_PLUS)*4,d1		; offset to NOT function
    2708/    2E0E : 60C4                	BRA.s		LAB_1C13				; do set-up for function then execute
    2709/    2E10 :                     
    2710/    2E10 :                     								; wasn't +, - or NOT so ...
    2711/    2E10 :                     LAB_1BE7
    2712/    2E10 : B03C 00AB           	CMP.b		#TK_FN,d0				; compare with token for FN
    2713/    2E14 : 6700 0514           	BEQ		LAB_201E				; if FN go evaluate FNx
    2714/    2E18 :                     
    2715/    2E18 :                     								; wasn't +, -, NOT or FN so ...
    2716/    2E18 : 903C 00BF           	SUB.b		#TK_SGN,d0				; compare with token for SGN & normalise
    2717/    2E1C : 6500 F34A           	BCS		LAB_SNER				; if < SGN token then do syntax error
    2718/    2E20 :                     
    2719/    2E20 :                     ; get value from line .. continued
    2720/    2E20 :                     ; only functions left so set up function references
    2721/    2E20 :                     
    2722/    2E20 :                     ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
    2723/    2E20 :                     ; to process function calls. now the function vector is computed and pushed on the stack
    2724/    2E20 :                     ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
    2725/    2E20 :                     ; is calculated and the routine called, if not this routine just does RTS. whichever
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 50 - 11/4/2023 8:40:20


    2726/    2E20 :                     ; happens the RTS at the end of this routine, or the preprocess routine calls, the
    2727/    2E20 :                     ; function code
    2728/    2E20 :                     
    2729/    2E20 :                     ; this also removes some less than elegant code that was used to bypass type checking
    2730/    2E20 :                     ; for functions that returned strings
    2731/    2E20 :                     
    2732/    2E20 : C07C 007F           	AND.w		#$7F,d0				; mask byte
    2733/    2E24 : D040                	ADD.w		d0,d0					; *2 (2 bytes per function offset)
    2734/    2E26 :                     
    2735/    2E26 : 41FA 20B0           	LEA		LAB_FTBL(pc),a0			; pointer to functions vector table
    2736/    2E2A : 3230 0000           	MOVE.w	(a0,d0.w),d1			; get function vector offset
    2737/    2E2E : 4870 1000           	PEA		(a0,d1.w)				; push function vector
    2738/    2E32 :                     
    2739/    2E32 : 41FA 2058           	LEA		LAB_FTPP(pc),a0			; pointer to functions preprocess vector table
    2740/    2E36 : 3030 0000           	MOVE.w	(a0,d0.w),d0			; get function preprocess vector offset
    2741/    2E3A : 6712                	BEQ.s		LAB_1C2A				; no preprocess vector so go do function
    2742/    2E3C :                     
    2743/    2E3C : 41F0 0000           	LEA		(a0,d0.w),a0			; get function preprocess vector
    2744/    2E40 : 4ED0                	JMP		(a0)					; go do preprocess routine then function
    2745/    2E42 :                     
    2746/    2E42 :                     
    2747/    2E42 :                     ;************************************************************************************
    2748/    2E42 :                     ;
    2749/    2E42 :                     ; process string expression in parenthesis
    2750/    2E42 :                     
    2751/    2E42 :                     LAB_PPFS
    2752/    2E42 : 6100 FF54           	BSR		LAB_1BF7				; process expression in parenthesis
    2753/    2E46 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type
    2754/    2E4A : 6A00 F2F0           	BPL		LAB_TMER				; if numeric do Type missmatch Error/warm start
    2755/    2E4E :                     
    2756/    2E4E :                     LAB_1C2A
    2757/    2E4E : 4E75                	RTS							; else do function
    2758/    2E50 :                     
    2759/    2E50 :                     
    2760/    2E50 :                     ;************************************************************************************
    2761/    2E50 :                     ;
    2762/    2E50 :                     ; process numeric expression in parenthesis
    2763/    2E50 :                     
    2764/    2E50 :                     LAB_PPFN
    2765/    2E50 : 6100 FF46           	BSR		LAB_1BF7				; process expression in parenthesis
    2766/    2E54 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type
    2767/    2E58 : 6B00 F2E2           	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
    2768/    2E5C :                     
    2769/    2E5C : 4E75                	RTS							; else do function
    2770/    2E5E :                     
    2771/    2E5E :                     
    2772/    2E5E :                     ;************************************************************************************
    2773/    2E5E :                     ;
    2774/    2E5E :                     ; set numeric data type and increment BASIC execute pointer
    2775/    2E5E :                     
    2776/    2E5E :                     LAB_PPBI
    2777/    2E5E : 177C 0000 05B5      	MOVE.b	#$00,Dtypef(a3)			; clear data type flag, $00=float
    2778/    2E64 : 101D                	MOVE.b	(a5)+,d0				; get next BASIC byte
    2779/    2E66 : 4E75                	RTS							; do function
    2780/    2E68 :                     
    2781/    2E68 :                     
    2782/    2E68 :                     ;************************************************************************************
    2783/    2E68 :                     ;
    2784/    2E68 :                     ; process string for LEFT$, RIGHT$ or MID$
    2785/    2E68 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 51 - 11/4/2023 8:40:20


    2786/    2E68 :                     LAB_LRMS
    2787/    2E68 : 6100 FDE6           	BSR		LAB_EVEZ				; evaluate (should be string) expression
    2788/    2E6C : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type flag
    2789/    2E70 : 6A00 F2CA           	BPL		LAB_TMER				; if type is not string do type mismatch error
    2790/    2E74 :                     
    2791/    2E74 : 141D                	MOVE.b	(a5)+,d2				; get BASIC byte
    2792/    2E76 : B43C 002C           	CMP.b		#',',d2				; compare with comma
    2793/    2E7A : 6600 F2EC           	BNE		LAB_SNER				; if not "," go do syntax error/warm start
    2794/    2E7E :                     
    2795/    2E7E : 2F2B 0590           	MOVE.l	FAC1_m(a3),-(sp)			; save descriptor pointer
    2796/    2E82 : 6100 08AC           	BSR		LAB_GTWO				; get word parameter, result in d0 and Itemp
    2797/    2E86 : 205F                	MOVEA.l	(sp)+,a0				; restore descriptor pointer
    2798/    2E88 : 4E75                	RTS							; do function
    2799/    2E8A :                     
    2800/    2E8A :                     
    2801/    2E8A :                     ;************************************************************************************
    2802/    2E8A :                     ;
    2803/    2E8A :                     ; process numeric expression(s) for BIN$ or HEX$
    2804/    2E8A :                     
    2805/    2E8A :                     LAB_BHSS
    2806/    2E8A : 6100 FDC4           	BSR		LAB_EVEZ				; evaluate expression (no decrement)
    2807/    2E8E : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type
    2808/    2E92 : 6B00 F2A8           	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
    2809/    2E96 :                     
    2810/    2E96 : 6100 0DD0           	BSR		LAB_2831				; convert FAC1 floating to fixed
    2811/    2E9A :                     								; result in d0 and Itemp
    2812/    2E9A : 7200                	MOVEQ		#0,d1					; set default to no leading "0"s
    2813/    2E9C : 141D                	MOVE.b	(a5)+,d2				; get BASIC byte
    2814/    2E9E : B43C 002C           	CMP.b		#',',d2				; compare with comma
    2815/    2EA2 : 660C                	BNE.s		LAB_BHCB				; if not "," go check close bracket
    2816/    2EA4 :                     
    2817/    2EA4 : 2F00                	MOVE.l	d0,-(sp)				; copy number to stack
    2818/    2EA6 : 6100 0872           	BSR		LAB_GTBY				; get byte value
    2819/    2EAA : 2200                	MOVE.l	d0,d1					; copy leading 0s #
    2820/    2EAC : 201F                	MOVE.l	(sp)+,d0				; restore number from stack
    2821/    2EAE : 141D                	MOVE.b	(a5)+,d2				; get BASIC byte
    2822/    2EB0 :                     LAB_BHCB
    2823/    2EB0 : B43C 0029           	CMP.b		#')',d2				; compare with close bracket
    2824/    2EB4 : 6600 F2B2           	BNE		LAB_SNER				; if not ")" do Syntax Error/warm start
    2825/    2EB8 :                     
    2826/    2EB8 : 4E75                	RTS							; go do function
    2827/    2EBA :                     
    2828/    2EBA :                     
    2829/    2EBA :                     ;************************************************************************************
    2830/    2EBA :                     ;
    2831/    2EBA :                     ; perform EOR
    2832/    2EBA :                     
    2833/    2EBA :                     LAB_EOR
    2834/    2EBA : 6116                	BSR.s		GetFirst				; get two values for OR, AND or EOR
    2835/    2EBC :                     								; first in d0, and Itemp, second in d2
    2836/    2EBC : B580                	EOR.l		d2,d0					; EOR values
    2837/    2EBE : 6000 03F0           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
    2838/    2EC2 :                     
    2839/    2EC2 :                     
    2840/    2EC2 :                     ;************************************************************************************
    2841/    2EC2 :                     ;
    2842/    2EC2 :                     ; perform OR
    2843/    2EC2 :                     
    2844/    2EC2 :                     LAB_OR
    2845/    2EC2 : 610E                	BSR.s		GetFirst				; get two values for OR, AND or EOR
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 52 - 11/4/2023 8:40:20


    2846/    2EC4 :                     								; first in d0, and Itemp, second in d2
    2847/    2EC4 : 8082                	OR.l		d2,d0					; do OR
    2848/    2EC6 : 6000 03E8           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
    2849/    2ECA :                     
    2850/    2ECA :                     
    2851/    2ECA :                     ;************************************************************************************
    2852/    2ECA :                     ;
    2853/    2ECA :                     ; perform AND
    2854/    2ECA :                     
    2855/    2ECA :                     LAB_AND
    2856/    2ECA : 6106                	BSR.s		GetFirst				; get two values for OR, AND or EOR
    2857/    2ECC :                     								; first in d0, and Itemp, second in d2
    2858/    2ECC : C082                	AND.l		d2,d0					; do AND
    2859/    2ECE : 6000 03E0           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
    2860/    2ED2 :                     
    2861/    2ED2 :                     
    2862/    2ED2 :                     ;************************************************************************************
    2863/    2ED2 :                     ;
    2864/    2ED2 :                     ; get two values for OR, AND, EOR
    2865/    2ED2 :                     ; first in d0, second in d2
    2866/    2ED2 :                     
    2867/    2ED2 :                     GetFirst
    2868/    2ED2 : 6100 0228           	BSR		LAB_EVIR				; evaluate integer expression (no sign check)
    2869/    2ED6 :                     								; result in d0 and Itemp
    2870/    2ED6 : 2400                	MOVE.l	d0,d2					; copy second value
    2871/    2ED8 : 6100 0CF6           	BSR		LAB_279B				; copy FAC2 to FAC1, get first value in
    2872/    2EDC :                     								; expression
    2873/    2EDC : 6000 021E           	BRA		LAB_EVIR				; evaluate integer expression (no sign check)
    2874/    2EE0 :                     								; result in d0 and Itemp & return
    2875/    2EE0 :                     
    2876/    2EE0 :                     
    2877/    2EE0 :                     ;************************************************************************************
    2878/    2EE0 :                     ;
    2879/    2EE0 :                     ; perform NOT
    2880/    2EE0 :                     
    2881/    2EE0 :                     LAB_EQUAL
    2882/    2EE0 : 6100 021A           	BSR		LAB_EVIR				; evaluate integer expression (no sign check)
    2883/    2EE4 :                     								; result in d0 and Itemp
    2884/    2EE4 : 4680                	NOT.l		d0					; bitwise invert
    2885/    2EE6 : 6000 03C8           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
    2886/    2EEA :                     
    2887/    2EEA :                     
    2888/    2EEA :                     ;************************************************************************************
    2889/    2EEA :                     ;
    2890/    2EEA :                     ; perform comparisons
    2891/    2EEA :                     ; do < compare
    2892/    2EEA :                     
    2893/    2EEA :                     LAB_LTHAN
    2894/    2EEA : 6100 FD4E           	BSR		LAB_CKTM				; type match check, set C for string
    2895/    2EEE : 6506                	BCS.s		LAB_1CAE				; branch if string
    2896/    2EF0 :                     
    2897/    2EF0 :                     								; do numeric < compare
    2898/    2EF0 : 6100 0D4A           	BSR		LAB_27FA				; compare FAC1 with FAC2
    2899/    2EF4 :                     								; returns d0=+1 if FAC1 > FAC2
    2900/    2EF4 :                     								; returns d0= 0 if FAC1 = FAC2
    2901/    2EF4 :                     								; returns d0=-1 if FAC1 < FAC2
    2902/    2EF4 : 6042                	BRA.s		LAB_1CF2				; process result
    2903/    2EF6 :                     
    2904/    2EF6 :                     								; do string < compare
    2905/    2EF6 :                     LAB_1CAE
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 53 - 11/4/2023 8:40:20


    2906/    2EF6 : 177C 0000 05B5      	MOVE.b	#$00,Dtypef(a3)			; clear data type, $80=string, $40=integer,
    2907/    2EFC :                     								; $00=float
    2908/    2EFC : 6100 06BC           	BSR		LAB_22B6				; pop string off descriptor stack, or from top
    2909/    2F00 :                     								; of string space returns d0 = length,
    2910/    2F00 :                     								; a0 = pointer
    2911/    2F00 : 2248                	MOVEA.l	a0,a1					; copy string 2 pointer
    2912/    2F02 : 2200                	MOVE.l	d0,d1					; copy string 2 length
    2913/    2F04 : 206B 0598           	MOVEA.l	FAC2_m(a3),a0			; get string 1 descriptor pointer
    2914/    2F08 : 6100 06B4           	BSR		LAB_22BA				; pop (a0) descriptor, returns with ..
    2915/    2F0C :                     								; d0 = length, a0 = pointer
    2916/    2F0C : 2400                	MOVE.l	d0,d2					; copy length
    2917/    2F0E : 6604                	BNE.s		LAB_1CB5				; branch if not null string
    2918/    2F10 :                     
    2919/    2F10 : 4A81                	TST.l		d1					; test if string 2 is null also
    2920/    2F12 : 6724                	BEQ.s		LAB_1CF2				; if so do string 1 = string 2
    2921/    2F14 :                     
    2922/    2F14 :                     LAB_1CB5
    2923/    2F14 : 9481                	SUB.l		d1,d2					; subtract string 2 length
    2924/    2F16 : 670C                	BEQ.s		LAB_1CD5				; branch if strings = length
    2925/    2F18 :                     
    2926/    2F18 : 6504                	BCS.s		LAB_1CD4				; branch if string 1 < string 2
    2927/    2F1A :                     
    2928/    2F1A : 70FF                	MOVEQ		#-1,d0				; set for string 1 > string 2
    2929/    2F1C : 6008                	BRA.s		LAB_1CD6				; go do character comapare
    2930/    2F1E :                     
    2931/    2F1E :                     LAB_1CD4
    2932/    2F1E : 2200                	MOVE.l	d0,d1					; string 1 length is compare length
    2933/    2F20 : 7001                	MOVEQ		#1,d0					; and set for string 1 < string 2
    2934/    2F22 : 6002                	BRA.s		LAB_1CD6				; go do character comapare
    2935/    2F24 :                     
    2936/    2F24 :                     LAB_1CD5
    2937/    2F24 : 2002                	MOVE.l	d2,d0					; set for string 1 = string 2
    2938/    2F26 :                     LAB_1CD6
    2939/    2F26 : 5381                	SUBQ.l	#1,d1					; adjust length for DBcc loop
    2940/    2F28 :                     
    2941/    2F28 :                     								; d1 is length to compare, d0 is <=> for length
    2942/    2F28 :                     								; a0 is string 1 pointer, a1 is string 2 pointer
    2943/    2F28 :                     LAB_1CE6
    2944/    2F28 : B308                	CMPM.b	(a0)+,(a1)+				; compare string bytes (1 with 2)
    2945/    2F2A : 56C9 FFFC           	DBNE		d1,LAB_1CE6				; loop if same and not end yet
    2946/    2F2E :                     
    2947/    2F2E : 6708                	BEQ.s		LAB_1CF2				; if = to here, then go use length compare
    2948/    2F30 :                     
    2949/    2F30 : 6404                	BCC.s		LAB_1CDB				; else branch if string 1 > string 2
    2950/    2F32 :                     
    2951/    2F32 : 70FF                	MOVEQ		#-1,d0				; else set for string 1 < string 2
    2952/    2F34 : 6002                	BRA.s		LAB_1CF2				; go set result
    2953/    2F36 :                     
    2954/    2F36 :                     LAB_1CDB
    2955/    2F36 : 7001                	MOVEQ		#1,d0					; and set for string 1 > string 2
    2956/    2F38 :                     
    2957/    2F38 :                     LAB_1CF2
    2958/    2F38 : 5200                	ADDQ.b	#1,d0					; make result 0, 1 or 2
    2959/    2F3A : 1200                	MOVE.b	d0,d1					; copy to d1
    2960/    2F3C : 7001                	MOVEQ		#1,d0					; set d0 longword
    2961/    2F3E : E338                	ROL.b		d1,d0					; make 1, 2 or 4 (result = flag bit)
    2962/    2F40 : C02B 05E1           	AND.b		Cflag(a3),d0			; AND with comparison evaluation flag
    2963/    2F44 : 6700 0CDE           	BEQ		LAB_27DB				; exit if not a wanted result (i.e. false)
    2964/    2F48 :                     
    2965/    2F48 : 70FF                	MOVEQ		#-1,d0				; else set -1 (true)
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 54 - 11/4/2023 8:40:20


    2966/    2F4A : 6000 0CD8           	BRA		LAB_27DB				; save d0 as integer & return
    2967/    2F4E :                     
    2968/    2F4E :                     
    2969/    2F4E :                     LAB_1CFE
    2970/    2F4E : 6100 FE54           	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
    2971/    2F52 :                     
    2972/    2F52 :                     
    2973/    2F52 :                     ;************************************************************************************
    2974/    2F52 :                     ;
    2975/    2F52 :                     ; perform DIM
    2976/    2F52 :                     
    2977/    2F52 :                     LAB_DIM
    2978/    2F52 : 72FF                	MOVEQ		#-1,d1				; set "DIM" flag
    2979/    2F54 : 6170                	BSR.s		LAB_1D10				; search for or dimension a variable
    2980/    2F56 : 6100 FE58           	BSR		LAB_GBYT				; scan memory
    2981/    2F5A : 66F2                	BNE.s		LAB_1CFE				; loop and scan for "," if not null
    2982/    2F5C :                     
    2983/    2F5C : 4E75                	RTS
    2984/    2F5E :                     
    2985/    2F5E :                     
    2986/    2F5E :                     ;************************************************************************************
    2987/    2F5E :                     ;
    2988/    2F5E :                     ; perform << (left shift)
    2989/    2F5E :                     
    2990/    2F5E :                     LAB_LSHIFT
    2991/    2F5E : 612E                	BSR.s		GetPair				; get an integer and byte pair
    2992/    2F60 :                     								; byte is in d2, integer is in d0 and Itemp
    2993/    2F60 : 6708                	BEQ.s		NoShift				; branch if byte zero
    2994/    2F62 :                     
    2995/    2F62 : B43C 0020           	CMP.b		#$20,d2				; compare bit count with 32d
    2996/    2F66 : 6420                	BCC.s		TooBig				; branch if >=
    2997/    2F68 :                     
    2998/    2F68 : E5A0                	ASL.l		d2,d0					; shift longword
    2999/    2F6A :                     NoShift
    3000/    2F6A : 6000 0344           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
    3001/    2F6E :                     
    3002/    2F6E :                     
    3003/    2F6E :                     ;************************************************************************************
    3004/    2F6E :                     ;
    3005/    2F6E :                     ; perform >> (right shift)
    3006/    2F6E :                     
    3007/    2F6E :                     LAB_RSHIFT
    3008/    2F6E : 611E                	BSR.s		GetPair				; get an integer and byte pair
    3009/    2F70 :                     								; byte is in d2, integer is in d0 and Itemp
    3010/    2F70 : 67F8                	BEQ.s		NoShift				; branch if byte zero
    3011/    2F72 :                     
    3012/    2F72 : B43C 0020           	CMP.b		#$20,d2				; compare bit count with 32d
    3013/    2F76 : 650A                	BCS.s		Not2Big				; branch if >= (return shift)
    3014/    2F78 :                     
    3015/    2F78 : 4A80                	TST.l		d0					; test sign bit
    3016/    2F7A : 6A0C                	BPL.s		TooBig				; branch if +ve
    3017/    2F7C :                     
    3018/    2F7C : 70FF                	MOVEQ		#-1,d0				; set longword
    3019/    2F7E : 6000 0330           	BRA		LAB_AYFC				; convert d0 to longword in FAC1 & RET
    3020/    2F82 :                     
    3021/    2F82 :                     Not2Big
    3022/    2F82 : E4A0                	ASR.l		d2,d0					; shift longword
    3023/    2F84 : 6000 032A           	BRA		LAB_AYFC				; convert d0 to longword in FAC1 & RET
    3024/    2F88 :                     
    3025/    2F88 :                     TooBig
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 55 - 11/4/2023 8:40:20


    3026/    2F88 : 7000                	MOVEQ		#0,d0					; clear longword
    3027/    2F8A : 6000 0324           	BRA		LAB_AYFC				; convert d0 to longword in FAC1 & RET
    3028/    2F8E :                     
    3029/    2F8E :                     
    3030/    2F8E :                     ;************************************************************************************
    3031/    2F8E :                     ;
    3032/    2F8E :                     ; get an integer and byte pair
    3033/    2F8E :                     ; byte is in d2, integer is in d0 and Itemp
    3034/    2F8E :                     
    3035/    2F8E :                     GetPair
    3036/    2F8E : 6100 078E           	BSR		LAB_EVBY				; evaluate byte expression, result in d0 and
    3037/    2F92 :                     								; Itemp
    3038/    2F92 : 1400                	MOVE.b	d0,d2					; save it
    3039/    2F94 : 6100 0C3A           	BSR		LAB_279B				; copy FAC2 to FAC1, get first value in
    3040/    2F98 :                     								; expression
    3041/    2F98 : 6100 0162           	BSR		LAB_EVIR				; evaluate integer expression (no sign check)
    3042/    2F9C :                     								; result in d0 and Itemp
    3043/    2F9C : 4A02                	TST.b		d2					; test byte value
    3044/    2F9E : 4E75                	RTS
    3045/    2FA0 :                     
    3046/    2FA0 :                     
    3047/    2FA0 :                     ;************************************************************************************
    3048/    2FA0 :                     ;
    3049/    2FA0 :                     ; check alpha, return C=0 if<"A" or >"Z" or <"a" to "z">
    3050/    2FA0 :                     
    3051/    2FA0 :                     LAB_CASC
    3052/    2FA0 : B03C 0061           	CMP.b		#$61,d0				; compare with "a"
    3053/    2FA4 : 6410                	BCC.s		LAB_1D83				; if >="a" go check =<"z"
    3054/    2FA6 :                     
    3055/    2FA6 :                     
    3056/    2FA6 :                     ;************************************************************************************
    3057/    2FA6 :                     ;
    3058/    2FA6 :                     ; check alpha upper case, return C=0 if<"A" or >"Z"
    3059/    2FA6 :                     
    3060/    2FA6 :                     LAB_CAUC
    3061/    2FA6 : B03C 0041           	CMP.b		#$41,d0				; compare with "A"
    3062/    2FAA : 6404                	BCC.s		LAB_1D8A				; if >="A" go check =<"Z"
    3063/    2FAC :                     
    3064/    2FAC : 8040                	OR		d0,d0					; make C=0
    3065/    2FAE : 4E75                	RTS
    3066/    2FB0 :                     
    3067/    2FB0 :                     LAB_1D8A
    3068/    2FB0 : B03C 005B           	CMP.b		#$5B,d0				; compare with "Z"+1
    3069/    2FB4 :                     								; carry set if byte<="Z"
    3070/    2FB4 : 4E75                	RTS
    3071/    2FB6 :                     
    3072/    2FB6 :                     LAB_1D83
    3073/    2FB6 : B03C 007B           	CMP.b		#$7B,d0				; compare with "z"+1
    3074/    2FBA :                     								; carry set if byte<="z"
    3075/    2FBA : 4E75                	RTS
    3076/    2FBC :                     
    3077/    2FBC :                     
    3078/    2FBC :                     ;************************************************************************************
    3079/    2FBC :                     ;
    3080/    2FBC :                     ; search for or create variable. this is used to automatically create a variable if
    3081/    2FBC :                     ; it is not found. any routines that need to create the variable call LAB_GVAR via
    3082/    2FBC :                     ; this point and error generation is supressed and the variable will be created
    3083/    2FBC :                     ;
    3084/    2FBC :                     ; return pointer to variable in Cvaral and a0
    3085/    2FBC :                     ; set data type to variable type
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 56 - 11/4/2023 8:40:20


    3086/    2FBC :                     
    3087/    2FBC :                     LAB_SVAR
    3088/    2FBC : 6102                	BSR.s		LAB_GVAR				; search for variable
    3089/    2FBE :                     LAB_FVAR
    3090/    2FBE : 4E75                	RTS
    3091/    2FC0 :                     
    3092/    2FC0 :                     
    3093/    2FC0 :                     ;************************************************************************************
    3094/    2FC0 :                     ;
    3095/    2FC0 :                     ; search for variable. if this routine is called from anywhere but the above call and
    3096/    2FC0 :                     ; the variable searched for does not exist then an error will be returned
    3097/    2FC0 :                     ;
    3098/    2FC0 :                     ; DIM flag is in d1.b
    3099/    2FC0 :                     ; return pointer to variable in Cvaral and a0
    3100/    2FC0 :                     ; set data type to variable type
    3101/    2FC0 :                     
    3102/    2FC0 :                     LAB_GVAR
    3103/    2FC0 : 7200                	MOVEQ		#$00,d1				; set DIM flag = $00
    3104/    2FC2 : 6100 FDEC           	BSR		LAB_GBYT				; scan memory (1st character)
    3105/    2FC6 :                     LAB_1D10
    3106/    2FC6 : 1741 05B4           	MOVE.b	d1,Defdim(a3)			; save DIM flag
    3107/    2FCA :                     
    3108/    2FCA :                     ; search for FN name entry point
    3109/    2FCA :                     
    3110/    2FCA :                     LAB_1D12
    3111/    2FCA : 61D4                	BSR.s		LAB_CASC				; check byte, return C=0 if<"A" or >"Z"
    3112/    2FCC : 6400 F19A           	BCC		LAB_SNER				; if not, syntax error then warm start
    3113/    2FD0 :                     
    3114/    2FD0 :                     								; it is a variable name so ...
    3115/    2FD0 : 7200                	MOVEQ		#$0,d1				; set index for name byte
    3116/    2FD2 : 41EB 046A           	LEA		Varname(a3),a0			; pointer to variable name
    3117/    2FD6 : 2081                	MOVE.l	d1,(a0)				; clear the variable name
    3118/    2FD8 : 1741 05B5           	MOVE.b	d1,Dtypef(a3)			; clear the data type, $80=string, $40=integer,
    3119/    2FDC :                     								; $00=float
    3120/    2FDC :                     
    3121/    2FDC :                     LAB_1D2D
    3122/    2FDC : B27C 0004           	CMP.w		#$04,d1				; done all significant characters?
    3123/    2FE0 : 6406                	BCC.s		LAB_1D2E				; if so go ignore any more
    3124/    2FE2 :                     
    3125/    2FE2 : 1180 1000           	MOVE.b	d0,(a0,d1.w)			; save the character
    3126/    2FE6 : 5241                	ADDQ.w	#1,d1					; increment index
    3127/    2FE8 :                     LAB_1D2E
    3128/    2FE8 : 6100 FDC4           	BSR		LAB_IGBY				; increment & scan memory (next character)
    3129/    2FEC : 65EE                	BCS.s		LAB_1D2D				; branch if character = "0"-"9" (ok)
    3130/    2FEE :                     
    3131/    2FEE :                     								; character wasn't "0" to "9" so ...
    3132/    2FEE : 61B0                	BSR.s		LAB_CASC				; check byte, return C=0 if<"A" or >"Z"
    3133/    2FF0 : 65EA                	BCS.s		LAB_1D2D				; branch if = "A"-"Z" (ok)
    3134/    2FF2 :                     
    3135/    2FF2 :                     								; check if string variable
    3136/    2FF2 : B03C 0024           	CMP.b		#'$',d0				; compare with "$"
    3137/    2FF6 : 660C                	BNE.s		LAB_1D44				; branch if not string
    3138/    2FF8 :                     
    3139/    2FF8 :                     								; type is string
    3140/    2FF8 : 002B 0080 046B      	OR.b		#$80,Varname+1(a3)		; set top bit of 2nd character, indicate string
    3141/    2FFE : 6100 FDAE           	BSR		LAB_IGBY				; increment & scan memory
    3142/    3002 : 6010                	BRA.s		LAB_1D45				; skip integer check
    3143/    3004 :                     
    3144/    3004 :                     								; check if integer variable
    3145/    3004 :                     LAB_1D44
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 57 - 11/4/2023 8:40:20


    3146/    3004 : B03C 0026           	CMP.b		#'&',d0				; compare with "&"
    3147/    3008 : 660A                	BNE.s		LAB_1D45				; branch if not integer
    3148/    300A :                     
    3149/    300A :                     								; type is integer
    3150/    300A : 002B 0080 046C      	OR.b		#$80,Varname+2(a3)		; set top bit of 3rd character, indicate integer
    3151/    3010 : 6100 FD9C           	BSR		LAB_IGBY				; increment & scan memory
    3152/    3014 :                     
    3153/    3014 :                     ; after we have determined the variable type we need to determine
    3154/    3014 :                     ; if it's an array of type
    3155/    3014 :                     
    3156/    3014 :                     								; gets here with character after var name in d0
    3157/    3014 :                     LAB_1D45
    3158/    3014 : 4A2B 05DF           	TST.b		Sufnxf(a3)				; test function name flag
    3159/    3018 : 670E                	BEQ.s		LAB_1D48				; if not FN or FN variable continue
    3160/    301A :                     
    3161/    301A : 6A14                	BPL.s		LAB_1D49				; if FN variable go find or create it
    3162/    301C :                     
    3163/    301C :                     								; else was FN name
    3164/    301C : 202B 046A           	MOVE.l	Varname(a3),d0			; get whole function name
    3165/    3020 : 7208                	MOVEQ		#8,d1					; set step to next function size -4
    3166/    3022 : 41EB 0432           	LEA		Sfncl(a3),a0			; get pointer to start of functions
    3167/    3026 : 601C                	BRA.s		LAB_1D4B				; go find function
    3168/    3028 :                     
    3169/    3028 :                     LAB_1D48
    3170/    3028 : 903C 0028           	SUB.b		#'(',d0				; subtract "("
    3171/    302C : 6700 00F4           	BEQ		LAB_1E17				; if "(" go find, or make, array
    3172/    3030 :                     
    3173/    3030 :                     ; either find or create var
    3174/    3030 :                     ; var name (1st four characters only!) is in Varname
    3175/    3030 :                     
    3176/    3030 :                     								; variable name wasn't var( .. so look for
    3177/    3030 :                     								; plain variable
    3178/    3030 :                     LAB_1D49
    3179/    3030 : 202B 046A           	MOVE.l	Varname(a3),d0			; get whole variable name
    3180/    3034 :                     LAB_1D4A
    3181/    3034 : 7204                	MOVEQ		#4,d1					; set step to next variable size -4
    3182/    3036 : 41EB 0436           	LEA		Svarl(a3),a0			; get pointer to start of variables
    3183/    303A :                     
    3184/    303A : 0800 0017           	BTST.l	#23,d0				; test if string name
    3185/    303E : 6704                	BEQ.s		LAB_1D4B				; branch if not
    3186/    3040 :                     
    3187/    3040 : 5441                	ADDQ.w	#2,d1					; 6 bytes per string entry
    3188/    3042 : 5848                	ADDQ.w	#(Sstrl-Svarl),a0			; move to string area
    3189/    3044 :                     
    3190/    3044 :                     LAB_1D4B
    3191/    3044 : 2268 0004           	MOVEA.l	4(a0),a1				; get end address
    3192/    3048 : 2050                	MOVEA.l	(a0),a0				; get start address
    3193/    304A : 6006                	BRA.s		LAB_1D5E				; enter loop at exit check
    3194/    304C :                     
    3195/    304C :                     LAB_1D5D
    3196/    304C : B098                	CMP.l		(a0)+,d0				; compare this variable with name
    3197/    304E : 6776                	BEQ.s		LAB_1DD7				; branch if match (found var)
    3198/    3050 :                     
    3199/    3050 : D1C1                	ADDA.l	d1,a0					; add offset to next variable
    3200/    3052 :                     LAB_1D5E
    3201/    3052 : B1C9                	CMPA.l	a1,a0					; compare address with variable space end
    3202/    3054 : 66F6                	BNE.s		LAB_1D5D				; if not end go check next
    3203/    3056 :                     
    3204/    3056 : 4A2B 05DF           	TST.b		Sufnxf(a3)				; is it a function or function variable
    3205/    305A : 660A                	BNE.s		LAB_1D94				; if was go do DEF or function variable
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 58 - 11/4/2023 8:40:20


    3206/    305C :                     
    3207/    305C :                     								; reached end of variable mem without match
    3208/    305C :                     								; ... so create new variable, possibly
    3209/    305C :                     
    3210/    305C : 45FA FF60           	LEA		LAB_FVAR(pc),a2			; get the address of the create if doesn't
    3211/    3060 :                     								; exist call to LAB_GVAR
    3212/    3060 : B5D7                	CMPA.l	(sp),a2				; compare the return address with expected
    3213/    3062 : 6600 F0C0           	BNE		LAB_UVER				; if not create go do error or return null
    3214/    3066 :                     
    3215/    3066 :                     ; this will only branch if the call to LAB_GVAR wasn't from LAB_SVAR
    3216/    3066 :                     
    3217/    3066 :                     LAB_1D94
    3218/    3066 : 082B 0000 05DF      	BTST.b	#0,Sufnxf(a3)			; test function search flag
    3219/    306C : 6600 F0BE           	BNE		LAB_UFER				; if not doing DEF then go do undefined
    3220/    3070 :                     								; function error
    3221/    3070 :                     
    3222/    3070 :                     								; else create new variable/function
    3223/    3070 :                     LAB_1D98
    3224/    3070 : 246B 0442           	MOVEA.l	Earryl(a3),a2			; get end of block to move
    3225/    3074 : 240A                	MOVE.l	a2,d2					; copy end of block to move
    3226/    3076 : 9489                	SUB.l		a1,d2					; calculate block to move size
    3227/    3078 :                     
    3228/    3078 : 204A                	MOVEA.l	a2,a0					; copy end of block to move
    3229/    307A : 5881                	ADDQ.l	#4,d1					; space for one variable/function + name
    3230/    307C : D5C1                	ADDA.l	d1,a2					; add space for one variable/function
    3231/    307E : 274A 0442           	MOVE.l	a2,Earryl(a3)			; set new array mem end
    3232/    3082 : E28A                	LSR.l		#1,d2					; /2 for word copy
    3233/    3084 : 6712                	BEQ.s		LAB_1DAF				; skip move if zero length block
    3234/    3086 :                     
    3235/    3086 : 5382                	SUBQ.l	#1,d2					; -1 for DFB loop
    3236/    3088 : 4842                	SWAP		d2					; swap high word to low word
    3237/    308A :                     LAB_1DAC
    3238/    308A : 4842                	SWAP		d2					; swap high word to low word
    3239/    308C :                     LAB_1DAE
    3240/    308C : 3520                	MOVE.w	-(a0),-(a2)				; copy word
    3241/    308E : 51CA FFFC           	DBF		d2,LAB_1DAE				; loop until done
    3242/    3092 :                     
    3243/    3092 : 4842                	SWAP		d2					; swap high word to low word
    3244/    3094 : 51CA FFF4           	DBF		d2,LAB_1DAC				; decrement high count and loop until done
    3245/    3098 :                     
    3246/    3098 :                     ; get here after creating either a function, variable or string
    3247/    3098 :                     ; if function set variables start, string start, array start
    3248/    3098 :                     ; if variable set string start, array start
    3249/    3098 :                     ; if string set array start
    3250/    3098 :                     
    3251/    3098 :                     LAB_1DAF
    3252/    3098 : 4A2B 05DF           	TST.b		Sufnxf(a3)				; was it function
    3253/    309C : 6B08                	BMI.s		LAB_1DB0				; branch if was FN
    3254/    309E :                     
    3255/    309E : 0800 0017           	BTST.l	#23,d0				; was it string
    3256/    30A2 : 660A                	BNE.s		LAB_1DB2				; branch if string
    3257/    30A4 :                     
    3258/    30A4 : 6004                	BRA.s		LAB_1DB1				; branch if was plain variable
    3259/    30A6 :                     
    3260/    30A6 :                     LAB_1DB0
    3261/    30A6 : D3AB 0436           	ADD.l		d1,Svarl(a3)			; set new variable memory start
    3262/    30AA :                     LAB_1DB1
    3263/    30AA : D3AB 043A           	ADD.l		d1,Sstrl(a3)			; set new start of strings
    3264/    30AE :                     LAB_1DB2
    3265/    30AE : D3AB 043E           	ADD.l		d1,Sarryl(a3)			; set new array memory start
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 59 - 11/4/2023 8:40:20


    3266/    30B2 : 20C0                	MOVE.l	d0,(a0)+				; save variable/function name
    3267/    30B4 : 20BC 0000 0000      	MOVE.l	#$00,(a0)				; initialise variable
    3268/    30BA : 0800 0017           	BTST.l	#23,d0				; was it string
    3269/    30BE : 6706                	BEQ.s		LAB_1DD7				; branch if not string
    3270/    30C0 :                     
    3271/    30C0 : 317C 0000 0004      	MOVE.w	#$00,4(a0)				; else initialise string length
    3272/    30C6 :                     
    3273/    30C6 :                     								; found a match for var ((Vrschl) = ptr)
    3274/    30C6 :                     LAB_1DD7
    3275/    30C6 : 2200                	MOVE.l	d0,d1					; ........ $....... &....... ........
    3276/    30C8 : D281                	ADD.l		d1,d1					; .......$ .......& ........ .......0
    3277/    30CA : 4841                	SWAP		d1					; ........ .......0 .......$ .......&
    3278/    30CC : E219                	ROR.b		#1,d1					; ........ .......0 .......$ &.......
    3279/    30CE : E249                	LSR.w		#1,d1					; ........ .......0 0....... $&.....�.
    3280/    30D0 : C23C 00C0           	AND.b		#$C0,d1				; mask the type bits
    3281/    30D4 : 1741 05B5           	MOVE.b	d1,Dtypef(a3)			; save the data type
    3282/    30D8 :                     
    3283/    30D8 : 177C 0000 05DF      	MOVE.b	#$00,Sufnxf(a3)			; clear FN flag byte
    3284/    30DE : 4E75                	RTS
    3285/    30E0 :                     
    3286/    30E0 :                     
    3287/    30E0 :                     ;************************************************************************************
    3288/    30E0 :                     ;
    3289/    30E0 :                     ; set-up array pointer, d0, to first element in array
    3290/    30E0 :                     ; set d0 to (a0)+2*(Dimcnt)+$0A
    3291/    30E0 :                     
    3292/    30E0 :                     LAB_1DE6
    3293/    30E0 : 7005                	MOVEQ		#5,d0					; set d0 to 5 (*2 = 10, later)
    3294/    30E2 : D02B 05DB           	ADD.b		Dimcnt(a3),d0			; add # of dimensions (1, 2 or 3)
    3295/    30E6 : D080                	ADD.l		d0,d0					; *2 (bytes per dimension size)
    3296/    30E8 : D088                	ADD.l		a0,d0					; add array start pointer
    3297/    30EA : 4E75                	RTS
    3298/    30EC :                     
    3299/    30EC :                     
    3300/    30EC :                     ;************************************************************************************
    3301/    30EC :                     ;
    3302/    30EC :                     ; evaluate unsigned integer expression
    3303/    30EC :                     
    3304/    30EC :                     LAB_EVIN
    3305/    30EC : 6100 FCC0           	BSR		LAB_IGBY				; increment & scan memory
    3306/    30F0 : 6100 FB44           	BSR		LAB_EVNM				; evaluate expression & check is numeric,
    3307/    30F4 :                     								; else do type mismatch
    3308/    30F4 :                     
    3309/    30F4 :                     
    3310/    30F4 :                     ;************************************************************************************
    3311/    30F4 :                     ;
    3312/    30F4 :                     ; evaluate positive integer expression, result in d0 and Itemp
    3313/    30F4 :                     
    3314/    30F4 :                     LAB_EVPI
    3315/    30F4 : 4A2B 0595           	TST.b		FAC1_s(a3)				; test FAC1 sign (b7)
    3316/    30F8 : 6B00 F062           	BMI		LAB_FCER				; do function call error if -ve
    3317/    30FC :                     
    3318/    30FC :                     
    3319/    30FC :                     ;************************************************************************************
    3320/    30FC :                     ;
    3321/    30FC :                     ; evaluate integer expression, no sign check
    3322/    30FC :                     ; result in d0 and Itemp, exit with flags set correctly
    3323/    30FC :                     
    3324/    30FC :                     LAB_EVIR
    3325/    30FC : 0C2B 00A0 0594      	CMPI.b	#$A0,FAC1_e(a3)			; compare exponent with exponent = 2^32 (n>2^31)
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 60 - 11/4/2023 8:40:20


    3326/    3102 : 6500 0B64           	BCS		LAB_2831				; convert FAC1 floating to fixed
    3327/    3106 :                     								; result in d0 and Itemp
    3328/    3106 : 6600 F054           	BNE		LAB_FCER				; if > do function call error, then warm start
    3329/    310A :                     
    3330/    310A : 4A2B 0595           	TST.b		FAC1_s(a3)				; test sign of FAC1
    3331/    310E : 6A00 0B58           	BPL		LAB_2831				; if +ve then ok
    3332/    3112 :                     
    3333/    3112 : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get mantissa
    3334/    3116 : 4480                	NEG.l		d0					; do -d0
    3335/    3118 : 6800 F042           	BVC		LAB_FCER				; if not $80000000 do FC error, then warm start
    3336/    311C :                     
    3337/    311C : 2740 042A           	MOVE.l	d0,Itemp(a3)			; else just set it
    3338/    3120 : 4E75                	RTS
    3339/    3122 :                     
    3340/    3122 :                     
    3341/    3122 :                     ;************************************************************************************
    3342/    3122 :                     ;
    3343/    3122 :                     ; find or make array
    3344/    3122 :                     
    3345/    3122 :                     LAB_1E17
    3346/    3122 : 3F2B 05B4           	MOVE.w	Defdim(a3),-(sp)			; get DIM flag and data type flag (word in mem)
    3347/    3126 : 7200                	MOVEQ		#0,d1					; clear dimensions count
    3348/    3128 :                     
    3349/    3128 :                     ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
    3350/    3128 :                     
    3351/    3128 :                     LAB_1E1F
    3352/    3128 : 3F01                	MOVE.w	d1,-(sp)				; save dimensions count
    3353/    312A : 2F2B 046A           	MOVE.l	Varname(a3),-(sp)			; save variable name
    3354/    312E : 61BC                	BSR.s		LAB_EVIN				; evaluate integer expression
    3355/    3130 :                     
    3356/    3130 : 4840                	SWAP		d0					; swap high word to low word
    3357/    3132 : 4A40                	TST.w		d0					; test swapped high word
    3358/    3134 : 6600 F016           	BNE		LAB_ABER				; if too big do array bounds error
    3359/    3138 :                     
    3360/    3138 : 275F 046A           	MOVE.l	(sp)+,Varname(a3)			; restore variable name
    3361/    313C : 321F                	MOVE.w	(sp)+,d1				; restore dimensions count
    3362/    313E : 301F                	MOVE.w	(sp)+,d0				; restore DIM and data type flags
    3363/    3140 : 3F2B 042C           	MOVE.w	Itemp+2(a3),-(sp)			; stack this dimension size
    3364/    3144 : 3F00                	MOVE.w	d0,-(sp)				; save DIM and data type flags
    3365/    3146 : 5241                	ADDQ.w	#1,d1					; increment dimensions count
    3366/    3148 : 6100 FC66           	BSR		LAB_GBYT				; scan memory
    3367/    314C : B03C 002C           	CMP.b		#$2C,d0				; compare with ","
    3368/    3150 : 67D6                	BEQ.s		LAB_1E1F				; if found go do next dimension
    3369/    3152 :                     
    3370/    3152 : 1741 05DB           	MOVE.b	d1,Dimcnt(a3)			; store dimensions count
    3371/    3156 : 6100 FC44           	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
    3372/    315A : 375F 05B4           	MOVE.w	(sp)+,Defdim(a3)			; restore DIM and data type flags (word in mem)
    3373/    315E : 206B 043E           	MOVEA.l	Sarryl(a3),a0			; get array mem start
    3374/    3162 :                     
    3375/    3162 :                     ; now check to see if we are at the end of array memory (we would be if there were
    3376/    3162 :                     ; no arrays).
    3377/    3162 :                     
    3378/    3162 :                     LAB_1E5C
    3379/    3162 : 2748 05AC           	MOVE.l	a0,Astrtl(a3)			; save as array start pointer
    3380/    3166 : B1EB 0442           	CMPA.l	Earryl(a3),a0			; compare with array mem end
    3381/    316A : 672E                	BEQ.s		LAB_1EA1				; go build array if not found
    3382/    316C :                     
    3383/    316C :                     								; search for array
    3384/    316C : 2010                	MOVE.l	(a0),d0				; get this array name
    3385/    316E : B0AB 046A           	CMP.l		Varname(a3),d0			; compare with array name
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 61 - 11/4/2023 8:40:20


    3386/    3172 : 670A                	BEQ.s		LAB_1E8D				; array found so branch
    3387/    3174 :                     
    3388/    3174 :                     								; no match
    3389/    3174 : 2068 0004           	MOVEA.l	4(a0),a0				; get this array size
    3390/    3178 : D1EB 05AC           	ADDA.l	Astrtl(a3),a0			; add to array start pointer
    3391/    317C : 60E4                	BRA.s		LAB_1E5C				; go check next array
    3392/    317E :                     
    3393/    317E :                     								; found array, are we trying to dimension it?
    3394/    317E :                     LAB_1E8D
    3395/    317E : 4A2B 05B4           	TST.b		Defdim(a3)				; are we trying to dimension it?
    3396/    3182 : 6600 EFC4           	BNE		LAB_DDER				; if so do double dimension error/warm start
    3397/    3186 :                     
    3398/    3186 :                     ; found the array and we're not dimensioning it so we must find an element in it
    3399/    3186 :                     
    3400/    3186 : 6100 FF58           	BSR		LAB_1DE6				; set data pointer, d0, to the first element
    3401/    318A :                     								; in the array
    3402/    318A : 5048                	ADDQ.w	#8,a0					; index to dimension count
    3403/    318C : 3018                	MOVE.w	(a0)+,d0				; get no of dimensions
    3404/    318E : B02B 05DB           	CMP.b		Dimcnt(a3),d0			; compare with dimensions count
    3405/    3192 : 6700 0094           	BEQ		LAB_1F28				; found array so go get element
    3406/    3196 :                     
    3407/    3196 : 6000 EF84           	BRA		LAB_WDER				; else wrong so do "Wrong dimensions" error
    3408/    319A :                     
    3409/    319A :                     								; array not found, so possibly build it
    3410/    319A :                     LAB_1EA1
    3411/    319A : 4A2B 05B4           	TST.b		Defdim(a3)				; test the default DIM flag
    3412/    319E : 6700 EF80           	BEQ		LAB_UDER				; if default flag is clear then we are not
    3413/    31A2 :                     								; explicitly dimensioning an array so go
    3414/    31A2 :                     								; do an "Undimensioned array" error
    3415/    31A2 :                     
    3416/    31A2 : 6100 FF3C           	BSR		LAB_1DE6				; set data pointer, d0, to the first element
    3417/    31A6 :                     								; in the array
    3418/    31A6 : 202B 046A           	MOVE.l	Varname(a3),d0			; get array name
    3419/    31AA : 20C0                	MOVE.l	d0,(a0)+				; save array name
    3420/    31AC : 7204                	MOVEQ		#4,d1					; set 4 bytes per element
    3421/    31AE : 0800 0017           	BTST.l	#23,d0				; test if string array
    3422/    31B2 : 6702                	BEQ.s		LAB_1EDF				; branch if not string
    3423/    31B4 :                     
    3424/    31B4 : 7206                	MOVEQ		#6,d1					; else 6 bytes per element
    3425/    31B6 :                     LAB_1EDF
    3426/    31B6 : 2741 05A8           	MOVE.l	d1,Asptl(a3)			; set array data size (bytes per element)
    3427/    31BA : 122B 05DB           	MOVE.b	Dimcnt(a3),d1			; get dimensions count
    3428/    31BE : 5848                	ADDQ.w	#4,a0					; skip the array size now (don't know it yet!)
    3429/    31C0 : 30C1                	MOVE.w	d1,(a0)+				; set array's dimensions count
    3430/    31C2 :                     
    3431/    31C2 :                     ; now calculate the array data space size
    3432/    31C2 :                     
    3433/    31C2 :                     LAB_1EC0
    3434/    31C2 :                     
    3435/    31C2 :                     ; If you want arrays to dimension themselves by default then comment out the test
    3436/    31C2 :                     ; above and uncomment the next three code lines and the label LAB_1ED0
    3437/    31C2 :                     
    3438/    31C2 :                     ;	MOVE.w	#$0A,d1				; set default dimension value, allow 0 to 9
    3439/    31C2 :                     ;	TST.b		Defdim(a3)				; test default DIM flag
    3440/    31C2 :                     ;	BNE.s		LAB_1ED0				; branch if b6 of Defdim is clear
    3441/    31C2 :                     
    3442/    31C2 : 321F                	MOVE.w	(sp)+,d1				; get dimension size
    3443/    31C4 :                     ;LAB_1ED0
    3444/    31C4 : 30C1                	MOVE.w	d1,(a0)+				; save to array header
    3445/    31C6 : 6100 00AE           	BSR		LAB_1F7C				; do this dimension size+1	; array size
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 62 - 11/4/2023 8:40:20


    3446/    31CA :                     								; (d1+1)*(Asptl), result in d0
    3447/    31CA : 2740 05A8           	MOVE.l	d0,Asptl(a3)			; save array data size
    3448/    31CE : 532B 05DB           	SUBQ.b	#1,Dimcnt(a3)			; decrement dimensions count
    3449/    31D2 : 66EE                	BNE.s		LAB_1EC0				; loop while not = 0
    3450/    31D4 :                     
    3451/    31D4 : D1EB 05A8           	ADDA.l	Asptl(a3),a0			; add size to first element address
    3452/    31D8 : 6500 EF7A           	BCS		LAB_OMER				; if overflow go do "Out of memory" error
    3453/    31DC :                     
    3454/    31DC : B1EB 0446           	CMPA.l	Sstorl(a3),a0			; compare with bottom of string memory
    3455/    31E0 : 650C                	BCS.s		LAB_1ED6				; branch if less (is ok)
    3456/    31E2 :                     
    3457/    31E2 : 6100 028E           	BSR		LAB_GARB				; do garbage collection routine
    3458/    31E6 : B1EB 0446           	CMPA.l	Sstorl(a3),a0			; compare with bottom of string memory
    3459/    31EA : 6400 EF68           	BCC		LAB_OMER				; if Sstorl <= a0 do "Out of memory"
    3460/    31EE :                     								; error then warm start
    3461/    31EE :                     
    3462/    31EE :                     LAB_1ED6							; ok exit, carry set
    3463/    31EE : 2748 0442           	MOVE.l	a0,Earryl(a3)			; save array mem end
    3464/    31F2 : 7000                	MOVEQ		#0,d0					; zero d0
    3465/    31F4 : 222B 05A8           	MOVE.l	Asptl(a3),d1			; get size in bytes
    3466/    31F8 : E289                	LSR.l		#1,d1					; /2 for word fill (may be odd # words)
    3467/    31FA : 5341                	SUBQ.w	#1,d1					; adjust for DBF loop
    3468/    31FC :                     LAB_1ED8
    3469/    31FC : 3100                	MOVE.w	d0,-(a0)				; decrement pointer and clear word
    3470/    31FE : 51C9 FFFC           	DBF		d1,LAB_1ED8				; decrement & loop until low word done
    3471/    3202 :                     
    3472/    3202 : 4841                	SWAP		d1					; swap words
    3473/    3204 : 4A41                	TST.w		d1					; test high word
    3474/    3206 : 6706                	BEQ.s		LAB_1F07				; exit if done
    3475/    3208 :                     
    3476/    3208 : 5341                	SUBQ.w	#1,d1					; decrement low (high) word
    3477/    320A : 4841                	SWAP		d1					; swap back
    3478/    320C : 60EE                	BRA.s		LAB_1ED8				; go do a whole block
    3479/    320E :                     
    3480/    320E :                     ; now we need to calculate the array size by doing Earryl - Astrtl
    3481/    320E :                     
    3482/    320E :                     LAB_1F07
    3483/    320E : 206B 05AC           	MOVEA.l	Astrtl(a3),a0			; get for calculation and as pointer
    3484/    3212 : 202B 0442           	MOVE.l	Earryl(a3),d0			; get array memory end
    3485/    3216 : 9088                	SUB.l		a0,d0					; calculate array size
    3486/    3218 : 2140 0004           	MOVE.l	d0,4(a0)				; save size to array
    3487/    321C : 4A2B 05B4           	TST.b		Defdim(a3)				; test default DIM flag
    3488/    3220 : 6652                	BNE.s		RTS_011				; exit (RET) if this was a DIM command
    3489/    3222 :                     
    3490/    3222 :                     								; else, find element
    3491/    3222 : 5048                	ADDQ.w	#8,a0					; index to dimension count
    3492/    3224 : 3758 05DB           	MOVE.w	(a0)+,Dimcnt(a3)			; get array's dimension count
    3493/    3228 :                     
    3494/    3228 :                     ; we have found, or built, the array. now we need to find the element
    3495/    3228 :                     
    3496/    3228 :                     LAB_1F28
    3497/    3228 : 7000                	MOVEQ		#0,d0					; clear first result
    3498/    322A : 2740 05A8           	MOVE.l	d0,Asptl(a3)			; clear array data pointer
    3499/    322E :                     
    3500/    322E :                     ; compare nth dimension bound (a0) with nth index (sp)+
    3501/    322E :                     ; if greater do array bounds error
    3502/    322E :                     
    3503/    322E :                     LAB_1F2C
    3504/    322E : 3218                	MOVE.w	(a0)+,d1				; get nth dimension bound
    3505/    3230 : B257                	CMP.w		(sp),d1				; compare nth index with nth dimension bound
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 63 - 11/4/2023 8:40:20


    3506/    3232 : 6500 EF18           	BCS		LAB_ABER				; if d1 less or = do array bounds error
    3507/    3236 :                     
    3508/    3236 :                     ; now do pointer = pointer	; nth dimension + nth index
    3509/    3236 :                     
    3510/    3236 : 4A80                	TST.l		d0					; test pointer
    3511/    3238 : 6702                	BEQ.s		LAB_1F5A				; skip multiply if last result = null
    3512/    323A :                     
    3513/    323A : 613A                	BSR.s		LAB_1F7C				; do this dimension size+1	; array size
    3514/    323C :                     LAB_1F5A
    3515/    323C : 7200                	MOVEQ		#0,d1					; clear longword
    3516/    323E : 321F                	MOVE.w	(sp)+,d1				; get nth dimension index
    3517/    3240 : D081                	ADD.l		d1,d0					; add index to size
    3518/    3242 : 2740 05A8           	MOVE.l	d0,Asptl(a3)			; save array data pointer
    3519/    3246 :                     
    3520/    3246 : 532B 05DB           	SUBQ.b	#1,Dimcnt(a3)			; decrement dimensions count
    3521/    324A : 66E2                	BNE.s		LAB_1F2C				; loop if dimensions still to do
    3522/    324C :                     
    3523/    324C : 177C 0000 05B5      	MOVE.b	#0,Dtypef(a3)			; set data type to float
    3524/    3252 : 7203                	MOVEQ		#3,d1					; set for numeric array
    3525/    3254 : 4A2B 046B           	TST.b		Varname+1(a3)			; test if string array
    3526/    3258 : 6A0A                	BPL.s		LAB_1F6A				; branch if not string
    3527/    325A :                     
    3528/    325A : 7205                	MOVEQ		#5,d1					; else set for string array
    3529/    325C : 177C 0080 05B5      	MOVE.b	#$80,Dtypef(a3)			; and set data type to string
    3530/    3262 : 600C                	BRA.s		LAB_1F6B				; skip integer test
    3531/    3264 :                     
    3532/    3264 :                     LAB_1F6A
    3533/    3264 : 4A2B 046C           	TST.b		Varname+2(a3)			; test if integer array
    3534/    3268 : 6A06                	BPL.s		LAB_1F6B				; branch if not integer
    3535/    326A :                     
    3536/    326A : 177C 0040 05B5      	MOVE.b	#$40,Dtypef(a3)			; else set data type to integer
    3537/    3270 :                     LAB_1F6B
    3538/    3270 : 6104                	BSR.s		LAB_1F7C				; do element size (d1)	; array size (Asptl)
    3539/    3272 : D1C0                	ADDA.l	d0,a0					; add array data start pointer
    3540/    3274 :                     RTS_011
    3541/    3274 : 4E75                	RTS
    3542/    3276 :                     
    3543/    3276 :                     
    3544/    3276 :                     ;************************************************************************************
    3545/    3276 :                     ;
    3546/    3276 :                     ; do this dimension size (d1)	; array data size (Asptl)
    3547/    3276 :                     
    3548/    3276 :                     ; do a 16 x 32 bit multiply
    3549/    3276 :                     ; d1 holds the 16 bit multiplier
    3550/    3276 :                     ; Asptl holds the 32 bit multiplicand
    3551/    3276 :                     
    3552/    3276 :                     ; d0	bbbb  bbbb
    3553/    3276 :                     ; d1	0000  aaaa
    3554/    3276 :                     ;	----------
    3555/    3276 :                     ; d0	rrrr  rrrr
    3556/    3276 :                     
    3557/    3276 :                     LAB_1F7C
    3558/    3276 : 202B 05A8           	MOVE.l	Asptl(a3),d0			; get result
    3559/    327A : 2400                	MOVE.l	d0,d2					; copy it
    3560/    327C : 4842                	SWAP		d2					; shift high word to low word
    3561/    327E : C0C1                	MULU.w	d1,d0					; d1	; low word = low result
    3562/    3280 : C4C1                	MULU.w	d1,d2					; d1	; high word = high result
    3563/    3282 : 4842                	SWAP		d2					; align words for test
    3564/    3284 : 4A42                	TST.w		d2					; must be zero
    3565/    3286 : 6600 EECC           	BNE		LAB_OMER				; if overflow go do "Out of memory" error
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 64 - 11/4/2023 8:40:20


    3566/    328A :                     
    3567/    328A : D082                	ADD.l		d2,d0					; calculate result
    3568/    328C : 6500 EEC6           	BCS		LAB_OMER				; if overflow go do "Out of memory" error
    3569/    3290 :                     
    3570/    3290 : D0AB 05A8           	ADD.l		Asptl(a3),d0			; add original
    3571/    3294 : 6500 EEBE           	BCS		LAB_OMER				; if overflow go do "Out of memory" error
    3572/    3298 :                     
    3573/    3298 : 4E75                	RTS
    3574/    329A :                     
    3575/    329A :                     
    3576/    329A :                     ;************************************************************************************
    3577/    329A :                     ;
    3578/    329A :                     ; perform FRE()
    3579/    329A :                     
    3580/    329A :                     LAB_FRE
    3581/    329A : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
    3582/    329E :                     								; $00=float
    3583/    329E : 6A04                	BPL.s		LAB_1FB4				; branch if numeric
    3584/    32A0 :                     
    3585/    32A0 : 6100 0318           	BSR		LAB_22B6				; pop string off descriptor stack, or from
    3586/    32A4 :                     								; top of string space, returns d0 = length,
    3587/    32A4 :                     								; a0 = pointer
    3588/    32A4 :                     
    3589/    32A4 :                     								; FRE(n) was numeric so do this
    3590/    32A4 :                     LAB_1FB4
    3591/    32A4 : 6100 01CC           	BSR		LAB_GARB				; go do garbage collection
    3592/    32A8 : 202B 0446           	MOVE.l	Sstorl(a3),d0			; get bottom of string space
    3593/    32AC : 90AB 0442           	SUB.l		Earryl(a3),d0			; subtract array mem end
    3594/    32B0 :                     
    3595/    32B0 :                     
    3596/    32B0 :                     ;************************************************************************************
    3597/    32B0 :                     ;
    3598/    32B0 :                     ; convert d0 to signed longword in FAC1
    3599/    32B0 :                     
    3600/    32B0 :                     LAB_AYFC
    3601/    32B0 : 177C 0000 05B5      	MOVE.b	#$00,Dtypef(a3)			; clear data type, $80=string, $40=integer,
    3602/    32B6 :                     								; $00=float
    3603/    32B6 : 377C A000 0594      	MOVE.w	#$A000,FAC1_e(a3)			; set FAC1 exponent and clear sign (b7)
    3604/    32BC : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; save FAC1 mantissa
    3605/    32C0 : 6A00 0640           	BPL		LAB_24D0				; convert if +ve
    3606/    32C4 :                     
    3607/    32C4 : 003C 0001           	ORI.b		#1,CCR				; else set carry
    3608/    32C8 : 6000 0638           	BRA		LAB_24D0				; do +/- (carry is sign) & normalise FAC1
    3609/    32CC :                     
    3610/    32CC :                     
    3611/    32CC :                     ;************************************************************************************
    3612/    32CC :                     ;
    3613/    32CC :                     ; remember if the line length is zero (infinite line) then POS(n) will return
    3614/    32CC :                     ; position MOD tabsize
    3615/    32CC :                     
    3616/    32CC :                     ; perform POS()
    3617/    32CC :                     
    3618/    32CC :                     LAB_POS
    3619/    32CC : 102B 05E5           	MOVE.b	TPos(a3),d0				; get terminal position
    3620/    32D0 :                     
    3621/    32D0 :                     ; convert d0 to unsigned byte in FAC1
    3622/    32D0 :                     
    3623/    32D0 :                     LAB_1FD0
    3624/    32D0 : C0BC 0000 00FF      	AND.l		#$FF,d0				; clear high bits
    3625/    32D6 : 60D8                	BRA.s		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 65 - 11/4/2023 8:40:20


    3626/    32D8 :                     
    3627/    32D8 :                     ; check not direct (used by DEF and INPUT)
    3628/    32D8 :                     
    3629/    32D8 :                     LAB_CKRN
    3630/    32D8 : 4A2B 0452           	TST.b		Clinel(a3)				; test current line #
    3631/    32DC : 6B00 EE62           	BMI		LAB_IDER				; if -ve go do illegal direct error then warm
    3632/    32E0 :                     								; start
    3633/    32E0 :                     
    3634/    32E0 : 4E75                	RTS							; can continue so return
    3635/    32E2 :                     
    3636/    32E2 :                     
    3637/    32E2 :                     ;************************************************************************************
    3638/    32E2 :                     ;
    3639/    32E2 :                     ; perform DEF
    3640/    32E2 :                     
    3641/    32E2 :                     LAB_DEF
    3642/    32E2 : 70AB                	MOVEQ		#TK_FN-$100,d0			; get FN token
    3643/    32E4 : 6100 FAC0           	BSR		LAB_SCCA				; scan for CHR$(d0), else syntax error and
    3644/    32E8 :                     								; warm start
    3645/    32E8 :                     								; return character after d0
    3646/    32E8 : 177C 0080 05DF      	MOVE.b	#$80,Sufnxf(a3)			; set FN flag bit
    3647/    32EE : 6100 FCDA           	BSR		LAB_1D12				; get FN name
    3648/    32F2 : 2748 05B0           	MOVE.l	a0,func_l(a3)			; save function pointer
    3649/    32F6 :                     
    3650/    32F6 : 61E0                	BSR.s		LAB_CKRN				; check not direct (back here if ok)
    3651/    32F8 : 0C1D 0028           	CMP.b		#$28,(a5)+				; check next byte is "(" and increment
    3652/    32FC : 6600 EE6A           	BNE		LAB_SNER				; else do syntax error/warm start
    3653/    3300 :                     
    3654/    3300 : 177C 007E 05DF      	MOVE.b	#$7E,Sufnxf(a3)			; set FN variable flag bits
    3655/    3306 : 6100 FCB4           	BSR		LAB_SVAR				; search for or create a variable
    3656/    330A :                     								; return the variable address in a0
    3657/    330A : 6100 FA90           	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
    3658/    330E : 70BD                	MOVEQ		#TK_EQUAL-$100,d0			; = token
    3659/    3310 : 6100 FA94           	BSR		LAB_SCCA				; scan for CHR$(A), else syntax error/warm start
    3660/    3314 :                     								; return character after d0
    3661/    3314 : 2F2B 046A           	MOVE.l	Varname(a3),-(sp)			; push current variable name
    3662/    3318 : 2F0D                	MOVE.l	a5,-(sp)				; push BASIC execute pointer
    3663/    331A : 6100 F412           	BSR		LAB_DATA				; go perform DATA, find end of DEF FN statement
    3664/    331E : 206B 05B0           	MOVEA.l	func_l(a3),a0			; get the function pointer
    3665/    3322 : 209F                	MOVE.l	(sp)+,(a0)				; save BASIC execute pointer to function
    3666/    3324 : 215F 0004           	MOVE.l	(sp)+,4(a0)				; save current variable name to function
    3667/    3328 : 4E75                	RTS
    3668/    332A :                     
    3669/    332A :                     
    3670/    332A :                     ;************************************************************************************
    3671/    332A :                     ;
    3672/    332A :                     ; evaluate FNx
    3673/    332A :                     
    3674/    332A :                     LAB_201E
    3675/    332A : 177C 0081 05DF      	MOVE.b	#$81,Sufnxf(a3)			; set FN flag (find not create)
    3676/    3330 : 6100 FA7C           	BSR		LAB_IGBY				; increment & scan memory
    3677/    3334 : 6100 FC94           	BSR		LAB_1D12				; get FN name
    3678/    3338 : 1F2B 05B5           	MOVE.b	Dtypef(a3),-(sp)			; push data type flag (function type)
    3679/    333C : 2F08                	MOVE.l	a0,-(sp)				; push function pointer
    3680/    333E : 0C15 0028           	CMP.b		#$28,(a5)				; check next byte is "(", no increment
    3681/    3342 : 6600 EE24           	BNE		LAB_SNER				; else do syntax error/warm start
    3682/    3346 :                     
    3683/    3346 : 6100 FA50           	BSR		LAB_1BF7				; evaluate expression within parentheses
    3684/    334A : 205F                	MOVEA.l	(sp)+,a0				; pop function pointer
    3685/    334C : 2748 05B0           	MOVE.l	a0,func_l(a3)			; set function pointer
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 66 - 11/4/2023 8:40:20


    3686/    3350 : 1F2B 05B5           	MOVE.b	Dtypef(a3),-(sp)			; push data type flag (function expression type)
    3687/    3354 :                     
    3688/    3354 : 2028 0004           	MOVE.l	4(a0),d0				; get function variable name
    3689/    3358 : 6100 FCDA           	BSR		LAB_1D4A				; go find function variable (already created)
    3690/    335C :                     
    3691/    335C :                     								; now check type match for variable
    3692/    335C : 101F                	MOVE.b	(sp)+,d0				; pop data type flag (function expression type)
    3693/    335E : E318                	ROL.b		#1,d0					; set carry if type = string
    3694/    3360 : 6100 F8D8           	BSR		LAB_CKTM				; type match check, set C for string
    3695/    3364 :                     
    3696/    3364 :                     								; now stack the function variable value before
    3697/    3364 :                     								; use
    3698/    3364 : 6712                	BEQ.s		LAB_2043				; branch if not string
    3699/    3366 :                     
    3700/    3366 : 43EB 0476           	LEA		des_sk_e(a3),a1			; get string stack pointer max+1
    3701/    336A : B9C9                	CMPA.l	a1,a4					; compare string stack pointer with max+1
    3702/    336C : 6700 EDC6           	BEQ		LAB_SCER				; if no space on the stack go do string too
    3703/    3370 :                     								; complex error
    3704/    3370 :                     
    3705/    3370 : 3928 0004           	MOVE.w	4(a0),-(a4)				; string length on descriptor stack
    3706/    3374 : 2910                	MOVE.l	(a0),-(a4)				; string address on stack
    3707/    3376 : 6002                	BRA.s		LAB_204S				; skip var push
    3708/    3378 :                     
    3709/    3378 :                     LAB_2043
    3710/    3378 : 2F10                	MOVE.l	(a0),-(sp)				; push variable
    3711/    337A :                     LAB_204S
    3712/    337A : 2F08                	MOVE.l	a0,-(sp)				; push variable address
    3713/    337C : 1F2B 05B5           	MOVE.b	Dtypef(a3),-(sp)			; push variable data type
    3714/    3380 :                     
    3715/    3380 : 6132                	BSR.s		LAB_2045				; pack function expression value into (a0)
    3716/    3382 :                     								; (function variable)
    3717/    3382 : 2F0D                	MOVE.l	a5,-(sp)				; push BASIC execute pointer
    3718/    3384 : 206B 05B0           	MOVEA.l	func_l(a3),a0			; get function pointer
    3719/    3388 : 2A50                	MOVEA.l	(a0),a5				; save function execute ptr as BASIC execute ptr
    3720/    338A : 6100 F8C2           	BSR		LAB_EVEX				; evaluate expression
    3721/    338E : 6100 FA20           	BSR		LAB_GBYT				; scan memory
    3722/    3392 : 6600 EDD4           	BNE		LAB_SNER				; if not [EOL] or [EOS] do syntax error and
    3723/    3396 :                     								; warm start
    3724/    3396 :                     
    3725/    3396 : 2A5F                	MOVE.l	(sp)+,a5				; restore BASIC execute pointer
    3726/    3398 :                     
    3727/    3398 :                     ; restore variable from stack and test data type
    3728/    3398 :                     
    3729/    3398 : 101F                	MOVE.b	(sp)+,d0				; pull variable data type
    3730/    339A : 205F                	MOVEA.l	(sp)+,a0				; pull variable address
    3731/    339C : 4A00                	TST.b		d0					; test variable data type
    3732/    339E : 6A08                	BPL.s		LAB_204T				; branch if not string
    3733/    33A0 :                     
    3734/    33A0 : 209C                	MOVE.l	(a4)+,(a0)				; string address from descriptor stack
    3735/    33A2 : 315C 0004           	MOVE.w	(a4)+,4(a0)				; string length from descriptor stack
    3736/    33A6 : 6002                	BRA.s		LAB_2044				; skip variable pull
    3737/    33A8 :                     
    3738/    33A8 :                     LAB_204T
    3739/    33A8 : 209F                	MOVE.l	(sp)+,(a0)				; restore variable from stack
    3740/    33AA :                     LAB_2044
    3741/    33AA : 101F                	MOVE.b	(sp)+,d0				; pop data type flag (function type)
    3742/    33AC : E318                	ROL.b		#1,d0					; set carry if type = string
    3743/    33AE : 6100 F88A           	BSR		LAB_CKTM				; type match check, set C for string
    3744/    33B2 : 4E75                	RTS
    3745/    33B4 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 67 - 11/4/2023 8:40:20


    3746/    33B4 :                     LAB_2045
    3747/    33B4 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type
    3748/    33B8 : 6A00 07F0           	BPL		LAB_2778				; if numeric pack FAC1 into variable (a0)
    3749/    33BC :                     								; and return
    3750/    33BC :                     
    3751/    33BC : 2448                	MOVEA.l	a0,a2					; copy variable pointer
    3752/    33BE : 6000 F512           	BRA		LAB_17D6				; go do string LET & return
    3753/    33C2 :                     
    3754/    33C2 :                     
    3755/    33C2 :                     
    3756/    33C2 :                     ;************************************************************************************
    3757/    33C2 :                     ;
    3758/    33C2 :                     ; perform STR$()
    3759/    33C2 :                     
    3760/    33C2 :                     LAB_STRS
    3761/    33C2 : 6100 0950           	BSR		LAB_2970				; convert FAC1 to string
    3762/    33C6 :                     
    3763/    33C6 :                     ; scan, set up string
    3764/    33C6 :                     ; print " terminated string to FAC1 stack
    3765/    33C6 :                     
    3766/    33C6 :                     LAB_20AE
    3767/    33C6 : 7422                	MOVEQ		#$22,d2				; set Srchc character (terminator 1)
    3768/    33C8 : 3602                	MOVE.w	d2,d3					; set Asrch character (terminator 2)
    3769/    33CA :                     
    3770/    33CA :                     ; print d2/d3 terminated string to FAC1 stack
    3771/    33CA :                     ; d2 = Srchc, d3 = Asrch, a0 is source
    3772/    33CA :                     ; a6 is temp
    3773/    33CA :                     
    3774/    33CA :                     LAB_20B4
    3775/    33CA : 7200                	MOVEQ		#0,d1					; clear longword
    3776/    33CC : 5341                	SUBQ.w	#1,d1					; set length to -1
    3777/    33CE : 2448                	MOVEA.l	a0,a2					; copy start to calculate end
    3778/    33D0 :                     LAB_20BE
    3779/    33D0 : 5241                	ADDQ.w	#1,d1					; increment length
    3780/    33D2 : 1030 1000           	MOVE.b	(a0,d1.w),d0			; get byte from string
    3781/    33D6 : 6710                	BEQ.s		LAB_20D0				; exit loop if null byte [EOS]
    3782/    33D8 :                     
    3783/    33D8 : B002                	CMP.b		d2,d0					; compare with search character (terminator 1)
    3784/    33DA : 6704                	BEQ.s		LAB_20CB				; branch if terminator
    3785/    33DC :                     
    3786/    33DC : B003                	CMP.b		d3,d0					; compare with terminator 2
    3787/    33DE : 66F0                	BNE.s		LAB_20BE				; loop if not terminator 2 (or null string)
    3788/    33E0 :                     
    3789/    33E0 :                     LAB_20CB
    3790/    33E0 : B03C 0022           	CMP.b		#$22,d0				; compare with "
    3791/    33E4 : 6602                	BNE.s		LAB_20D0				; branch if not "
    3792/    33E6 :                     
    3793/    33E6 : 524A                	ADDQ.w	#1,a2					; else increment string start (skip " at end)
    3794/    33E8 :                     LAB_20D0
    3795/    33E8 : D5C1                	ADDA.l	d1,a2					; add longowrd length to make string end+1
    3796/    33EA :                     
    3797/    33EA : B1CB                	CMPA.l	a3,a0					; is string in ram
    3798/    33EC : 651E                	BCS.s		LAB_RTST				; if not go push descriptor on stack & exit
    3799/    33EE :                     								; (could be message string from ROM)
    3800/    33EE :                     
    3801/    33EE : B1EB 042E           	CMPA.l	Smeml(a3),a0			; is string in utility ram
    3802/    33F2 : 6418                	BCC.s		LAB_RTST				; if not go push descriptor on stack & exit
    3803/    33F4 :                     								; (is in string or program space)
    3804/    33F4 :                     
    3805/    33F4 :                     								; (else) copy string to string memory
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 68 - 11/4/2023 8:40:20


    3806/    33F4 :                     LAB_20C9
    3807/    33F4 : 2248                	MOVEA.l	a0,a1					; copy descriptor pointer
    3808/    33F6 : 2001                	MOVE.l	d1,d0					; copy longword length
    3809/    33F8 : 6604                	BNE.s		LAB_20D8				; branch if not null string
    3810/    33FA :                     
    3811/    33FA : 2041                	MOVEA.l	d1,a0					; make null pointer
    3812/    33FC : 600E                	BRA.s		LAB_RTST				; go push descriptor on stack & exit
    3813/    33FE :                     
    3814/    33FE :                     LAB_20D8
    3815/    33FE : 6126                	BSR.s		LAB_2115				; make string space d1 bytes long
    3816/    3400 : D1C1                	ADDA.l	d1,a0					; new string end
    3817/    3402 : D3C1                	ADDA.l	d1,a1					; old string end
    3818/    3404 : 5340                	SUBQ.w	#1,d0					; -1 for DBF loop
    3819/    3406 :                     LAB_20E0
    3820/    3406 : 1121                	MOVE.b	-(a1),-(a0)				; copy byte (source can be odd aligned)
    3821/    3408 : 51C8 FFFC           	DBF		d0,LAB_20E0				; loop until done
    3822/    340C :                     
    3823/    340C :                     
    3824/    340C :                     
    3825/    340C :                     ;************************************************************************************
    3826/    340C :                     ;
    3827/    340C :                     ; check for space on descriptor stack then ...
    3828/    340C :                     ; put string address and length on descriptor stack & update stack pointers
    3829/    340C :                     ; start is in a0, length is in d1
    3830/    340C :                     
    3831/    340C :                     LAB_RTST
    3832/    340C : 43EB 0476           	LEA		des_sk_e(a3),a1			; get string stack pointer max+1
    3833/    3410 : B9C9                	CMPA.l	a1,a4					; compare string stack pointer with max+1
    3834/    3412 : 6700 ED20           	BEQ		LAB_SCER				; if no space on string stack ..
    3835/    3416 :                     								; .. go do 'string too complex' error
    3836/    3416 :                     
    3837/    3416 :                     								; push string & update pointers
    3838/    3416 : 3901                	MOVE.w	d1,-(a4)				; string length on descriptor stack
    3839/    3418 : 2908                	MOVE.l	a0,-(a4)				; string address on stack
    3840/    341A : 274C 0590           	MOVE.l	a4,FAC1_m(a3)			; string descriptor pointer in FAC1
    3841/    341E : 177C 0080 05B5      	MOVE.b	#$80,Dtypef(a3)			; save data type flag, $80=string
    3842/    3424 : 4E75                	RTS
    3843/    3426 :                     
    3844/    3426 :                     
    3845/    3426 :                     ;************************************************************************************
    3846/    3426 :                     ;
    3847/    3426 :                     ; build descriptor a0/d1
    3848/    3426 :                     ; make space in string memory for string d1.w long
    3849/    3426 :                     ; return pointer in a0/Sutill
    3850/    3426 :                     
    3851/    3426 :                     LAB_2115
    3852/    3426 : 4A41                	TST.w		d1					; test length
    3853/    3428 : 672E                	BEQ.s		LAB_2128				; branch if user wants null string
    3854/    342A :                     
    3855/    342A :                     								; make space for string d1 long
    3856/    342A : 2F00                	MOVE.l	d0,-(sp)				; save d0
    3857/    342C : 7000                	MOVEQ		#0,d0					; clear longword
    3858/    342E : 1740 05DE           	MOVE.b	d0,Gclctd(a3)			; clear garbage collected flag (b7)
    3859/    3432 : 7001                	MOVEQ		#1,d0					; +1 to possibly round up
    3860/    3434 : C041                	AND.w		d1,d0					; mask odd bit
    3861/    3436 : D041                	ADD.w		d1,d0					; ensure d0 is even length
    3862/    3438 : 6404                	BCC.s		LAB_2117				; branch if no overflow
    3863/    343A :                     
    3864/    343A : 7001                	MOVEQ		#1,d0					; set to allocate 65536 bytes
    3865/    343C : 4840                	SWAP		d0					; makes $00010000
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 69 - 11/4/2023 8:40:20


    3866/    343E :                     LAB_2117
    3867/    343E : 206B 0446           	MOVEA.l	Sstorl(a3),a0			; get bottom of string space
    3868/    3442 : 91C0                	SUBA.l	d0,a0					; subtract string length
    3869/    3444 : B1EB 0442           	CMPA.l	Earryl(a3),a0			; compare with top of array space
    3870/    3448 : 6512                	BCS.s		LAB_2137				; if less do out of memory error
    3871/    344A :                     
    3872/    344A : 2748 0446           	MOVE.l	a0,Sstorl(a3)			; save bottom of string space
    3873/    344E : 2748 044E           	MOVE.l	a0,Sutill(a3)			; save string utility pointer
    3874/    3452 : 201F                	MOVE.l	(sp)+,d0				; restore d0
    3875/    3454 : 4A41                	TST.w		d1					; set flags on length
    3876/    3456 : 4E75                	RTS
    3877/    3458 :                     
    3878/    3458 :                     LAB_2128
    3879/    3458 : 3041                	MOVEA.w	d1,a0					; make null pointer
    3880/    345A : 4E75                	RTS
    3881/    345C :                     
    3882/    345C :                     LAB_2137
    3883/    345C : 4A2B 05DE           	TST.b		Gclctd(a3)				; get garbage collected flag
    3884/    3460 : 6B00 ECF2           	BMI		LAB_OMER				; do "Out of memory" error, then warm start
    3885/    3464 :                     
    3886/    3464 : 2F09                	MOVE.l	a1,-(sp)				; save a1
    3887/    3466 : 610A                	BSR.s		LAB_GARB				; else go do garbage collection
    3888/    3468 : 225F                	MOVEA.l	(sp)+,a1				; restore a1
    3889/    346A : 177C 0080 05DE      	MOVE.b	#$80,Gclctd(a3)			; set garbage collected flag
    3890/    3470 : 60CC                	BRA.s		LAB_2117				; go try again
    3891/    3472 :                     
    3892/    3472 :                     
    3893/    3472 :                     ;************************************************************************************
    3894/    3472 :                     ;
    3895/    3472 :                     ; garbage collection routine
    3896/    3472 :                     
    3897/    3472 :                     LAB_GARB
    3898/    3472 : 48E7 E0E0           	MOVEM.l	d0-d2/a0-a2,-(sp)			; save registers
    3899/    3476 : 276B 044A 0446      	MOVE.l	Ememl(a3),Sstorl(a3)		; start with no strings
    3900/    347C :                     
    3901/    347C :                     								; re-run routine from last ending
    3902/    347C :                     LAB_214B
    3903/    347C : 222B 0442           	MOVE.l	Earryl(a3),d1			; set highest uncollected string so far
    3904/    3480 : 7000                	MOVEQ		#0,d0					; clear longword
    3905/    3482 : 2240                	MOVEA.l	d0,a1					; clear string to move pointer
    3906/    3484 : 206B 043A           	MOVEA.l	Sstrl(a3),a0			; set pointer to start of strings
    3907/    3488 : 41E8 0004           	LEA		4(a0),a0				; index to string pointer
    3908/    348C : 246B 043E           	MOVEA.l	Sarryl(a3),a2			; set end pointer to start of arrays (end of
    3909/    3490 :                     								; strings)
    3910/    3490 : 6008                	BRA.s		LAB_2176				; branch into loop at end loop test
    3911/    3492 :                     
    3912/    3492 :                     LAB_2161
    3913/    3492 : 6100 0084           	BSR		LAB_2206				; test and set if this is the highest string
    3914/    3496 : 41E8 000A           	LEA		10(a0),a0				; increment to next string
    3915/    349A :                     LAB_2176
    3916/    349A : B1CA                	CMPA.l	a2,a0					; compare end of area with pointer
    3917/    349C : 65F4                	BCS.s		LAB_2161				; go do next if not at end
    3918/    349E :                     
    3919/    349E :                     ; done strings, now do arrays.
    3920/    349E :                     
    3921/    349E : 41E8 FFFC           	LEA		-4(a0),a0				; decrement pointer to start of arrays
    3922/    34A2 : 246B 0442           	MOVEA.l	Earryl(a3),a2			; set end pointer to end of arrays
    3923/    34A6 : 6024                	BRA.s		LAB_218F				; branch into loop at end loop test
    3924/    34A8 :                     
    3925/    34A8 :                     LAB_217E
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 70 - 11/4/2023 8:40:20


    3926/    34A8 : 2428 0004           	MOVE.l	4(a0),d2				; get array size
    3927/    34AC : D488                	ADD.l		a0,d2					; makes start of next array
    3928/    34AE :                     
    3929/    34AE : 2010                	MOVE.l	(a0),d0				; get array name
    3930/    34B0 : 0800 0017           	BTST		#23,d0				; test string flag
    3931/    34B4 : 6714                	BEQ.s		LAB_218B				; branch if not string
    3932/    34B6 :                     
    3933/    34B6 : 3028 0008           	MOVE.w	8(a0),d0				; get # of dimensions
    3934/    34BA : D040                	ADD.w		d0,d0					; *2
    3935/    34BC : D0C0                	ADDA.w	d0,a0					; add to skip dimension size(s)
    3936/    34BE : 41E8 000A           	LEA		10(a0),a0				; increment to first element
    3937/    34C2 :                     LAB_2183
    3938/    34C2 : 6154                	BSR.s		LAB_2206				; test and set if this is the highest string
    3939/    34C4 : 5C48                	ADDQ.w	#6,a0					; increment to next element
    3940/    34C6 : B1C2                	CMPA.l	d2,a0					; compare with start of next array
    3941/    34C8 : 66F8                	BNE.s		LAB_2183				; go do next if not at end of array
    3942/    34CA :                     
    3943/    34CA :                     LAB_218B
    3944/    34CA : 2042                	MOVEA.l	d2,a0					; pointer to next array
    3945/    34CC :                     LAB_218F
    3946/    34CC : B5C8                	CMPA.l	a0,a2					; compare pointer with array end
    3947/    34CE : 66D8                	BNE.s		LAB_217E				; go do next if not at end
    3948/    34D0 :                     
    3949/    34D0 :                     ; done arrays and variables, now just the descriptor stack to do
    3950/    34D0 :                     
    3951/    34D0 : 204C                	MOVEA.l	a4,a0					; get descriptor stack pointer
    3952/    34D2 : 45EB 048E           	LEA		des_sk(a3),a2			; set end pointer to end of stack
    3953/    34D6 : 6006                	BRA.s		LAB_21C4				; branch into loop at end loop test
    3954/    34D8 :                     
    3955/    34D8 :                     LAB_21C2
    3956/    34D8 : 613E                	BSR.s		LAB_2206				; test and set if this is the highest string
    3957/    34DA : 41E8 0006           	LEA		6(a0),a0				; increment to next string
    3958/    34DE :                     LAB_21C4
    3959/    34DE : B5C8                	CMPA.l	a0,a2					; compare pointer with stack end
    3960/    34E0 : 66F6                	BNE.s		LAB_21C2				; go do next if not at end
    3961/    34E2 :                     
    3962/    34E2 :                     ; descriptor search complete, now either exit or set-up and move string
    3963/    34E2 :                     
    3964/    34E2 : 2009                	MOVE.l	a1,d0					; set the flags (a1 is move string)
    3965/    34E4 : 672C                	BEQ.s		LAB_21D1				; go tidy up and exit if no move
    3966/    34E6 :                     
    3967/    34E6 : 2051                	MOVEA.l	(a1),a0				; a0 is now string start
    3968/    34E8 : 7200                	MOVEQ		#0,d1					; clear d1
    3969/    34EA : 3229 0004           	MOVE.w	4(a1),d1				; d1 is string length
    3970/    34EE : 5281                	ADDQ.l	#1,d1					; +1
    3971/    34F0 : C23C 00FE           	AND.b		#$FE,d1				; make even length
    3972/    34F4 : D1C1                	ADDA.l	d1,a0					; pointer is now to string end+1
    3973/    34F6 : 246B 0446           	MOVEA.l	Sstorl(a3),a2			; is destination end+1
    3974/    34FA : B1CA                	CMPA.l	a2,a0					; does the string need moving
    3975/    34FC : 670C                	BEQ.s		LAB_2240				; branch if not
    3976/    34FE :                     
    3977/    34FE : E289                	LSR.l		#1,d1					; word move so do /2
    3978/    3500 : 5341                	SUBQ.w	#1,d1					; -1 for DBF loop
    3979/    3502 :                     LAB_2216
    3980/    3502 : 3520                	MOVE.w	-(a0),-(a2)				; copy word
    3981/    3504 : 51C9 FFFC           	DBF		d1,LAB_2216				; loop until done
    3982/    3508 :                     
    3983/    3508 : 228A                	MOVE.l	a2,(a1)				; save new string start
    3984/    350A :                     LAB_2240
    3985/    350A : 2751 0446           	MOVE.l	(a1),Sstorl(a3)			; string start is new string mem start
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 71 - 11/4/2023 8:40:20


    3986/    350E : 6000 FF6C           	BRA		LAB_214B				; re-run routine from last ending
    3987/    3512 :                     								; (but don't collect this string)
    3988/    3512 :                     
    3989/    3512 :                     LAB_21D1
    3990/    3512 : 4CDF 0707           	MOVEM.l	(sp)+,d0-d2/a0-a2			; restore registers
    3991/    3516 : 4E75                	RTS
    3992/    3518 :                     
    3993/    3518 :                     ; test and set if this is the highest string
    3994/    3518 :                     
    3995/    3518 :                     LAB_2206
    3996/    3518 : 2010                	MOVE.l	(a0),d0				; get this string pointer
    3997/    351A : 6728                	BEQ.s		RTS_012				; exit if null string
    3998/    351C :                     
    3999/    351C : B280                	CMP.l		d0,d1					; compare with highest uncollected string so far
    4000/    351E : 6424                	BCC.s		RTS_012				; exit if <= with highest so far
    4001/    3520 :                     
    4002/    3520 : B0AB 0446           	CMP.l		Sstorl(a3),d0			; compare with bottom of string space
    4003/    3524 : 641E                	BCC.s		RTS_012				; exit if >= bottom of string space
    4004/    3526 :                     
    4005/    3526 : 70FF                	MOVEQ		#-1,d0				; d0 = $FFFFFFFF
    4006/    3528 : 3028 0004           	MOVE.w	4(a0),d0				; d0 is string length
    4007/    352C : 4440                	NEG.w		d0					; make -ve
    4008/    352E : C03C 00FE           	AND.b		#$FE,d0				; make -ve even length
    4009/    3532 : D0AB 0446           	ADD.l		Sstorl(a3),d0			; add string store to -ve length
    4010/    3536 : B090                	CMP.l		(a0),d0				; compare with string address
    4011/    3538 : 6706                	BEQ.s		LAB_2212				; if = go move string store pointer down
    4012/    353A :                     
    4013/    353A : 2210                	MOVE.l	(a0),d1				; highest = current
    4014/    353C : 2248                	MOVEA.l	a0,a1					; string to move = current
    4015/    353E : 4E75                	RTS
    4016/    3540 :                     
    4017/    3540 :                     LAB_2212
    4018/    3540 : 2740 0446           	MOVE.l	d0,Sstorl(a3)			; set new string store start
    4019/    3544 :                     RTS_012
    4020/    3544 : 4E75                	RTS
    4021/    3546 :                     
    4022/    3546 :                     
    4023/    3546 :                     ;************************************************************************************
    4024/    3546 :                     ;
    4025/    3546 :                     ; concatenate - add strings
    4026/    3546 :                     ; string descriptor 1 is in FAC1_m, string 2 is in line
    4027/    3546 :                     
    4028/    3546 :                     LAB_224D
    4029/    3546 : 487A F738           	PEA		LAB_1ADB(pc)			; continue evaluation after concatenate
    4030/    354A : 2F2B 0590           	MOVE.l	FAC1_m(a3),-(sp)			; stack descriptor pointer for string 1
    4031/    354E :                     
    4032/    354E : 6100 F80C           	BSR		LAB_GVAL				; get value from line
    4033/    3552 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type flag
    4034/    3556 : 6A00 EBE4           	BPL		LAB_TMER				; if type is not string do type mismatch error
    4035/    355A :                     
    4036/    355A : 205F                	MOVEA.l	(sp)+,a0				; restore descriptor pointer for string 1
    4037/    355C :                     
    4038/    355C :                     ;************************************************************************************
    4039/    355C :                     ;
    4040/    355C :                     ; concatenate
    4041/    355C :                     ; string descriptor 1 is in a0, string descriptor 2 is in FAC1_m
    4042/    355C :                     
    4043/    355C :                     LAB_224E
    4044/    355C : 226B 0590           	MOVEA.l	FAC1_m(a3),a1			; copy descriptor pointer 2
    4045/    3560 : 3228 0004           	MOVE.w	4(a0),d1				; get length 1
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 72 - 11/4/2023 8:40:20


    4046/    3564 : D269 0004           	ADD.w		4(a1),d1				; add length 2
    4047/    3568 : 6500 EBCE           	BCS		LAB_SLER				; if overflow go do 'string too long' error
    4048/    356C :                     
    4049/    356C : 2F08                	MOVE.l	a0,-(sp)				; save descriptor pointer 1
    4050/    356E : 6100 FEB6           	BSR		LAB_2115				; make space d1 bytes long
    4051/    3572 : 2748 0598           	MOVE.l	a0,FAC2_m(a3)			; save new string start pointer
    4052/    3576 : 2057                	MOVEA.l	(sp),a0				; copy descriptor pointer 1 from stack
    4053/    3578 : 3028 0004           	MOVE.w	4(a0),d0				; get length
    4054/    357C : 2050                	MOVEA.l	(a0),a0				; get string pointer
    4055/    357E : 6120                	BSR.s		LAB_229E				; copy string d0 bytes long from a0 to Sutill
    4056/    3580 :                     								; return with a0 = pointer, d1 = length
    4057/    3580 :                     
    4058/    3580 : 206B 0590           	MOVEA.l	FAC1_m(a3),a0			; get descriptor pointer for string 2
    4059/    3584 : 6138                	BSR.s		LAB_22BA				; pop (a0) descriptor, returns with ..
    4060/    3586 :                     								; a0 = pointer, d0 = length
    4061/    3586 : 6118                	BSR.s		LAB_229E				; copy string d0 bytes long from a0 to Sutill
    4062/    3588 :                     								; return with a0 = pointer, d1 = length
    4063/    3588 :                     
    4064/    3588 : 205F                	MOVEA.l	(sp)+,a0				; get descriptor pointer for string 1
    4065/    358A : 6132                	BSR.s		LAB_22BA				; pop (a0) descriptor, returns with ..
    4066/    358C :                     								; d0 = length, a0 = pointer
    4067/    358C :                     
    4068/    358C : 206B 0598           	MOVEA.l	FAC2_m(a3),a0			; retreive the result string pointer
    4069/    3590 : 2208                	MOVE.l	a0,d1					; copy the result string pointer
    4070/    3592 : 6700 FE78           	BEQ		LAB_RTST				; if it is a null string just return it
    4071/    3596 :                     								; a0 = pointer, d1 = length
    4072/    3596 :                     
    4073/    3596 : 4481                	NEG.l		d1					; else make the start pointer negative
    4074/    3598 : D2AB 044E           	ADD.l		Sutill(a3),d1			; add the end pointert to give the length
    4075/    359C : 6000 FE6E           	BRA		LAB_RTST				; push string on descriptor stack
    4076/    35A0 :                     								; a0 = pointer, d1 = length
    4077/    35A0 :                     
    4078/    35A0 :                     
    4079/    35A0 :                     ;************************************************************************************
    4080/    35A0 :                     ;
    4081/    35A0 :                     ; copy string d0 bytes long from a0 to Sutill
    4082/    35A0 :                     ; return with a0 = pointer, d1 = length
    4083/    35A0 :                     
    4084/    35A0 :                     LAB_229E
    4085/    35A0 : 3200                	MOVE.w	d0,d1					; copy and check length
    4086/    35A2 : 6714                	BEQ.s		RTS_013				; skip copy if null
    4087/    35A4 :                     
    4088/    35A4 : 226B 044E           	MOVEA.l	Sutill(a3),a1			; get destination pointer
    4089/    35A8 : 2F09                	MOVE.l	a1,-(sp)				; save destination string pointer
    4090/    35AA : 5340                	SUBQ.w	#1,d0					; subtract for DBF loop
    4091/    35AC :                     LAB_22A0
    4092/    35AC : 12D8                	MOVE.b	(a0)+,(a1)+				; copy byte
    4093/    35AE : 51C8 FFFC           	DBF		d0,LAB_22A0				; loop if not done
    4094/    35B2 :                     
    4095/    35B2 : 2749 044E           	MOVE.l	a1,Sutill(a3)			; update Sutill to end of copied string
    4096/    35B6 : 205F                	MOVEA.l	(sp)+,a0				; restore destination string pointer
    4097/    35B8 :                     RTS_013
    4098/    35B8 : 4E75                	RTS
    4099/    35BA :                     
    4100/    35BA :                     
    4101/    35BA :                     ;************************************************************************************
    4102/    35BA :                     ;
    4103/    35BA :                     ; pop string off descriptor stack, or from top of string space
    4104/    35BA :                     ; returns with d0.l = length, a0 = pointer
    4105/    35BA :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 73 - 11/4/2023 8:40:20


    4106/    35BA :                     LAB_22B6
    4107/    35BA : 206B 0590           	MOVEA.l	FAC1_m(a3),a0			; get descriptor pointer
    4108/    35BE :                     
    4109/    35BE :                     
    4110/    35BE :                     ;************************************************************************************
    4111/    35BE :                     ;
    4112/    35BE :                     ; pop (a0) descriptor off stack or from string space
    4113/    35BE :                     ; returns with d0.l = length, a0 = pointer
    4114/    35BE :                     
    4115/    35BE :                     LAB_22BA
    4116/    35BE : 48E7 4040           	MOVEM.l	a1/d1,-(sp)				; save other regs
    4117/    35C2 : B9C8                	CMPA.l	a0,a4					; is string on the descriptor stack
    4118/    35C4 : 6602                	BNE.s		LAB_22BD				; skip pop if not
    4119/    35C6 :                     
    4120/    35C6 : 5C4C                	ADDQ.w	#$06,a4				; else update stack pointer
    4121/    35C8 :                     LAB_22BD
    4122/    35C8 : 7000                	MOVEQ		#0,d0					; clear string length longword
    4123/    35CA : 2258                	MOVEA.l	(a0)+,a1				; get string address
    4124/    35CC : 3018                	MOVE.w	(a0)+,d0				; get string length
    4125/    35CE :                     
    4126/    35CE : B9C8                	CMPA.l	a0,a4					; was it on the descriptor stack
    4127/    35D0 : 6610                	BNE.s		LAB_22E6				; branch if it wasn't
    4128/    35D2 :                     
    4129/    35D2 : B3EB 0446           	CMPA.l	Sstorl(a3),a1			; compare string address with bottom of string
    4130/    35D6 :                     								; space
    4131/    35D6 : 660A                	BNE.s		LAB_22E6				; branch if <>
    4132/    35D8 :                     
    4133/    35D8 : 7201                	MOVEQ		#1,d1					; mask for odd bit
    4134/    35DA : C240                	AND.w		d0,d1					; AND length
    4135/    35DC : D280                	ADD.l		d0,d1					; make it fit word aligned length
    4136/    35DE :                     
    4137/    35DE : D3AB 0446           	ADD.l		d1,Sstorl(a3)			; add to bottom of string space
    4138/    35E2 :                     LAB_22E6
    4139/    35E2 : 2049                	MOVEA.l	a1,a0					; copy to a0
    4140/    35E4 : 4CDF 0202           	MOVEM.l	(sp)+,a1/d1				; restore other regs
    4141/    35E8 : 4A80                	TST.l		d0					; set flags on length
    4142/    35EA : 4E75                	RTS
    4143/    35EC :                     
    4144/    35EC :                     
    4145/    35EC :                     ;************************************************************************************
    4146/    35EC :                     ;
    4147/    35EC :                     ; perform CHR$()
    4148/    35EC :                     
    4149/    35EC :                     LAB_CHRS
    4150/    35EC : 6100 0130           	BSR		LAB_EVBY				; evaluate byte expression, result in d0 and
    4151/    35F0 :                     								; Itemp
    4152/    35F0 :                     LAB_MKCHR
    4153/    35F0 : 7201                	MOVEQ		#1,d1					; string is single byte
    4154/    35F2 : 6100 FE32           	BSR		LAB_2115				; make string space d1 bytes long
    4155/    35F6 :                     								; return a0/Sutill = pointer, others unchanged
    4156/    35F6 : 1080                	MOVE.b	d0,(a0)				; save byte in string (byte IS string!)
    4157/    35F8 : 6000 FE12           	BRA		LAB_RTST				; push string on descriptor stack
    4158/    35FC :                     								; a0 = pointer, d1 = length
    4159/    35FC :                     
    4160/    35FC :                     
    4161/    35FC :                     ;************************************************************************************
    4162/    35FC :                     ;
    4163/    35FC :                     ; perform LEFT$()
    4164/    35FC :                     
    4165/    35FC :                     ; enter with a0 is descriptor, d0 & Itemp is word 1
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 74 - 11/4/2023 8:40:20


    4166/    35FC :                     
    4167/    35FC :                     LAB_LEFT
    4168/    35FC : C141                	EXG		d0,d1					; word in d1
    4169/    35FE : 6100 F79C           	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
    4170/    3602 :                     
    4171/    3602 : 4A81                	TST.l		d1					; test returned length
    4172/    3604 : 6722                	BEQ.s		LAB_231C				; branch if null return
    4173/    3606 :                     
    4174/    3606 : 7000                	MOVEQ		#0,d0					; clear start offset
    4175/    3608 : B268 0004           	CMP.w		4(a0),d1				; compare word parameter with string length
    4176/    360C : 651A                	BCS.s		LAB_231C				; branch if string length > word parameter
    4177/    360E :                     
    4178/    360E : 6014                	BRA.s		LAB_2317				; go copy whole string
    4179/    3610 :                     
    4180/    3610 :                     
    4181/    3610 :                     ;************************************************************************************
    4182/    3610 :                     ;
    4183/    3610 :                     ; perform RIGHT$()
    4184/    3610 :                     
    4185/    3610 :                     ; enter with a0 is descriptor, d0 & Itemp is word 1
    4186/    3610 :                     
    4187/    3610 :                     LAB_RIGHT
    4188/    3610 : C141                	EXG		d0,d1					; word in d1
    4189/    3612 : 6100 F788           	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
    4190/    3616 :                     
    4191/    3616 : 4A81                	TST.l		d1					; test returned length
    4192/    3618 : 670E                	BEQ.s		LAB_231C				; branch if null return
    4193/    361A :                     
    4194/    361A : 3028 0004           	MOVE.w	4(a0),d0				; get string length
    4195/    361E : 9081                	SUB.l		d1,d0					; subtract word
    4196/    3620 : 6406                	BCC.s		LAB_231C				; branch if string length > word parameter
    4197/    3622 :                     
    4198/    3622 :                     								; else copy whole string
    4199/    3622 :                     LAB_2316
    4200/    3622 : 7000                	MOVEQ		#0,d0					; clear start offset
    4201/    3624 :                     LAB_2317
    4202/    3624 : 3228 0004           	MOVE.w	4(a0),d1				; else make parameter = length
    4203/    3628 :                     
    4204/    3628 :                     ; get here with ...
    4205/    3628 :                     ;   a0 - points to descriptor
    4206/    3628 :                     ;   d0 - is offset from string start
    4207/    3628 :                     ;   d1 - is required string length
    4208/    3628 :                     
    4209/    3628 :                     LAB_231C
    4210/    3628 : 2248                	MOVEA.l	a0,a1					; save string descriptor pointer
    4211/    362A : 6100 FDFA           	BSR		LAB_2115				; make string space d1 bytes long
    4212/    362E :                     								; return a0/Sutill = pointer, others unchanged
    4213/    362E : 2049                	MOVEA.l	a1,a0					; restore string descriptor pointer
    4214/    3630 : 2F00                	MOVE.l	d0,-(sp)				; save start offset (longword)
    4215/    3632 : 618A                	BSR.s		LAB_22BA				; pop (a0) descriptor, returns with ..
    4216/    3634 :                     								; d0 = length, a0 = pointer
    4217/    3634 : D1DF                	ADDA.l	(sp)+,a0				; adjust pointer to start of wanted string
    4218/    3636 : 3001                	MOVE.w	d1,d0					; length to d0
    4219/    3638 : 6100 FF66           	BSR		LAB_229E				; store string d0 bytes long from (a0) to
    4220/    363C :                     								; (Sutill) return with a0 = pointer,
    4221/    363C :                     								; d1 = length
    4222/    363C : 6000 FDCE           	BRA		LAB_RTST				; push string on descriptor stack
    4223/    3640 :                     								; a0 = pointer, d1 = length
    4224/    3640 :                     
    4225/    3640 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 75 - 11/4/2023 8:40:20


    4226/    3640 :                     ;************************************************************************************
    4227/    3640 :                     ;
    4228/    3640 :                     ; perform MID$()
    4229/    3640 :                     
    4230/    3640 :                     ; enter with a0 is descriptor, d0 & Itemp is word 1
    4231/    3640 :                     
    4232/    3640 :                     LAB_MIDS
    4233/    3640 : 7E00                	MOVEQ		#0,d7					; clear longword
    4234/    3642 : 5347                	SUBQ.w	#1,d7					; set default length = 65535
    4235/    3644 : 2F00                	MOVE.l	d0,-(sp)				; save word 1
    4236/    3646 : 6100 F768           	BSR		LAB_GBYT				; scan memory
    4237/    364A : B03C 002C           	CMP.b		#',',d0				; was it ","
    4238/    364E : 660C                	BNE.s		LAB_2358				; branch if not "," (skip second byte get)
    4239/    3650 :                     
    4240/    3650 : 101D                	MOVE.b	(a5)+,d0				; increment pointer past ","
    4241/    3652 : 2F08                	MOVE.l	a0,-(sp)				; save descriptor pointer
    4242/    3654 : 6100 00DA           	BSR		LAB_GTWO				; get word parameter, result in d0 and Itemp
    4243/    3658 : 205F                	MOVEA.l	(sp)+,a0				; restore descriptor pointer
    4244/    365A : 2E00                	MOVE.l	d0,d7					; copy length
    4245/    365C :                     LAB_2358
    4246/    365C : 6100 F73E           	BSR		LAB_1BFB				; scan for ")", else do syntax error then warm
    4247/    3660 :                     								; start
    4248/    3660 : 201F                	MOVE.l	(sp)+,d0				; restore word 1
    4249/    3662 : 7200                	MOVEQ		#0,d1					; null length
    4250/    3664 : 5380                	SUBQ.l	#1,d0					; decrement start index (word 1)
    4251/    3666 : 6B00 EAF4           	BMI		LAB_FCER				; if was null do function call error then warm
    4252/    366A :                     								; start
    4253/    366A :                     
    4254/    366A : B068 0004           	CMP.w		4(a0),d0				; compare string length with start index
    4255/    366E : 64B8                	BCC.s		LAB_231C				; if start not in string do null string (d1=0)
    4256/    3670 :                     
    4257/    3670 : 2207                	MOVE.l	d7,d1					; get length back
    4258/    3672 : DE40                	ADD.w		d0,d7					; d7 now = MID$() end
    4259/    3674 : 6506                	BCS.s		LAB_2368				; already too long so do RIGHT$ equivalent
    4260/    3676 :                     
    4261/    3676 : BE68 0004           	CMP.w		4(a0),d7				; compare string length with start index+length
    4262/    367A : 65AC                	BCS.s		LAB_231C				; if end in string go do string
    4263/    367C :                     
    4264/    367C :                     LAB_2368
    4265/    367C : 3228 0004           	MOVE.w	4(a0),d1				; get string length
    4266/    3680 : 9240                	SUB.w		d0,d1					; subtract start offset
    4267/    3682 : 60A4                	BRA.s		LAB_231C				; go do string (effectively RIGHT$)
    4268/    3684 :                     
    4269/    3684 :                     
    4270/    3684 :                     ;************************************************************************************
    4271/    3684 :                     ;
    4272/    3684 :                     ; perform LCASE$()
    4273/    3684 :                     
    4274/    3684 :                     LAB_LCASE
    4275/    3684 : 6100 FF34           	BSR		LAB_22B6				; pop string off descriptor stack or from memory
    4276/    3688 :                     								; returns with d0 = length, a0 = pointer
    4277/    3688 : 2200                	MOVE.l	d0,d1					; copy the string length
    4278/    368A : 6756                	BEQ.s		NoString				; if null go return a null string
    4279/    368C :                     
    4280/    368C :                     ; else copy and change the string
    4281/    368C :                     
    4282/    368C : 2248                	MOVEA.l	a0,a1					; copy the string address
    4283/    368E : 6100 FD96           	BSR		LAB_2115				; make a string space d1 bytes long
    4284/    3692 : D1C1                	ADDA.l	d1,a0					; new string end
    4285/    3694 : D3C1                	ADDA.l	d1,a1					; old string end
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 76 - 11/4/2023 8:40:20


    4286/    3696 : 3401                	MOVE.w	d1,d2					; copy length for loop
    4287/    3698 : 5342                	SUBQ.w	#1,d2					; -1 for DBF loop
    4288/    369A :                     LC_loop
    4289/    369A : 1021                	MOVE.b	-(a1),d0				; get byte from string
    4290/    369C :                     
    4291/    369C : B03C 005B           	CMP.b		#$5B,d0				; compare with "Z"+1
    4292/    36A0 : 640A                	BCC.s		NoUcase				; if > "Z" skip change
    4293/    36A2 :                     
    4294/    36A2 : B03C 0041           	CMP.b		#$41,d0				; compare with "A"
    4295/    36A6 : 6504                	BCS.s		NoUcase				; if < "A" skip change
    4296/    36A8 :                     
    4297/    36A8 : 0000 0020           	ORI.b		#$20,d0				; convert upper case to lower case
    4298/    36AC :                     NoUcase
    4299/    36AC : 1100                	MOVE.b	d0,-(a0)				; copy upper case byte back to string
    4300/    36AE : 51CA FFEA           	DBF		d2,LC_loop				; decrement and loop if not all done
    4301/    36B2 :                     
    4302/    36B2 : 602E                	BRA.s		NoString				; tidy up & exit (branch always)
    4303/    36B4 :                     
    4304/    36B4 :                     
    4305/    36B4 :                     ;************************************************************************************
    4306/    36B4 :                     ;
    4307/    36B4 :                     ; perform UCASE$()
    4308/    36B4 :                     
    4309/    36B4 :                     LAB_UCASE
    4310/    36B4 : 6100 FF04           	BSR		LAB_22B6				; pop string off descriptor stack or from memory
    4311/    36B8 :                     								; returns with d0 = length, a0 = pointer
    4312/    36B8 : 2200                	MOVE.l	d0,d1					; copy the string length
    4313/    36BA : 6726                	BEQ.s		NoString				; if null go return a null string
    4314/    36BC :                     
    4315/    36BC :                     ; else copy and change the string
    4316/    36BC :                     
    4317/    36BC : 2248                	MOVEA.l	a0,a1					; copy the string address
    4318/    36BE : 6100 FD66           	BSR		LAB_2115				; make a string space d1 bytes long
    4319/    36C2 : D1C1                	ADDA.l	d1,a0					; new string end
    4320/    36C4 : D3C1                	ADDA.l	d1,a1					; old string end
    4321/    36C6 : 3401                	MOVE.w	d1,d2					; copy length for loop
    4322/    36C8 : 5342                	SUBQ.w	#1,d2					; -1 for DBF loop
    4323/    36CA :                     UC_loop
    4324/    36CA : 1021                	MOVE.b	-(a1),d0				; get a byte from the string
    4325/    36CC :                     
    4326/    36CC : B03C 0061           	CMP.b		#$61,d0				; compare with "a"
    4327/    36D0 : 650A                	BCS.s		NoLcase				; if < "a" skip change
    4328/    36D2 :                     
    4329/    36D2 : B03C 007B           	CMP.b		#$7B,d0				; compare with "z"+1
    4330/    36D6 : 6404                	BCC.s		NoLcase				; if > "z" skip change
    4331/    36D8 :                     
    4332/    36D8 : 0200 00DF           	ANDI.b	#$DF,d0				; convert lower case to upper case
    4333/    36DC :                     NoLcase
    4334/    36DC : 1100                	MOVE.b	d0,-(a0)				; copy upper case byte back to string
    4335/    36DE : 51CA FFEA           	DBF		d2,UC_loop				; decrement and loop if not all done
    4336/    36E2 :                     
    4337/    36E2 :                     NoString
    4338/    36E2 : 6000 FD28           	BRA		LAB_RTST				; push string on descriptor stack
    4339/    36E6 :                     								; a0 = pointer, d1 = length
    4340/    36E6 :                     
    4341/    36E6 :                     
    4342/    36E6 :                     ;************************************************************************************
    4343/    36E6 :                     ;
    4344/    36E6 :                     ; perform SADD()
    4345/    36E6 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 77 - 11/4/2023 8:40:20


    4346/    36E6 :                     LAB_SADD
    4347/    36E6 : 101D                	MOVE.b	(a5)+,d0				; increment pointer
    4348/    36E8 : 6100 F8D6           	BSR		LAB_GVAR				; get variable address in a0
    4349/    36EC : 6100 F6AE           	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
    4350/    36F0 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type flag
    4351/    36F4 : 6A00 EA46           	BPL		LAB_TMER				; if numeric do Type missmatch Error
    4352/    36F8 : 2010                	MOVE.l	(a0),d0					; get string address
    4353/    36FA : 6000 FBB4           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
    4354/    36FE :                     
    4355/    36FE :                     
    4356/    36FE :                     ;************************************************************************************
    4357/    36FE :                     ;
    4358/    36FE :                     ; perform LEN()
    4359/    36FE :                     
    4360/    36FE :                     LAB_LENS
    4361/    36FE : 487A FBB0           	PEA		LAB_AYFC(pc)			; set return address to convert d0 to signed
    4362/    3702 :                     								; longword in FAC1
    4363/    3702 : 6000 FEB6           	BRA		LAB_22B6				; pop string off descriptor stack or from memory
    4364/    3706 :                     								; returns with d0 = length, a0 = pointer
    4365/    3706 :                     
    4366/    3706 :                     
    4367/    3706 :                     ;************************************************************************************
    4368/    3706 :                     ;
    4369/    3706 :                     ; perform ASC()
    4370/    3706 :                     
    4371/    3706 :                     LAB_ASC
    4372/    3706 : 6100 FEB2           	BSR		LAB_22B6				; pop string off descriptor stack or from memory
    4373/    370A :                     								; returns with d0 = length, a0 = pointer
    4374/    370A : 4A40                	TST.w		d0					; test length
    4375/    370C : 6700 EA4E           	BEQ		LAB_FCER				; if null do function call error then warm start
    4376/    3710 :                     
    4377/    3710 : 1010                	MOVE.b	(a0),d0				; get first character byte
    4378/    3712 : 6000 FBBC           	BRA		LAB_1FD0				; convert d0 to unsigned byte in FAC1 & return
    4379/    3716 :                     
    4380/    3716 :                     
    4381/    3716 :                     ;************************************************************************************
    4382/    3716 :                     ;
    4383/    3716 :                     ; increment and get byte, result in d0 and Itemp
    4384/    3716 :                     
    4385/    3716 :                     LAB_SGBY
    4386/    3716 : 6100 F696           	BSR		LAB_IGBY				; increment & scan memory
    4387/    371A :                     
    4388/    371A :                     
    4389/    371A :                     ;************************************************************************************
    4390/    371A :                     ;
    4391/    371A :                     ; get byte parameter, result in d0 and Itemp
    4392/    371A :                     
    4393/    371A :                     LAB_GTBY
    4394/    371A : 6100 F51A           	BSR		LAB_EVNM				; evaluate expression & check is numeric,
    4395/    371E :                     								; else do type mismatch
    4396/    371E :                     
    4397/    371E :                     
    4398/    371E :                     ;************************************************************************************
    4399/    371E :                     ;
    4400/    371E :                     ; evaluate byte expression, result in d0 and Itemp
    4401/    371E :                     
    4402/    371E :                     LAB_EVBY
    4403/    371E : 6100 F9D4           	BSR		LAB_EVPI				; evaluate positive integer expression
    4404/    3722 :                     								; result in d0 and Itemp
    4405/    3722 : 123C 0080           	MOVE.b		#$80,d1				; set mask/2
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 78 - 11/4/2023 8:40:20


    4406/    3726 : D281                	ADD.l		d1,d1					; =$FFFFFF00
    4407/    3728 : C280                	AND.l		d0,d1					; check top 24 bits
    4408/    372A : 6600 EA30           	BNE		LAB_FCER				; if <> 0 do function call error/warm start
    4409/    372E :                     
    4410/    372E : 4E75                	RTS
    4411/    3730 :                     
    4412/    3730 :                     
    4413/    3730 :                     ;************************************************************************************
    4414/    3730 :                     ;
    4415/    3730 :                     ; get word parameter, result in d0 and Itemp
    4416/    3730 :                     
    4417/    3730 :                     LAB_GTWO
    4418/    3730 : 6100 F504           	BSR		LAB_EVNM				; evaluate expression & check is numeric,
    4419/    3734 :                     								; else do type mismatch
    4420/    3734 : 6100 F9BE           	BSR		LAB_EVPI				; evaluate positive integer expression
    4421/    3738 :                     								; result in d0 and Itemp
    4422/    3738 : 4840                	SWAP		d0					; copy high word to low word
    4423/    373A : 4A40                	TST.w		d0					; set flags
    4424/    373C : 6600 EA1E           	BNE		LAB_FCER				; if <> 0 do function call error/warm start
    4425/    3740 :                     
    4426/    3740 : 4840                	SWAP		d0					; copy high word to low word
    4427/    3742 : 4E75                	RTS
    4428/    3744 :                     
    4429/    3744 :                     
    4430/    3744 :                     ;************************************************************************************
    4431/    3744 :                     ;
    4432/    3744 :                     ; perform VAL()
    4433/    3744 :                     
    4434/    3744 :                     LAB_VAL
    4435/    3744 : 6100 FE74           	BSR		LAB_22B6				; pop string off descriptor stack or from memory
    4436/    3748 :                     								; returns with d0 = length, a0 = pointer
    4437/    3748 : 6722                	BEQ.s		LAB_VALZ				; string was null so set result = $00
    4438/    374A :                     								; clear FAC1 exponent & sign & return
    4439/    374A :                     
    4440/    374A : 2C4D                	MOVEA.l	a5,a6					; save BASIC execute pointer
    4441/    374C : 2A48                	MOVEA.l	a0,a5					; copy string pointer to execute pointer
    4442/    374E : D1C0                	ADDA.l	d0,a0					; string end+1
    4443/    3750 : 1010                	MOVE.b	(a0),d0				; get byte from string+1
    4444/    3752 : 3F00                	MOVE.w	d0,-(sp)				; save it
    4445/    3754 : 2F08                	MOVE.l	a0,-(sp)				; save address
    4446/    3756 : 10BC 0000           	MOVE.b	#0,(a0)				; null terminate string
    4447/    375A : 6100 F654           	BSR		LAB_GBYT				; scan memory
    4448/    375E : 6100 114C           	BSR		LAB_2887				; get FAC1 from string
    4449/    3762 : 205F                	MOVEA.l	(sp)+,a0				; restore pointer
    4450/    3764 : 301F                	MOVE.w	(sp)+,d0				; pop byte
    4451/    3766 : 1080                	MOVE.b	d0,(a0)				; restore to memory
    4452/    3768 : 2A4E                	MOVEA.l	a6,a5					; restore BASIC execute pointer
    4453/    376A : 4E75                	RTS
    4454/    376C :                     
    4455/    376C :                     LAB_VALZ
    4456/    376C : 3740 0594           	MOVE.w	d0,FAC1_e(a3)			; clear FAC1 exponent & sign
    4457/    3770 : 4E75                	RTS
    4458/    3772 :                     
    4459/    3772 :                     
    4460/    3772 :                     ;************************************************************************************
    4461/    3772 :                     ;
    4462/    3772 :                     ; get two parameters for POKE or WAIT, first parameter in a0, second in d0
    4463/    3772 :                     
    4464/    3772 :                     LAB_GADB
    4465/    3772 : 6100 F4C2           	BSR		LAB_EVNM				; evaluate expression & check is numeric,
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 79 - 11/4/2023 8:40:20


    4466/    3776 :                     								; else do type mismatch
    4467/    3776 : 6100 F984           	BSR		LAB_EVIR				; evaluate integer expression
    4468/    377A :                     								; (does FC error not OF error if out of range)
    4469/    377A : 2F00                	MOVE.l	d0,-(sp)				; copy to stack
    4470/    377C : 6100 F626           	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
    4471/    3780 : 6198                	BSR.s		LAB_GTBY				; get byte parameter, result in d0 and Itemp
    4472/    3782 : 205F                	MOVEA.l	(sp)+,a0				; pull address
    4473/    3784 : 4E75                	RTS
    4474/    3786 :                     
    4475/    3786 :                     
    4476/    3786 :                     ;************************************************************************************
    4477/    3786 :                     ;
    4478/    3786 :                     ; get two parameters for DOKE or WAITW, first parameter in a0, second in d0
    4479/    3786 :                     
    4480/    3786 :                     LAB_GADW
    4481/    3786 : 611E                	BSR.s		LAB_GEAD				; get even address for word/long memory actions
    4482/    3788 :                     								; address returned in d0 and on the stack
    4483/    3788 : 6100 F61A           	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
    4484/    378C : 6100 F4A8           	BSR		LAB_EVNM				; evaluate expression & check is numeric,
    4485/    3790 :                     								; else do type mismatch
    4486/    3790 : 6100 F96A           	BSR		LAB_EVIR				; evaluate integer expression
    4487/    3794 :                     								; result in d0 and Itemp
    4488/    3794 : 4840                	SWAP		d0					; swap words
    4489/    3796 : 4A40                	TST.w		d0					; test high word
    4490/    3798 : 6706                	BEQ.s		LAB_XGADW				; exit if null
    4491/    379A :                     
    4492/    379A : 5240                	ADDQ.w	#1,d0					; increment word
    4493/    379C : 6600 E9BE           	BNE		LAB_FCER				; if <> 0 do function call error/warm start
    4494/    37A0 :                     
    4495/    37A0 :                     LAB_XGADW
    4496/    37A0 : 4840                	SWAP		d0					; swap words back
    4497/    37A2 : 205F                	MOVEA.l	(sp)+,a0				; pull address
    4498/    37A4 : 4E75                	RTS
    4499/    37A6 :                     
    4500/    37A6 :                     
    4501/    37A6 :                     ;************************************************************************************
    4502/    37A6 :                     ;
    4503/    37A6 :                     ; get even address (for word or longword memory actions)
    4504/    37A6 :                     ; address returned in d0 and on the stack
    4505/    37A6 :                     ; does address error if the address is odd
    4506/    37A6 :                     
    4507/    37A6 :                     LAB_GEAD
    4508/    37A6 : 6100 F48E           	BSR		LAB_EVNM				; evaluate expression & check is numeric,
    4509/    37AA :                     								; else do type mismatch
    4510/    37AA : 6100 F950           	BSR		LAB_EVIR				; evaluate integer expression
    4511/    37AE :                     								; (does FC error not OF error if out of range)
    4512/    37AE : 0800 0000           	BTST		#0,d0					; test low bit of longword
    4513/    37B2 : 6600 E964           	BNE		LAB_ADER				; if address is odd do address error/warm start
    4514/    37B6 :                     
    4515/    37B6 : 2057                	MOVEA.l	(sp),a0				; copy return address
    4516/    37B8 : 2E80                	MOVE.l	d0,(sp)				; even address on stack
    4517/    37BA : 4ED0                	JMP		(a0)					; effectively RTS
    4518/    37BC :                     
    4519/    37BC :                     
    4520/    37BC :                     ;************************************************************************************
    4521/    37BC :                     ;
    4522/    37BC :                     ; perform PEEK()
    4523/    37BC :                     
    4524/    37BC :                     LAB_PEEK
    4525/    37BC : 6100 F93E           	BSR		LAB_EVIR				; evaluate integer expression
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 80 - 11/4/2023 8:40:20


    4526/    37C0 :                     								; (does FC error not OF error if out of range)
    4527/    37C0 : 2040                	MOVEA.l	d0,a0					; copy to address register
    4528/    37C2 : 1010                	MOVE.b	(a0),d0				; get byte
    4529/    37C4 : 6000 FB0A           	BRA		LAB_1FD0				; convert d0 to unsigned byte in FAC1 & return
    4530/    37C8 :                     
    4531/    37C8 :                     
    4532/    37C8 :                     ;************************************************************************************
    4533/    37C8 :                     ;
    4534/    37C8 :                     ; perform POKE
    4535/    37C8 :                     
    4536/    37C8 :                     LAB_POKE
    4537/    37C8 : 61A8                	BSR.s		LAB_GADB				; get two parameters for POKE or WAIT
    4538/    37CA :                     								; first parameter in a0, second in d0
    4539/    37CA : 1080                	MOVE.b	d0,(a0)				; put byte in memory
    4540/    37CC : 4E75                	RTS
    4541/    37CE :                     
    4542/    37CE :                     
    4543/    37CE :                     ;************************************************************************************
    4544/    37CE :                     ;
    4545/    37CE :                     ; perform DEEK()
    4546/    37CE :                     
    4547/    37CE :                     LAB_DEEK
    4548/    37CE : 6100 F92C           	BSR		LAB_EVIR				; evaluate integer expression
    4549/    37D2 :                     								; (does FC error not OF error if out of range)
    4550/    37D2 : E208                	LSR.b		#1,d0					; shift bit 0 to carry
    4551/    37D4 : 6500 E942           	BCS		LAB_ADER				; if address is odd do address error/warm start
    4552/    37D8 :                     
    4553/    37D8 : D000                	ADD.b		d0,d0					; shift byte back
    4554/    37DA : C188                	EXG		d0,a0					; copy to address register
    4555/    37DC : 7000                	MOVEQ		#0,d0					; clear top bits
    4556/    37DE : 3010                	MOVE.w	(a0),d0				; get word
    4557/    37E0 : 6000 FACE           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
    4558/    37E4 :                     
    4559/    37E4 :                     
    4560/    37E4 :                     ;************************************************************************************
    4561/    37E4 :                     ;
    4562/    37E4 :                     ; perform LEEK()
    4563/    37E4 :                     
    4564/    37E4 :                     LAB_LEEK
    4565/    37E4 : 6100 F916           	BSR		LAB_EVIR				; evaluate integer expression
    4566/    37E8 :                     								; (does FC error not OF error if out of range)
    4567/    37E8 : E208                	LSR.b		#1,d0					; shift bit 0 to carry
    4568/    37EA : 6500 E92C           	BCS		LAB_ADER				; if address is odd do address error/warm start
    4569/    37EE :                     
    4570/    37EE : D000                	ADD.b		d0,d0					; shift byte back
    4571/    37F0 : C188                	EXG		d0,a0					; copy to address register
    4572/    37F2 : 2010                	MOVE.l	(a0),d0				; get longword
    4573/    37F4 : 6000 FABA           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
    4574/    37F8 :                     
    4575/    37F8 :                     
    4576/    37F8 :                     ;************************************************************************************
    4577/    37F8 :                     ;
    4578/    37F8 :                     ; perform DOKE
    4579/    37F8 :                     
    4580/    37F8 :                     LAB_DOKE
    4581/    37F8 : 618C                	BSR.s		LAB_GADW				; get two parameters for DOKE or WAIT
    4582/    37FA :                     								; first parameter in a0, second in d0
    4583/    37FA : 3080                	MOVE.w	d0,(a0)				; put word in memory
    4584/    37FC : 4E75                	RTS
    4585/    37FE :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 81 - 11/4/2023 8:40:20


    4586/    37FE :                     
    4587/    37FE :                     ;************************************************************************************
    4588/    37FE :                     ;
    4589/    37FE :                     ; perform LOKE
    4590/    37FE :                     
    4591/    37FE :                     LAB_LOKE
    4592/    37FE : 61A6                	BSR.s		LAB_GEAD				; get even address for word/long memory actions
    4593/    3800 :                     								; address returned in d0 and on the stack
    4594/    3800 : 6100 F5A2           	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
    4595/    3804 : 6100 F430           	BSR		LAB_EVNM				; evaluate expression & check is numeric,
    4596/    3808 :                     								; else do type mismatch
    4597/    3808 : 6100 F8F2           	BSR		LAB_EVIR				; evaluate integer value (no sign check)
    4598/    380C : 205F                	MOVEA.l	(sp)+,a0				; pull address
    4599/    380E : 2080                	MOVE.l	d0,(a0)				; put longword in memory
    4600/    3810 :                     RTS_015
    4601/    3810 : 4E75                	RTS
    4602/    3812 :                     
    4603/    3812 :                     
    4604/    3812 :                     ;************************************************************************************
    4605/    3812 :                     ;
    4606/    3812 :                     ; perform SWAP
    4607/    3812 :                     
    4608/    3812 :                     LAB_SWAP
    4609/    3812 : 6100 F7AC           	BSR		LAB_GVAR				; get variable 1 address in a0
    4610/    3816 : 2F08                	MOVE.l	a0,-(sp)				; save variable 1 address
    4611/    3818 : 182B 05B5           	MOVE.b	Dtypef(a3),d4			; copy variable 1 data type, $80=string,
    4612/    381C :                     								; $40=inetger, $00=float
    4613/    381C :                     
    4614/    381C : 6100 F586           	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
    4615/    3820 : 6100 F79E           	BSR		LAB_GVAR				; get variable 2 address in a0
    4616/    3824 : 245F                	MOVEA.l	(sp)+,a2				; restore variable 1 address
    4617/    3826 : B82B 05B5           	CMP.b		Dtypef(a3),d4			; compare variable 1 data type with variable 2
    4618/    382A :                     								; data type
    4619/    382A : 6600 E910           	BNE		LAB_TMER				; if not both the same type do "Type mismatch"
    4620/    382E :                     								; error then warm start
    4621/    382E :                     
    4622/    382E : 2010                	MOVE.l	(a0),d0				; get variable 2
    4623/    3830 : 20D2                	MOVE.l	(a2),(a0)+				; copy variable 1 to variable 2
    4624/    3832 : 24C0                	MOVE.l	d0,(a2)+				; save variable 2 to variable 1
    4625/    3834 :                     
    4626/    3834 : 4A04                	TST.b		d4					; check data type
    4627/    3836 : 6AD8                	BPL.s		RTS_015				; exit if not string
    4628/    3838 :                     
    4629/    3838 : 3010                	MOVE.w	(a0),d0				; get string 2 length
    4630/    383A : 3092                	MOVE.w	(a2),(a0)				; copy string 1 length to string 2 length
    4631/    383C : 3480                	MOVE.w	d0,(a2)				; save string 2 length to string 1 length
    4632/    383E : 4E75                	RTS
    4633/    3840 :                     
    4634/    3840 :                     
    4635/    3840 :                     ;************************************************************************************
    4636/    3840 :                     ;
    4637/    3840 :                     ; perform USR
    4638/    3840 :                     
    4639/    3840 :                     LAB_USR
    4640/    3840 : 4EAB 0406           	JSR		Usrjmp(a3)				; do user vector
    4641/    3844 : 6000 F556           	BRA		LAB_1BFB				; scan for ")", else do syntax error/warm start
    4642/    3848 :                     
    4643/    3848 :                     
    4644/    3848 :                     ;************************************************************************************
    4645/    3848 :                     ;
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 82 - 11/4/2023 8:40:20


    4646/    3848 :                     ; perform LOAD
    4647/    3848 :                     
    4648/    3848 :                     LAB_LOAD
    4649/    3848 : 4EEB 0418           	JMP		V_LOAD(a3)				; do load vector
    4650/    384C :                     
    4651/    384C :                     
    4652/    384C :                     ;************************************************************************************
    4653/    384C :                     ;
    4654/    384C :                     ; perform SAVE
    4655/    384C :                     
    4656/    384C :                     LAB_SAVE
    4657/    384C : 4EEB 041E           	JMP		V_SAVE(a3)				; do save vector
    4658/    3850 :                     
    4659/    3850 :                     
    4660/    3850 :                     ;************************************************************************************
    4661/    3850 :                     ;
    4662/    3850 :                     ; perform CALL
    4663/    3850 :                     
    4664/    3850 :                     LAB_CALL
    4665/    3850 : 487A F55E           	PEA		LAB_GBYT(pc)			; put return address on stack
    4666/    3854 : 6100 FF50           	BSR		LAB_GEAD				; get even address for word/long memory actions
    4667/    3858 :                     								; address returned in d0 and on the stack
    4668/    3858 : 4E75                	RTS							; effectively calls the routine
    4669/    385A :                     
    4670/    385A :                     ; if the called routine exits correctly then it will return via the get byte routine.
    4671/    385A :                     ; this will then get the next byte for the interpreter and return
    4672/    385A :                     
    4673/    385A :                     
    4674/    385A :                     ;************************************************************************************
    4675/    385A :                     ;
    4676/    385A :                     ; perform WAIT
    4677/    385A :                     
    4678/    385A :                     LAB_WAIT
    4679/    385A : 6100 FF16           	BSR		LAB_GADB				; get two parameters for POKE or WAIT
    4680/    385E :                     								; first parameter in a0, second in d0
    4681/    385E : 2F08                	MOVE.l	a0,-(sp)				; save address
    4682/    3860 : 3F00                	MOVE.w	d0,-(sp)				; save byte
    4683/    3862 : 7400                	MOVEQ		#0,d2					; clear mask
    4684/    3864 : 6100 F54A           	BSR		LAB_GBYT				; scan memory
    4685/    3868 : 6706                	BEQ.s		LAB_2441				; skip if no third argument
    4686/    386A :                     
    4687/    386A : 6100 F534           	BSR		LAB_SCGB				; scan for "," & get byte,
    4688/    386E :                     								; else do syntax error/warm start
    4689/    386E : 2400                	MOVE.l	d0,d2					; copy mask
    4690/    3870 :                     LAB_2441
    4691/    3870 : 321F                	MOVE.w	(sp)+,d1				; get byte
    4692/    3872 : 205F                	MOVEA.l	(sp)+,a0				; get address
    4693/    3874 :                     LAB_2445
    4694/    3874 : 1010                	MOVE.b	(a0),d0				; read memory byte
    4695/    3876 : B500                	EOR.b		d2,d0					; EOR with second argument (mask)
    4696/    3878 : C001                	AND.b		d1,d0					; AND with first argument (byte)
    4697/    387A : 67F8                	BEQ.s		LAB_2445				; loop if result is zero
    4698/    387C :                     
    4699/    387C : 4E75                	RTS
    4700/    387E :                     
    4701/    387E :                     
    4702/    387E :                     ;************************************************************************************
    4703/    387E :                     ;
    4704/    387E :                     ; perform subtraction, FAC1 from FAC2
    4705/    387E :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 83 - 11/4/2023 8:40:20


    4706/    387E :                     LAB_SUBTRACT
    4707/    387E : 0A2B 0080 0595      	EORI.b	#$80,FAC1_s(a3)			; complement FAC1 sign
    4708/    3884 : 176B 059D 059E      	MOVE.b	FAC2_s(a3),FAC_sc(a3)		; copy FAC2 sign byte
    4709/    388A :                     
    4710/    388A : 102B 0595           	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign byte
    4711/    388E : B12B 059E           	EOR.b		d0,FAC_sc(a3)			; EOR with FAC2 sign
    4712/    3892 :                     
    4713/    3892 :                     
    4714/    3892 :                     ;************************************************************************************
    4715/    3892 :                     ;
    4716/    3892 :                     ; add FAC2 to FAC1
    4717/    3892 :                     
    4718/    3892 :                     LAB_ADD
    4719/    3892 : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get exponent
    4720/    3896 : 6700 0338           	BEQ		LAB_279B				; FAC1 was zero so copy FAC2 to FAC1 & return
    4721/    389A :                     
    4722/    389A :                     								; FAC1 is non zero
    4723/    389A : 41EB 0598           	LEA		FAC2_m(a3),a0			; set pointer1 to FAC2 mantissa
    4724/    389E : 102B 059C           	MOVE.b	FAC2_e(a3),d0			; get FAC2 exponent
    4725/    38A2 : 6746                	BEQ.s		RTS_016				; exit if zero
    4726/    38A4 :                     
    4727/    38A4 : 902B 0594           	SUB.b		FAC1_e(a3),d0			; subtract FAC1 exponent
    4728/    38A8 : 6722                	BEQ.s		LAB_24A8				; branch if = (go add mantissa)
    4729/    38AA :                     
    4730/    38AA : 650A                	BCS.s		LAB_249C				; branch if FAC2 < FAC1
    4731/    38AC :                     
    4732/    38AC :                     								; FAC2 > FAC1
    4733/    38AC : 376B 059C 0594      	MOVE.w	FAC2_e(a3),FAC1_e(a3)		; copy sign and exponent of FAC2
    4734/    38B2 : 4400                	NEG.b		d0					; negate exponent difference (make diff -ve)
    4735/    38B4 : 5148                	SUBQ.w	#8,a0					; pointer1 to FAC1
    4736/    38B6 :                     
    4737/    38B6 :                     LAB_249C
    4738/    38B6 : 4400                	NEG.b		d0					; negate exponent difference (make diff +ve)
    4739/    38B8 : 2F01                	MOVE.l	d1,-(sp)				; save d1
    4740/    38BA : B03C 0020           	CMP.b		#32,d0				; compare exponent diff with 32
    4741/    38BE : 6D04                	BLT.s		LAB_2467				; branch if range >= 32
    4742/    38C0 :                     
    4743/    38C0 : 7200                	MOVEQ		#0,d1					; clear d1
    4744/    38C2 : 6004                	BRA.s		LAB_2468				; go clear smaller mantissa
    4745/    38C4 :                     
    4746/    38C4 :                     LAB_2467
    4747/    38C4 : 2210                	MOVE.l	(a0),d1				; get FACx mantissa
    4748/    38C6 : E0A9                	LSR.l		d0,d1					; shift d0 times right
    4749/    38C8 :                     LAB_2468
    4750/    38C8 : 2081                	MOVE.l	d1,(a0)				; save it back
    4751/    38CA : 221F                	MOVE.l	(sp)+,d1				; restore d1
    4752/    38CC :                     
    4753/    38CC :                     								; exponents are equal now do mantissa add or
    4754/    38CC :                     								; subtract
    4755/    38CC :                     LAB_24A8
    4756/    38CC : 4A2B 059E           	TST.b		FAC_sc(a3)				; test sign compare (FAC1 EOR FAC2)
    4757/    38D0 : 6B1A                	BMI.s		LAB_24F8				; if <> go do subtract
    4758/    38D2 :                     
    4759/    38D2 : 202B 0598           	MOVE.l	FAC2_m(a3),d0			; get FAC2 mantissa
    4760/    38D6 : D0AB 0590           	ADD.l		FAC1_m(a3),d0			; add FAC1 mantissa
    4761/    38DA : 640A                	BCC.s		LAB_24F7				; save and exit if no carry (FAC1 is normal)
    4762/    38DC :                     
    4763/    38DC : E290                	ROXR.l	#1,d0					; else shift carry back into mantissa
    4764/    38DE : 522B 0594           	ADDQ.b	#1,FAC1_e(a3)			; increment FAC1 exponent
    4765/    38E2 : 6500 E874           	BCS		LAB_OFER				; if carry do overflow error & warm start
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 84 - 11/4/2023 8:40:20


    4766/    38E6 :                     
    4767/    38E6 :                     LAB_24F7
    4768/    38E6 : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; save mantissa
    4769/    38EA :                     RTS_016
    4770/    38EA : 4E75                	RTS
    4771/    38EC :                     								; signs are different
    4772/    38EC :                     LAB_24F8
    4773/    38EC : 43EB 0590           	LEA		FAC1_m(a3),a1			; pointer 2 to FAC1
    4774/    38F0 : B3C8                	CMPA.l	a0,a1					; compare pointers
    4775/    38F2 : 6602                	BNE.s		LAB_24B4				; branch if <>
    4776/    38F4 :                     
    4777/    38F4 : 5049                	ADDQ.w	#8,a1					; else pointer2 to FAC2
    4778/    38F6 :                     
    4779/    38F6 :                     								; take smaller from bigger (take sign of bigger)
    4780/    38F6 :                     LAB_24B4
    4781/    38F6 : 2011                	MOVE.l	(a1),d0				; get larger mantissa
    4782/    38F8 : 2210                	MOVE.l	(a0),d1				; get smaller mantissa
    4783/    38FA : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; save larger mantissa
    4784/    38FE : 93AB 0590           	SUB.l		d1,FAC1_m(a3)			; subtract smaller
    4785/    3902 :                     
    4786/    3902 :                     
    4787/    3902 :                     ;************************************************************************************
    4788/    3902 :                     ;
    4789/    3902 :                     ; do +/- (carry is sign) & normalise FAC1
    4790/    3902 :                     
    4791/    3902 :                     LAB_24D0
    4792/    3902 : 640A                	BCC.s		LAB_24D5				; branch if result is +ve
    4793/    3904 :                     
    4794/    3904 :                     								; erk! subtract is the wrong way round so
    4795/    3904 :                     								; negate everything
    4796/    3904 : 0A2B 00FF 0595      	EORI.b	#$FF,FAC1_s(a3)			; complement FAC1 sign
    4797/    390A : 44AB 0590           	NEG.l		FAC1_m(a3)				; negate FAC1 mantissa
    4798/    390E :                     
    4799/    390E :                     
    4800/    390E :                     ;************************************************************************************
    4801/    390E :                     ;
    4802/    390E :                     ; normalise FAC1
    4803/    390E :                     
    4804/    390E :                     LAB_24D5
    4805/    390E : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get mantissa
    4806/    3912 : 6B2E                	BMI.s		LAB_24DA				; mantissa is normal so just exit
    4807/    3914 :                     
    4808/    3914 : 6606                	BNE.s		LAB_24D9				; mantissa is not zero so go normalise FAC1
    4809/    3916 :                     
    4810/    3916 : 3740 0594           	MOVE.w	d0,FAC1_e(a3)			; else make FAC1 = +zero
    4811/    391A : 4E75                	RTS
    4812/    391C :                     
    4813/    391C :                     LAB_24D9
    4814/    391C : 2F01                	MOVE.l	d1,-(sp)				; save d1
    4815/    391E : 2200                	MOVE.l	d0,d1					; mantissa to d1
    4816/    3920 : 7000                	MOVEQ		#0,d0					; clear d0
    4817/    3922 : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get exponent byte
    4818/    3926 : 6714                	BEQ.s		LAB_24D8				; if exponent is zero then clean up and exit
    4819/    3928 :                     LAB_24D6
    4820/    3928 : D281                	ADD.l		d1,d1					; shift mantissa, ADD is quicker for a single
    4821/    392A :                     								; shift
    4822/    392A : 5BC8 FFFC           	DBMI		d0,LAB_24D6				; decrement exponent and loop if mantissa and
    4823/    392E :                     								; exponent +ve
    4824/    392E :                     
    4825/    392E : 4A40                	TST.w		d0					; test exponent
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 85 - 11/4/2023 8:40:20


    4826/    3930 : 670A                	BEQ.s		LAB_24D8				; if exponent is zero make FAC1 zero
    4827/    3932 :                     
    4828/    3932 : 6A02                	BPL.s		LAB_24D7				; if exponent is >zero go save FAC1
    4829/    3934 :                     
    4830/    3934 : 7001                	MOVEQ		#1,d0					; else set for zero after correction
    4831/    3936 :                     LAB_24D7
    4832/    3936 : 5300                	SUBQ.b	#1,d0					; adjust exponent for loop
    4833/    3938 : 2741 0590           	MOVE.l	d1,FAC1_m(a3)			; save normalised mantissa
    4834/    393C :                     LAB_24D8
    4835/    393C : 221F                	MOVE.l	(sp)+,d1				; restore d1
    4836/    393E : 1740 0594           	MOVE.b	d0,FAC1_e(a3)			; save corrected exponent
    4837/    3942 :                     LAB_24DA
    4838/    3942 : 4E75                	RTS
    4839/    3944 :                     
    4840/    3944 :                     
    4841/    3944 :                     ;************************************************************************************
    4842/    3944 :                     ;
    4843/    3944 :                     ; perform LOG()
    4844/    3944 :                     
    4845/    3944 :                     LAB_LOG
    4846/    3944 : 4A2B 0595           	TST.b		FAC1_s(a3)				; test sign
    4847/    3948 : 6B00 E812           	BMI		LAB_FCER				; if -ve do function call error/warm start
    4848/    394C :                     
    4849/    394C : 7E00                	MOVEQ		#0,d7					; clear d7
    4850/    394E : 1747 059E           	MOVE.b	d7,FAC_sc(a3)			; clear sign compare
    4851/    3952 : 1E2B 0594           	MOVE.b	FAC1_e(a3),d7			; get exponent
    4852/    3956 : 6700 E804           	BEQ		LAB_FCER				; if 0 do function call error/warm start
    4853/    395A :                     
    4854/    395A : 9EBC 0000 0081      	SUB.l		#$81,d7				; normalise exponent
    4855/    3960 : 177C 0081 0594      	MOVE.b	#$81,FAC1_e(a3)			; force a value between 1 and 2
    4856/    3966 : 2C2B 0590           	MOVE.l	FAC1_m(a3),d6			; copy mantissa
    4857/    396A :                     
    4858/    396A : 277C 8000 0000      	MOVE.l	#$80000000,FAC2_m(a3)		; set mantissa for 1
             3970 : 0598             
    4859/    3972 : 377C 8100 059C      	MOVE.w	#$8100,FAC2_e(a3)			; set exponent for 1
    4860/    3978 : 6100 FF18           	BSR		LAB_ADD				; find arg+1
    4861/    397C : 7000                	MOVEQ		#0,d0					; setup for calc skip
    4862/    397E : 3740 059C           	MOVE.w	d0,FAC2_e(a3)			; set FAC1 for zero result
    4863/    3982 : DC86                	ADD.l		d6,d6					; shift 1 bit out
    4864/    3984 : 2746 0598           	MOVE.l	d6,FAC2_m(a3)			; put back FAC2
    4865/    3988 : 6758                	BEQ.s		LAB_LONN				; if 0 skip calculation
    4866/    398A :                     
    4867/    398A : 377C 8000 059C      	MOVE.w	#$8000,FAC2_e(a3)			; set exponent for .5
    4868/    3990 : 6100 0130           	BSR		LAB_DIVIDE				; do (arg-1)/(arg+1)
    4869/    3994 : 4A2B 0594           	TST.b		FAC1_e(a3)				; test exponent
    4870/    3998 : 6748                	BEQ.s		LAB_LONN				; if 0 skip calculation
    4871/    399A :                     
    4872/    399A : 122B 0594           	MOVE.b	FAC1_e(a3),d1			; get exponent
    4873/    399E : 923C 0082           	SUB.b		#$82,d1				; normalise and two integer bits
    4874/    39A2 : 4401                	NEG.b		d1					; negate for shift
    4875/    39A4 :                     ;	CMP.b		#$1F,d1				; will mantissa vanish?
    4876/    39A4 :                     ;	BGT.s		LAB_dunno				; if so do ???
    4877/    39A4 :                     
    4878/    39A4 : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get mantissa
    4879/    39A8 : E2A8                	LSR.l		d1,d0					; shift in two integer bits
    4880/    39AA :                     
    4881/    39AA :                     ; d0 = arg
    4882/    39AA :                     ; d0 = x, d1 = y
    4883/    39AA :                     ; d2 = x1, d3 = y1
    4884/    39AA :                     ; d4 = shift count
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 86 - 11/4/2023 8:40:20


    4885/    39AA :                     ; d5 = loop count
    4886/    39AA :                     ; d6 = z
    4887/    39AA :                     ; a0 = table pointer
    4888/    39AA :                     
    4889/    39AA : 7C00                	MOVEQ		#0,d6					; z = 0
    4890/    39AC : 223C 4000 0000      	MOVE.l	#1<<30,d1				; y = 1
    4891/    39B2 : 41FA 1408           	LEA		TAB_HTHET(pc),a0			; get pointer to hyperbolic tangent table
    4892/    39B6 : 7A1E                	MOVEQ		#30,d5				; loop 31 times
    4893/    39B8 : 7801                	MOVEQ		#1,d4					; set shift count
    4894/    39BA : 6006                	BRA.s		LAB_LOCC				; entry point for loop
    4895/    39BC :                     
    4896/    39BC :                     LAB_LAAD
    4897/    39BC : E8A2                	ASR.l		d4,d2					; x1 >> i
    4898/    39BE : 9282                	SUB.l		d2,d1					; y = y - x1
    4899/    39C0 : DC90                	ADD.l		(a0),d6				; z = z + tanh(i)
    4900/    39C2 :                     LAB_LOCC
    4901/    39C2 : 2400                	MOVE.l	d0,d2					; x1 = x
    4902/    39C4 : 2601                	MOVE.l	d1,d3					; y1 = Y
    4903/    39C6 : E8A3                	ASR.l		d4,d3					; y1 >> i
    4904/    39C8 : 6402                	BCC.s		LAB_LOLP
    4905/    39CA :                     
    4906/    39CA : 5283                	ADDQ.l	#1,d3
    4907/    39CC :                     LAB_LOLP
    4908/    39CC : 9083                	SUB.l		d3,d0					; x = x - y1
    4909/    39CE : 6AEC                	BPL.s		LAB_LAAD				; branch if > 0
    4910/    39D0 :                     
    4911/    39D0 : 2002                	MOVE.l	d2,d0					; get x back
    4912/    39D2 : 5848                	ADDQ.w	#4,a0					; next entry
    4913/    39D4 : 5284                	ADDQ.l	#1,d4					; next i
    4914/    39D6 : E28B                	LSR.l		#1,d3					; /2
    4915/    39D8 : 6704                	BEQ.s		LAB_LOCX				; branch y1 = 0
    4916/    39DA :                     
    4917/    39DA : 51CD FFF0           	DBF		d5,LAB_LOLP				; decrement and loop if not done
    4918/    39DE :                     
    4919/    39DE :                     								; now sort out the result
    4920/    39DE :                     LAB_LOCX
    4921/    39DE : DC86                	ADD.l		d6,d6					; *2
    4922/    39E0 : 2006                	MOVE.l	d6,d0					; setup for d7 = 0
    4923/    39E2 :                     LAB_LONN
    4924/    39E2 : 2800                	MOVE.l	d0,d4					; save cordic result
    4925/    39E4 : 7A00                	MOVEQ		#0,d5					; set default exponent sign
    4926/    39E6 : 4A87                	TST.l		d7					; check original exponent sign
    4927/    39E8 : 6716                	BEQ.s		LAB_LOXO				; branch if original was 0
    4928/    39EA :                     
    4929/    39EA : 6A04                	BPL.s		LAB_LOXP				; branch if was +ve
    4930/    39EC :                     
    4931/    39EC : 4487                	NEG.l		d7					; make original exponent +ve
    4932/    39EE : 7A80                	MOVEQ		#$80-$100,d5			; make sign -ve
    4933/    39F0 :                     LAB_LOXP
    4934/    39F0 : 1745 0595           	MOVE.b	d5,FAC1_s(a3)			; save original exponent sign
    4935/    39F4 : 4847                	SWAP		d7					; 16 bit shift
    4936/    39F6 : E18F                	LSL.l		#8,d7					; easy first part
    4937/    39F8 : 7A88                	MOVEQ		#$88-$100,d5			; start with byte
    4938/    39FA :                     LAB_LONE
    4939/    39FA : 5385                	SUBQ.l	#1,d5					; decrement exponent
    4940/    39FC : DE87                	ADD.l		d7,d7					; shift mantissa
    4941/    39FE : 6AFA                	BPL.s		LAB_LONE				; loop if not normal
    4942/    3A00 :                     
    4943/    3A00 :                     LAB_LOXO
    4944/    3A00 : 2747 0590           	MOVE.l	d7,FAC1_m(a3)			; save original exponent as mantissa
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 87 - 11/4/2023 8:40:20


    4945/    3A04 : 1745 0594           	MOVE.b	d5,FAC1_e(a3)			; save exponent for this
    4946/    3A08 : 277C B172 17F8      	MOVE.l	#$B17217F8,FAC2_m(a3)		; LOG(2) mantissa
             3A0E : 0598             
    4947/    3A10 : 377C 8000 059C      	MOVE.w	#$8000,FAC2_e(a3)			; LOG(2) exponent & sign
    4948/    3A16 : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; make sign compare = FAC1 sign
    4949/    3A1C : 6118                	BSR.s		LAB_MULTIPLY			; do multiply
    4950/    3A1E : 2744 0598           	MOVE.l	d4,FAC2_m(a3)			; save cordic result
    4951/    3A22 : 6710                	BEQ.s		LAB_LOWZ				; branch if zero
    4952/    3A24 :                     
    4953/    3A24 : 377C 8200 059C      	MOVE.w	#$8200,FAC2_e(a3)			; set exponent & sign
    4954/    3A2A : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; clear sign compare
    4955/    3A30 : 6100 FE60           	BSR		LAB_ADD				; and add for final result
    4956/    3A34 :                     
    4957/    3A34 :                     LAB_LOWZ
    4958/    3A34 : 4E75                	RTS
    4959/    3A36 :                     
    4960/    3A36 :                     
    4961/    3A36 :                     ;************************************************************************************
    4962/    3A36 :                     ;
    4963/    3A36 :                     ; multiply FAC1 by FAC2
    4964/    3A36 :                     
    4965/    3A36 :                     LAB_MULTIPLY
    4966/    3A36 : 48E7 F800           	MOVEM.l	d0-d4,-(sp)				; save registers
    4967/    3A3A : 4A2B 0594           	TST.b		FAC1_e(a3)				; test FAC1 exponent
    4968/    3A3E : 6776                	BEQ.s		LAB_MUUF				; if exponent zero go make result zero
    4969/    3A40 :                     
    4970/    3A40 : 102B 059C           	MOVE.b	FAC2_e(a3),d0			; get FAC2 exponent
    4971/    3A44 : 6770                	BEQ.s		LAB_MUUF				; if exponent zero go make result zero
    4972/    3A46 :                     
    4973/    3A46 : 176B 059E 0595      	MOVE.b	FAC_sc(a3),FAC1_s(a3)		; sign compare becomes sign
    4974/    3A4C :                     
    4975/    3A4C : D02B 0594           	ADD.b		FAC1_e(a3),d0			; multiply exponents by adding
    4976/    3A50 : 640A                	BCC.s		LAB_MNOC				; branch if no carry
    4977/    3A52 :                     
    4978/    3A52 : 903C 0080           	SUB.b		#$80,d0				; normalise result
    4979/    3A56 : 6400 E700           	BCC		LAB_OFER				; if no carry do overflow
    4980/    3A5A :                     
    4981/    3A5A : 6006                	BRA.s		LAB_MADD				; branch
    4982/    3A5C :                     
    4983/    3A5C :                     								; no carry for exponent add
    4984/    3A5C :                     LAB_MNOC
    4985/    3A5C : 903C 0080           	SUB.b		#$80,d0				; normalise result
    4986/    3A60 : 6554                	BCS.s		LAB_MUUF				; return zero if underflow
    4987/    3A62 :                     
    4988/    3A62 :                     LAB_MADD
    4989/    3A62 : 1740 0594           	MOVE.b	d0,FAC1_e(a3)			; save exponent
    4990/    3A66 :                     
    4991/    3A66 :                     								; d1 (FAC1) x d2 (FAC2)
    4992/    3A66 : 222B 0590           	MOVE.l	FAC1_m(a3),d1			; get FAC1 mantissa
    4993/    3A6A : 242B 0598           	MOVE.l	FAC2_m(a3),d2			; get FAC2 mantissa
    4994/    3A6E :                     
    4995/    3A6E : 3801                	MOVE.w	d1,d4					; copy low word FAC1
    4996/    3A70 : 2001                	MOVE.l	d1,d0					; copy long word FAC1
    4997/    3A72 : 4840                	SWAP		d0					; high word FAC1 to low word FAC1
    4998/    3A74 : 3600                	MOVE.w	d0,d3					; copy high word FAC1
    4999/    3A76 :                     
    5000/    3A76 : C2C2                	MULU		d2,d1					; low word FAC2 x low word FAC1
    5001/    3A78 : C0C2                	MULU		d2,d0					; low word FAC2 x high word FAC1
    5002/    3A7A : 4842                	SWAP		d2					; high word FAC2 to low word FAC2
    5003/    3A7C : C8C2                	MULU		d2,d4					; high word FAC2 x low word FAC1
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 88 - 11/4/2023 8:40:20


    5004/    3A7E : C6C2                	MULU		d2,d3					; high word FAC2 x high word FAC1
    5005/    3A80 :                     
    5006/    3A80 :                     ; done multiply, now add partial products
    5007/    3A80 :                     
    5008/    3A80 :                     ;			d1 =					aaaa  ----	FAC2_L x FAC1_L
    5009/    3A80 :                     ;			d0 =				bbbb  aaaa		FAC2_L x FAC1_H
    5010/    3A80 :                     ;			d4 =				bbbb  aaaa		FAC2_H x FAC1_L
    5011/    3A80 :                     ;			d3 =			cccc  bbbb			FAC2_H x FAC1_H
    5012/    3A80 :                     ;			product =		mmmm  mmmm
    5013/    3A80 :                     
    5014/    3A80 : D2BC 0000 8000      	ADD.L		#$8000,d1				; round up lowest word
    5015/    3A86 : 4241                	CLR.w		d1					; clear low word, don't need it
    5016/    3A88 : 4841                	SWAP		d1					; align high word
    5017/    3A8A : D280                	ADD.l		d0,d1					; add FAC2_L x FAC1_H (can't be carry)
    5018/    3A8C :                     LAB_MUF1
    5019/    3A8C : D284                	ADD.l		d4,d1					; now add intermediate (FAC2_H x FAC1_L)
    5020/    3A8E : 6406                	BCC.s		LAB_MUF2				; branch if no carry
    5021/    3A90 :                     
    5022/    3A90 : D6BC 0001 0000      	ADD.l		#$10000,d3				; else correct result
    5023/    3A96 :                     LAB_MUF2
    5024/    3A96 : D2BC 0000 8000      	ADD.l		#$8000,d1				; round up low word
    5025/    3A9C : 4241                	CLR.w		d1					; clear low word
    5026/    3A9E : 4841                	SWAP		d1					; align for final add
    5027/    3AA0 : D283                	ADD.l		d3,d1					; add FAC2_H x FAC1_H, result
    5028/    3AA2 : 6B08                	BMI.s		LAB_MUF3				; branch if normalisation not needed
    5029/    3AA4 :                     
    5030/    3AA4 : D281                	ADD.l		d1,d1					; shift mantissa
    5031/    3AA6 : 532B 0594           	SUBQ.b	#1,FAC1_e(a3)			; adjust exponent
    5032/    3AAA : 670A                	BEQ.s		LAB_MUUF				; branch if underflow
    5033/    3AAC :                     
    5034/    3AAC :                     LAB_MUF3
    5035/    3AAC : 2741 0590           	MOVE.l	d1,FAC1_m(a3)			; save mantissa
    5036/    3AB0 :                     LAB_MUEX
    5037/    3AB0 : 4CDF 001F           	MOVEM.l	(sp)+,d0-d4				; restore registers
    5038/    3AB4 : 4E75                	RTS
    5039/    3AB6 :                     								; either zero or underflow result
    5040/    3AB6 :                     LAB_MUUF
    5041/    3AB6 : 7000                	MOVEQ		#0,d0					; quick clear
    5042/    3AB8 : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; clear mantissa
    5043/    3ABC : 3740 0594           	MOVE.w	d0,FAC1_e(a3)			; clear sign and exponent
    5044/    3AC0 : 60EE                	BRA.s		LAB_MUEX				; restore regs & exit
    5045/    3AC2 :                     
    5046/    3AC2 :                     
    5047/    3AC2 :                     ;************************************************************************************
    5048/    3AC2 :                     ;
    5049/    3AC2 :                     ; do FAC2/FAC1, result in FAC1
    5050/    3AC2 :                     ; fast hardware divide version
    5051/    3AC2 :                     
    5052/    3AC2 :                     LAB_DIVIDE
    5053/    3AC2 : 2F07                	MOVE.l	d7,-(sp)				; save d7
    5054/    3AC4 : 7000                	MOVEQ		#0,d0					; clear FAC2 exponent
    5055/    3AC6 : 2400                	MOVE.l	d0,d2					; clear FAC1 exponent
    5056/    3AC8 :                     
    5057/    3AC8 : 142B 0594           	MOVE.b	FAC1_e(a3),d2			; get FAC1 exponent
    5058/    3ACC : 6700 E676           	BEQ		LAB_DZER				; if zero go do /0 error
    5059/    3AD0 :                     
    5060/    3AD0 : 102B 059C           	MOVE.b	FAC2_e(a3),d0			; get FAC2 exponent
    5061/    3AD4 : 6766                	BEQ.s		LAB_DIV0				; if zero return zero
    5062/    3AD6 :                     
    5063/    3AD6 : 9042                	SUB.w		d2,d0					; get result exponent by subtracting
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 89 - 11/4/2023 8:40:20


    5064/    3AD8 : D07C 0080           	ADD.w		#$80,d0				; correct 16 bit exponent result
    5065/    3ADC :                     
    5066/    3ADC : 176B 059E 0595      	MOVE.b	FAC_sc(a3),FAC1_s(a3)		; sign compare is result sign
    5067/    3AE2 :                     
    5068/    3AE2 :                     ; now to do 32/32 bit mantissa divide
    5069/    3AE2 :                     
    5070/    3AE2 : 422B 059F           	CLR.b		flag(a3)				; clear 'flag' byte
    5071/    3AE6 : 262B 0590           	MOVE.l	FAC1_m(a3),d3			; get FAC1 mantissa
    5072/    3AEA : 282B 0598           	MOVE.l	FAC2_m(a3),d4			; get FAC2 mantissa
    5073/    3AEE : B883                	CMP.l		d3,d4					; compare FAC2 with FAC1 mantissa
    5074/    3AF0 : 6744                	BEQ.s		LAB_MAN1				; set mantissa result = 1 if equal
    5075/    3AF2 :                     
    5076/    3AF2 : 6506                	BCS.s		AC1gtAC2				; branch if FAC1 > FAC2
    5077/    3AF4 :                     
    5078/    3AF4 : 9883                	SUB.l		d3,d4					; subtract FAC1 from FAC2, result now must be <1
    5079/    3AF6 : 562B 059F           	ADDQ.b	#3,flag(a3)				; FAC2>FAC1 so set 'flag' byte
    5080/    3AFA :                     AC1gtAC2
    5081/    3AFA : 6146                	BSR.s		LAB_32_16				; do 32/16 divide
    5082/    3AFC : 4841                	SWAP		d1					; move 16 bit result to high word
    5083/    3AFE : 2802                	MOVE.l	d2,d4					; copy remainder longword
    5084/    3B00 : 6142                	BSR.s		LAB_3216				; do 32/16 divide again (skip copy d4 to d2)
    5085/    3B02 : 84C5                	DIVU.w	d5,d2					; now divide remainder to make guard word
    5086/    3B04 : 1E2B 059F           	MOVE.b	flag(a3),d7				; now normalise, get flag byte back
    5087/    3B08 : 6708                	BEQ.s		LAB_DIVX				; skip add if null
    5088/    3B0A :                     
    5089/    3B0A :                     ; else result was >1 so we need to add 1 to result mantissa and adjust exponent
    5090/    3B0A :                     
    5091/    3B0A : E20F                	LSR.b		#1,d7					; shift 1 into eXtend
    5092/    3B0C : E291                	ROXR.l	#1,d1					; shift extend result >>
    5093/    3B0E : E252                	ROXR.w	#1,d2					; shift extend guard word >>
    5094/    3B10 : 5200                	ADDQ.b	#1,d0					; adjust exponent
    5095/    3B12 :                     
    5096/    3B12 :                     ; now round result to 32 bits
    5097/    3B12 :                     
    5098/    3B12 :                     LAB_DIVX
    5099/    3B12 : D442                	ADD.w		d2,d2					; guard bit into eXtend bit
    5100/    3B14 : 6408                	BCC.s		L_DIVRND				; branch if guard=0
    5101/    3B16 :                     
    5102/    3B16 : 5281                	ADDQ.l	#1,d1					; add guard to mantissa
    5103/    3B18 : 6404                	BCC.s		L_DIVRND				; branch if no overflow
    5104/    3B1A :                     
    5105/    3B1A :                     LAB_SET1
    5106/    3B1A : E291                	ROXR.l	#1,d1					; shift extend result >>
    5107/    3B1C : 5240                	ADDQ.w	#1,d0					; adjust exponent
    5108/    3B1E :                     
    5109/    3B1E :                     								; test for over/under flow
    5110/    3B1E :                     L_DIVRND
    5111/    3B1E : 3600                	MOVE.w	d0,d3					; copy exponent
    5112/    3B20 : 6B1A                	BMI.s		LAB_DIV0				; if -ve return zero
    5113/    3B22 :                     
    5114/    3B22 : 0243 FF00           	ANDI.w	#$FF00,d3				; mask word high byte
    5115/    3B26 : 6600 E630           	BNE		LAB_OFER				; branch if overflow
    5116/    3B2A :                     
    5117/    3B2A :                     								; move result into FAC1
    5118/    3B2A :                     LAB_XDIV
    5119/    3B2A : 2E1F                	MOVE.l	(sp)+,d7				; restore d7
    5120/    3B2C : 1740 0594           	MOVE.b	d0,FAC1_e(a3)			; save result exponent
    5121/    3B30 : 2741 0590           	MOVE.l	d1,FAC1_m(a3)			; save result mantissa
    5122/    3B34 : 4E75                	RTS
    5123/    3B36 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 90 - 11/4/2023 8:40:20


    5124/    3B36 :                     ; FAC1 mantissa = FAC2 mantissa so set result mantissa
    5125/    3B36 :                     
    5126/    3B36 :                     LAB_MAN1
    5127/    3B36 : 7201                	MOVEQ		#1,d1					; set bit
    5128/    3B38 : E2A9                	LSR.l		d1,d1					; bit into eXtend
    5129/    3B3A : 60DE                	BRA.s		LAB_SET1				; set mantissa, adjust exponent and exit
    5130/    3B3C :                     
    5131/    3B3C :                     ; result is zero
    5132/    3B3C :                     
    5133/    3B3C :                     LAB_DIV0
    5134/    3B3C : 7000                	MOVEQ		#0,d0					; zero exponent & sign
    5135/    3B3E : 2200                	MOVE.l	d0,d1					; zero mantissa
    5136/    3B40 : 60E8                	BRA		LAB_XDIV				; exit divide
    5137/    3B42 :                     
    5138/    3B42 :                     ; divide 16 bits into 32, AB/Ex
    5139/    3B42 :                     ;
    5140/    3B42 :                     ; d4			AAAA	BBBB				; 32 bit numerator
    5141/    3B42 :                     ; d3			EEEE	xxxx				; 16 bit denominator
    5142/    3B42 :                     ;
    5143/    3B42 :                     ; returns -
    5144/    3B42 :                     ;
    5145/    3B42 :                     ; d1			xxxx	DDDD				; 16 bit result
    5146/    3B42 :                     ; d2				HHHH	IIII			; 32 bit remainder
    5147/    3B42 :                     
    5148/    3B42 :                     LAB_32_16
    5149/    3B42 : 2404                	MOVE.l	d4,d2					; copy FAC2 mantissa		(AB)
    5150/    3B44 :                     LAB_3216
    5151/    3B44 : 2A03                	MOVE.l	d3,d5					; copy FAC1 mantissa		(EF)
    5152/    3B46 : 4245                	CLR.w		d5					; clear low word d1		(Ex)
    5153/    3B48 : 4845                	SWAP		d5					; swap high word to low word	(xE)
    5154/    3B4A :                     
    5155/    3B4A :                     ; d3			EEEE	FFFF				; denominator copy
    5156/    3B4A :                     ; d5		0000	EEEE					; denominator high word
    5157/    3B4A :                     ; d2			AAAA	BBBB				; numerator copy
    5158/    3B4A :                     ; d4			AAAA	BBBB				; numerator
    5159/    3B4A :                     
    5160/    3B4A : 88C5                	DIVU.w	d5,d4					; do FAC2/FAC1 high word	(AB/E)
    5161/    3B4C : 6802                	BVC.s		LAB_LT_1				; if no overflow DIV was ok
    5162/    3B4E :                     
    5163/    3B4E : 78FF                	MOVEQ		#-1,d4				; else set default value
    5164/    3B50 :                     
    5165/    3B50 :                     ; done the divide, now check the result, we have ...
    5166/    3B50 :                     
    5167/    3B50 :                     ; d3			EEEE	FFFF				; denominator copy
    5168/    3B50 :                     ; d5		0000	EEEE					; denominator high word
    5169/    3B50 :                     ; d2			AAAA	BBBB				; numerator copy
    5170/    3B50 :                     ; d4			MMMM	DDDD				; result MOD and DIV
    5171/    3B50 :                     
    5172/    3B50 :                     LAB_LT_1
    5173/    3B50 : 3C04                	MOVE.w	d4,d6					; copy 16 bit result
    5174/    3B52 : 3204                	MOVE.w	d4,d1					; copy 16 bit result again
    5175/    3B54 :                     
    5176/    3B54 :                     ; we now have ..
    5177/    3B54 :                     ; d3			EEEE	FFFF				; denominator copy
    5178/    3B54 :                     ; d5		0000	EEEE					; denominator high word
    5179/    3B54 :                     ; d6			xxxx  DDDD				; result DIV copy
    5180/    3B54 :                     ; d1			xxxx  DDDD				; result DIV copy
    5181/    3B54 :                     ; d2			AAAA	BBBB				; numerator copy
    5182/    3B54 :                     ; d4			MMMM	DDDD				; result MOD and DIV
    5183/    3B54 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 91 - 11/4/2023 8:40:20


    5184/    3B54 :                     ; now multiply out 32 bit denominator by 16 bit result
    5185/    3B54 :                     ; QRS = AB*D
    5186/    3B54 :                     
    5187/    3B54 : CCC3                	MULU.w	d3,d6					; FFFF	; DDDD =       rrrr  SSSS
    5188/    3B56 : C8C5                	MULU.w	d5,d4					; EEEE	; DDDD = QQQQ  rrrr
    5189/    3B58 :                     
    5190/    3B58 :                     ; we now have ..
    5191/    3B58 :                     ; d3			EEEE	FFFF				; denominator copy
    5192/    3B58 :                     ; d5		0000	EEEE					; denominator high word
    5193/    3B58 :                     ; d6				rrrr  SSSS			; 48 bit result partial low
    5194/    3B58 :                     ; d1			xxxx  DDDD				; result DIV copy
    5195/    3B58 :                     ; d2			AAAA	BBBB				; numerator copy
    5196/    3B58 :                     ; d4			QQQQ	rrrr				; 48 bit result partial
    5197/    3B58 :                     
    5198/    3B58 : 3E06                	MOVE.w	d6,d7					; copy low word of low multiply
    5199/    3B5A :                     
    5200/    3B5A :                     ; d7				xxxx	SSSS			; 48 bit result partial low
    5201/    3B5A :                     
    5202/    3B5A : 4246                	CLR.w		d6					; clear low word of low multiply
    5203/    3B5C : 4846                	SWAP		d6					; high word of low multiply to low word
    5204/    3B5E :                     
    5205/    3B5E :                     ; d6			0000	rrrr				; high word of 48 bit result partial low
    5206/    3B5E :                     
    5207/    3B5E : D886                	ADD.l		d6,d4
    5208/    3B60 :                     
    5209/    3B60 :                     ; d4			QQQQ	RRRR				; 48 bit result partial high longword
    5210/    3B60 :                     
    5211/    3B60 : 7C00                	MOVEQ		#0,d6					; clear to extend numerator to 48 bits
    5212/    3B62 :                     
    5213/    3B62 :                     ; now do GHI = AB0 - QRS (which is the remainder)
    5214/    3B62 :                     
    5215/    3B62 : 9C47                	SUB.w		d7,d6					; low word subtract
    5216/    3B64 :                     
    5217/    3B64 :                     ; d6				xxxx	IIII			; remainder low word
    5218/    3B64 :                     
    5219/    3B64 : 9584                	SUBX.l	d4,d2					; high longword subtract
    5220/    3B66 :                     
    5221/    3B66 :                     ; d2			GGGG	HHHH				; remainder high longword
    5222/    3B66 :                     
    5223/    3B66 :                     ; now if we got the divide correct then the remainder high longword will be +ve
    5224/    3B66 :                     
    5225/    3B66 : 6A08                	BPL.s		L_DDIV				; branch if result is ok (<needed)
    5226/    3B68 :                     
    5227/    3B68 :                     ; remainder was -ve so DDDD is too big
    5228/    3B68 :                     
    5229/    3B68 :                     LAB_REMM
    5230/    3B68 : 5341                	SUBQ.w	#1,d1					; adjust DDDD
    5231/    3B6A :                     
    5232/    3B6A :                     ; d3				xxxx	FFFF			; denominator copy
    5233/    3B6A :                     ; d6				xxxx	IIII			; remainder low word
    5234/    3B6A :                     
    5235/    3B6A : DC43                	ADD.w		d3,d6					; add EF*1 low remainder low word
    5236/    3B6C :                     
    5237/    3B6C :                     ; d5			0000	EEEE				; denominator high word
    5238/    3B6C :                     ; d2			GGGG	HHHH				; remainder high longword
    5239/    3B6C :                     
    5240/    3B6C : D585                	ADDX.l	d5,d2					; add extend EF*1 to remainder high longword
    5241/    3B6E : 6BF8                	BMI.s		LAB_REMM				; loop if result still too big
    5242/    3B70 :                     
    5243/    3B70 :                     ; all done and result correct or <
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 92 - 11/4/2023 8:40:20


    5244/    3B70 :                     
    5245/    3B70 :                     L_DDIV
    5246/    3B70 : 4842                	SWAP		d2					; remainder mid word to high word
    5247/    3B72 :                     
    5248/    3B72 :                     ; d2			HHHH	GGGG				; (high word /should/ be $0000)
    5249/    3B72 :                     
    5250/    3B72 : 3406                	MOVE.w	d6,d2					; remainder in high word
    5251/    3B74 :                     
    5252/    3B74 :                     ; d2				HHHH	IIII			; now is 32 bit remainder
    5253/    3B74 :                     ; d1			xxxx	DDDD				; 16 bit result
    5254/    3B74 :                     
    5255/    3B74 : 4E75                	RTS
    5256/    3B76 :                     
    5257/    3B76 :                     
    5258/    3B76 :                     ;************************************************************************************
    5259/    3B76 :                     ;
    5260/    3B76 :                     ; unpack memory (a0) into FAC1
    5261/    3B76 :                     
    5262/    3B76 :                     LAB_UFAC
    5263/    3B76 : 2010                	MOVE.l	(a0),d0				; get packed value
    5264/    3B78 : 4840                	SWAP		d0					; exponent and sign into least significant word
    5265/    3B7A : 3740 0594           	MOVE.w	d0,FAC1_e(a3)			; save exponent and sign
    5266/    3B7E : 6708                	BEQ.s		LAB_NB1T				; branch if exponent (and the rest) zero
    5267/    3B80 :                     
    5268/    3B80 : 807C 0080           	OR.w		#$80,d0				; set MSb
    5269/    3B84 : 4840                	SWAP		d0					; word order back to normal
    5270/    3B86 : E180                	ASL.l		#8,d0					; shift exponent & clear guard byte
    5271/    3B88 :                     LAB_NB1T
    5272/    3B88 : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; move into FAC1
    5273/    3B8C :                     
    5274/    3B8C : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
    5275/    3B90 : 4E75                	RTS
    5276/    3B92 :                     
    5277/    3B92 :                     
    5278/    3B92 :                     ;************************************************************************************
    5279/    3B92 :                     ;
    5280/    3B92 :                     ; set numeric variable, pack FAC1 into Lvarpl
    5281/    3B92 :                     
    5282/    3B92 :                     LAB_PFAC
    5283/    3B92 : 2F08                	MOVE.l	a0,-(sp)				; save pointer
    5284/    3B94 : 206B 0472           	MOVEA.l	Lvarpl(a3),a0			; get destination pointer
    5285/    3B98 : 082B 0006 05B5      	BTST		#6,Dtypef(a3)			; test data type
    5286/    3B9E : 670C                	BEQ.s		LAB_277C				; branch if floating
    5287/    3BA0 :                     
    5288/    3BA0 : 6100 00C6           	BSR		LAB_2831				; convert FAC1 floating to fixed
    5289/    3BA4 :                     								; result in d0 and Itemp
    5290/    3BA4 : 2080                	MOVE.l	d0,(a0)				; save in var
    5291/    3BA6 : 205F                	MOVE.l	(sp)+,a0				; restore pointer
    5292/    3BA8 : 4E75                	RTS
    5293/    3BAA :                     
    5294/    3BAA :                     
    5295/    3BAA :                     ;************************************************************************************
    5296/    3BAA :                     ;
    5297/    3BAA :                     ; normalise round and pack FAC1 into (a0)
    5298/    3BAA :                     
    5299/    3BAA :                     LAB_2778
    5300/    3BAA : 2F08                	MOVE.l	a0,-(sp)				; save pointer
    5301/    3BAC :                     LAB_277C
    5302/    3BAC : 6100 FD60           	BSR		LAB_24D5				; normalise FAC1
    5303/    3BB0 : 612C                	BSR.s		LAB_27BA				; round FAC1
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 93 - 11/4/2023 8:40:20


    5304/    3BB2 : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get FAC1 mantissa
    5305/    3BB6 : E098                	ROR.l		#8,d0					; align 24/32 bit mantissa
    5306/    3BB8 : 4840                	SWAP		d0					; exponent/sign into 0-15
    5307/    3BBA : C07C 007F           	AND.w		#$7F,d0				; clear exponent and sign bit
    5308/    3BBE : 022B 0080 0595      	ANDI.b	#$80,FAC1_s(a3)			; clear non sign bits in sign
    5309/    3BC4 : 806B 0594           	OR.w		FAC1_e(a3),d0			; OR in exponent and sign
    5310/    3BC8 : 4840                	SWAP		d0					; move exponent and sign back to 16-31
    5311/    3BCA : 2080                	MOVE.l	d0,(a0)				; store in destination
    5312/    3BCC : 205F                	MOVE.l	(sp)+,a0				; restore pointer
    5313/    3BCE : 4E75                	RTS
    5314/    3BD0 :                     
    5315/    3BD0 :                     
    5316/    3BD0 :                     ;************************************************************************************
    5317/    3BD0 :                     ;
    5318/    3BD0 :                     ; copy FAC2 to FAC1
    5319/    3BD0 :                     
    5320/    3BD0 :                     LAB_279B
    5321/    3BD0 : 376B 059C 0594      	MOVE.w	FAC2_e(a3),FAC1_e(a3)		; copy exponent & sign
    5322/    3BD6 : 276B 0598 0590      	MOVE.l	FAC2_m(a3),FAC1_m(a3)		; copy mantissa
    5323/    3BDC : 4E75                	RTS
    5324/    3BDE :                     
    5325/    3BDE :                     
    5326/    3BDE :                     ;************************************************************************************
    5327/    3BDE :                     ;
    5328/    3BDE :                     ; round FAC1
    5329/    3BDE :                     
    5330/    3BDE :                     LAB_27BA
    5331/    3BDE : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
    5332/    3BE2 : 6720                	BEQ.s		LAB_27C4				; branch if zero
    5333/    3BE4 :                     
    5334/    3BE4 : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get FAC1
    5335/    3BE8 : D0BC 0000 0080      	ADD.l		#$80,d0				; round to 24 bit
    5336/    3BEE : 640A                	BCC.s		LAB_27C3				; branch if no overflow
    5337/    3BF0 :                     
    5338/    3BF0 : E290                	ROXR.l	#1,d0					; shift FAC1 mantissa
    5339/    3BF2 : 522B 0594           	ADDQ.b	#1,FAC1_e(a3)			; correct exponent
    5340/    3BF6 : 6500 E560           	BCS		LAB_OFER				; if carry do overflow error & warm start
    5341/    3BFA :                     
    5342/    3BFA :                     LAB_27C3
    5343/    3BFA : C03C 0000           	AND.b		#$00,d0				; clear guard byte
    5344/    3BFE : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; save back to FAC1
    5345/    3C02 : 4E75                	RTS
    5346/    3C04 :                     
    5347/    3C04 :                     LAB_27C4
    5348/    3C04 : 1740 0595           	MOVE.b	d0,FAC1_s(a3)			; make zero always +ve
    5349/    3C08 :                     RTS_017
    5350/    3C08 : 4E75                	RTS
    5351/    3C0A :                     
    5352/    3C0A :                     
    5353/    3C0A :                     ;************************************************************************************
    5354/    3C0A :                     ;
    5355/    3C0A :                     ; get FAC1 sign
    5356/    3C0A :                     ; return d0=-1,C=1/-ve d0=+1,C=0/+ve
    5357/    3C0A :                     
    5358/    3C0A :                     LAB_27CA
    5359/    3C0A : 7000                	MOVEQ		#0,d0					; clear d0
    5360/    3C0C : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
    5361/    3C10 : 67F6                	BEQ.s		RTS_017				; exit if zero (already correct SGN(0)=0)
    5362/    3C12 :                     
    5363/    3C12 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 94 - 11/4/2023 8:40:20


    5364/    3C12 :                     ;************************************************************************************
    5365/    3C12 :                     ;
    5366/    3C12 :                     ; return d0=-1,C=1/-ve d0=+1,C=0/+ve
    5367/    3C12 :                     ; no = 0 check
    5368/    3C12 :                     
    5369/    3C12 :                     LAB_27CE
    5370/    3C12 : 102B 0595           	MOVE.b	FAC1_s(a3),d0			; else get FAC1 sign (b7)
    5371/    3C16 :                     
    5372/    3C16 :                     
    5373/    3C16 :                     ;************************************************************************************
    5374/    3C16 :                     ;
    5375/    3C16 :                     ; return d0=-1,C=1/-ve d0=+1,C=0/+ve
    5376/    3C16 :                     ; no = 0 check, sign in d0
    5377/    3C16 :                     
    5378/    3C16 :                     LAB_27D0
    5379/    3C16 : 4880                	EXT.w		d0					; make word
    5380/    3C18 : 48C0                	EXT.l		d0					; make longword
    5381/    3C1A : E080                	ASR.l		#8,d0					; move sign bit through byte to carry
    5382/    3C1C : 65EA                	BCS.s		RTS_017				; exit if carry set
    5383/    3C1E :                     
    5384/    3C1E : 7001                	MOVEQ		#1,d0					; set result for +ve sign
    5385/    3C20 : 4E75                	RTS
    5386/    3C22 :                     
    5387/    3C22 :                     
    5388/    3C22 :                     ;************************************************************************************
    5389/    3C22 :                     ;
    5390/    3C22 :                     ; perform SGN()
    5391/    3C22 :                     
    5392/    3C22 :                     LAB_SGN
    5393/    3C22 : 61E6                	BSR.s		LAB_27CA				; get FAC1 sign
    5394/    3C24 :                     								; return d0=-1/-ve d0=+1/+ve
    5395/    3C24 :                     
    5396/    3C24 :                     
    5397/    3C24 :                     ;************************************************************************************
    5398/    3C24 :                     ;
    5399/    3C24 :                     ; save d0 as integer longword
    5400/    3C24 :                     
    5401/    3C24 :                     LAB_27DB
    5402/    3C24 : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; save FAC1 mantissa
    5403/    3C28 : 377C A000 0594      	MOVE.w	#$A000,FAC1_e(a3)			; set FAC1 exponent & sign
    5404/    3C2E : D080                	ADD.l		d0,d0					; top bit into carry
    5405/    3C30 : 6000 FCD0           	BRA		LAB_24D0				; do +/- (carry is sign) & normalise FAC1
    5406/    3C34 :                     
    5407/    3C34 :                     
    5408/    3C34 :                     ;************************************************************************************
    5409/    3C34 :                     ;
    5410/    3C34 :                     ; perform ABS()
    5411/    3C34 :                     
    5412/    3C34 :                     LAB_ABS
    5413/    3C34 : 177C 0000 0595      	MOVE.b	#0,FAC1_s(a3)			; clear FAC1 sign
    5414/    3C3A : 4E75                	RTS
    5415/    3C3C :                     
    5416/    3C3C :                     
    5417/    3C3C :                     ;************************************************************************************
    5418/    3C3C :                     ;
    5419/    3C3C :                     ; compare FAC1 with FAC2
    5420/    3C3C :                     ; returns d0=+1 Cb=0 if FAC1 > FAC2
    5421/    3C3C :                     ; returns d0= 0 Cb=0 if FAC1 = FAC2
    5422/    3C3C :                     ; returns d0=-1 Cb=1 if FAC1 < FAC2
    5423/    3C3C :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 95 - 11/4/2023 8:40:20


    5424/    3C3C :                     LAB_27FA
    5425/    3C3C : 122B 059C           	MOVE.b	FAC2_e(a3),d1			; get FAC2 exponent
    5426/    3C40 : 67C8                	BEQ.s		LAB_27CA				; branch if FAC2 exponent=0 & get FAC1 sign
    5427/    3C42 :                     								; d0=-1,C=1/-ve d0=+1,C=0/+ve
    5428/    3C42 :                     
    5429/    3C42 : 102B 059E           	MOVE.b	FAC_sc(a3),d0			; get FAC sign compare
    5430/    3C46 : 6BCA                	BMI.s		LAB_27CE				; if signs <> do return d0=-1,C=1/-ve
    5431/    3C48 :                     								; d0=+1,C=0/+ve & return
    5432/    3C48 :                     
    5433/    3C48 : 102B 0595           	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
    5434/    3C4C : B22B 0594           	CMP.b		FAC1_e(a3),d1			; compare FAC1 exponent with FAC2 exponent
    5435/    3C50 : 660A                	BNE.s		LAB_2828				; branch if different
    5436/    3C52 :                     
    5437/    3C52 : 222B 0598           	MOVE.l	FAC2_m(a3),d1			; get FAC2 mantissa
    5438/    3C56 : B2AB 0590           	CMP.l		FAC1_m(a3),d1			; compare mantissas
    5439/    3C5A : 6708                	BEQ.s		LAB_282F				; exit if mantissas equal
    5440/    3C5C :                     
    5441/    3C5C :                     ; gets here if number <> FAC1
    5442/    3C5C :                     
    5443/    3C5C :                     LAB_2828
    5444/    3C5C : 65B8                	BCS.s		LAB_27D0				; if FAC1 > FAC2 return d0=-1,C=1/-ve d0=+1,
    5445/    3C5E :                     								; C=0/+ve
    5446/    3C5E :                     
    5447/    3C5E : 0A00 0080           	EORI.b	#$80,d0				; else toggle FAC1 sign
    5448/    3C62 :                     LAB_282E
    5449/    3C62 : 60B2                	BRA.s		LAB_27D0				; return d0=-1,C=1/-ve d0=+1,C=0/+ve
    5450/    3C64 :                     
    5451/    3C64 :                     LAB_282F
    5452/    3C64 : 7000                	MOVEQ		#0,d0					; clear result
    5453/    3C66 : 4E75                	RTS
    5454/    3C68 :                     
    5455/    3C68 :                     
    5456/    3C68 :                     ;************************************************************************************
    5457/    3C68 :                     ;
    5458/    3C68 :                     ; convert FAC1 floating to fixed
    5459/    3C68 :                     ; result in d0 and Itemp, sets flags correctly
    5460/    3C68 :                     
    5461/    3C68 :                     LAB_2831
    5462/    3C68 : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; copy mantissa
    5463/    3C6C : 6732                	BEQ.s		LAB_284J				; branch if mantissa = 0
    5464/    3C6E :                     
    5465/    3C6E : 2F01                	MOVE.l	d1,-(sp)				; save d1
    5466/    3C70 : 123C 00A0           	MOVE.b		#$A0,d1				; set for no floating bits
    5467/    3C74 : 922B 0594           	SUB.b		FAC1_e(a3),d1			; subtract FAC1 exponent
    5468/    3C78 : 6500 E4DE           	BCS		LAB_OFER				; do overflow if too big
    5469/    3C7C :                     
    5470/    3C7C : 660E                	BNE.s		LAB_284G				; branch if exponent was not $A0
    5471/    3C7E :                     
    5472/    3C7E : 4A2B 0595           	TST.b		FAC1_s(a3)				; test FAC1 sign
    5473/    3C82 : 6A1A                	BPL.s		LAB_284H				; branch if FAC1 +ve
    5474/    3C84 :                     
    5475/    3C84 : 4480                	NEG.l		d0
    5476/    3C86 : 6916                	BVS.s		LAB_284H				; branch if was $80000000
    5477/    3C88 :                     
    5478/    3C88 : 6000 E4CE           	BRA		LAB_OFER				; do overflow if too big
    5479/    3C8C :                     
    5480/    3C8C :                     LAB_284G
    5481/    3C8C : B23C 0020           	CMP.b		#$20,d1				; compare with minimum result for integer
    5482/    3C90 : 6502                	BCS.s		LAB_284L				; if < minimum just do shift
    5483/    3C92 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 96 - 11/4/2023 8:40:20


    5484/    3C92 : 7000                	MOVEQ		#0,d0					; else return zero
    5485/    3C94 :                     LAB_284L
    5486/    3C94 : E2A8                	LSR.l		d1,d0					; shift integer
    5487/    3C96 :                     
    5488/    3C96 : 4A2B 0595           	TST.b		FAC1_s(a3)				; test FAC1 sign (b7)
    5489/    3C9A : 6A02                	BPL.s		LAB_284H				; branch if FAC1 +ve
    5490/    3C9C :                     
    5491/    3C9C : 4480                	NEG.l		d0					; negate integer value
    5492/    3C9E :                     LAB_284H
    5493/    3C9E : 221F                	MOVE.l	(sp)+,d1				; restore d1
    5494/    3CA0 :                     LAB_284J
    5495/    3CA0 : 2740 042A           	MOVE.l	d0,Itemp(a3)			; save result to Itemp
    5496/    3CA4 : 4E75                	RTS
    5497/    3CA6 :                     
    5498/    3CA6 :                     
    5499/    3CA6 :                     ;************************************************************************************
    5500/    3CA6 :                     ;
    5501/    3CA6 :                     ; perform INT()
    5502/    3CA6 :                     
    5503/    3CA6 :                     LAB_INT
    5504/    3CA6 : 103C 00A0           	MOVE.b		#$A0,d0				; set for no floating bits
    5505/    3CAA : 902B 0594           	SUB.b		FAC1_e(a3),d0			; subtract FAC1 exponent
    5506/    3CAE : 6310                	BLS.s		LAB_IRTS				; exit if exponent >= $A0
    5507/    3CB0 :                     								; (too big for fraction part!)
    5508/    3CB0 :                     
    5509/    3CB0 : B03C 0020           	CMP.b		#$20,d0				; compare with minimum result for integer
    5510/    3CB4 : 6400 0262           	BCC		LAB_POZE				; if >= minimum go return 0
    5511/    3CB8 :                     								; (too small for integer part!)
    5512/    3CB8 :                     
    5513/    3CB8 : 72FF                	MOVEQ		#-1,d1				; set integer mask
    5514/    3CBA : E1A1                	ASL.l		d0,d1					; shift mask [8+2*d0]
    5515/    3CBC : C3AB 0590           	AND.l		d1,FAC1_m(a3)			; mask mantissa
    5516/    3CC0 :                     LAB_IRTS
    5517/    3CC0 : 4E75                	RTS
    5518/    3CC2 :                     
    5519/    3CC2 :                     
    5520/    3CC2 :                     ;************************************************************************************
    5521/    3CC2 :                     ;
    5522/    3CC2 :                     ; print " in line [LINE #]"
    5523/    3CC2 :                     
    5524/    3CC2 :                     LAB_2953
    5525/    3CC2 : 41FA 1800           	LEA		LAB_LMSG(pc),a0			; point to " in line " message
    5526/    3CC6 : 6100 ED1C           	BSR		LAB_18C3				; print null terminated string
    5527/    3CCA :                     
    5528/    3CCA :                     								; Print Basic line #
    5529/    3CCA : 202B 0452           	MOVE.l	Clinel(a3),d0			; get current line
    5530/    3CCE :                     
    5531/    3CCE :                     
    5532/    3CCE :                     ;************************************************************************************
    5533/    3CCE :                     ;
    5534/    3CCE :                     ; print d0 as unsigned integer
    5535/    3CCE :                     
    5536/    3CCE :                     LAB_295E
    5537/    3CCE : 43FA 0DEE           	LEA		Bin2dec(pc),a1			; get table address
    5538/    3CD2 : 7200                	MOVEQ		#0,d1					; table index
    5539/    3CD4 : 41EB 05CC           	LEA		Usdss(a3),a0			; output string start
    5540/    3CD8 : 2401                	MOVE.l	d1,d2					; output string index
    5541/    3CDA :                     LAB_2967
    5542/    3CDA : 2631 1000           	MOVE.l	(a1,d1.w),d3			; get table value
    5543/    3CDE : 6714                	BEQ.s		LAB_2969				; exit if end marker
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 97 - 11/4/2023 8:40:20


    5544/    3CE0 :                     
    5545/    3CE0 : 782F                	MOVEQ		#'0'-1,d4				; set character to "0"-1
    5546/    3CE2 :                     LAB_2968
    5547/    3CE2 : 5244                	ADDQ.w	#1,d4					; next numeric character
    5548/    3CE4 : 9083                	SUB.l		d3,d0					; subtract table value
    5549/    3CE6 : 6AFA                	BPL.s		LAB_2968				; not overdone so loop
    5550/    3CE8 :                     
    5551/    3CE8 : D083                	ADD.l		d3,d0					; correct value
    5552/    3CEA : 1184 2000           	MOVE.b	d4,(a0,d2.w)			; character out to string
    5553/    3CEE : 5841                	ADDQ.w	#4,d1					; increment table pointer
    5554/    3CF0 : 5242                	ADDQ.w	#1,d2					; increment output string pointer
    5555/    3CF2 : 60E6                	BRA.s		LAB_2967				; loop
    5556/    3CF4 :                     
    5557/    3CF4 :                     LAB_2969
    5558/    3CF4 : D03C 0030           	ADD.b		#'0',d0				; make last character
    5559/    3CF8 : 1180 2000           	MOVE.b	d0,(a0,d2.w)			; character out to string
    5560/    3CFC : 5348                	SUBQ.w	#1,a0					; decrement a0 (allow simple loop)
    5561/    3CFE :                     
    5562/    3CFE :                     								; now find non zero start of string
    5563/    3CFE :                     LAB_296A
    5564/    3CFE : 5248                	ADDQ.w	#1,a0					; increment a0 (this will never carry to b16)
    5565/    3D00 : 43EB 05D5           	LEA		BHsend-1(a3),a1			; get string end
    5566/    3D04 : B1C9                	CMPA.l	a1,a0					; are we at end
    5567/    3D06 : 6700 ECDC           	BEQ		LAB_18C3				; if so print null terminated string and RETURN
    5568/    3D0A :                     
    5569/    3D0A : 0C10 0030           	CMPI.b	#'0',(a0)				; is character "0" ?
    5570/    3D0E : 67EE                	BEQ.s		LAB_296A				; loop if so
    5571/    3D10 :                     
    5572/    3D10 : 6000 ECD2           	BRA		LAB_18C3				; print null terminated string from memory & RET
    5573/    3D14 :                     
    5574/    3D14 :                     
    5575/    3D14 :                     ;************************************************************************************
    5576/    3D14 :                     ;
    5577/    3D14 :                     ; convert FAC1 to ASCII string result in (a0)
    5578/    3D14 :                     ; STR$() function enters here
    5579/    3D14 :                     
    5580/    3D14 :                     ; now outputs 7 significant digits
    5581/    3D14 :                     
    5582/    3D14 :                     ; d0 is character out
    5583/    3D14 :                     ; d1 is save index
    5584/    3D14 :                     ; d2 is gash
    5585/    3D14 :                     
    5586/    3D14 :                     ; a0 is output string pointer
    5587/    3D14 :                     
    5588/    3D14 :                     LAB_2970
    5589/    3D14 : 43EB 05C6           	LEA		Decss(a3),a1			; set output string start
    5590/    3D18 :                     
    5591/    3D18 : 7420                	MOVEQ		#' ',d2				; character = " ", assume +ve
    5592/    3D1A : 08AB 0007 0595      	BCLR.b	#7,FAC1_s(a3)			; test and clear FAC1 sign (b7)
    5593/    3D20 : 6702                	BEQ.s		LAB_2978				; branch if +ve
    5594/    3D22 :                     
    5595/    3D22 : 742D                	MOVEQ		#'-',d2				; else character = "-"
    5596/    3D24 :                     LAB_2978
    5597/    3D24 : 1282                	MOVE.b	d2,(a1)				; save the sign character
    5598/    3D26 : 142B 0594           	MOVE.b	FAC1_e(a3),d2			; get FAC1 exponent
    5599/    3D2A : 6608                	BNE.s		LAB_2989				; branch if FAC1<>0
    5600/    3D2C :                     
    5601/    3D2C :                     								; exponent was $00 so FAC1 is 0
    5602/    3D2C : 7030                	MOVEQ		#'0',d0				; set character = "0"
    5603/    3D2E : 7201                	MOVEQ		#1,d1					; set output string index
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 98 - 11/4/2023 8:40:20


    5604/    3D30 : 6000 01A8           	BRA		LAB_2A89				; save last character, [EOT] & exit
    5605/    3D34 :                     
    5606/    3D34 :                     								; FAC1 is some non zero value
    5607/    3D34 :                     LAB_2989
    5608/    3D34 : 177C 0000 05AC      	MOVE.b	#0,numexp(a3)			; clear number exponent count
    5609/    3D3A : B43C 0081           	CMP.b		#$81,d2				; compare FAC1 exponent with $81 (>1.00000)
    5610/    3D3E :                     
    5611/    3D3E : 6448                	BCC.s		LAB_299C				; branch if FAC1=>1
    5612/    3D40 :                     
    5613/    3D40 :                     								; else FAC1 < 1
    5614/    3D40 : 277C 9896 8000      	MOVE.l	#$98968000,FAC2_m(a3)		; 10000000 mantissa
             3D46 : 0598             
    5615/    3D48 : 377C 9800 059C      	MOVE.w	#$9800,FAC2_e(a3)			; 10000000 exponent & sign
    5616/    3D4E : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; make FAC1 sign sign compare
    5617/    3D54 : 6100 FCE0           	BSR		LAB_MULTIPLY			; do FAC2*FAC1
    5618/    3D58 :                     
    5619/    3D58 : 177C 00F9 05AC      	MOVE.b	#$F9,numexp(a3)			; set number exponent count (-7)
    5620/    3D5E : 6028                	BRA.s		LAB_299C				; go test for fit
    5621/    3D60 :                     
    5622/    3D60 :                     LAB_29B9
    5623/    3D60 : 376B 0594 059C      	MOVE.w	FAC1_e(a3),FAC2_e(a3)		; copy exponent & sign from FAC1 to FAC2
    5624/    3D66 : 276B 0590 0598      	MOVE.l	FAC1_m(a3),FAC2_m(a3)		; copy FAC1 mantissa to FAC2 mantissa
    5625/    3D6C : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; save FAC1_s as sign compare
    5626/    3D72 :                     
    5627/    3D72 : 277C CCCC CCCD      	MOVE.l	#$CCCCCCCD,FAC1_m(a3)		; 1/10 mantissa
             3D78 : 0590             
    5628/    3D7A : 377C 7D00 0594      	MOVE.w	#$7D00,FAC1_e(a3)			; 1/10 exponent & sign
    5629/    3D80 : 6100 FCB4           	BSR		LAB_MULTIPLY			; do FAC2*FAC1, effectively divide by 10 but
    5630/    3D84 :                     								; faster
    5631/    3D84 :                     
    5632/    3D84 : 522B 05AC           	ADDQ.b	#1,numexp(a3)			; increment number exponent count
    5633/    3D88 :                     LAB_299C
    5634/    3D88 : 277C 9896 7F70      	MOVE.l	#$98967F70,FAC2_m(a3)		; 9999999.4375 mantissa
             3D8E : 0598             
    5635/    3D90 : 377C 9800 059C      	MOVE.w	#$9800,FAC2_e(a3)			; 9999999.4375 exponent & sign
    5636/    3D96 :                     								; (max before scientific notation)
    5637/    3D96 : 6100 0150           	BSR		LAB_27F0				; fast compare FAC1 with FAC2
    5638/    3D9A :                     								; returns d0=+1 C=0 if FAC1 > FAC2
    5639/    3D9A :                     								; returns d0= 0 C=0 if FAC1 = FAC2
    5640/    3D9A :                     								; returns d0=-1 C=1 if FAC1 < FAC2
    5641/    3D9A : 62C4                	BHI.s		LAB_29B9				; go do /10 if FAC1 > 9999999.4375
    5642/    3D9C :                     
    5643/    3D9C : 6750                	BEQ.s		LAB_29C3				; branch if FAC1 = 9999999.4375
    5644/    3D9E :                     
    5645/    3D9E :                     								; FAC1 < 9999999.4375
    5646/    3D9E : 277C F423 F800      	MOVE.l	#$F423F800,FAC2_m(a3)		; set mantissa for 999999.5
             3DA4 : 0598             
    5647/    3DA6 : 377C 9400 059C      	MOVE.w	#$9400,FAC2_e(a3)			; set exponent for 999999.5
    5648/    3DAC :                     
    5649/    3DAC : 41EB 0590           	LEA		FAC1_m(a3),a0			; set pointer for x10
    5650/    3DB0 :                     LAB_29A7
    5651/    3DB0 : 6100 0136           	BSR		LAB_27F0				; fast compare FAC1 with FAC2
    5652/    3DB4 :                     								; returns d0=+1 C=0 if FAC1 > FAC2
    5653/    3DB4 :                     								; returns d0= 0 C=0 if FAC1 = FAC2
    5654/    3DB4 :                     								; returns d0=-1 C=1 if FAC1 < FAC2
    5655/    3DB4 : 6220                	BHI.s		LAB_29C0				; branch if FAC1 > 99999.9375,no decimal places
    5656/    3DB6 :                     
    5657/    3DB6 :                     								; FAC1 <= 999999.5 so do x 10
    5658/    3DB6 : 2010                	MOVE.l	(a0),d0				; get FAC1 mantissa
    5659/    3DB8 : 1228 0004           	MOVE.b	4(a0),d1				; get FAC1 exponent
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 99 - 11/4/2023 8:40:20


    5660/    3DBC : 2400                	MOVE.l	d0,d2					; copy it
    5661/    3DBE : E488                	LSR.l		#2,d0					; /4
    5662/    3DC0 : D082                	ADD.l		d2,d0					; add FAC1 (x1.125)
    5663/    3DC2 : 6404                	BCC.s		LAB_29B7				; branch if no carry
    5664/    3DC4 :                     
    5665/    3DC4 : E290                	ROXR.l	#1,d0					; shift carry back in
    5666/    3DC6 : 5201                	ADDQ.b	#1,d1					; increment exponent (never overflows)
    5667/    3DC8 :                     LAB_29B7
    5668/    3DC8 : 5601                	ADDQ.b	#3,d1					; correct exponent ( 8 x 1.125 = 10 )
    5669/    3DCA :                     								; (never overflows)
    5670/    3DCA : 2080                	MOVE.l	d0,(a0)				; save new mantissa
    5671/    3DCC : 1141 0004           	MOVE.b	d1,4(a0)				; save new exponent
    5672/    3DD0 : 532B 05AC           	SUBQ.b	#1,numexp(a3)			; decrement number exponent count
    5673/    3DD4 : 60DA                	BRA.s		LAB_29A7				; go test again
    5674/    3DD6 :                     
    5675/    3DD6 :                     								; now we have just the digits to do
    5676/    3DD6 :                     LAB_29C0
    5677/    3DD6 : 277C 8000 0000      	MOVE.l	#$80000000,FAC2_m(a3)		; set mantissa for 0.5
             3DDC : 0598             
    5678/    3DDE : 377C 8000 059C      	MOVE.w	#$8000,FAC2_e(a3)			; set exponent for 0.5
    5679/    3DE4 : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; sign compare = sign
    5680/    3DEA : 6100 FAA6           	BSR		LAB_ADD				; add the 0.5 to FAC1 (round FAC1)
    5681/    3DEE :                     
    5682/    3DEE :                     LAB_29C3
    5683/    3DEE : 6100 FE78           	BSR		LAB_2831				; convert FAC1 floating to fixed
    5684/    3DF2 :                     								; result in d0 and Itemp
    5685/    3DF2 : 7401                	MOVEQ		#$01,d2				; set default digits before dp = 1
    5686/    3DF4 : 102B 05AC           	MOVE.b	numexp(a3),d0			; get number exponent count
    5687/    3DF8 : D03C 0008           	ADD.b		#8,d0					; allow 7 digits before point
    5688/    3DFC : 6B0C                	BMI.s		LAB_29D9				; if -ve then 1 digit before dp
    5689/    3DFE :                     
    5690/    3DFE : B03C 0009           	CMP.b		#$09,d0				; d0>=9 if n>=1E7
    5691/    3E02 : 6406                	BCC.s		LAB_29D9				; branch if >= $09
    5692/    3E04 :                     
    5693/    3E04 :                     								; < $08
    5694/    3E04 : 5300                	SUBQ.b	#1,d0					; take 1 from digit count
    5695/    3E06 : 1400                	MOVE.b	d0,d2					; copy byte
    5696/    3E08 : 7002                	MOVEQ		#$02,d0				; set exponent adjust
    5697/    3E0A :                     LAB_29D9
    5698/    3E0A : 7200                	MOVEQ		#0,d1					; set output string index
    5699/    3E0C : 5500                	SUBQ.b	#2,d0					; -2
    5700/    3E0E : 1740 05AD           	MOVE.b	d0,expcnt(a3)			; save exponent adjust
    5701/    3E12 : 1742 05AC           	MOVE.b	d2,numexp(a3)			; save digits before dp count
    5702/    3E16 : 1002                	MOVE.b	d2,d0					; copy digits before dp count
    5703/    3E18 : 6702                	BEQ.s		LAB_29E4				; branch if no digits before dp
    5704/    3E1A :                     
    5705/    3E1A : 6A14                	BPL.s		LAB_29F7				; branch if digits before dp
    5706/    3E1C :                     
    5707/    3E1C :                     LAB_29E4
    5708/    3E1C : 5281                	ADDQ.l	#1,d1					; increment index
    5709/    3E1E : 13BC 002E 1000      	MOVE.b	#'.',(a1,d1.w)			; save to output string
    5710/    3E24 :                     
    5711/    3E24 : 4A02                	TST.b		d2					; test digits before dp count
    5712/    3E26 : 6708                	BEQ.s		LAB_29F7				; branch if no digits before dp
    5713/    3E28 :                     
    5714/    3E28 : 5281                	ADDQ.l	#1,d1					; increment index
    5715/    3E2A : 13BC 0030 1000      	MOVE.b	#'0',(a1,d1.w)			; save to output string
    5716/    3E30 :                     LAB_29F7
    5717/    3E30 : 7400                	MOVEQ		#0,d2					; clear index (point to 1,000,000)
    5718/    3E32 : 7080                	MOVEQ		#$80-$100,d0			; set output character
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 100 - 11/4/2023 8:40:20


    5719/    3E34 :                     LAB_29FB
    5720/    3E34 : 41FA 1122           	LEA		LAB_2A9A(pc),a0			; get base of table
    5721/    3E38 : 2630 2000           	MOVE.l	(a0,d2.w),d3			; get table value
    5722/    3E3C :                     LAB_29FD
    5723/    3E3C : 5200                	ADDQ.b	#1,d0					; increment output character
    5724/    3E3E : D7AB 042A           	ADD.l		d3,Itemp(a3)			; add to (now fixed) mantissa
    5725/    3E42 : 0800 0007           	BTST		#7,d0					; set test sense (z flag only)
    5726/    3E46 : 6504                	BCS.s		LAB_2A18				; did carry so has wrapped past zero
    5727/    3E48 :                     
    5728/    3E48 : 67F2                	BEQ.s		LAB_29FD				; no wrap and +ve test so try again
    5729/    3E4A :                     
    5730/    3E4A : 6002                	BRA.s		LAB_2A1A				; found this digit
    5731/    3E4C :                     
    5732/    3E4C :                     LAB_2A18
    5733/    3E4C : 66EE                	BNE.s		LAB_29FD				; wrap and -ve test so try again
    5734/    3E4E :                     
    5735/    3E4E :                     LAB_2A1A
    5736/    3E4E : 6406                	BCC.s		LAB_2A21				; branch if +ve test result
    5737/    3E50 :                     
    5738/    3E50 : 4400                	NEG.b		d0					; negate the digit number
    5739/    3E52 : D03C 000B           	ADD.b		#$0B,d0				; and subtract from 11 decimal
    5740/    3E56 :                     LAB_2A21
    5741/    3E56 : D03C 002F           	ADD.b		#$2F,d0				; add "0"-1 to result
    5742/    3E5A : 5842                	ADDQ.w	#4,d2					; increment index to next less power of ten
    5743/    3E5C : 5241                	ADDQ.w	#1,d1					; increment output string index
    5744/    3E5E : 1600                	MOVE.b	d0,d3					; copy character to d3
    5745/    3E60 : C63C 007F           	AND.b		#$7F,d3				; mask out top bit
    5746/    3E64 : 1383 1000           	MOVE.b	d3,(a1,d1.w)			; save to output string
    5747/    3E68 : 042B 0001 05AC      	SUB.b		#1,numexp(a3)			; decrement # of characters before the dp
    5748/    3E6E : 6608                	BNE.s		LAB_2A3B				; branch if still characters to do
    5749/    3E70 :                     
    5750/    3E70 :                     								; else output the point
    5751/    3E70 : 5281                	ADDQ.l	#1,d1					; increment index
    5752/    3E72 : 13BC 002E 1000      	MOVE.b	#'.',(a1,d1.w)			; save to output string
    5753/    3E78 :                     LAB_2A3B
    5754/    3E78 : C03C 0080           	AND.b		#$80,d0				; mask test sense bit
    5755/    3E7C : 0A00 0080           	EORI.b	#$80,d0				; invert it
    5756/    3E80 : B43C 001C           	CMP.b		#LAB_2A9B-LAB_2A9A,d2		; compare table index with max+4
    5757/    3E84 : 66AE                	BNE.s		LAB_29FB				; loop if not max
    5758/    3E86 :                     
    5759/    3E86 :                     								; now remove trailing zeroes
    5760/    3E86 :                     LAB_2A4B
    5761/    3E86 : 1031 1000           	MOVE.b	(a1,d1.w),d0			; get character from output string
    5762/    3E8A : 5381                	SUBQ.l	#1,d1					; decrement output string index
    5763/    3E8C : B03C 0030           	CMP.b		#'0',d0				; compare with "0"
    5764/    3E90 : 67F4                	BEQ.s		LAB_2A4B				; loop until non "0" character found
    5765/    3E92 :                     
    5766/    3E92 : B03C 002E           	CMP.b		#'.',d0				; compare with "."
    5767/    3E96 : 6702                	BEQ.s		LAB_2A58				; branch if was dp
    5768/    3E98 :                     
    5769/    3E98 :                     								; else restore last character
    5770/    3E98 : 5281                	ADDQ.l	#1,d1					; increment output string index
    5771/    3E9A :                     LAB_2A58
    5772/    3E9A : 13BC 002B 1002      	MOVE.b	#'+',2(a1,d1.w)			; save character "+" to output string
    5773/    3EA0 : 4A2B 05AD           	TST.b		expcnt(a3)				; test exponent count
    5774/    3EA4 : 6738                	BEQ.s		LAB_2A8C				; if zero go set null terminator & exit
    5775/    3EA6 :                     
    5776/    3EA6 :                     								; exponent isn't zero so write exponent
    5777/    3EA6 : 6A0A                	BPL.s		LAB_2A68				; branch if exponent count +ve
    5778/    3EA8 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 101 - 11/4/2023 8:40:20


    5779/    3EA8 : 13BC 002D 1002      	MOVE.b	#'-',2(a1,d1.w)			; save character "-" to output string
    5780/    3EAE : 442B 05AD           	NEG.b		expcnt(a3)				; convert -ve to +ve
    5781/    3EB2 :                     LAB_2A68
    5782/    3EB2 : 13BC 0045 1001      	MOVE.b	#'E',1(a1,d1.w)			; save character "E" to output string
    5783/    3EB8 : 142B 05AD           	MOVE.b	expcnt(a3),d2			; get exponent count
    5784/    3EBC : 702F                	MOVEQ		#$2F,d0				; one less than "0" character
    5785/    3EBE :                     LAB_2A74
    5786/    3EBE : 5200                	ADDQ.b	#1,d0					; increment 10's character
    5787/    3EC0 : 943C 000A           	SUB.b		#$0A,d2				; subtract 10 from exponent count
    5788/    3EC4 : 64F8                	BCC.s		LAB_2A74				; loop while still >= 0
    5789/    3EC6 :                     
    5790/    3EC6 : D43C 003A           	ADD.b		#$3A,d2				; add character ":", $30+$0A, result is 10-value
    5791/    3ECA : 1380 1003           	MOVE.b	d0,3(a1,d1.w)			; save 10's character to output string
    5792/    3ECE : 1382 1004           	MOVE.b	d2,4(a1,d1.w)			; save 1's character to output string
    5793/    3ED2 : 13BC 0000 1005      	MOVE.b	#0,5(a1,d1.w)			; save null terminator after last character
    5794/    3ED8 : 600A                	BRA.s		LAB_2A91				; go set string pointer (a0) and exit
    5795/    3EDA :                     
    5796/    3EDA :                     LAB_2A89
    5797/    3EDA : 1380 1000           	MOVE.b	d0,(a1,d1.w)			; save last character to output string
    5798/    3EDE :                     LAB_2A8C
    5799/    3EDE : 13BC 0000 1001      	MOVE.b	#0,1(a1,d1.w)			; save null terminator after last character
    5800/    3EE4 :                     LAB_2A91
    5801/    3EE4 : 2049                	MOVEA.l	a1,a0					; set result string pointer (a0)
    5802/    3EE6 : 4E75                	RTS
    5803/    3EE8 :                     
    5804/    3EE8 :                     
    5805/    3EE8 :                     ;************************************************************************************
    5806/    3EE8 :                     ;
    5807/    3EE8 :                     ; fast compare FAC1 with FAC2
    5808/    3EE8 :                     ; assumes both are +ve and FAC2>0
    5809/    3EE8 :                     ; returns d0=+1 C=0 if FAC1 > FAC2
    5810/    3EE8 :                     ; returns d0= 0 C=0 if FAC1 = FAC2
    5811/    3EE8 :                     ; returns d0=-1 C=1 if FAC1 < FAC2
    5812/    3EE8 :                     
    5813/    3EE8 :                     LAB_27F0
    5814/    3EE8 : 7000                	MOVEQ		#0,d0					; set for FAC1 = FAC2
    5815/    3EEA : 122B 059C           	MOVE.b	FAC2_e(a3),d1			; get FAC2 exponent
    5816/    3EEE : B22B 0594           	CMP.b		FAC1_e(a3),d1			; compare FAC1 exponent with FAC2 exponent
    5817/    3EF2 : 660A                	BNE.s		LAB_27F1				; branch if different
    5818/    3EF4 :                     
    5819/    3EF4 : 222B 0598           	MOVE.l	FAC2_m(a3),d1			; get FAC2 mantissa
    5820/    3EF8 : B2AB 0590           	CMP.l		FAC1_m(a3),d1			; compare mantissas
    5821/    3EFC : 6708                	BEQ.s		LAB_27F3				; exit if mantissas equal
    5822/    3EFE :                     
    5823/    3EFE :                     LAB_27F1
    5824/    3EFE : 6504                	BCS.s		LAB_27F2				; if FAC1 > FAC2 return d0=+1,C=0
    5825/    3F00 :                     
    5826/    3F00 : 5380                	SUBQ.l	#1,d0					; else FAC1 < FAC2 return d0=-1,C=1
    5827/    3F02 : 4E75                	RTS
    5828/    3F04 :                     
    5829/    3F04 :                     LAB_27F2
    5830/    3F04 : 5280                	ADDQ.l	#1,d0
    5831/    3F06 :                     LAB_27F3
    5832/    3F06 : 4E75                	RTS
    5833/    3F08 :                     
    5834/    3F08 :                     
    5835/    3F08 :                     ;************************************************************************************
    5836/    3F08 :                     ;
    5837/    3F08 :                     ; make FAC1 = 1
    5838/    3F08 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 102 - 11/4/2023 8:40:20


    5839/    3F08 :                     LAB_POON
    5840/    3F08 : 277C 8000 0000      	MOVE.l	#$80000000,FAC1_m(a3)		; 1 mantissa
             3F0E : 0590             
    5841/    3F10 : 377C 8100 0594      	MOVE.w	#$8100,FAC1_e(a3)			; 1 exonent & sign
    5842/    3F16 : 4E75                	RTS
    5843/    3F18 :                     
    5844/    3F18 :                     
    5845/    3F18 :                     ;************************************************************************************
    5846/    3F18 :                     ;
    5847/    3F18 :                     ; make FAC1 = 0
    5848/    3F18 :                     
    5849/    3F18 :                     LAB_POZE
    5850/    3F18 : 7000                	MOVEQ		#0,d0					; clear longword
    5851/    3F1A : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; 0 mantissa
    5852/    3F1E : 3740 0594           	MOVE.w	d0,FAC1_e(a3)			; 0 exonent & sign
    5853/    3F22 : 4E75                	RTS
    5854/    3F24 :                     
    5855/    3F24 :                     
    5856/    3F24 :                     ;************************************************************************************
    5857/    3F24 :                     ;
    5858/    3F24 :                     ; perform power function
    5859/    3F24 :                     ; the number is in FAC2, the power is in FAC1
    5860/    3F24 :                     ; no longer trashes Itemp
    5861/    3F24 :                     
    5862/    3F24 :                     LAB_POWER
    5863/    3F24 : 4A2B 0594           	TST.b		FAC1_e(a3)				; test power
    5864/    3F28 : 67DE                	BEQ.s		LAB_POON				; if zero go return 1
    5865/    3F2A :                     
    5866/    3F2A : 4A2B 059C           	TST.b		FAC2_e(a3)				; test number
    5867/    3F2E : 67E8                	BEQ.s		LAB_POZE				; if zero go return 0
    5868/    3F30 :                     
    5869/    3F30 : 1F2B 059D           	MOVE.b	FAC2_s(a3),-(sp)			; save number sign
    5870/    3F34 : 6A20                	BPL.s		LAB_POWP				; power of positive number
    5871/    3F36 :                     
    5872/    3F36 : 7200                	MOVEQ		#0,d1					; clear d1
    5873/    3F38 : 1741 059D           	MOVE.b	d1,FAC2_s(a3)			; make sign +ve
    5874/    3F3C :                     
    5875/    3F3C :                     								; number sign was -ve and can only be raised to
    5876/    3F3C :                     								; an integer power which gives an x +j0 result,
    5877/    3F3C :                     								; else do 'function call' error
    5878/    3F3C : 122B 0594           	MOVE.b	FAC1_e(a3),d1			; get power exponent
    5879/    3F40 : 927C 0080           	SUB.w		#$80,d1				; normalise to .5
    5880/    3F44 : 6300 E216           	BLS		LAB_FCER				; if 0<power<1 then do 'function call' error
    5881/    3F48 :                     
    5882/    3F48 :                     								; now shift all the integer bits out
    5883/    3F48 : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get power mantissa
    5884/    3F4C : E3A0                	ASL.l		d1,d0					; shift mantissa
    5885/    3F4E : 6600 E20C           	BNE		LAB_FCER				; if power<>INT(power) then do 'function call'
    5886/    3F52 :                     								; error
    5887/    3F52 :                     
    5888/    3F52 : 6502                	BCS.s		LAB_POWP				; if integer value odd then leave result -ve
    5889/    3F54 :                     
    5890/    3F54 : 1E80                	MOVE.b	d0,(sp)				; save result sign +ve
    5891/    3F56 :                     LAB_POWP
    5892/    3F56 : 2F2B 0590           	MOVE.l	FAC1_m(a3),-(sp)			; save power mantissa
    5893/    3F5A : 3F2B 0594           	MOVE.w	FAC1_e(a3),-(sp)			; save power sign & exponent
    5894/    3F5E :                     
    5895/    3F5E : 6100 FC70           	BSR		LAB_279B				; copy number to FAC1
    5896/    3F62 : 6100 F9E0           	BSR		LAB_LOG				; find log of number
    5897/    3F66 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 103 - 11/4/2023 8:40:20


    5898/    3F66 : 301F                	MOVE.w	(sp)+,d0				; get power sign & exponent
    5899/    3F68 : 275F 0598           	MOVE.l	(sp)+,FAC2_m(a3)			; get power mantissa
    5900/    3F6C : 3740 059C           	MOVE.w	d0,FAC2_e(a3)			; save sign & exponent to FAC2
    5901/    3F70 : 1740 059E           	MOVE.b	d0,FAC_sc(a3)			; save sign as sign compare
    5902/    3F74 : 102B 0595           	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
    5903/    3F78 : B12B 059E           	EOR.b		d0,FAC_sc(a3)			; make sign compare (FAC1_s EOR FAC2_s)
    5904/    3F7C :                     
    5905/    3F7C : 6100 FAB8           	BSR		LAB_MULTIPLY			; multiply by power
    5906/    3F80 : 6158                	BSR.s		LAB_EXP				; find exponential
    5907/    3F82 : 175F 0595           	MOVE.b	(sp)+,FAC1_s(a3)			; restore number sign
    5908/    3F86 : 4E75                	RTS
    5909/    3F88 :                     
    5910/    3F88 :                     
    5911/    3F88 :                     ;************************************************************************************
    5912/    3F88 :                     ;
    5913/    3F88 :                     ; do - FAC1
    5914/    3F88 :                     
    5915/    3F88 :                     LAB_GTHAN
    5916/    3F88 : 4A2B 0594           	TST.b		FAC1_e(a3)				; test for non zero FAC1
    5917/    3F8C : 6706                	BEQ.s		RTS_020				; branch if null
    5918/    3F8E :                     
    5919/    3F8E : 0A2B 0080 0595      	EORI.b	#$80,FAC1_s(a3)			; (else) toggle FAC1 sign bit
    5920/    3F94 :                     RTS_020
    5921/    3F94 : 4E75                	RTS
    5922/    3F96 :                     
    5923/    3F96 :                     
    5924/    3F96 :                     ;************************************************************************************
    5925/    3F96 :                     ;
    5926/    3F96 :                     								; return +1
    5927/    3F96 :                     LAB_EX1
    5928/    3F96 : 277C 8000 0000      	MOVE.l	#$80000000,FAC1_m(a3)		; +1 mantissa
             3F9C : 0590             
    5929/    3F9E : 377C 8100 0594      	MOVE.w	#$8100,FAC1_e(a3)			; +1 sign & exponent
    5930/    3FA4 : 4E75                	RTS
    5931/    3FA6 :                     								; do over/under flow
    5932/    3FA6 :                     LAB_EXOU
    5933/    3FA6 : 4A2B 0595           	TST.b		FAC1_s(a3)				; test sign
    5934/    3FAA : 6A00 E1AC           	BPL		LAB_OFER				; was +ve so do overflow error
    5935/    3FAE :                     
    5936/    3FAE :                     								; else underflow so return zero
    5937/    3FAE : 7000                	MOVEQ		#0,d0					; clear longword
    5938/    3FB0 : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; 0 mantissa
    5939/    3FB4 : 3740 0594           	MOVE.w	d0,FAC1_e(a3)			; 0 sign & exponent
    5940/    3FB8 : 4E75                	RTS
    5941/    3FBA :                     								; fraction was zero so do 2^n
    5942/    3FBA :                     LAB_EXOF
    5943/    3FBA : 277C 8000 0000      	MOVE.l	#$80000000,FAC1_m(a3)		; +n mantissa
             3FC0 : 0590             
    5944/    3FC2 : 177C 0000 0595      	MOVE.b	#0,FAC1_s(a3)			; clear sign
    5945/    3FC8 : 4A2B 05B4           	TST.b		cosout(a3)				; test sign flag
    5946/    3FCC : 6A02                	BPL.s		LAB_EXOL				; branch if +ve
    5947/    3FCE :                     
    5948/    3FCE : 4481                	NEG.l		d1					; else do 1/2^n
    5949/    3FD0 :                     LAB_EXOL
    5950/    3FD0 : D23C 0081           	ADD.b		#$81,d1				; adjust exponent
    5951/    3FD4 : 1741 0594           	MOVE.b	d1,FAC1_e(a3)			; save exponent
    5952/    3FD8 : 4E75                	RTS
    5953/    3FDA :                     
    5954/    3FDA :                     ; perform EXP()	(x^e)
    5955/    3FDA :                     ; valid input range is -88 to +88
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 104 - 11/4/2023 8:40:20


    5956/    3FDA :                     
    5957/    3FDA :                     LAB_EXP
    5958/    3FDA : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get exponent
    5959/    3FDE : 67B6                	BEQ.s		LAB_EX1				; return 1 for zero in
    5960/    3FE0 :                     
    5961/    3FE0 : B03C 0064           	CMP.b		#$64,d0				; compare exponent with min
    5962/    3FE4 : 65B0                	BCS.s		LAB_EX1				; if smaller just return 1
    5963/    3FE6 :                     
    5964/    3FE6 :                     ;	MOVEM.l	d1-d6/a0,-(sp)			; save the registers
    5965/    3FE6 : 177C 0000 05B4      	MOVE.b	#0,cosout(a3)			; flag +ve number
    5966/    3FEC : 222B 0590           	MOVE.l	FAC1_m(a3),d1			; get mantissa
    5967/    3FF0 : B03C 0087           	CMP.b		#$87,d0				; compare exponent with max
    5968/    3FF4 : 62B0                	BHI.s		LAB_EXOU				; go do over/under flow if greater
    5969/    3FF6 :                     
    5970/    3FF6 : 6608                	BNE.s		LAB_EXCM				; branch if less
    5971/    3FF8 :                     
    5972/    3FF8 :                     								; else is 2^7
    5973/    3FF8 : B2BC B00F 33C7      	CMP.l		#$B00F33C7,d1			; compare mantissa with n*2^7 max
    5974/    3FFE : 64A6                	BCC.s		LAB_EXOU				; if => go over/underflow
    5975/    4000 :                     
    5976/    4000 :                     LAB_EXCM
    5977/    4000 : 4A2B 0595           	TST.b		FAC1_s(a3)				; test sign
    5978/    4004 : 6A0C                	BPL.s		LAB_EXPS				; branch if arg +ve
    5979/    4006 :                     
    5980/    4006 : 177C 00FF 05B4      	MOVE.b	#$FF,cosout(a3)			; flag -ve number
    5981/    400C : 177C 0000 0595      	MOVE.b	#0,FAC1_s(a3)			; take absolute value
    5982/    4012 :                     LAB_EXPS
    5983/    4012 :                     								; now do n/LOG(2)
    5984/    4012 : 277C B8AA 3B29      	MOVE.l	#$B8AA3B29,FAC2_m(a3)		; 1/LOG(2) mantissa
             4018 : 0598             
    5985/    401A : 377C 8100 059C      	MOVE.w	#$8100,FAC2_e(a3)			; 1/LOG(2) exponent & sign
    5986/    4020 : 177C 0000 059E      	MOVE.b	#0,FAC_sc(a3)			; we know they're both +ve
    5987/    4026 : 6100 FA0E           	BSR		LAB_MULTIPLY			; effectively divide by log(2)
    5988/    402A :                     
    5989/    402A :                     								; max here is +/- 127
    5990/    402A :                     								; now separate integer and fraction
    5991/    402A : 177C 0000 05D9      	MOVE.b	#0,tpower(a3)			; clear exponent add byte
    5992/    4030 : 1A2B 0594           	MOVE.b	FAC1_e(a3),d5			; get exponent
    5993/    4034 : 9A3C 0080           	SUB.b		#$80,d5				; normalise
    5994/    4038 : 6324                	BLS.s		LAB_ESML				; branch if < 1 (d5 is 0 or -ve)
    5995/    403A :                     
    5996/    403A :                     								; result is > 1
    5997/    403A : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get mantissa
    5998/    403E : 2200                	MOVE.l	d0,d1					; copy it
    5999/    4040 : 2C05                	MOVE.l	d5,d6					; copy normalised exponent
    6000/    4042 :                     
    6001/    4042 : 4446                	NEG.w		d6					; make -ve
    6002/    4044 : DC7C 0020           	ADD.w		#32,d6				; is now 32-d6
    6003/    4048 : ECA9                	LSR.l		d6,d1					; just integer bits
    6004/    404A : 1741 05D9           	MOVE.b	d1,tpower(a3)			; set exponent add byte
    6005/    404E :                     
    6006/    404E : EBA8                	LSL.l		d5,d0					; shift out integer bits
    6007/    4050 : 6700 FF68           	BEQ		LAB_EXOF				; fraction is zero so do 2^n
    6008/    4054 :                     
    6009/    4054 : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; fraction to FAC1
    6010/    4058 : 377C 8000 0594      	MOVE.w	#$8000,FAC1_e(a3)			; set exponent & sign
    6011/    405E :                     
    6012/    405E :                     								; multiple was < 1
    6013/    405E :                     LAB_ESML
    6014/    405E : 277C B172 17F8      	MOVE.l	#$B17217F8,FAC2_m(a3)		; LOG(2) mantissa
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 105 - 11/4/2023 8:40:20


             4064 : 0598             
    6015/    4066 : 377C 8000 059C      	MOVE.w	#$8000,FAC2_e(a3)			; LOG(2) exponent & sign
    6016/    406C : 177C 0000 059E      	MOVE.b	#0,FAC_sc(a3)			; clear sign compare
    6017/    4072 : 6100 F9C2           	BSR		LAB_MULTIPLY			; multiply by log(2)
    6018/    4076 :                     
    6019/    4076 : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get mantissa
    6020/    407A : 1A2B 0594           	MOVE.b	FAC1_e(a3),d5			; get exponent
    6021/    407E : 9A7C 0082           	SUB.w		#$82,d5				; normalise and -2 (result is -1 to -30)
    6022/    4082 : 4445                	NEG.w		d5					; make +ve
    6023/    4084 : EAA8                	LSR.l		d5,d0					; shift for 2 integer bits
    6024/    4086 :                     
    6025/    4086 :                     ; d0 = arg
    6026/    4086 :                     ; d6 = x, d1 = y
    6027/    4086 :                     ; d2 = x1, d3 = y1
    6028/    4086 :                     ; d4 = shift count
    6029/    4086 :                     ; d5 = loop count
    6030/    4086 :                     								; now do cordic set-up
    6031/    4086 : 7200                	MOVEQ		#0,d1					; y = 0
    6032/    4088 : 2C3C 26A3 D110      	MOVE.l	#KFCTSEED,d6			; x = 1 with jkh inverse factored out
    6033/    408E : 41FA 0D2C           	LEA		TAB_HTHET(pc),a0			; get pointer to hyperbolic arctan table
    6034/    4092 : 7800                	MOVEQ		#0,d4					; clear shift count
    6035/    4094 :                      
    6036/    4094 :                     								; cordic loop, shifts 4 and 13 (and 39
    6037/    4094 :                     								; if it went that far) need to be repeated
    6038/    4094 : 7A03                	MOVEQ		#3,d5					; 4 loops
    6039/    4096 : 6136                	BSR.s		LAB_EXCC				; do loops 1 through 4
    6040/    4098 : 5948                	SUBQ.w	#4,a0					; do table entry again
    6041/    409A : 5384                	SUBQ.l	#1,d4					; do shift count again
    6042/    409C : 7A09                	MOVEQ		#9,d5					; 10 loops
    6043/    409E : 612E                	BSR.s		LAB_EXCC				; do loops 4 (again) through 13
    6044/    40A0 : 5948                	SUBQ.w	#4,a0					; do table entry again
    6045/    40A2 : 5384                	SUBQ.l	#1,d4					; do shift count again
    6046/    40A4 : 7A12                	MOVEQ		#18,d5				; 19 loops
    6047/    40A6 : 6126                	BSR.s		LAB_EXCC				; do loops 13 (again) through 31
    6048/    40A8 :                      
    6049/    40A8 :                     								; now get the result
    6050/    40A8 : 4A2B 05B4           	TST.b		cosout(a3)				; test sign flag
    6051/    40AC : 6A06                	BPL.s		LAB_EXPL				; branch if +ve
    6052/    40AE :                     
    6053/    40AE : 4481                	NEG.l		d1					; do -y
    6054/    40B0 : 442B 05D9           	NEG.b		tpower(a3)				; do -exp
    6055/    40B4 :                     LAB_EXPL
    6056/    40B4 : 7083                	MOVEQ		#$83-$100,d0			; set exponent
    6057/    40B6 : DC81                	ADD.l		d1,d6					; y = y +/- x
    6058/    40B8 : 6B06                	BMI.s		LAB_EXRN				; branch if result normal
    6059/    40BA :                     
    6060/    40BA :                     LAB_EXNN
    6061/    40BA : 5380                	SUBQ.l	#1,d0					; decrement exponent
    6062/    40BC : DC86                	ADD.l		d6,d6					; shift mantissa
    6063/    40BE : 6AFA                	BPL.s		LAB_EXNN				; loop if not normal
    6064/    40C0 :                     
    6065/    40C0 :                     LAB_EXRN
    6066/    40C0 : 2746 0590           	MOVE.l	d6,FAC1_m(a3)			; save exponent result
    6067/    40C4 : D02B 05D9           	ADD.b		tpower(a3),d0			; add integer part
    6068/    40C8 : 1740 0594           	MOVE.b	d0,FAC1_e(a3)			; save exponent
    6069/    40CC :                     ;	MOVEM.l	(sp)+,d1-d6/a0			; restore registers
    6070/    40CC : 4E75                	RTS
    6071/    40CE :                      
    6072/    40CE :                     								; cordic loop
    6073/    40CE :                     LAB_EXCC
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 106 - 11/4/2023 8:40:20


    6074/    40CE : 5284                	ADDQ.l	#1,d4					; increment shift count
    6075/    40D0 : 2406                	MOVE.l	d6,d2					; x1 = x
    6076/    40D2 : E8A2                	ASR.l		d4,d2					; x1 >> n
    6077/    40D4 : 2601                	MOVE.l	d1,d3					; y1 = y
    6078/    40D6 : E8A3                	ASR.l		d4,d3					; y1 >> n
    6079/    40D8 : 4A80                	TST.l		d0					; test arg
    6080/    40DA : 6B0C                	BMI.s		LAB_EXAD				; branch if -ve
    6081/    40DC :                     
    6082/    40DC : D282                	ADD.l		d2,d1					; y = y + x1
    6083/    40DE : DC83                	ADD.l		d3,d6					; x = x + y1
    6084/    40E0 : 9098                	SUB.l		(a0)+,d0				; arg = arg - atnh(a0)
    6085/    40E2 : 51CD FFEA           	DBF		d5,LAB_EXCC				; decrement and loop if not done
    6086/    40E6 :                     
    6087/    40E6 : 4E75                	RTS
    6088/    40E8 :                     
    6089/    40E8 :                     LAB_EXAD
    6090/    40E8 : 9282                	SUB.l		d2,d1					; y = y - x1
    6091/    40EA : 9C83                	SUB.l		d3,d6					; x = x + y1
    6092/    40EC : D098                	ADD.l		(a0)+,d0				; arg = arg + atnh(a0)
    6093/    40EE : 51CD FFDE           	DBF		d5,LAB_EXCC				; decrement and loop if not done
    6094/    40F2 :                     
    6095/    40F2 : 4E75                	RTS
    6096/    40F4 :                     
    6097/    40F4 :                     
    6098/    40F4 :                     ;************************************************************************************
    6099/    40F4 :                     ;
    6100/    40F4 :                     ; RND(n), 32 bit Galois version. make n=0 for 19th next number in sequence or n<>0
    6101/    40F4 :                     ; to get 19th next number in sequence after seed n. This version of the PRNG uses
    6102/    40F4 :                     ; the Galois method and a sample of 65536 bytes produced gives the following values.
    6103/    40F4 :                     
    6104/    40F4 :                     ; Entropy = 7.997442 bits per byte
    6105/    40F4 :                     ; Optimum compression would reduce these 65536 bytes by 0 percent
    6106/    40F4 :                     
    6107/    40F4 :                     ; Chi square distribution for 65536 samples is 232.01, and
    6108/    40F4 :                     ; randomly would exceed this value 75.00 percent of the time
    6109/    40F4 :                     
    6110/    40F4 :                     ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
    6111/    40F4 :                     ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
    6112/    40F4 :                     ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
    6113/    40F4 :                     
    6114/    40F4 :                     LAB_RND
    6115/    40F4 : 4A2B 0594           	TST.b		FAC1_e(a3)				; get FAC1 exponent
    6116/    40F8 : 6708                	BEQ.s		NextPRN				; do next random number if zero
    6117/    40FA :                     
    6118/    40FA :                     								; else get seed into random number store
    6119/    40FA : 41EB 05A0           	LEA		PRNlword(a3),a0			; set PRNG pointer
    6120/    40FE : 6100 FAAA           	BSR		LAB_2778				; pack FAC1 into (a0)
    6121/    4102 :                     NextPRN
    6122/    4102 : 72AF                	MOVEQ		#$AF-$100,d1			; set EOR value
    6123/    4104 : 7412                	MOVEQ		#18,d2				; do this 19 times
    6124/    4106 : 202B 05A0           	MOVE.l	PRNlword(a3),d0			; get current
    6125/    410A :                     Ninc0
    6126/    410A : D080                	ADD.l		d0,d0					; shift left 1 bit
    6127/    410C : 6402                	BCC.s		Ninc1					; branch if bit 32 not set
    6128/    410E :                     
    6129/    410E : B300                	EOR.b		d1,d0					; do Galois LFSR feedback
    6130/    4110 :                     Ninc1
    6131/    4110 : 51CA FFF8           	DBF		d2,Ninc0				; loop
    6132/    4114 :                     
    6133/    4114 : 2740 05A0           	MOVE.l	d0,PRNlword(a3)			; save back to seed word
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 107 - 11/4/2023 8:40:20


    6134/    4118 : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; copy to FAC1 mantissa
    6135/    411C : 377C 8000 0594      	MOVE.w	#$8000,FAC1_e(a3)			; set the exponent and clear the sign
    6136/    4122 : 6000 F7EA           	BRA		LAB_24D5				; normalise FAC1 & return
    6137/    4126 :                     
    6138/    4126 :                     
    6139/    4126 :                     ;************************************************************************************
    6140/    4126 :                     ;
    6141/    4126 :                     ; cordic TAN(x) routine, TAN(x) = SIN(x)/COS(x)
    6142/    4126 :                     ; x = angle in radians
    6143/    4126 :                     
    6144/    4126 :                     LAB_TAN
    6145/    4126 : 6138                	BSR.s		LAB_SIN				; go do SIN/COS cordic compute
    6146/    4128 : 376B 0594 059C      	MOVE.w	FAC1_e(a3),FAC2_e(a3)		; copy exponent & sign from FAC1 to FAC2
    6147/    412E : 276B 0590 0598      	MOVE.l	FAC1_m(a3),FAC2_m(a3)		; copy FAC1 mantissa to FAC2 mantissa
    6148/    4134 : 2741 0590           	MOVE.l	d1,FAC1_m(a3)			; get COS(x) mantissa
    6149/    4138 : 1743 0594           	MOVE.b	d3,FAC1_e(a3)			; get COS(x) exponent
    6150/    413C : 6700 E01A           	BEQ		LAB_OFER				; do overflow if COS = 0
    6151/    4140 :                     
    6152/    4140 : 6100 F7CC           	BSR		LAB_24D5				; normalise FAC1
    6153/    4144 : 6000 F97C           	BRA		LAB_DIVIDE				; do FAC2/FAC1 and return, FAC_sc set by SIN
    6154/    4148 :                     								; COS calculation
    6155/    4148 :                     
    6156/    4148 :                     
    6157/    4148 :                     ;************************************************************************************
    6158/    4148 :                     ;
    6159/    4148 :                     ; cordic SIN(x), COS(x) routine
    6160/    4148 :                     ; x = angle in radians
    6161/    4148 :                     
    6162/    4148 :                     LAB_COS
    6163/    4148 : 277C C90F DAA3      	MOVE.l	#$C90FDAA3,FAC2_m(a3)		; pi/2 mantissa (LSB is rounded up so
             414E : 0598             
    6164/    4150 :                     								; COS(PI/2)=0)
    6165/    4150 : 377C 8100 059C      	MOVE.w	#$8100,FAC2_e(a3)			; pi/2 exponent and sign
    6166/    4156 : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; sign = FAC1 sign (b7)
    6167/    415C : 6100 F734           	BSR		LAB_ADD				; add FAC2 to FAC1, adjust for COS(x)
    6168/    4160 :                     
    6169/    4160 :                     
    6170/    4160 :                     ;************************************************************************************
    6171/    4160 :                     ;
    6172/    4160 :                     ; SIN/COS cordic calculator
    6173/    4160 :                     
    6174/    4160 :                     LAB_SIN
    6175/    4160 : 177C 0000 05B4      	MOVE.b	#0,cosout(a3)			; set needed result
    6176/    4166 :                     
    6177/    4166 : 277C A2F9 836F      	MOVE.l	#$A2F9836F,FAC2_m(a3)		; 1/pi mantissa (LSB is rounded up so SIN(PI)=0)
             416C : 0598             
    6178/    416E : 377C 7F00 059C      	MOVE.w	#$7F00,FAC2_e(a3)			; 1/pi exponent & sign
    6179/    4174 : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; sign = FAC1 sign (b7)
    6180/    417A : 6100 F8BA           	BSR		LAB_MULTIPLY			; multiply by 1/pi
    6181/    417E :                     
    6182/    417E : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
    6183/    4182 : 671C                	BEQ.s		LAB_SCZE				; branch if zero
    6184/    4184 :                     
    6185/    4184 : 41FA 0B36           	LEA		TAB_SNCO(pc),a0			; get pointer to constants table
    6186/    4188 : 2C2B 0590           	MOVE.l	FAC1_m(a3),d6			; get FAC1 mantissa
    6187/    418C : 5300                	SUBQ.b	#1,d0					; 2 radians in 360 degrees so /2
    6188/    418E : 6710                	BEQ.s		LAB_SCZE				; branch if zero
    6189/    4190 :                     
    6190/    4190 : 903C 0080           	SUB.b		#$80,d0				; normalise exponent
    6191/    4194 : 6B18                	BMI.s		LAB_SCL0				; branch if < 1
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 108 - 11/4/2023 8:40:20


    6192/    4196 :                     
    6193/    4196 :                     								; X is > 1
    6194/    4196 : B03C 0020           	CMP.b		#$20,d0				; is it >= 2^32
    6195/    419A : 6404                	BCC.s		LAB_SCZE				; may as well do zero
    6196/    419C :                     
    6197/    419C : E1AE                	LSL.l		d0,d6					; shift out integer part bits
    6198/    419E : 6618                	BNE.s		LAB_CORD				; if fraction go test quadrant and adjust
    6199/    41A0 :                     
    6200/    41A0 :                     								; else no fraction so do zero
    6201/    41A0 :                     LAB_SCZE
    6202/    41A0 : 7481                	MOVEQ		#$81-$100,d2			; set exponent for 1.0
    6203/    41A2 : 7600                	MOVEQ		#0,d3					; set exponent for 0.0
    6204/    41A4 : 203C 8000 0000      	MOVE.l	#$80000000,d0			; mantissa for 1.0
    6205/    41AA : 2203                	MOVE.l	d3,d1					; mantissa for 0.0
    6206/    41AC : 6062                	BRA.s		outloop				; go output it
    6207/    41AE :                     
    6208/    41AE :                     								; x is < 1
    6209/    41AE :                     LAB_SCL0
    6210/    41AE : 4400                	NEG.b		d0					; make +ve
    6211/    41B0 : B03C 001E           	CMP.b		#$1E,d0				; is it <= 2^-30
    6212/    41B4 : 64EA                	BCC.s		LAB_SCZE				; may as well do zero
    6213/    41B6 :                     
    6214/    41B6 : E0AE                	LSR.l		d0,d6					; shift out <= 2^-32 bits
    6215/    41B8 :                     
    6216/    41B8 :                     ; cordic calculator, argument in d6
    6217/    41B8 :                     ; table pointer in a0, returns in d0-d3
    6218/    41B8 :                     
    6219/    41B8 :                     LAB_CORD
    6220/    41B8 : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; copy as sign compare for TAN
    6221/    41BE : DC86                	ADD.l		d6,d6					; shift 0.5 bit into carry
    6222/    41C0 : 6406                	BCC.s		LAB_LTPF				; branch if less than 0.5
    6223/    41C2 :                     
    6224/    41C2 : 0A2B 00FF 0595      	EORI.b	#$FF,FAC1_s(a3)			; toggle result sign
    6225/    41C8 :                     LAB_LTPF
    6226/    41C8 : DC86                	ADD.l		d6,d6					; shift 0.25 bit into carry
    6227/    41CA : 640C                	BCC.s		LAB_LTPT				; branch if less than 0.25
    6228/    41CC :                     
    6229/    41CC : 0A2B 00FF 05B4      	EORI.b	#$FF,cosout(a3)			; toggle needed result
    6230/    41D2 : 0A2B 00FF 059E      	EORI.b	#$FF,FAC_sc(a3)			; toggle sign compare for TAN
    6231/    41D8 :                     
    6232/    41D8 :                     LAB_LTPT
    6233/    41D8 : E48E                	LSR.l		#2,d6					; shift the bits back (clear integer bits)
    6234/    41DA : 67C4                	BEQ.s		LAB_SCZE				; no fraction so go do zero
    6235/    41DC :                     
    6236/    41DC :                     								; set start values
    6237/    41DC : 7A01                	MOVEQ		#1,d5					; set bit count
    6238/    41DE : 2028 FFFC           	MOVE.l	-4(a0),d0				; get multiply constant (1st itteration d0)
    6239/    41E2 : 2200                	MOVE.l	d0,d1					; 1st itteration d1
    6240/    41E4 : 9C98                	SUB.l		(a0)+,d6				; 1st always +ve so do 1st step
    6241/    41E6 : 6008                	BRA.s		mainloop				; jump into routine
    6242/    41E8 :                     
    6243/    41E8 :                     subloop
    6244/    41E8 : 9C98                	SUB.l		(a0)+,d6				; z = z - arctan(i)/2pi
    6245/    41EA : 9083                	SUB.l		d3,d0					; x = x - y1
    6246/    41EC : D282                	ADD.l		d2,d1					; y = y + x1
    6247/    41EE : 6012                	BRA.s		nexta					; back to main loop
    6248/    41F0 :                     
    6249/    41F0 :                     mainloop
    6250/    41F0 : 2400                	MOVE.l	d0,d2					; x1 = x
    6251/    41F2 : EAA2                	ASR.l		d5,d2					; / (2 ^ i)
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 109 - 11/4/2023 8:40:20


    6252/    41F4 : 2601                	MOVE.l	d1,d3					; y1 = y
    6253/    41F6 : EAA3                	ASR.l		d5,d3					; / (2 ^ i)
    6254/    41F8 : 4A86                	TST.l		d6					; test sign (is 2^0 bit)
    6255/    41FA : 6AEC                	BPL.s		subloop				; go do subtract if > 1
    6256/    41FC :                     
    6257/    41FC : DC98                	ADD.l		(a0)+,d6				; z = z + arctan(i)/2pi
    6258/    41FE : D083                	ADD.l		d3,d0					; x = x + y1
    6259/    4200 : 9282                	SUB.l		d2,d1					; y = y + x1
    6260/    4202 :                     nexta
    6261/    4202 : 5285                	ADDQ.l	#1,d5					; i = i + 1
    6262/    4204 : BABC 0000 001E      	CMP.l		#$1E,d5				; check end condition
    6263/    420A : 66E4                	BNE.s		mainloop				; loop if not all done
    6264/    420C :                     
    6265/    420C :                     								; now untangle output value
    6266/    420C : 7481                	MOVEQ		#$81-$100,d2			; set exponent for 0 to .99 rec.
    6267/    420E : 2602                	MOVE.l	d2,d3					; copy it for cos output
    6268/    4210 :                     outloop
    6269/    4210 : 4A2B 05B4           	TST.b		cosout(a3)				; did we want cos output?
    6270/    4214 : 6B04                	BMI.s		subexit				; if so skip
    6271/    4216 :                     
    6272/    4216 : C141                	EXG		d0,d1					; swap SIN and COS mantissas
    6273/    4218 : C543                	EXG		d2,d3					; swap SIN and COS exponents
    6274/    421A :                     subexit
    6275/    421A : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; set result mantissa
    6276/    421E : 1742 0594           	MOVE.b	d2,FAC1_e(a3)			; set result exponent
    6277/    4222 : 6000 F6EA           	BRA		LAB_24D5				; normalise FAC1 & return
    6278/    4226 :                     
    6279/    4226 :                     
    6280/    4226 :                     
    6281/    4226 :                     ;************************************************************************************
    6282/    4226 :                     ;
    6283/    4226 :                     ; perform ATN()
    6284/    4226 :                     
    6285/    4226 :                     LAB_ATN
    6286/    4226 : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
    6287/    422A : 6700 00AC           	BEQ		RTS_021				; ATN(0) = 0 so skip calculation
    6288/    422E :                     
    6289/    422E : 177C 0000 05B4      	MOVE.b	#0,cosout(a3)			; set result needed
    6290/    4234 : B03C 0081           	CMP.b		#$81,d0				; compare exponent with 1
    6291/    4238 : 6528                	BCS.s		LAB_ATLE				; branch if n<1
    6292/    423A :                     
    6293/    423A : 6608                	BNE.s		LAB_ATGO				; branch if n>1
    6294/    423C :                     
    6295/    423C : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get mantissa
    6296/    4240 : D080                	ADD.l		d0,d0					; shift left
    6297/    4242 : 671E                	BEQ.s		LAB_ATLE				; branch if n=1
    6298/    4244 :                     
    6299/    4244 :                     LAB_ATGO
    6300/    4244 : 277C 8000 0000      	MOVE.l	#$80000000,FAC2_m(a3)		; set mantissa for 1
             424A : 0598             
    6301/    424C : 377C 8100 059C      	MOVE.w	#$8100,FAC2_e(a3)			; set exponent for 1
    6302/    4252 : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; sign compare = sign
    6303/    4258 : 6100 F868           	BSR		LAB_DIVIDE				; do 1/n
    6304/    425C : 177C 00FF 05B4      	MOVE.b	#$FF,cosout(a3)			; set inverse result needed
    6305/    4262 :                     LAB_ATLE
    6306/    4262 : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get FAC1 mantissa
    6307/    4266 : 123C 0082           	MOVE.b		#$82,d1				; set to correct exponent
    6308/    426A : 922B 0594           	SUB.b		FAC1_e(a3),d1			; subtract FAC1 exponent (always <= 1)
    6309/    426E : E2A8                	LSR.l		d1,d0					; shift in two integer part bits
    6310/    4270 : 41FA 0ACA           	LEA		TAB_ATNC(pc),a0			; get pointer to arctan table
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 110 - 11/4/2023 8:40:20


    6311/    4274 : 7C00                	MOVEQ		#0,d6					; Z = 0
    6312/    4276 : 223C 4000 0000      	MOVE.l	#1<<30,d1				; y = 1
    6313/    427C : 7A1D                	MOVEQ		#29,d5				; loop 30 times
    6314/    427E : 7801                	MOVEQ		#1,d4					; shift counter
    6315/    4280 : 6006                	BRA.s		LAB_ATCD				; enter loop
    6316/    4282 :                     
    6317/    4282 :                     LAB_ATNP
    6318/    4282 : E8A2                	ASR.l		d4,d2					; x1 / 2^i
    6319/    4284 : D282                	ADD.l		d2,d1					; y = y + x1
    6320/    4286 : DC90                	ADD.l		(a0),d6				; z = z + atn(i)
    6321/    4288 :                     LAB_ATCD
    6322/    4288 : 2400                	MOVE.l	d0,d2					; x1 = x
    6323/    428A : 2601                	MOVE.l	d1,d3					; y1 = y
    6324/    428C : E8A3                	ASR.l		d4,d3					; y1 / 2^i
    6325/    428E :                     LAB_CATN
    6326/    428E : 9083                	SUB.l		d3,d0					; x = x - y1
    6327/    4290 : 6AF0                	BPL.s		LAB_ATNP				; branch if x >= 0
    6328/    4292 :                     
    6329/    4292 : 2002                	MOVE.l	d2,d0					; else get x back
    6330/    4294 : 5848                	ADDQ.w	#4,a0					; increment pointer
    6331/    4296 : 5284                	ADDQ.l	#1,d4					; increment i
    6332/    4298 : E283                	ASR.l		#1,d3					; y1 / 2^i
    6333/    429A : 51CD FFF2           	DBF		d5,LAB_CATN				; decrement and loop if not done
    6334/    429E :                     
    6335/    429E : 177C 0082 0594      	MOVE.b	#$82,FAC1_e(a3)			; set new exponent
    6336/    42A4 : 2746 0590           	MOVE.l	d6,FAC1_m(a3)			; save mantissa
    6337/    42A8 : 6100 F664           	BSR		LAB_24D5				; normalise FAC1
    6338/    42AC :                     
    6339/    42AC : 4A2B 05B4           	TST.b		cosout(a3)				; was it > 1 ?
    6340/    42B0 : 6A26                	BPL.s		RTS_021				; branch if not
    6341/    42B2 :                     
    6342/    42B2 : 1E2B 0595           	MOVE.b	FAC1_s(a3),d7			; get sign
    6343/    42B6 : 177C 0000 0595      	MOVE.b	#0,FAC1_s(a3)			; clear sign
    6344/    42BC : 277C C90F DAA2      	MOVE.l	#$C90FDAA2,FAC2_m(a3)		; set -(pi/2)
             42C2 : 0598             
    6345/    42C4 : 377C 8180 059C      	MOVE.w	#$8180,FAC2_e(a3)			; set exponent and sign
    6346/    42CA : 177C 00FF 059E      	MOVE.b	#$FF,FAC_sc(a3)			; set sign compare
    6347/    42D0 : 6100 F5C0           	BSR		LAB_ADD				; perform addition, FAC2 to FAC1
    6348/    42D4 : 1747 0595           	MOVE.b	d7,FAC1_s(a3)			; restore sign
    6349/    42D8 :                     RTS_021
    6350/    42D8 : 4E75                	RTS
    6351/    42DA :                     
    6352/    42DA :                     
    6353/    42DA :                     ;************************************************************************************
    6354/    42DA :                     ;
    6355/    42DA :                     ; perform BITSET
    6356/    42DA :                     
    6357/    42DA :                     LAB_BITSET
    6358/    42DA : 6100 F496           	BSR		LAB_GADB				; get two parameters for POKE or WAIT
    6359/    42DE :                     								; first parameter in a0, second in d0
    6360/    42DE : B03C 0008           	CMP.b		#$08,d0				; only 0 to 7 are allowed
    6361/    42E2 : 6400 DE78           	BCC		LAB_FCER				; branch if > 7
    6362/    42E6 :                     
    6363/    42E6 : 01D0                	BSET		d0,(a0)				; set bit
    6364/    42E8 : 4E75                	RTS
    6365/    42EA :                     
    6366/    42EA :                     
    6367/    42EA :                     ;************************************************************************************
    6368/    42EA :                     ;
    6369/    42EA :                     ; perform BITCLR
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 111 - 11/4/2023 8:40:20


    6370/    42EA :                     
    6371/    42EA :                     LAB_BITCLR
    6372/    42EA : 6100 F486           	BSR		LAB_GADB				; get two parameters for POKE or WAIT
    6373/    42EE :                     								; first parameter in a0, second in d0
    6374/    42EE : B03C 0008           	CMP.b		#$08,d0				; only 0 to 7 are allowed
    6375/    42F2 : 6400 DE68           	BCC		LAB_FCER				; branch if > 7
    6376/    42F6 :                     
    6377/    42F6 : 0190                	BCLR		d0,(a0)				; clear bit
    6378/    42F8 : 4E75                	RTS
    6379/    42FA :                     
    6380/    42FA :                     
    6381/    42FA :                     ;************************************************************************************
    6382/    42FA :                     ;
    6383/    42FA :                     ; perform BITTST()
    6384/    42FA :                     
    6385/    42FA :                     LAB_BTST
    6386/    42FA : 101D                	MOVE.b	(a5)+,d0				; increment BASIC pointer
    6387/    42FC : 6100 F474           	BSR		LAB_GADB				; get two parameters for POKE or WAIT
    6388/    4300 :                     								; first parameter in a0, second in d0
    6389/    4300 : B03C 0008           	CMP.b		#$08,d0				; only 0 to 7 are allowed
    6390/    4304 : 6400 DE56           	BCC		LAB_FCER				; branch if > 7
    6391/    4308 :                     
    6392/    4308 : 2200                	MOVE.l	d0,d1					; copy bit # to test
    6393/    430A : 6100 EAA4           	BSR		LAB_GBYT				; get next BASIC byte
    6394/    430E : B03C 0029           	CMP.b		#')',d0				; is next character ")"
    6395/    4312 : 6600 DE54           	BNE		LAB_SNER				; if not ")" go do syntax error, then warm start
    6396/    4316 :                     
    6397/    4316 : 6100 EA96           	BSR		LAB_IGBY				; update execute pointer (to character past ")")
    6398/    431A : 7000                	MOVEQ		#0,d0					; set the result as zero
    6399/    431C : 0310                	BTST		d1,(a0)				; test bit
    6400/    431E : 6700 F904           	BEQ		LAB_27DB				; branch if zero (already correct)
    6401/    4322 :                     
    6402/    4322 : 70FF                	MOVEQ		#-1,d0				; set for -1 result
    6403/    4324 : 6000 F8FE           	BRA		LAB_27DB				; go do SGN tail
    6404/    4328 :                     
    6405/    4328 :                     
    6406/    4328 :                     ;************************************************************************************
    6407/    4328 :                     ;
    6408/    4328 :                     ; perform USING$()
    6409/    4328 :                     
    6410/    4328 : =$0                 fsd		EQU	 0						;   (sp) format string descriptor pointer
    6411/    4328 : =$4                 fsti	EQU	 4						;  4(sp) format string this index
    6412/    4328 : =$6                 fsli	EQU	 6						;  6(sp) format string last index
    6413/    4328 : =$8                 fsdpi	EQU	 8						;  8(sp) format string decimal point index
    6414/    4328 : =$A                 fsdc	EQU	10						; 10(sp) format string decimal characters
    6415/    4328 : =$8                 fend	EQU	12-4						;  x(sp) end-4, fsd is popped by itself
    6416/    4328 :                     
    6417/    4328 : ='#'                ofchr	EQU	'#'						; the overflow character
    6418/    4328 :                     
    6419/    4328 :                     LAB_USINGS
    6420/    4328 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type, $80=string
    6421/    432C : 6A00 DDE6           	BPL		LAB_FOER				; if not string type go do format error
    6422/    4330 :                     
    6423/    4330 : 246B 0590           	MOVEA.l	FAC1_m(a3),a2			; get the format string descriptor pointer
    6424/    4334 : 3E2A 0004           	MOVE.w	4(a2),d7				; get the format string length
    6425/    4338 : 6700 DDDA           	BEQ		LAB_FOER				; if null string go do format error
    6426/    433C :                     
    6427/    433C :                     ; clear the format string values
    6428/    433C :                     
    6429/    433C : 7000                	MOVEQ		#0,d0					; clear d0
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 112 - 11/4/2023 8:40:20


    6430/    433E : 3F00                	MOVE.w	d0,-(sp)				; clear the format string decimal characters
    6431/    4340 : 3F00                	MOVE.w	d0,-(sp)				; clear the format string decimal point index
    6432/    4342 : 3F00                	MOVE.w	d0,-(sp)				; clear the format string last index
    6433/    4344 : 3F00                	MOVE.w	d0,-(sp)				; clear the format string this index
    6434/    4346 : 2F0A                	MOVE.l	a2,-(sp)				; save the format string descriptor pointer
    6435/    4348 :                     
    6436/    4348 :                     ; make a null return string for the first string add
    6437/    4348 :                     
    6438/    4348 : 7200                	MOVEQ		#0,d1					; make a null string
    6439/    434A : 2041                	MOVEA.l	d1,a0					; with a null pointer
    6440/    434C : 6100 F0BE           	BSR		LAB_RTST				; push a string on the descriptor stack
    6441/    4350 :                     								; a0 = pointer, d1 = length
    6442/    4350 :                     
    6443/    4350 :                     ; do the USING$() function next value
    6444/    4350 :                     
    6445/    4350 : 101D                	MOVE.b	(a5)+,d0				; get the next BASIC byte
    6446/    4352 :                     LAB_U002
    6447/    4352 : B03C 002C           	CMP.b		#',',d0				; compare with comma
    6448/    4356 : 6600 DE10           	BNE		LAB_SNER				; if not "," go do syntax error
    6449/    435A :                     
    6450/    435A : 6100 028E           	BSR		LAB_ProcFo				; process the format string
    6451/    435E : 4A02                	TST.b		d2					; test the special characters flag
    6452/    4360 : 6700 DDB2           	BEQ		LAB_FOER				; if no special characters go do format error
    6453/    4364 :                     
    6454/    4364 : 6100 E8E8           	BSR		LAB_EVEX				; evaluate the expression
    6455/    4368 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test the data type
    6456/    436C : 6B00 DDCE           	BMI		LAB_TMER				; if string type go do type missmatch error
    6457/    4370 :                     
    6458/    4370 : 4A2B 0594           	TST.b		FAC1_e(a3)				; test FAC1 exponent
    6459/    4374 : 6732                	BEQ.s		LAB_U004				; if FAC1 = 0 skip the rounding
    6460/    4376 :                     
    6461/    4376 : 322F 000A           	MOVE.w	fsdc(sp),d1				; get the format string decimal character count
    6462/    437A : B27C 0008           	CMP.w		#8,d1					; compare the fraction digit count with 8
    6463/    437E : 6428                	BCC.s		LAB_U004				; if >= 8 skip the rounding
    6464/    4380 :                     
    6465/    4380 : 3001                	MOVE.w	d1,d0					; else copy the fraction digit count
    6466/    4382 : D241                	ADD.w		d1,d1					;	; 2
    6467/    4384 : D240                	ADD.w		d0,d1					;	; 3
    6468/    4386 : D241                	ADD.w		d1,d1					;	; 6
    6469/    4388 : 41FA 0844           	LEA		LAB_P_10(pc),a0			; get the rounding table base
    6470/    438C : 2770 1002 0598      	MOVE.l	2(a0,d1.w),FAC2_m(a3)		; get the rounding mantissa
    6471/    4392 : 3030 1000           	MOVE.w	(a0,d1.w),d0			; get the rounding exponent
    6472/    4396 : 907C 0100           	SUB.w		#$100,d0				; effectively divide the mantissa by 2
    6473/    439A : 3740 059C           	MOVE.w	d0,FAC2_e(a3)			; save the rounding exponent
    6474/    439E : 177C 0000 059E      	MOVE.b	#$00,FAC_sc(a3)			; clear the sign compare
    6475/    43A4 : 6100 F4EC           	BSR		LAB_ADD				; round the value to n places
    6476/    43A8 :                     LAB_U004
    6477/    43A8 : 6100 F96A           	BSR		LAB_2970				; convert FAC1 to string - not on stack
    6478/    43AC :                     
    6479/    43AC : 6100 01FE           	BSR		LAB_DupFmt				; duplicate the processed format string section
    6480/    43B0 :                     								; returns length in d1, pointer in a0
    6481/    43B0 :                     
    6482/    43B0 :                     ; process the number string, length in d6, decimal point index in d2
    6483/    43B0 :                     
    6484/    43B0 : 45EB 05C6           	LEA		Decss(a3),a2			; set the number string start
    6485/    43B4 : 7C00                	MOVEQ		#0,d6					; clear the number string index
    6486/    43B6 : 782E                	MOVEQ		#'.',d4				; set the decimal point character
    6487/    43B8 :                     LAB_U005
    6488/    43B8 : 3406                	MOVE.w	d6,d2					; save the index to flag the decimal point
    6489/    43BA :                     LAB_U006
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 113 - 11/4/2023 8:40:20


    6490/    43BA : 5246                	ADDQ.w	#1,d6					; increment the number string index
    6491/    43BC : 1032 6000           	MOVE.b	(a2,d6.w),d0			; get a number string character
    6492/    43C0 : 677A                	BEQ.s		LAB_U010				; if null then number complete
    6493/    43C2 :                     
    6494/    43C2 : B03C 0045           	CMP.b		#'E',d0				; compare the character with an "E"
    6495/    43C6 : 6706                	BEQ.s		LAB_U008				; was sx[.x]Esxx so go handle sci notation
    6496/    43C8 :                     
    6497/    43C8 : B004                	CMP.b		d4,d0					; compare the character with "."
    6498/    43CA : 66EE                	BNE.s		LAB_U006				; if not decimal point go get the next digit
    6499/    43CC :                     
    6500/    43CC : 60EA                	BRA.s		LAB_U005				; go save the index and get the next digit
    6501/    43CE :                     
    6502/    43CE :                     ; have found an sx[.x]Esxx number, the [.x] will not be present for a single digit
    6503/    43CE :                     
    6504/    43CE :                     LAB_U008
    6505/    43CE : 3606                	MOVE.w	d6,d3					; copy the index to the "E"
    6506/    43D0 : 5343                	SUBQ.w	#1,d3					; -1 gives the last digit index
    6507/    43D2 :                     
    6508/    43D2 : 5246                	ADDQ.w	#1,d6					; increment the index to the exponent sign
    6509/    43D4 : 1032 6000           	MOVE.b	(a2,d6.w),d0			; get the exponent sign character
    6510/    43D8 : B03C 002D           	CMP.b		#'-',d0				; compare the exponent sign with "-"
    6511/    43DC : 6600 DD7E           	BNE		LAB_FCER				; if it wasn't sx[.x]E-xx go do function
    6512/    43E0 :                     								; call error
    6513/    43E0 :                     
    6514/    43E0 :                     ; found an sx[.x]E-xx number so check the exponent magnitude
    6515/    43E0 :                     
    6516/    43E0 : 5246                	ADDQ.w	#1,d6					; increment the index to the exponent 10s
    6517/    43E2 : 1032 6000           	MOVE.b	(a2,d6.w),d0			; get the exponent 10s character
    6518/    43E6 : B03C 0030           	CMP.b		#'0',d0				; compare the exponent 10s with "0"
    6519/    43EA : 6704                	BEQ.s		LAB_U009				; if it was sx[.x]E-0x go get the exponent
    6520/    43EC :                     								; 1s character
    6521/    43EC :                     
    6522/    43EC : 700A                	MOVEQ		#10,d0				; else start writing at index 10
    6523/    43EE : 6008                	BRA.s		LAB_U00A				; go copy the digits
    6524/    43F0 :                     
    6525/    43F0 :                     ; found an sx[.x]E-0x number so get the exponent magnitude
    6526/    43F0 :                     
    6527/    43F0 :                     LAB_U009
    6528/    43F0 : 5246                	ADDQ.w	#1,d6					; increment the index to the exponent 1s
    6529/    43F2 : 700F                	MOVEQ		#$0F,d0				; set the mask for the exponent 1s digit
    6530/    43F4 : C032 6000           	AND.b		(a2,d6.w),d0			; get and convert the exponent 1s digit
    6531/    43F8 :                     LAB_U00A
    6532/    43F8 : 3403                	MOVE.w	d3,d2					; copy the number last digit index
    6533/    43FA : 0C42 0001           	CMPI.w	#1,d2					; is the number of the form sxE-0x
    6534/    43FE : 6602                	BNE.s		LAB_U00B				; if it is sx.xE-0x skip the increment
    6535/    4400 :                     
    6536/    4400 :                     								; else make room for the decimal point
    6537/    4400 : 5242                	ADDQ.w	#1,d2					; add 1 to the write index
    6538/    4402 :                     LAB_U00B
    6539/    4402 : D440                	ADD.w		d0,d2					; add the exponent 1s to the write index
    6540/    4404 : 700A                	MOVEQ		#10,d0				; set the maximum write index
    6541/    4406 : 9042                	SUB.w		d2,d0					; compare the index with the maximum
    6542/    4408 : 6E0C                	BGT.s		LAB_U00C				; if the index < the maximum continue
    6543/    440A :                     
    6544/    440A : D440                	ADD.w		d0,d2					; else set the index to the maximum
    6545/    440C : D640                	ADD.w		d0,d3					; adjust the read index
    6546/    440E : 0C43 0001           	CMPI.w	#1,d3					; compare the adjusted index with 1
    6547/    4412 : 6E02                	BGT.s		LAB_U00C				; if > 1 continue
    6548/    4414 :                     
    6549/    4414 : 7600                	MOVEQ		#0,d3					; else allow for the decimal point
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 114 - 11/4/2023 8:40:20


    6550/    4416 :                     LAB_U00C
    6551/    4416 : 3C02                	MOVE.w		d2,d6					; copy the write index as the number
    6552/    4418 :                     								; string length
    6553/    4418 : 7000                	MOVEQ		#0,d0					; clear d0 to null terminate the number
    6554/    441A :                     								; string
    6555/    441A :                     LAB_U00D
    6556/    441A : 1580 2000           	MOVE.b	d0,(a2,d2.w)			; save the character to the number string
    6557/    441E : 5342                	SUBQ.w	#1,d2					; decrement the number write index
    6558/    4420 : 0C42 0001           	CMPI.w	#1,d2					; compare the number write index with 1
    6559/    4424 : 6712                	BEQ.s		LAB_U00F				; if at the decimal point go save it
    6560/    4426 :                     
    6561/    4426 :                     								; else write a digit to the number string
    6562/    4426 : 7030                	MOVEQ		#'0',d0				; default to "0"
    6563/    4428 : 4A43                	TST.w		d3					; test the number read index
    6564/    442A : 67EE                	BEQ.s		LAB_U00D				; if zero just go save the "0"
    6565/    442C :                     
    6566/    442C :                     LAB_U00E
    6567/    442C : 1032 3000           	MOVE.b	(a2,d3.w),d0			; read the next number digit
    6568/    4430 : 5343                	SUBQ.w	#1,d3					; decrement the read index
    6569/    4432 : B004                	CMP.b		d4,d0					; compare the digit with "."
    6570/    4434 : 66E4                	BNE.s		LAB_U00D				; if not "." go save the digit
    6571/    4436 :                     
    6572/    4436 : 60F4                	BRA.s		LAB_U00E				; else go get the next digit
    6573/    4438 :                     
    6574/    4438 :                     LAB_U00F
    6575/    4438 : 1584 2000           	MOVE.b	d4,(a2,d2.w)			; save the decimal point
    6576/    443C :                     LAB_U010
    6577/    443C : 4A42                	TST.w		d2					; test the number string decimal point index
    6578/    443E : 6602                	BNE.s		LAB_U014				; if dp present skip the reset
    6579/    4440 :                     
    6580/    4440 : 3406                	MOVE.w	d6,d2					; make the decimal point index = the length
    6581/    4442 :                     
    6582/    4442 :                     ; copy the fractional digit characters from the number string
    6583/    4442 :                     
    6584/    4442 :                     LAB_U014
    6585/    4442 : 3602                	MOVE.w	d2,d3					; copy the number string decimal point index
    6586/    4444 : 5243                	ADDQ.w	#1,d3					; increment the number string index
    6587/    4446 : 382F 0008           	MOVE.w	fsdpi(sp),d4			; get the new format string decimal point index
    6588/    444A :                     LAB_U018
    6589/    444A : 5244                	ADDQ.w	#1,d4					; increment the new format string index
    6590/    444C : B244                	CMP.w		d4,d1					; compare it with the new format string length
    6591/    444E : 6322                	BLS.s		LAB_U022				; if done the fraction digits go do integer
    6592/    4450 :                     
    6593/    4450 : 1030 4000           	MOVE.b	(a0,d4.w),d0			; get a new format string character
    6594/    4454 : B03C 0025           	CMP.b		#'%',d0				; compare it with "%"
    6595/    4458 : 6706                	BEQ.s		LAB_U01C				; if "%" go copy a number character
    6596/    445A :                     
    6597/    445A : B03C 0023           	CMP.b		#'#',d0				; compare it with "#"
    6598/    445E : 66EA                	BNE.s		LAB_U018				; if not "#" go do the next new format character
    6599/    4460 :                     
    6600/    4460 :                     LAB_U01C
    6601/    4460 : 7030                	MOVEQ		#'0',d0				; default to "0" character
    6602/    4462 : BC43                	CMP.w		d3,d6					; compare the number string index with length
    6603/    4464 : 6306                	BLS.s		LAB_U020				; if there skip the character get
    6604/    4466 :                     
    6605/    4466 : 1032 3000           	MOVE.b	(a2,d3.w),d0			; get a character from the number string
    6606/    446A : 5243                	ADDQ.w	#1,d3					; increment the number string index
    6607/    446C :                     LAB_U020
    6608/    446C : 1180 4000           	MOVE.b	d0,(a0,d4.w)			; save the number character to the new format
    6609/    4470 :                     								; string
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 115 - 11/4/2023 8:40:20


    6610/    4470 : 60D8                	BRA.s		LAB_U018				; go do the next new format character
    6611/    4472 :                     
    6612/    4472 :                     ; now copy the integer digit characters from the number string
    6613/    4472 :                     
    6614/    4472 :                     LAB_U022
    6615/    4472 : 7C00                	MOVEQ		#0,d6					; clear the sign done flag
    6616/    4474 : 7A00                	MOVEQ		#0,d5					; clear the sign present flag
    6617/    4476 : 5342                	SUBQ.w	#1,d2					; decrement the number string index
    6618/    4478 : 6608                	BNE.s		LAB_U026				; if not now at sign continue
    6619/    447A :                     
    6620/    447A : 7401                	MOVEQ		#1,d2					; increment the number string index
    6621/    447C : 15BC 0030 2000      	MOVE.b	#'0',(a2,d2.w)			; replace the point with a zero
    6622/    4482 :                     LAB_U026
    6623/    4482 : 382F 0008           	MOVE.w	fsdpi(sp),d4			; get the new format string decimal point index
    6624/    4486 : B244                	CMP.w		d4,d1					; compare it with the new format string length
    6625/    4488 : 6402                	BCC.s		LAB_U02A				; if within the string go use the index
    6626/    448A :                     
    6627/    448A : 3801                	MOVE.w	d1,d4					; else set the index to the end of the string
    6628/    448C :                     LAB_U02A
    6629/    448C : 5344                	SUBQ.w	#1,d4					; decrement the new format string index
    6630/    448E : 6B62                	BMI.s		LAB_U03E				; if all done go test for any overflow
    6631/    4490 :                     
    6632/    4490 : 1030 4000           	MOVE.b	(a0,d4.w),d0			; else get a new format string character
    6633/    4494 :                     
    6634/    4494 : 7E30                	MOVEQ		#'0',d7				; default to "0" character
    6635/    4496 : B03C 0025           	CMP.b		#'%',d0				; compare it with "%"
    6636/    449A : 6708                	BEQ.s		LAB_U02B				; if "%" go copy a number character
    6637/    449C :                     
    6638/    449C : 7E20                	MOVEQ		#' ',d7				; default to " " character
    6639/    449E : B03C 0023           	CMP.b		#'#',d0				; compare it with "#"
    6640/    44A2 : 6606                	BNE.s		LAB_U02C				; if not "#" go try ","
    6641/    44A4 :                     
    6642/    44A4 :                     LAB_U02B
    6643/    44A4 : 4A42                	TST.w		d2					; test the number string index
    6644/    44A6 : 6634                	BNE.s		LAB_U036				; if not at the sign go get a number character
    6645/    44A8 :                     
    6646/    44A8 : 6042                	BRA.s		LAB_U03C				; else go save the default character
    6647/    44AA :                     
    6648/    44AA :                     LAB_U02C
    6649/    44AA : B03C 002C           	CMP.b		#',',d0				; compare it with ","
    6650/    44AE : 6610                	BNE.s		LAB_U030				; if not "," go try the sign characters
    6651/    44B0 :                     
    6652/    44B0 : 4A42                	TST.w		d2					; test the number string index
    6653/    44B2 : 6608                	BNE.s		LAB_U02E				; if not at the sign keep the ","
    6654/    44B4 :                     
    6655/    44B4 : 0C30 0025 40FF      	CMP.b		#'%',-1(a0,d4.w)			; else compare the next format string character
    6656/    44BA :                     								; with "%"
    6657/    44BA : 6630                	BNE.s		LAB_U03C				; if not "%" keep the default character
    6658/    44BC :                     
    6659/    44BC :                     LAB_U02E
    6660/    44BC : 1E00                	MOVE.b	d0,d7					; else use the "," character
    6661/    44BE : 602C                	BRA.s		LAB_U03C				; go save the character to the string
    6662/    44C0 :                     
    6663/    44C0 :                     LAB_U030
    6664/    44C0 : B03C 002D           	CMP.b		#'-',d0				; compare it with "-"
    6665/    44C4 : 6710                	BEQ.s		LAB_U034				; if "-" go do the sign character
    6666/    44C6 :                     
    6667/    44C6 : B03C 002B           	CMP.b		#'+',d0				; compare it with "+"
    6668/    44CA : 66C0                	BNE.s		LAB_U02A				; if not "+" go do the next new format character
    6669/    44CC :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 116 - 11/4/2023 8:40:20


    6670/    44CC : 0C12 002D           	CMP.b		#'-',(a2)				; compare the sign character with "-"
    6671/    44D0 : 6704                	BEQ.s		LAB_U034				; if "-" don't change the sign character
    6672/    44D2 :                     
    6673/    44D2 : 14BC 002B           	MOVE.b	#'+',(a2)				; else make the sign character "+"
    6674/    44D6 :                     LAB_U034
    6675/    44D6 : 1A00                	MOVE.b	d0,d5					; set the sign present flag
    6676/    44D8 : 4A42                	TST.w		d2					; test the number string index
    6677/    44DA : 6708                	BEQ.s		LAB_U038				; if at the sign keep the default character
    6678/    44DC :                     
    6679/    44DC :                     LAB_U036
    6680/    44DC : 1E32 2000           	MOVE.b	(a2,d2.w),d7			; else get a character from the number string
    6681/    44E0 : 5342                	SUBQ.w	#1,d2					; decrement the number string index
    6682/    44E2 : 6008                	BRA.s		LAB_U03C				; go save the character
    6683/    44E4 :                     
    6684/    44E4 :                     LAB_U038
    6685/    44E4 : 4A06                	TST.b		d6					; test the sign done flag
    6686/    44E6 : 6604                	BNE.s		LAB_U03C				; if the sign has been done go use the space
    6687/    44E8 :                     								; character
    6688/    44E8 :                     
    6689/    44E8 : 1E12                	MOVE.b	(a2),d7				; else get the sign character
    6690/    44EA : 1C07                	MOVE.b	d7,d6					; flag that the sign has been done
    6691/    44EC :                     LAB_U03C
    6692/    44EC : 1187 4000           	MOVE.b	d7,(a0,d4.w)			; save the number character to the new format
    6693/    44F0 :                     								; string
    6694/    44F0 : 609A                	BRA.s		LAB_U02A				; go do the next new format character
    6695/    44F2 :                     
    6696/    44F2 :                     ; test for overflow conditions
    6697/    44F2 :                     
    6698/    44F2 :                     LAB_U03E
    6699/    44F2 : 4A42                	TST.w		d2					; test the number string index
    6700/    44F4 : 6614                	BNE.s		LAB_U040				; if all the digits aren't done go output
    6701/    44F6 :                     								; an overflow indication
    6702/    44F6 :                     
    6703/    44F6 :                     ; test for sign overflows
    6704/    44F6 :                     
    6705/    44F6 : 4A05                	TST.b		d5					; test the sign present flag
    6706/    44F8 : 6754                	BEQ.s		LAB_U04A				; if no sign present go add the string
    6707/    44FA :                     
    6708/    44FA :                     ; there was a sign in the format string
    6709/    44FA :                     
    6710/    44FA : 4A06                	TST.b		d6					; test the sign done flag
    6711/    44FC : 6650                	BNE.s		LAB_U04A				; if the sign is done go add the string
    6712/    44FE :                     
    6713/    44FE :                     ; the sign isn't done so see if it was mandatory
    6714/    44FE :                     
    6715/    44FE : 0C05 002B           	CMPI.b	#'+',d5				; compare the sign with "+"
    6716/    4502 : 6706                	BEQ.s		LAB_U040				; if it was "+" go output an overflow
    6717/    4504 :                     								; indication
    6718/    4504 :                     
    6719/    4504 :                     ; the sign wasn't mandatory but the number may have been negative
    6720/    4504 :                     
    6721/    4504 : 0C12 002D           	CMP.b		#'-',(a2)				; compare the sign character with "-"
    6722/    4508 : 6644                	BNE.s		LAB_U04A				; if it wasn't "-" go add the string
    6723/    450A :                     
    6724/    450A :                     ; else the sign was "-" and a sign hasn't been output so ..
    6725/    450A :                     
    6726/    450A :                     ; the number overflowed the format string so replace all the special format characters
    6727/    450A :                     ; with the overflow character
    6728/    450A :                     
    6729/    450A :                     LAB_U040
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 117 - 11/4/2023 8:40:20


    6730/    450A : 7A23                	MOVEQ		#ofchr,d5				; set the overflow character
    6731/    450C : 3E01                	MOVE.w	d1,d7					; copy the new format string length
    6732/    450E : 5347                	SUBQ.w	#1,d7					; adjust for the loop type
    6733/    4510 : 3C2F 0004           	MOVE.w	fsti(sp),d6				; copy the new format string last index
    6734/    4514 : 5346                	SUBQ.w	#1,d6					; -1 gives the last character of this string
    6735/    4516 : 6E02                	BGT.s		LAB_U044				; if not zero continue
    6736/    4518 :                     
    6737/    4518 : 3C07                	MOVE.w	d7,d6					; else set the format string index to the end
    6738/    451A :                     LAB_U044
    6739/    451A : 1031 6000           	MOVE.b	(a1,d6.w),d0			; get a character from the format string
    6740/    451E : 0C00 0023           	CMPI.b	#'#',d0				; compare it with "#" special format character
    6741/    4522 : 671E                	BEQ.s		LAB_U046				; if "#" go use the overflow character
    6742/    4524 :                     
    6743/    4524 : 0C00 0025           	CMPI.b	#'%',d0				; compare it with "%" special format character
    6744/    4528 : 6718                	BEQ.s		LAB_U046				; if "%" go use the overflow character
    6745/    452A :                     
    6746/    452A : 0C00 002C           	CMPI.b	#',',d0				; compare it with "," special format character
    6747/    452E : 6712                	BEQ.s		LAB_U046				; if "," go use the overflow character
    6748/    4530 :                     
    6749/    4530 : 0C00 002B           	CMPI.b	#'+',d0				; compare it with "+" special format character
    6750/    4534 : 670C                	BEQ.s		LAB_U046				; if "+" go use the overflow character
    6751/    4536 :                     
    6752/    4536 : 0C00 002D           	CMPI.b	#'-',d0				; compare it with "-" special format character
    6753/    453A : 6706                	BEQ.s		LAB_U046				; if "-" go use the overflow character
    6754/    453C :                     
    6755/    453C : 0C00 002E           	CMPI.b	#'.',d0				; compare it with "." special format character
    6756/    4540 : 6602                	BNE.s		LAB_U048				; if not "." skip the using overflow character
    6757/    4542 :                     
    6758/    4542 :                     LAB_U046
    6759/    4542 : 1005                	MOVE.b	d5,d0					; use the overflow character
    6760/    4544 :                     LAB_U048
    6761/    4544 : 1180 7000           	MOVE.b	d0,(a0,d7.w)			; save the character to the new format string
    6762/    4548 : 5346                	SUBQ.w	#1,d6					; decrement the format string index
    6763/    454A : 51CF FFCE           	DBF		d7,LAB_U044				; decrement the count and loop if not all done
    6764/    454E :                     
    6765/    454E :                     ; add the new string to the previous string
    6766/    454E :                     
    6767/    454E :                     LAB_U04A
    6768/    454E : 41EC 0006           	LEA		6(a4),a0				; get the descriptor pointer for string 1
    6769/    4552 : 274C 0590           	MOVE.l	a4,FAC1_m(a3)			; save the descriptor pointer for string 2
    6770/    4556 : 6100 F004           	BSR		LAB_224E				; concatenate the strings
    6771/    455A :                     
    6772/    455A :                     ; now check for any tail on the format string
    6773/    455A :                     
    6774/    455A : 302F 0004           	MOVE.w	fsti(sp),d0				; get this index
    6775/    455E : 6720                	BEQ.s		LAB_U04C				; if at start of string skip the output
    6776/    4560 :                     
    6777/    4560 : 3F40 0006           	MOVE.w	d0,fsli(sp)				; save this index to the last index
    6778/    4564 : 6100 0084           	BSR		LAB_ProcFo				; now process the format string
    6779/    4568 : 4A02                	TST.b		d2					; test the special characters flag
    6780/    456A : 6614                	BNE.s		LAB_U04C				; if special characters present skip the output
    6781/    456C :                     
    6782/    456C :                     ; else output the new string part
    6783/    456C :                     
    6784/    456C : 613E                	BSR.s		LAB_DupFmt				; duplicate the processed format string section
    6785/    456E : 3F6F 0004 0006      	MOVE.w	fsti(sp),fsli(sp)			; copy this index to the last index
    6786/    4574 :                     
    6787/    4574 :                     ; add the new string to the previous string
    6788/    4574 :                     
    6789/    4574 : 41EC 0006           	LEA		6(a4),a0				; get the descriptor pointer for string 1
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 118 - 11/4/2023 8:40:20


    6790/    4578 : 274C 0590           	MOVE.l	a4,FAC1_m(a3)			; save the descriptor pointer for string 2
    6791/    457C : 6100 EFDE           	BSR		LAB_224E				; concatenate the strings
    6792/    4580 :                     
    6793/    4580 :                     ; check for another value or end of function
    6794/    4580 :                     
    6795/    4580 :                     LAB_U04C
    6796/    4580 : 101D                	MOVE.b	(a5)+,d0				; get the next BASIC byte
    6797/    4582 : B03C 0029           	CMP.b		#')',d0				; compare with close bracket
    6798/    4586 : 6600 FDCA           	BNE		LAB_U002				; if not ")" go do next value
    6799/    458A :                     
    6800/    458A :                     ; pop the result string off the descriptor stack
    6801/    458A :                     
    6802/    458A : 204C                	MOVEA.l	a4,a0					; copy the result string descriptor pointer
    6803/    458C : 222B 0446           	MOVE.l	Sstorl(a3),d1			; save the bottom of string space
    6804/    4590 : 6100 F02C           	BSR		LAB_22BA				; pop (a0) descriptor, returns with ..
    6805/    4594 :                     								; d0 = length, a0 = pointer
    6806/    4594 : 2741 0446           	MOVE.l	d1,Sstorl(a3)			; restore the bottom of string space
    6807/    4598 : 2248                	MOVEA.l	a0,a1					; copy the string result pointer
    6808/    459A : 3200                	MOVE.w	d0,d1					; copy the string result length
    6809/    459C :                     
    6810/    459C :                     ; pop the format string off the descriptor stack
    6811/    459C :                     
    6812/    459C : 205F                	MOVEA.l	(sp)+,a0				; pull the format string descriptor pointer
    6813/    459E : 6100 F01E           	BSR		LAB_22BA				; pop (a0) descriptor, returns with ..
    6814/    45A2 :                     								; d0 = length, a0 = pointer
    6815/    45A2 :                     
    6816/    45A2 : 4FEF 0008           	LEA		fend(sp),sp				; dump the saved values
    6817/    45A6 :                     
    6818/    45A6 :                     ; push the result string back on the descriptor stack and return
    6819/    45A6 :                     
    6820/    45A6 : 2049                	MOVEA.l	a1,a0					; copy the result string pointer back
    6821/    45A8 : 6000 EE62           	BRA		LAB_RTST				; push a string on the descriptor stack and
    6822/    45AC :                     								; return. a0 = pointer, d1 = length
    6823/    45AC :                     
    6824/    45AC :                     
    6825/    45AC :                     ;************************************************************************************
    6826/    45AC :                     ;
    6827/    45AC :                     ; duplicate the processed format string section
    6828/    45AC :                     
    6829/    45AC :                     								; make a string as long as the format string
    6830/    45AC :                     LAB_DupFmt
    6831/    45AC : 226F 0004           	MOVEA.l	4+fsd(sp),a1			; get the format string descriptor pointer
    6832/    45B0 : 3E29 0004           	MOVE.w	4(a1),d7				; get the format string length
    6833/    45B4 : 342F 000A           	MOVE.w	4+fsli(sp),d2			; get the format string last index
    6834/    45B8 : 3C2F 0008           	MOVE.w	4+fsti(sp),d6			; get the format string this index
    6835/    45BC : 3206                	MOVE.w	d6,d1					; copy the format string this index
    6836/    45BE : 9242                	SUB.w		d2,d1					; subtract the format string last index
    6837/    45C0 : 6202                	BHI.s		LAB_D002				; if > 0 skip the correction
    6838/    45C2 :                     
    6839/    45C2 : D247                	ADD.w		d7,d1					; else add the format string length as the
    6840/    45C4 :                     								; correction
    6841/    45C4 :                     LAB_D002
    6842/    45C4 : 6100 EE60           	BSR		LAB_2115				; make string space d1 bytes long
    6843/    45C8 :                     								; return a0/Sutill = pointer, others unchanged
    6844/    45C8 :                     
    6845/    45C8 :                     ; push the new string on the descriptor stack
    6846/    45C8 :                     
    6847/    45C8 : 6100 EE42           	BSR		LAB_RTST				; push a string on the descriptor stack and
    6848/    45CC :                     								; return. a0 = pointer, d1 = length
    6849/    45CC :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 119 - 11/4/2023 8:40:20


    6850/    45CC :                     ; copy the characters from the format string
    6851/    45CC :                     
    6852/    45CC : 226F 0004           	MOVEA.l	4+fsd(sp),a1			; get the format string descriptor pointer
    6853/    45D0 : 2251                	MOVEA.l	(a1),a1				; get the format string pointer
    6854/    45D2 : 7800                	MOVEQ		#0,d4					; clear the new string index
    6855/    45D4 :                     LAB_D00A
    6856/    45D4 : 11B1 2000 4000      	MOVE.b	(a1,d2.w),(a0,d4.w)		; get a character from the format string and
    6857/    45DA :                     								; save it to the new string
    6858/    45DA : 5244                	ADDQ.w	#1,d4					; increment the new string index
    6859/    45DC : 5242                	ADDQ.w	#1,d2					; increment the format string index
    6860/    45DE : BE42                	CMP.w		d2,d7					; compare the format index with the length
    6861/    45E0 : 6602                	BNE.s		LAB_D00E				; if not there skip the reset
    6862/    45E2 :                     
    6863/    45E2 : 7400                	MOVEQ		#0,d2					; else reset the format string index
    6864/    45E4 :                     LAB_D00E
    6865/    45E4 : BC42                	CMP.w		d2,d6					; compare the index with this index
    6866/    45E6 : 66EC                	BNE.s		LAB_D00A				; if not equal go do the next character
    6867/    45E8 :                     
    6868/    45E8 : 4E75                	RTS
    6869/    45EA :                     
    6870/    45EA :                     
    6871/    45EA :                     ;************************************************************************************
    6872/    45EA :                     ;
    6873/    45EA :                     ; process the format string
    6874/    45EA :                     
    6875/    45EA :                     LAB_ProcFo
    6876/    45EA : 226F 0004           	MOVEA.l	4+fsd(sp),a1			; get the format string descriptor pointer
    6877/    45EE : 3E29 0004           	MOVE.w	4(a1),d7				; get the format string length
    6878/    45F2 : 2251                	MOVEA.l	(a1),a1				; get the format string pointer
    6879/    45F4 : 3C2F 000A           	MOVE.w	4+fsli(sp),d6			; get the format string last index
    6880/    45F8 :                     
    6881/    45F8 : 3F47 000C           	MOVE.w	d7,4+fsdpi(sp)			; set the format string decimal point index
    6882/    45FC :                     ;##	MOVE.w	#-1,4+fsdpi(sp)			; set the format string decimal point index
    6883/    45FC : 7A00                	MOVEQ		#0,d5					; no decimal point
    6884/    45FE : 7600                	MOVEQ		#0,d3					; no decimal characters
    6885/    4600 : 7400                	MOVEQ		#0,d2					; no special characters
    6886/    4602 :                     LAB_P004
    6887/    4602 : 1031 6000           	MOVE.b	(a1,d6.w),d0			; get a format string byte
    6888/    4606 :                     
    6889/    4606 : B03C 002C           	CMP.b		#',',d0				; compare it with ","
    6890/    460A : 6742                	BEQ.s		LAB_P01A				; if "," go do the next format string byte
    6891/    460C :                     
    6892/    460C : B03C 0023           	CMP.b		#'#',d0				; compare it with "#"
    6893/    4610 : 6706                	BEQ.s		LAB_P008				; if "#" go flag special characters
    6894/    4612 :                     
    6895/    4612 : B03C 0025           	CMP.b		#'%',d0				; compare it with "%"
    6896/    4616 : 6608                	BNE.s		LAB_P00C				; if not "%" go try "+"
    6897/    4618 :                     
    6898/    4618 :                     LAB_P008
    6899/    4618 : 4A85                	TST.l		d5					; test the decimal point flag
    6900/    461A : 6A10                	BPL.s		LAB_P00E				; if no point skip counting decimal characters
    6901/    461C :                     
    6902/    461C : 5243                	ADDQ.w	#1,d3					; else increment the decimal character count
    6903/    461E : 602E                	BRA.s		LAB_P01A				; go do the next character
    6904/    4620 :                     
    6905/    4620 :                     LAB_P00C
    6906/    4620 : B03C 002B           	CMP.b		#'+',d0				; compare it with "+"
    6907/    4624 : 6706                	BEQ.s		LAB_P00E				; if "+" go flag special characters
    6908/    4626 :                     
    6909/    4626 : B03C 002D           	CMP.b		#'-',d0				; compare it with "-"
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 120 - 11/4/2023 8:40:20


    6910/    462A : 6604                	BNE.s		LAB_P010				; if not "-" go check decimal point
    6911/    462C :                     
    6912/    462C :                     LAB_P00E
    6913/    462C : 8400                	OR.b		d0,d2					; flag special characters
    6914/    462E : 601E                	BRA.s		LAB_P01A				; go do the next character
    6915/    4630 :                     
    6916/    4630 :                     LAB_P010
    6917/    4630 : B03C 002E           	CMP.b		#'.',d0				; compare it with "."
    6918/    4634 : 6614                	BNE.s		LAB_P018				; if not "." go check next
    6919/    4636 :                     
    6920/    4636 :                     ; "." a decimal point
    6921/    4636 :                     
    6922/    4636 : 4A85                	TST.l		d5					; if there is already a decimal point
    6923/    4638 : 6B14                	BMI.s		LAB_P01A				; go do the next character
    6924/    463A :                     
    6925/    463A : 3006                	MOVE.w	d6,d0					; copy the decimal point index
    6926/    463C : 906F 000A           	SUB.w		4+fsli(sp),d0			; calculate it from the scan start
    6927/    4640 : 3F40 000C           	MOVE.w	d0,4+fsdpi(sp)			; save the decimal point index
    6928/    4644 : 7AFF                	MOVEQ		#-1,d5				; flag decimal point
    6929/    4646 : 8400                	OR.b		d0,d2					; flag special characters
    6930/    4648 : 6004                	BRA.s		LAB_P01A				; go do the next character
    6931/    464A :                     
    6932/    464A :                     ; was not a special character
    6933/    464A :                     
    6934/    464A :                     LAB_P018
    6935/    464A : 4A02                	TST.b		d2					; test if there have been special characters
    6936/    464C : 6608                	BNE.s		LAB_P01E				; if so exit the format string process
    6937/    464E :                     
    6938/    464E :                     LAB_P01A
    6939/    464E : 5246                	ADDQ.w	#1,d6					; increment the format string index
    6940/    4650 : BE46                	CMP.w		d6,d7					; compare it with the format string length
    6941/    4652 : 62AE                	BHI.s		LAB_P004				; if length > index go get the next character
    6942/    4654 :                     
    6943/    4654 : 7C00                	MOVEQ		#0,d6					; length = index so reset the format string
    6944/    4656 :                     								; index
    6945/    4656 :                     LAB_P01E
    6946/    4656 : 3F46 0008           	MOVE.w	d6,4+fsti(sp)			; save the format string this index
    6947/    465A : 3F43 000E           	MOVE.w	d3,4+fsdc(sp)			; save the format string decimal characters
    6948/    465E :                     
    6949/    465E : 4E75                	RTS
    6950/    4660 :                     
    6951/    4660 :                     
    6952/    4660 :                     ;************************************************************************************
    6953/    4660 :                     ;
    6954/    4660 :                     ; perform BIN$()
    6955/    4660 :                     ; # of leading 0s is in d1, the number is in d0
    6956/    4660 :                     
    6957/    4660 :                     LAB_BINS
    6958/    4660 : B23C 0021           	CMP.b		#$21,d1				; max + 1
    6959/    4664 : 6400 DAF6           	BCC		LAB_FCER				; exit if too big ( > or = )
    6960/    4668 :                     
    6961/    4668 : 741F                	MOVEQ		#$1F,d2				; bit count-1
    6962/    466A : 41EB 05B6           	LEA		Binss(a3),a0			; point to string
    6963/    466E : 7830                	MOVEQ		#$30,d4				; "0" character for ADDX
    6964/    4670 :                     NextB1
    6965/    4670 : 7600                	MOVEQ		#0,d3					; clear byte
    6966/    4672 : E288                	LSR.l		#1,d0					; shift bit into Xb
    6967/    4674 : D704                	ADDX.b	d4,d3					; add carry and character to zero
    6968/    4676 : 1183 2000           	MOVE.b	d3,(a0,d2.w)			; save character to string
    6969/    467A : 51CA FFF4           	DBF		d2,NextB1				; decrement and loop if not done
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 121 - 11/4/2023 8:40:20


    6970/    467E :                     
    6971/    467E :                     ; this is the exit code and is also used by HEX$()
    6972/    467E :                     
    6973/    467E :                     EndBHS
    6974/    467E : 177C 0000 05D6      	MOVE.b	#0,BHsend(a3)			; null terminate the string
    6975/    4684 : 4A01                	TST.b		d1					; test # of characters
    6976/    4686 : 670E                	BEQ.s		NextB2				; go truncate string
    6977/    4688 :                     
    6978/    4688 : 4481                	NEG.l		d1					; make -ve
    6979/    468A : D2BC 0000 05D6      	ADD.l		#BHsend,d1				; effectively (end-length)
    6980/    4690 : 41F3 1000           	LEA		0(a3,d1.w),a0			; effectively add (end-length) to pointer
    6981/    4694 : 600E                	BRA.s		BinPr					; go print string
    6982/    4696 :                     
    6983/    4696 :                     ; truncate string to remove leading "0"s
    6984/    4696 :                     
    6985/    4696 :                     NextB2
    6986/    4696 : 1010                	MOVE.b	(a0),d0				; get byte
    6987/    4698 : 670A                	BEQ.s		BinPr					; if null then end of string so add 1 and go
    6988/    469A :                     								; print it
    6989/    469A :                     
    6990/    469A : B03C 0030           	CMP.b		#'0',d0				; compare with "0"
    6991/    469E : 660E                	BNE.s		GoPr					; if not "0" then go print string from here
    6992/    46A0 :                     
    6993/    46A0 : 5248                	ADDQ.w	#1,a0					; else increment pointer
    6994/    46A2 : 60F2                	BRA.s		NextB2				; loop always
    6995/    46A4 :                     
    6996/    46A4 :                     ; make fixed length output string - ignore overflows!
    6997/    46A4 :                     
    6998/    46A4 :                     BinPr
    6999/    46A4 : 43EB 05D6           	LEA		BHsend(a3),a1			; get string end
    7000/    46A8 : B1C9                	CMPA.l	a1,a0					; are we at the string end
    7001/    46AA : 6602                	BNE.s		GoPr					; branch if not
    7002/    46AC :                     
    7003/    46AC : 5348                	SUBQ.w	#1,a0					; else need at least one zero
    7004/    46AE :                     GoPr
    7005/    46AE : 6000 ED16           	BRA		LAB_20AE				; print " terminated string to FAC1, stack & RET
    7006/    46B2 :                     
    7007/    46B2 :                     
    7008/    46B2 :                     ;************************************************************************************
    7009/    46B2 :                     ;
    7010/    46B2 :                     ; perform HEX$()
    7011/    46B2 :                     ; # of leading 0s is in d1, the number is in d0
    7012/    46B2 :                     
    7013/    46B2 :                     LAB_HEXS
    7014/    46B2 : B23C 0009           	CMP.b		#$09,d1				; max + 1
    7015/    46B6 : 6400 DAA4           	BCC		LAB_FCER				; exit if too big ( > or = )
    7016/    46BA :                     
    7017/    46BA : 7407                	MOVEQ		#$07,d2				; nibble count-1
    7018/    46BC : 41EB 05CE           	LEA		Hexss(a3),a0			; point to string
    7019/    46C0 : 7830                	MOVEQ		#$30,d4				; "0" character for ABCD
    7020/    46C2 :                     NextH1
    7021/    46C2 : 1600                	MOVE.b	d0,d3					; copy lowest byte
    7022/    46C4 : E898                	ROR.l		#4,d0					; shift nibble into 0-3
    7023/    46C6 : C63C 000F           	AND.b		#$0F,d3				; just this nibble
    7024/    46CA : 1A03                	MOVE.b	d3,d5					; copy it
    7025/    46CC : DA3C 00F6           	ADD.b		#$F6,d5				; set extend bit
    7026/    46D0 : C704                	ABCD		d4,d3					; decimal add extend and character to zero
    7027/    46D2 : 1183 2000           	MOVE.b	d3,(a0,d2.w)			; save character to string
    7028/    46D6 : 51CA FFEA           	DBF		d2,NextH1				; decrement and loop if not done
    7029/    46DA :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 122 - 11/4/2023 8:40:20


    7030/    46DA : 60A2                	BRA.s		EndBHS				; go process string
    7031/    46DC :                     
    7032/    46DC :                     
    7033/    46DC :                     ;************************************************************************************
    7034/    46DC :                     ;
    7035/    46DC :                     ; ctrl-c check routine. includes limited "life" byte save for INGET routine
    7036/    46DC :                     
    7037/    46DC :                     VEC_CC
    7038/    46DC : 4A2B 05E8           	TST.b		ccflag(a3)				; check [CTRL-C] check flag
    7039/    46E0 : 661E                	BNE.s		RTS_022				; exit if [CTRL-C] check inhibited
    7040/    46E2 :                     
    7041/    46E2 : 4EAB 040C           	JSR		V_INPT(a3)				; scan input device
    7042/    46E6 : 640E                	BCC.s		LAB_FBA0				; exit if buffer empty
    7043/    46E8 :                     
    7044/    46E8 : 1740 05E9           	MOVE.b	d0,ccbyte(a3)			; save received byte
    7045/    46EC : 177C 0020 05EA      	MOVE.b	#$20,ccnull(a3)			; set "life" timer for bytes countdown
    7046/    46F2 : 6000 DEDE           	BRA		LAB_1636				; return to BASIC
    7047/    46F6 :                     
    7048/    46F6 :                     LAB_FBA0
    7049/    46F6 : 4A2B 05EA           	TST.b		ccnull(a3)				; get countdown byte
    7050/    46FA : 6704                	BEQ.s		RTS_022				; exit if finished
    7051/    46FC :                     
    7052/    46FC : 532B 05EA           	SUBQ.b	#1,ccnull(a3)			; else decrement countdown
    7053/    4700 :                     RTS_022
    7054/    4700 : 4E75                	RTS
    7055/    4702 :                     
    7056/    4702 :                     
    7057/    4702 :                     ;************************************************************************************
    7058/    4702 :                     ;
    7059/    4702 :                     ; get byte from input device, no waiting
    7060/    4702 :                     ; returns with carry set if byte in A
    7061/    4702 :                     
    7062/    4702 :                     INGET
    7063/    4702 : 4EAB 040C           	JSR		V_INPT(a3)				; call scan input device
    7064/    4706 : 650A                	BCS.s		LAB_FB95				; if byte go reset timer
    7065/    4708 :                     
    7066/    4708 : 102B 05EA           	MOVE.b	ccnull(a3),d0			; get countdown
    7067/    470C : 67F2                	BEQ.s		RTS_022				; exit if empty
    7068/    470E :                     
    7069/    470E : 102B 05E9           	MOVE.b	ccbyte(a3),d0			; get last received byte
    7070/    4712 :                     LAB_FB95
    7071/    4712 : 177C 0000 05EA      	MOVE.b	#$00,ccnull(a3)			; clear timer because we got a byte
    7072/    4718 : 003C 0001           	ORI.b		#1,CCR				; set carry, flag we got a byte
    7073/    471C : 4E75                	RTS
    7074/    471E :                     
    7075/    471E :                     
    7076/    471E :                     ;************************************************************************************
    7077/    471E :                     ;
    7078/    471E :                     ; perform MAX()
    7079/    471E :                     
    7080/    471E :                     LAB_MAX
    7081/    471E : 6100 E530           	BSR		LAB_EVEZ				; evaluate expression (no decrement)
    7082/    4722 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type
    7083/    4726 : 6B00 DA14           	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
    7084/    472A :                     
    7085/    472A :                     LAB_MAXN
    7086/    472A : 612E                	BSR.s		LAB_PHFA				; push FAC1, evaluate expression,
    7087/    472C :                     								; pull FAC2 & compare with FAC1
    7088/    472C : 64FC                	BCC.s		LAB_MAXN				; branch if no swap to do
    7089/    472E :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 123 - 11/4/2023 8:40:20


    7090/    472E : 6100 F4A0           	BSR		LAB_279B				; copy FAC2 to FAC1
    7091/    4732 : 60F6                	BRA.s		LAB_MAXN				; go do next
    7092/    4734 :                     
    7093/    4734 :                     
    7094/    4734 :                     ;************************************************************************************
    7095/    4734 :                     ;
    7096/    4734 :                     ; perform MIN()
    7097/    4734 :                     
    7098/    4734 :                     LAB_MIN
    7099/    4734 : 6100 E51A           	BSR		LAB_EVEZ				; evaluate expression (no decrement)
    7100/    4738 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type
    7101/    473C : 6B00 D9FE           	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
    7102/    4740 :                     
    7103/    4740 :                     LAB_MINN
    7104/    4740 : 6118                	BSR.s		LAB_PHFA				; push FAC1, evaluate expression,
    7105/    4742 :                     								; pull FAC2 & compare with FAC1
    7106/    4742 : 63FC                	BLS.s		LAB_MINN				; branch if no swap to do
    7107/    4744 :                     
    7108/    4744 : 6100 F48A           	BSR		LAB_279B				; copy FAC2 to FAC1
    7109/    4748 : 60F6                	BRA.s		LAB_MINN				; go do next (branch always)
    7110/    474A :                     
    7111/    474A :                     ; exit routine. don't bother returning to the loop code
    7112/    474A :                     ; check for correct exit, else so syntax error
    7113/    474A :                     
    7114/    474A :                     LAB_MMEC
    7115/    474A : B03C 0029           	CMP.b		#')',d0				; is it end of function?
    7116/    474E : 6600 DA18           	BNE		LAB_SNER				; if not do MAX MIN syntax error
    7117/    4752 :                     
    7118/    4752 : 4FEF 0004           	LEA		4(sp),sp				; dump return address (faster)
    7119/    4756 : 6000 E656           	BRA		LAB_IGBY				; update BASIC execute pointer (to chr past ")")
    7120/    475A :                     								; and return
    7121/    475A :                     
    7122/    475A :                     ; check for next, evaluate & return or exit
    7123/    475A :                     ; this is the routine that does most of the work
    7124/    475A :                     
    7125/    475A :                     LAB_PHFA
    7126/    475A : 6100 E654           	BSR		LAB_GBYT				; get next BASIC byte
    7127/    475E : B03C 002C           	CMP.b		#',',d0				; is there more ?
    7128/    4762 : 66E6                	BNE.s		LAB_MMEC				; if not go do end check
    7129/    4764 :                     
    7130/    4764 : 3F2B 0594           	MOVE.w	FAC1_e(a3),-(sp)			; push exponent and sign
    7131/    4768 : 2F2B 0590           	MOVE.l	FAC1_m(a3),-(sp)			; push mantissa
    7132/    476C :                     
    7133/    476C : 6100 E4E2           	BSR		LAB_EVEZ				; evaluate expression (no decrement)
    7134/    4770 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type
    7135/    4774 : 6B00 D9C6           	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
    7136/    4778 :                     
    7137/    4778 :                     
    7138/    4778 :                     								; pop FAC2 (MAX/MIN expression so far)
    7139/    4778 : 275F 0598           	MOVE.l	(sp)+,FAC2_m(a3)			; pop mantissa
    7140/    477C :                     
    7141/    477C : 301F                	MOVE.w	(sp)+,d0				; pop exponent and sign
    7142/    477E : 3740 059C           	MOVE.w	d0,FAC2_e(a3)			; save exponent and sign
    7143/    4782 : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; get FAC1 sign
    7144/    4788 : B12B 059E           	EOR.b		d0,FAC_sc(a3)			; EOR to create sign compare
    7145/    478C : 6000 F4AE           	BRA		LAB_27FA				; compare FAC1 with FAC2 & return
    7146/    4790 :                     								; returns d0=+1 Cb=0 if FAC1 > FAC2
    7147/    4790 :                     								; returns d0= 0 Cb=0 if FAC1 = FAC2
    7148/    4790 :                     								; returns d0=-1 Cb=1 if FAC1 < FAC2
    7149/    4790 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 124 - 11/4/2023 8:40:20


    7150/    4790 :                     
    7151/    4790 :                     ;************************************************************************************
    7152/    4790 :                     ;
    7153/    4790 :                     ; perform WIDTH
    7154/    4790 :                     
    7155/    4790 :                     LAB_WDTH
    7156/    4790 : B03C 002C           	CMP.b		#',',d0				; is next byte ","
    7157/    4794 : 672C                	BEQ.s		LAB_TBSZ				; if so do tab size
    7158/    4796 :                     
    7159/    4796 : 6100 EF82           	BSR		LAB_GTBY				; get byte parameter, result in d0 and Itemp
    7160/    479A : 4A00                	TST.b		d0					; test result
    7161/    479C : 6712                	BEQ.s		LAB_NSTT				; branch if set for infinite line
    7162/    479E :                     
    7163/    479E : B03C 0010           	CMP.b		#$10,d0				; else make min width = 16d
    7164/    47A2 : 6500 D9B8           	BCS		LAB_FCER				; if less do function call error & exit
    7165/    47A6 :                     
    7166/    47A6 :                     ; this next compare ensures that we can't exit WIDTH via an error leaving the
    7167/    47A6 :                     ; tab size greater than the line length.
    7168/    47A6 :                     
    7169/    47A6 : B02B 05E2           	CMP.b		TabSiz(a3),d0			; compare with tab size
    7170/    47AA : 6404                	BCC.s		LAB_NSTT				; branch if >= tab size
    7171/    47AC :                     
    7172/    47AC : 1740 05E2           	MOVE.b	d0,TabSiz(a3)			; else make tab size = terminal width
    7173/    47B0 :                     LAB_NSTT
    7174/    47B0 : 1740 05E6           	MOVE.b	d0,TWidth(a3)			; set the terminal width
    7175/    47B4 : 6100 E5FA           	BSR		LAB_GBYT				; get BASIC byte back
    7176/    47B8 : 672C                	BEQ.s		WExit					; exit if no following
    7177/    47BA :                     
    7178/    47BA : B03C 002C           	CMP.b		#',',d0				; else is it ","
    7179/    47BE : 6600 D9A8           	BNE		LAB_SNER				; if not do syntax error
    7180/    47C2 :                     
    7181/    47C2 :                     LAB_TBSZ
    7182/    47C2 : 6100 EF52           	BSR		LAB_SGBY				; increment and get byte, result in d0 and Itemp
    7183/    47C6 : 4A00                	TST.b		d0					; test TAB size
    7184/    47C8 : 6B00 D992           	BMI		LAB_FCER				; if >127 do function call error & exit
    7185/    47CC :                     
    7186/    47CC : B03C 0001           	CMP.b		#1,d0					; compare with min-1
    7187/    47D0 : 6500 D98A           	BCS		LAB_FCER				; if <=1 do function call error & exit
    7188/    47D4 :                     
    7189/    47D4 : 122B 05E6           	MOVE.b	TWidth(a3),d1			; set flags for width
    7190/    47D8 : 6708                	BEQ.s		LAB_SVTB				; skip check if infinite line
    7191/    47DA :                     
    7192/    47DA : B02B 05E6           	CMP.b		TWidth(a3),d0			; compare TAB with width
    7193/    47DE : 6E00 D97C           	BGT		LAB_FCER				; branch if too big
    7194/    47E2 :                     
    7195/    47E2 :                     LAB_SVTB
    7196/    47E2 : 1740 05E2           	MOVE.b	d0,TabSiz(a3)			; save TAB size
    7197/    47E6 :                     
    7198/    47E6 :                     ; calculate tab column limit from TAB size. The Iclim is set to the last tab
    7199/    47E6 :                     ; position on a line that still has at least one whole tab width between it
    7200/    47E6 :                     ; and the end of the line.
    7201/    47E6 :                     
    7202/    47E6 :                     WExit
    7203/    47E6 : 102B 05E6           	MOVE.b	TWidth(a3),d0			; get width
    7204/    47EA : 670A                	BEQ.s		LAB_WDLP				; branch if infinite line
    7205/    47EC :                     
    7206/    47EC : B02B 05E2           	CMP.b		TabSiz(a3),d0			; compare with tab size
    7207/    47F0 : 6404                	BCC.s		LAB_WDLP				; branch if >= tab size
    7208/    47F2 :                     
    7209/    47F2 : 1740 05E2           	MOVE.b	d0,TabSiz(a3)			; else make tab size = terminal width
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 125 - 11/4/2023 8:40:20


    7210/    47F6 :                     LAB_WDLP
    7211/    47F6 : 902B 05E2           	SUB.b		TabSiz(a3),d0			; subtract tab size
    7212/    47FA : 64FA                	BCC.s		LAB_WDLP				; loop while no borrow
    7213/    47FC :                     
    7214/    47FC : D02B 05E2           	ADD.b		TabSiz(a3),d0			; add tab size back
    7215/    4800 : D02B 05E2           	ADD.b		TabSiz(a3),d0			; add tab size back again
    7216/    4804 :                     
    7217/    4804 : 4400                	NEG.b		d0					; make -ve
    7218/    4806 : D02B 05E6           	ADD.b		TWidth(a3),d0			; subtract remainder from width
    7219/    480A : 1740 05E7           	MOVE.b	d0,Iclim(a3)			; save tab column limit
    7220/    480E :                     RTS_023
    7221/    480E : 4E75                	RTS
    7222/    4810 :                     
    7223/    4810 :                     
    7224/    4810 :                     ;************************************************************************************
    7225/    4810 :                     ;
    7226/    4810 :                     ; perform SQR()
    7227/    4810 :                     
    7228/    4810 :                     ; d0 is number to find the root of
    7229/    4810 :                     ; d1 is the root result
    7230/    4810 :                     ; d2 is the remainder
    7231/    4810 :                     ; d3 is a counter
    7232/    4810 :                     ; d4 is temp
    7233/    4810 :                     
    7234/    4810 :                     LAB_SQR
    7235/    4810 : 4A2B 0595           	TST.b		FAC1_s(a3)				; test FAC1 sign
    7236/    4814 : 6B00 D946           	BMI		LAB_FCER				; if -ve do function call error
    7237/    4818 :                     
    7238/    4818 : 4A2B 0594           	TST.b		FAC1_e(a3)				; test exponent
    7239/    481C : 67F0                	BEQ.s		RTS_023				; exit if zero
    7240/    481E :                     
    7241/    481E : 48E7 7800           	MOVEM.l	d1-d4,-(sp)				; save registers
    7242/    4822 : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; copy FAC1
    7243/    4826 : 7400                	MOVEQ		#0,d2					; clear remainder
    7244/    4828 : 2202                	MOVE.l	d2,d1					; clear root
    7245/    482A :                     
    7246/    482A : 761F                	MOVEQ		#$1F,d3				; $1F for DBF, 64 pairs of bits to
    7247/    482C :                     								; do for a 32 bit result
    7248/    482C : 082B 0000 0594      	BTST		#0,FAC1_e(a3)			; test exponent odd/even
    7249/    4832 : 6606                	BNE.s		LAB_SQE2				; if odd only 1 shift first time
    7250/    4834 :                     
    7251/    4834 :                     LAB_SQE1
    7252/    4834 : D080                	ADD.l		d0,d0					; shift highest bit of number ..
    7253/    4836 : D582                	ADDX.l	d2,d2					; .. into remainder .. never overflows
    7254/    4838 : D281                	ADD.l		d1,d1					; root = root	; 2 .. never overflows
    7255/    483A :                     LAB_SQE2
    7256/    483A : D080                	ADD.l		d0,d0					; shift highest bit of number ..
    7257/    483C : D582                	ADDX.l	d2,d2					; .. into remainder .. never overflows
    7258/    483E :                     
    7259/    483E : 2801                	MOVE.l	d1,d4					; copy root
    7260/    4840 : D884                	ADD.l		d4,d4					; 2n
    7261/    4842 : 5284                	ADDQ.l	#1,d4					; 2n+1
    7262/    4844 :                     
    7263/    4844 : B484                	CMP.l		d4,d2					; compare 2n+1 to remainder
    7264/    4846 : 6504                	BCS.s		LAB_SQNS				; skip sub if remainder smaller
    7265/    4848 :                     
    7266/    4848 : 9484                	SUB.l		d4,d2					; subtract temp from remainder
    7267/    484A : 5281                	ADDQ.l	#1,d1					; increment root
    7268/    484C :                     LAB_SQNS
    7269/    484C : 51CB FFE6           	DBF		d3,LAB_SQE1				; loop if not all done
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 126 - 11/4/2023 8:40:20


    7270/    4850 :                     
    7271/    4850 : 2741 0590           	MOVE.l	d1,FAC1_m(a3)			; save result mantissa
    7272/    4854 : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get exponent (d0 is clear here)
    7273/    4858 : 907C 0080           	SUB.w		#$80,d0				; normalise
    7274/    485C : E248                	LSR.w		#1,d0					; /2
    7275/    485E : 6402                	BCC.s		LAB_SQNA				; skip increment if carry clear
    7276/    4860 :                     
    7277/    4860 : 5240                	ADDQ.w	#1,d0					; add bit zero back in (allow for half shift)
    7278/    4862 :                     LAB_SQNA
    7279/    4862 : D07C 0080           	ADD.w		#$80,d0				; re-bias to $80
    7280/    4866 : 1740 0594           	MOVE.b	d0,FAC1_e(a3)			; save it
    7281/    486A : 4CDF 001E           	MOVEM.l	(sp)+,d1-d4				; restore registers
    7282/    486E : 6000 F09E           	BRA		LAB_24D5				; normalise FAC1 & return
    7283/    4872 :                     
    7284/    4872 :                     
    7285/    4872 :                     ;************************************************************************************
    7286/    4872 :                     ;
    7287/    4872 :                     ; perform VARPTR()
    7288/    4872 :                     
    7289/    4872 :                     LAB_VARPTR
    7290/    4872 : 101D                	MOVE.b	(a5)+,d0				; increment pointer
    7291/    4874 :                     LAB_VARCALL
    7292/    4874 : 6100 E74A           	BSR		LAB_GVAR				; get variable address in a0
    7293/    4878 : 6100 E522           	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
    7294/    487C : 2008                	MOVE.l	a0,d0					; copy the variable address
    7295/    487E : 6000 EA30           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
    7296/    4882 :                     
    7297/    4882 :                     
    7298/    4882 :                     ;************************************************************************************
    7299/    4882 :                     ;
    7300/    4882 :                     ; perform RAMBASE
    7301/    4882 :                     
    7302/    4882 :                     LAB_RAM
    7303/    4882 : 41F8 0400           	LEA		ram_base,a0			; get start of EhBASIC RAM
    7304/    4886 : 2008                	MOVE.l	a0,d0					; copy it
    7305/    4888 : 6000 EA26           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
    7306/    488C :                     
    7307/    488C :                     
    7308/    488C :                     ;************************************************************************************
    7309/    488C :                     ;
    7310/    488C :                     ; perform PI
    7311/    488C :                     
    7312/    488C :                     LAB_PI
    7313/    488C : 277C C90F DAA2      	MOVE.l	#$C90FDAA2,FAC1_m(a3)		; pi mantissa (32 bit)
             4892 : 0590             
    7314/    4894 : 377C 8200 0594      	MOVE.w	#$8200,FAC1_e(a3)			; pi exponent and sign
    7315/    489A : 4E75                	RTS
    7316/    489C :                     
    7317/    489C :                     
    7318/    489C :                     ;************************************************************************************
    7319/    489C :                     ;
    7320/    489C :                     ; perform TWOPI
    7321/    489C :                     
    7322/    489C :                     LAB_TWOPI
    7323/    489C : 277C C90F DAA2      	MOVE.l	#$C90FDAA2,FAC1_m(a3)		; 2pi mantissa (32 bit)
             48A2 : 0590             
    7324/    48A4 : 377C 8300 0594      	MOVE.w	#$8300,FAC1_e(a3)			; 2pi exponent and sign
    7325/    48AA : 4E75                	RTS
    7326/    48AC :                     
    7327/    48AC :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 127 - 11/4/2023 8:40:20


    7328/    48AC :                     ;************************************************************************************
    7329/    48AC :                     ;
    7330/    48AC :                     ; get ASCII string equivalent into FAC1 as integer32 or float
    7331/    48AC :                     
    7332/    48AC :                     ; entry is with a5 pointing to the first character of the string
    7333/    48AC :                     ; exit with a5 pointing to the first character after the string
    7334/    48AC :                     
    7335/    48AC :                     ; d0 is character
    7336/    48AC :                     ; d1 is mantissa
    7337/    48AC :                     ; d2 is partial and table mantissa
    7338/    48AC :                     ; d3 is mantissa exponent (decimal & binary)
    7339/    48AC :                     ; d4 is decimal exponent
    7340/    48AC :                     
    7341/    48AC :                     ; get FAC1 from string
    7342/    48AC :                     ; this routine now handles hex and binary values from strings
    7343/    48AC :                     ; starting with "$" and "%" respectively
    7344/    48AC :                     
    7345/    48AC :                     LAB_2887
    7346/    48AC : 48E7 7C00           	MOVEM.l	d1-d5,-(sp)				; save registers
    7347/    48B0 : 7200                	MOVEQ		#$00,d1				; clear temp accumulator
    7348/    48B2 : 2601                	MOVE.l	d1,d3					; set mantissa decimal exponent count
    7349/    48B4 : 2801                	MOVE.l	d1,d4					; clear decimal exponent
    7350/    48B6 : 1741 0595           	MOVE.b	d1,FAC1_s(a3)			; clear sign byte
    7351/    48BA : 1741 05B5           	MOVE.b	d1,Dtypef(a3)			; set float data type
    7352/    48BE : 1741 05AF           	MOVE.b	d1,expneg(a3)			; clear exponent sign
    7353/    48C2 : 6100 E4EC           	BSR		LAB_GBYT				; get first byte back
    7354/    48C6 : 653C                	BCS.s		LAB_28FE				; go get floating if 1st character numeric
    7355/    48C8 :                     
    7356/    48C8 : B03C 002D           	CMP.b		#'-',d0				; or is it -ve number
    7357/    48CC : 6608                	BNE.s		LAB_289A				; branch if not
    7358/    48CE :                     
    7359/    48CE : 177C 00FF 0595      	MOVE.b	#$FF,FAC1_s(a3)			; set sign byte
    7360/    48D4 : 6006                	BRA.s		LAB_289C				; now go scan & check for hex/bin/int
    7361/    48D6 :                     
    7362/    48D6 :                     LAB_289A
    7363/    48D6 :                     								; first character wasn't numeric or -
    7364/    48D6 : B03C 002B           	CMP.b		#'+',d0				; compare with '+'
    7365/    48DA : 6606                	BNE.s		LAB_289D				; branch if not '+' (go check for '.'/hex/binary
    7366/    48DC :                     								; /integer)
    7367/    48DC :                     	
    7368/    48DC :                     LAB_289C
    7369/    48DC :                     								; was "+" or "-" to start, so get next character
    7370/    48DC : 6100 E4D0           	BSR		LAB_IGBY				; increment & scan memory
    7371/    48E0 : 6522                	BCS.s		LAB_28FE				; branch if numeric character
    7372/    48E2 :                     
    7373/    48E2 :                     LAB_289D
    7374/    48E2 : B03C 002E           	CMP.b		#'.',d0				; else compare with '.'
    7375/    48E6 : 6700 0092           	BEQ		LAB_2904				; branch if '.'
    7376/    48EA :                     
    7377/    48EA :                     								; code here for hex/binary/integer numbers
    7378/    48EA : B03C 0024           	CMP.b		#'$',d0				; compare with '$'
    7379/    48EE : 6700 010A           	BEQ		LAB_CHEX				; branch if '$'
    7380/    48F2 :                     
    7381/    48F2 : B03C 0025           	CMP.b		#'%',d0				; else compare with '%'
    7382/    48F6 : 6700 0164           	BEQ		LAB_CBIN				; branch if '%'
    7383/    48FA :                     
    7384/    48FA : 6000 008C           	BRA		LAB_2Y01				; not #.$%& so return 0
    7385/    48FE :                     
    7386/    48FE :                     LAB_28FD
    7387/    48FE : 6100 E4AE           	BSR		LAB_IGBY				; get next character
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 128 - 11/4/2023 8:40:20


    7388/    4902 : 646C                	BCC.s		LAB_2902				; exit loop if not a digit
    7389/    4904 :                     
    7390/    4904 :                     LAB_28FE
    7391/    4904 : 6100 01A8           	BSR		d1x10					; multiply d1 by 10 and add character
    7392/    4908 : 64F4                	BCC.s		LAB_28FD				; loop for more if no overflow
    7393/    490A :                     
    7394/    490A :                     LAB_28FF
    7395/    490A :                     								; overflowed mantissa, count 10s exponent
    7396/    490A : 5283                	ADDQ.l	#1,d3					; increment mantissa decimal exponent count
    7397/    490C : 6100 E4A0           	BSR		LAB_IGBY				; get next character
    7398/    4910 : 65F8                	BCS.s		LAB_28FF				; loop while numeric character
    7399/    4912 :                     
    7400/    4912 :                     								; done overflow, now flush fraction or do E
    7401/    4912 : B03C 002E           	CMP.b		#'.',d0				; else compare with '.'
    7402/    4916 : 6606                	BNE.s		LAB_2901				; branch if not '.'
    7403/    4918 :                     
    7404/    4918 :                     LAB_2900
    7405/    4918 :                     								; flush remaining fraction digits
    7406/    4918 : 6100 E494           	BSR		LAB_IGBY				; get next character
    7407/    491C : 65FA                	BCS		LAB_2900				; loop while numeric character
    7408/    491E :                     
    7409/    491E :                     LAB_2901
    7410/    491E :                     								; done number, only (possible) exponent remains
    7411/    491E : B03C 0045           	CMP.b		#'E',d0				; else compare with 'E'
    7412/    4922 : 6664                	BNE.s		LAB_2Y01				; if not 'E' all done, go evaluate
    7413/    4924 :                     
    7414/    4924 :                     								; process exponent
    7415/    4924 : 6100 E488           	BSR		LAB_IGBY				; get next character
    7416/    4928 : 6528                	BCS.s		LAB_2X04				; branch if digit
    7417/    492A :                     
    7418/    492A : B03C 002D           	CMP.b		#'-',d0				; or is it -ve number
    7419/    492E : 6706                	BEQ.s		LAB_2X01				; branch if so
    7420/    4930 :                     
    7421/    4930 : B03C 00B3           	CMP.b		#TK_MINUS,d0			; or is it -ve number
    7422/    4934 : 6608                	BNE.s		LAB_2X02				; branch if not
    7423/    4936 :                     
    7424/    4936 :                     LAB_2X01
    7425/    4936 : 177C 00FF 05AF      	MOVE.b	#$FF,expneg(a3)			; set exponent sign
    7426/    493C : 600E                	BRA.s		LAB_2X03				; now go scan & check exponent
    7427/    493E :                     
    7428/    493E :                     LAB_2X02
    7429/    493E : B03C 002B           	CMP.b		#'+',d0				; or is it +ve number
    7430/    4942 : 6708                	BEQ.s		LAB_2X03				; branch if so
    7431/    4944 :                     
    7432/    4944 : B03C 00B2           	CMP.b		#TK_PLUS,d0				; or is it +ve number
    7433/    4948 : 6600 D81E           	BNE		LAB_SNER				; wasn't - + TK_MINUS TK_PLUS or # so do error
    7434/    494C :                     
    7435/    494C :                     LAB_2X03
    7436/    494C : 6100 E460           	BSR		LAB_IGBY				; get next character
    7437/    4950 : 6436                	BCC.s		LAB_2Y01				; if not digit all done, go evaluate
    7438/    4952 :                     LAB_2X04
    7439/    4952 : C8FC 000A           	MULU		#10,d4				; multiply decimal exponent by 10
    7440/    4956 : C0BC 0000 00FF      	AND.l		#$FF,d0				; mask character
    7441/    495C : 903C 0030           	SUB.b		#'0',d0				; convert to value
    7442/    4960 : D880                	ADD.l		d0,d4					; add to decimal exponent
    7443/    4962 : B83C 0030           	CMP.b		#48,d4				; compare with decimal exponent limit+10
    7444/    4966 : 6FE4                	BLE.s		LAB_2X03				; loop if no overflow/underflow
    7445/    4968 :                     
    7446/    4968 :                     LAB_2X05
    7447/    4968 :                     								; exponent value has overflowed
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 129 - 11/4/2023 8:40:20


    7448/    4968 : 6100 E444           	BSR		LAB_IGBY				; get next character
    7449/    496C : 65FA                	BCS.s		LAB_2X05				; loop while numeric digit
    7450/    496E :                     
    7451/    496E : 6018                	BRA.s		LAB_2Y01				; all done, go evaluate
    7452/    4970 :                     
    7453/    4970 :                     LAB_2902
    7454/    4970 : B03C 002E           	CMP.b		#'.',d0				; else compare with '.'
    7455/    4974 : 6704                	BEQ.s		LAB_2904				; branch if was '.'
    7456/    4976 :                     
    7457/    4976 : 60A6                	BRA.s		LAB_2901				; branch if not '.' (go check/do 'E')
    7458/    4978 :                     
    7459/    4978 :                     LAB_2903
    7460/    4978 : 5383                	SUBQ.l	#1,d3					; decrement mantissa decimal exponent
    7461/    497A :                     LAB_2904
    7462/    497A :                     								; was dp so get fraction part
    7463/    497A : 6100 E432           	BSR		LAB_IGBY				; get next character
    7464/    497E : 649E                	BCC.s		LAB_2901				; exit loop if not a digit (go check/do 'E')
    7465/    4980 :                     
    7466/    4980 : 6100 012C           	BSR		d1x10					; multiply d1 by 10 and add character
    7467/    4984 : 64F2                	BCC.s		LAB_2903				; loop for more if no overflow
    7468/    4986 :                     
    7469/    4986 : 6090                	BRA.s		LAB_2900				; else go flush remaining fraction part
    7470/    4988 :                     
    7471/    4988 :                     LAB_2Y01
    7472/    4988 :                     								; now evaluate result
    7473/    4988 : 4A2B 05AF           	TST.b		expneg(a3)				; test exponent sign
    7474/    498C : 6A02                	BPL.s		LAB_2Y02				; branch if sign positive
    7475/    498E :                     
    7476/    498E : 4484                	NEG.l		d4					; negate decimal exponent
    7477/    4990 :                     LAB_2Y02
    7478/    4990 : D883                	ADD.l		d3,d4					; add mantissa decimal exponent
    7479/    4992 : 7620                	MOVEQ		#32,d3				; set up max binary exponent
    7480/    4994 : 4A81                	TST.l		d1					; test mantissa
    7481/    4996 : 6752                	BEQ.s		LAB_rtn0				; if mantissa=0 return 0
    7482/    4998 :                     
    7483/    4998 : 6B08                	BMI.s		LAB_2Y04				; branch if already mormalised
    7484/    499A :                     
    7485/    499A : 5383                	SUBQ.l	#1,d3					; decrement bianry exponent for DBMI loop
    7486/    499C :                     LAB_2Y03
    7487/    499C : D281                	ADD.l		d1,d1					; shift mantissa
    7488/    499E : 5BCB FFFC           	DBMI		d3,LAB_2Y03				; decrement & loop if not normalised
    7489/    49A2 :                     
    7490/    49A2 :                     								; ensure not too big or small
    7491/    49A2 :                     LAB_2Y04
    7492/    49A2 : B8BC 0000 0026      	CMP.l		#38,d4				; compare decimal exponent with max exponent
    7493/    49A8 : 6E00 D7AE           	BGT		LAB_OFER				; if greater do overflow error and warm start
    7494/    49AC :                     
    7495/    49AC : B8BC FFFF FFDA      	CMP.l		#-38,d4				; compare decimal exponent with min exponent
    7496/    49B2 : 6D34                	BLT.s		LAB_ret0				; if less just return zero
    7497/    49B4 :                     
    7498/    49B4 : 4484                	NEG.l		d4					; negate decimal exponent to go right way
    7499/    49B6 : C9FC 0006           	MULS		#6,d4					; 6 bytes per entry
    7500/    49BA : 2F08                	MOVE.l	a0,-(sp)				; save register
    7501/    49BC : 41FA 0210           	LEA		LAB_P_10(pc),a0			; point to table
    7502/    49C0 : 1770 4000 059C      	MOVE.b	(a0,d4.w),FAC2_e(a3)		; copy exponent for multiply
    7503/    49C6 : 2770 4002 0598      	MOVE.l	2(a0,d4.w),FAC2_m(a3)		; copy table mantissa
    7504/    49CC : 205F                	MOVE.l	(sp)+,a0				; restore register
    7505/    49CE :                     
    7506/    49CE : 0A03 0080           	EORI.b	#$80,d3				; normalise input exponent
    7507/    49D2 : 2741 0590           	MOVE.l	d1,FAC1_m(a3)			; save input mantissa
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 130 - 11/4/2023 8:40:20


    7508/    49D6 : 1743 0594           	MOVE.b	d3,FAC1_e(a3)			; save input exponent
    7509/    49DA : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; set sign as sign compare
    7510/    49E0 :                     
    7511/    49E0 : 4CDF 003E           	MOVEM.l	(sp)+,d1-d5				; restore registers
    7512/    49E4 : 6000 F050           	BRA		LAB_MULTIPLY			; go multiply input by table
    7513/    49E8 :                     
    7514/    49E8 :                     LAB_ret0
    7515/    49E8 : 7200                	MOVEQ		#0,d1					; clear mantissa
    7516/    49EA :                     LAB_rtn0
    7517/    49EA : 2601                	MOVE.l	d1,d3					; clear exponent
    7518/    49EC : 1743 0594           	MOVE.b	d3,FAC1_e(a3)			; save exponent
    7519/    49F0 : 2741 0590           	MOVE.l	d1,FAC1_m(a3)			; save mantissa
    7520/    49F4 : 4CDF 003E           	MOVEM.l	(sp)+,d1-d5				; restore registers
    7521/    49F8 : 4E75                	RTS
    7522/    49FA :                     
    7523/    49FA :                     
    7524/    49FA :                     ;************************************************************************************
    7525/    49FA :                     ;
    7526/    49FA :                     ; $ for hex add-on
    7527/    49FA :                     
    7528/    49FA :                     ; gets here if the first character was "$" for hex
    7529/    49FA :                     ; get hex number
    7530/    49FA :                     
    7531/    49FA :                     LAB_CHEX
    7532/    49FA : 177C 0040 05B5      	MOVE.b	#$40,Dtypef(a3)			; set integer numeric data type
    7533/    4A00 : 7620                	MOVEQ		#32,d3				; set up max binary exponent
    7534/    4A02 :                     LAB_CHXX
    7535/    4A02 : 6100 E3AA           	BSR		LAB_IGBY				; increment & scan memory
    7536/    4A06 : 6514                	BCS.s		LAB_ISHN				; branch if numeric character
    7537/    4A08 :                     
    7538/    4A08 : 803C 0020           	OR.b		#$20,d0				; case convert, allow "A" to "F" and "a" to "f"
    7539/    4A0C : 903C 0061           	SUB.b		#'a',d0				; subtract "a"
    7540/    4A10 : 652A                	BCS.s		LAB_CHX3				; exit if <"a"
    7541/    4A12 :                     
    7542/    4A12 : B03C 0006           	CMP.b		#$06,d0				; compare normalised with $06 (max+1)
    7543/    4A16 : 6424                	BCC.s		LAB_CHX3				; exit if >"f"
    7544/    4A18 :                     
    7545/    4A18 : D03C 003A           	ADD.b		#$3A,d0				; convert to nibble+"0"
    7546/    4A1C :                     LAB_ISHN
    7547/    4A1C : 616C                	BSR.s		d1x16					; multiply d1 by 16 and add the character
    7548/    4A1E : 64E2                	BCC.s		LAB_CHXX				; loop for more if no overflow
    7549/    4A20 :                     
    7550/    4A20 :                     								; overflowed mantissa, count 16s exponent
    7551/    4A20 :                     LAB_CHX1
    7552/    4A20 : 5883                	ADDQ.l	#4,d3					; increment mantissa exponent count
    7553/    4A22 : 6900 D734           	BVS		LAB_OFER				; do overflow error if overflowed
    7554/    4A26 :                     
    7555/    4A26 : 6100 E386           	BSR		LAB_IGBY				; get next character
    7556/    4A2A : 65F4                	BCS.s		LAB_CHX1				; loop while numeric character
    7557/    4A2C :                     
    7558/    4A2C : 803C 0020           	OR.b		#$20,d0				; case convert, allow "A" to "F" and "a" to "f"
    7559/    4A30 : 903C 0061           	SUB.b		#'a',d0				; subtract "a"
    7560/    4A34 : 6506                	BCS.s		LAB_CHX3				; exit if <"a"
    7561/    4A36 :                     
    7562/    4A36 : B03C 0006           	CMP.b		#$06,d0				; compare normalised with $06 (max+1)
    7563/    4A3A : 65E4                	BCS.s		LAB_CHX1				; loop if <="f"
    7564/    4A3C :                     
    7565/    4A3C :                     								; now return value
    7566/    4A3C :                     LAB_CHX3
    7567/    4A3C : 4A81                	TST.l		d1					; test mantissa
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 131 - 11/4/2023 8:40:20


    7568/    4A3E : 67AA                	BEQ.s		LAB_rtn0				; if mantissa=0 return 0
    7569/    4A40 :                     
    7570/    4A40 : 6B08                	BMI.s		LAB_exxf				; branch if already mormalised
    7571/    4A42 :                     
    7572/    4A42 : 5383                	SUBQ.l	#1,d3					; decrement bianry exponent for DBMI loop
    7573/    4A44 :                     LAB_CHX2
    7574/    4A44 : D281                	ADD.l		d1,d1					; shift mantissa
    7575/    4A46 : 5BCB FFFC           	DBMI		d3,LAB_CHX2				; decrement & loop if not normalised
    7576/    4A4A :                     
    7577/    4A4A :                     LAB_exxf
    7578/    4A4A : 0A03 0080           	EORI.b	#$80,d3				; normalise exponent
    7579/    4A4E : 1743 0594           	MOVE.b	d3,FAC1_e(a3)			; save exponent
    7580/    4A52 : 2741 0590           	MOVE.l	d1,FAC1_m(a3)			; save mantissa
    7581/    4A56 : 4CDF 003E           	MOVEM.l	(sp)+,d1-d5				; restore registers
    7582/    4A5A :                     RTS_024
    7583/    4A5A : 4E75                	RTS
    7584/    4A5C :                     
    7585/    4A5C :                     
    7586/    4A5C :                     ;************************************************************************************
    7587/    4A5C :                     ;
    7588/    4A5C :                     ; % for binary add-on
    7589/    4A5C :                     
    7590/    4A5C :                     ; gets here if the first character was "%" for binary
    7591/    4A5C :                     ; get binary number
    7592/    4A5C :                     
    7593/    4A5C :                     LAB_CBIN
    7594/    4A5C : 177C 0040 05B5      	MOVE.b	#$40,Dtypef(a3)			; set integer numeric data type
    7595/    4A62 : 7620                	MOVEQ		#32,d3				; set up max binary exponent
    7596/    4A64 :                     LAB_CBXN
    7597/    4A64 : 6100 E348           	BSR		LAB_IGBY				; increment & scan memory
    7598/    4A68 : 64D2                	BCC.s		LAB_CHX3				; if not numeric character go return value
    7599/    4A6A :                     
    7600/    4A6A : B03C 0032           	CMP.b		#'2',d0				; compare with "2" (max+1)
    7601/    4A6E : 64CC                	BCC.s		LAB_CHX3				; if >="2" go return value
    7602/    4A70 :                     
    7603/    4A70 : 2401                	MOVE.l	d1,d2					; copy value
    7604/    4A72 : 6124                	BSR.s		d1x02					; multiply d1 by 2 and add character
    7605/    4A74 : 64EE                	BCC.s		LAB_CBXN				; loop for more if no overflow
    7606/    4A76 :                     
    7607/    4A76 :                     								; overflowed mantissa, count 2s exponent
    7608/    4A76 :                     LAB_CBX1
    7609/    4A76 : 5283                	ADDQ.l	#1,d3					; increment mantissa exponent count
    7610/    4A78 : 6900 D6DE           	BVS		LAB_OFER				; do overflow error if overflowed
    7611/    4A7C :                     
    7612/    4A7C : 6100 E330           	BSR		LAB_IGBY				; get next character
    7613/    4A80 : 64BA                	BCC.s		LAB_CHX3				; if not numeric character go return value
    7614/    4A82 :                     
    7615/    4A82 : B03C 0032           	CMP.b		#'2',d0				; compare with "2" (max+1)
    7616/    4A86 : 65EE                	BCS.s		LAB_CBX1				; loop if <"2"
    7617/    4A88 :                     
    7618/    4A88 : 60B2                	BRA.s		LAB_CHX3				; if not numeric character go return value
    7619/    4A8A :                     
    7620/    4A8A :                     ; half way decent times 16 and times 2 with overflow checks
    7621/    4A8A :                     
    7622/    4A8A :                     d1x16
    7623/    4A8A : 2401                	MOVE.l	d1,d2					; copy value
    7624/    4A8C : D482                	ADD.l		d2,d2					; times two
    7625/    4A8E : 65CA                	BCS.s		RTS_024				; return if overflow
    7626/    4A90 :                     
    7627/    4A90 : D482                	ADD.l		d2,d2					; times four
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 132 - 11/4/2023 8:40:20


    7628/    4A92 : 65C6                	BCS.s		RTS_024				; return if overflow
    7629/    4A94 :                     
    7630/    4A94 : D482                	ADD.l		d2,d2					; times eight
    7631/    4A96 : 65C2                	BCS.s		RTS_024				; return if overflow
    7632/    4A98 :                     
    7633/    4A98 :                     d1x02
    7634/    4A98 : D482                	ADD.l		d2,d2					; times sixteen (ten/two)
    7635/    4A9A : 65BE                	BCS.s		RTS_024				; return if overflow
    7636/    4A9C :                     
    7637/    4A9C :                     ; now add in new digit
    7638/    4A9C :                     
    7639/    4A9C : C0BC 0000 00FF      	AND.l		#$FF,d0				; mask character
    7640/    4AA2 : 903C 0030           	SUB.b		#'0',d0				; convert to value
    7641/    4AA6 : D480                	ADD.l		d0,d2					; add to result
    7642/    4AA8 : 65B0                	BCS.s		RTS_024				; return if overflow, it should never ever do
    7643/    4AAA :                     								; this
    7644/    4AAA :                     
    7645/    4AAA : 2202                	MOVE.l	d2,d1					; copy result
    7646/    4AAC : 4E75                	RTS
    7647/    4AAE :                     
    7648/    4AAE :                     ; half way decent times 10 with overflow checks
    7649/    4AAE :                     
    7650/    4AAE :                     d1x10
    7651/    4AAE : 2401                	MOVE.l	d1,d2					; copy value
    7652/    4AB0 : D482                	ADD.l		d2,d2					; times two
    7653/    4AB2 : 6508                	BCS.s		RTS_025				; return if overflow
    7654/    4AB4 :                     
    7655/    4AB4 : D482                	ADD.l		d2,d2					; times four
    7656/    4AB6 : 6504                	BCS.s		RTS_025				; return if overflow
    7657/    4AB8 :                     
    7658/    4AB8 : D481                	ADD.l		d1,d2					; times five
    7659/    4ABA : 64DC                	BCC.s		d1x02					; do times two and add in new digit if ok
    7660/    4ABC :                     
    7661/    4ABC :                     RTS_025
    7662/    4ABC : 4E75                	RTS
    7663/    4ABE :                     
    7664/    4ABE :                     
    7665/    4ABE :                     ;************************************************************************************
    7666/    4ABE :                     ;
    7667/    4ABE :                     ; token values needed for BASIC
    7668/    4ABE :                     
    7669/    4ABE : =$80                TK_END		EQU $80				; $80
    7670/    4ABE : =$81                TK_FOR		EQU TK_END+1			; $81
    7671/    4ABE : =$82                TK_NEXT		EQU TK_FOR+1			; $82
    7672/    4ABE : =$83                TK_DATA		EQU TK_NEXT+1			; $83
    7673/    4ABE : =$84                TK_INPUT		EQU TK_DATA+1			; $84
    7674/    4ABE : =$85                TK_DIM		EQU TK_INPUT+1			; $85
    7675/    4ABE : =$86                TK_READ		EQU TK_DIM+1			; $86
    7676/    4ABE : =$87                TK_LET		EQU TK_READ+1			; $87
    7677/    4ABE : =$88                TK_DEC		EQU TK_LET+1			; $88
    7678/    4ABE : =$89                TK_GOTO		EQU TK_DEC+1			; $89
    7679/    4ABE : =$8A                TK_RUN		EQU TK_GOTO+1			; $8A
    7680/    4ABE : =$8B                TK_IF			EQU TK_RUN+1			; $8B
    7681/    4ABE : =$8C                TK_RESTORE		EQU TK_IF+1				; $8C
    7682/    4ABE : =$8D                TK_GOSUB		EQU TK_RESTORE+1			; $8D
    7683/    4ABE : =$8E                TK_RETURN		EQU TK_GOSUB+1			; $8E
    7684/    4ABE : =$8F                TK_REM		EQU TK_RETURN+1			; $8F
    7685/    4ABE : =$90                TK_STOP		EQU TK_REM+1			; $90
    7686/    4ABE : =$91                TK_ON			EQU TK_STOP+1			; $91
    7687/    4ABE : =$92                TK_NULL		EQU TK_ON+1				; $92
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 133 - 11/4/2023 8:40:20


    7688/    4ABE : =$93                TK_INC		EQU TK_NULL+1			; $93
    7689/    4ABE : =$94                TK_WAIT		EQU TK_INC+1			; $94
    7690/    4ABE : =$95                TK_LOAD		EQU TK_WAIT+1			; $95
    7691/    4ABE : =$96                TK_SAVE		EQU TK_LOAD+1			; $96
    7692/    4ABE : =$97                TK_DEF		EQU TK_SAVE+1			; $97
    7693/    4ABE : =$98                TK_POKE		EQU TK_DEF+1			; $98
    7694/    4ABE : =$99                TK_DOKE		EQU TK_POKE+1			; $99
    7695/    4ABE : =$9A                TK_LOKE		EQU TK_DOKE+1			; $9A
    7696/    4ABE : =$9B                TK_CALL		EQU TK_LOKE+1			; $9B
    7697/    4ABE : =$9C                TK_DO			EQU TK_CALL+1			; $9C
    7698/    4ABE : =$9D                TK_LOOP		EQU TK_DO+1				; $9D
    7699/    4ABE : =$9E                TK_PRINT		EQU TK_LOOP+1			; $9E
    7700/    4ABE : =$9F                TK_CONT		EQU TK_PRINT+1			; $9F
    7701/    4ABE : =$A0                TK_LIST		EQU TK_CONT+1			; $A0
    7702/    4ABE : =$A1                TK_CLEAR		EQU TK_LIST+1			; $A1
    7703/    4ABE : =$A2                TK_NEW		EQU TK_CLEAR+1			; $A2
    7704/    4ABE : =$A3                TK_WIDTH		EQU TK_NEW+1			; $A3
    7705/    4ABE : =$A4                TK_GET		EQU TK_WIDTH+1			; $A4
    7706/    4ABE : =$A5                TK_SWAP		EQU TK_GET+1			; $A5
    7707/    4ABE : =$A6                TK_BITSET		EQU TK_SWAP+1			; $A6
    7708/    4ABE : =$A7                TK_BITCLR		EQU TK_BITSET+1			; $A7
    7709/    4ABE : =$A8                TK_TAB		EQU TK_BITCLR+1			; $A8
    7710/    4ABE : =$A9                TK_ELSE		EQU TK_TAB+1			; $A9
    7711/    4ABE : =$AA                TK_TO			EQU TK_ELSE+1			; $AA
    7712/    4ABE : =$AB                TK_FN			EQU TK_TO+1				; $AB
    7713/    4ABE : =$AC                TK_SPC		EQU TK_FN+1				; $AC
    7714/    4ABE : =$AD                TK_THEN		EQU TK_SPC+1			; $AD
    7715/    4ABE : =$AE                TK_NOT		EQU TK_THEN+1			; $AE
    7716/    4ABE : =$AF                TK_STEP		EQU TK_NOT+1			; $AF
    7717/    4ABE : =$B0                TK_UNTIL		EQU TK_STEP+1			; $B0
    7718/    4ABE : =$B1                TK_WHILE		EQU TK_UNTIL+1			; $B1
    7719/    4ABE : =$B2                TK_PLUS		EQU TK_WHILE+1			; $B2
    7720/    4ABE : =$B3                TK_MINUS		EQU TK_PLUS+1			; $B3
    7721/    4ABE : =$B4                TK_MULT		EQU TK_MINUS+1			; $B4
    7722/    4ABE : =$B5                TK_DIV		EQU TK_MULT+1			; $B5
    7723/    4ABE : =$B6                TK_POWER		EQU TK_DIV+1			; $B6
    7724/    4ABE : =$B7                TK_AND		EQU TK_POWER+1			; $B7
    7725/    4ABE : =$B8                TK_EOR		EQU TK_AND+1			; $B8
    7726/    4ABE : =$B9                TK_OR			EQU TK_EOR+1			; $B9
    7727/    4ABE : =$BA                TK_RSHIFT		EQU TK_OR+1				; $BA
    7728/    4ABE : =$BB                TK_LSHIFT		EQU TK_RSHIFT+1			; $BB
    7729/    4ABE : =$BC                TK_GT			EQU TK_LSHIFT+1			; $BC
    7730/    4ABE : =$BD                TK_EQUAL		EQU TK_GT+1				; $BD
    7731/    4ABE : =$BE                TK_LT			EQU TK_EQUAL+1			; $BE
    7732/    4ABE : =$BF                TK_SGN		EQU TK_LT+1				; $BF
    7733/    4ABE : =$C0                TK_INT		EQU TK_SGN+1			; $C0
    7734/    4ABE : =$C1                TK_ABS		EQU TK_INT+1			; $C1
    7735/    4ABE : =$C2                TK_USR		EQU TK_ABS+1			; $C2
    7736/    4ABE : =$C3                TK_FRE		EQU TK_USR+1			; $C3
    7737/    4ABE : =$C4                TK_POS		EQU TK_FRE+1			; $C4
    7738/    4ABE : =$C5                TK_SQR		EQU TK_POS+1			; $C5
    7739/    4ABE : =$C6                TK_RND		EQU TK_SQR+1			; $C6
    7740/    4ABE : =$C7                TK_LOG		EQU TK_RND+1			; $C7
    7741/    4ABE : =$C8                TK_EXP		EQU TK_LOG+1			; $C8
    7742/    4ABE : =$C9                TK_COS		EQU TK_EXP+1			; $C9
    7743/    4ABE : =$CA                TK_SIN		EQU TK_COS+1			; $CA
    7744/    4ABE : =$CB                TK_TAN		EQU TK_SIN+1			; $CB
    7745/    4ABE : =$CC                TK_ATN		EQU TK_TAN+1			; $CC
    7746/    4ABE : =$CD                TK_PEEK		EQU TK_ATN+1			; $CD
    7747/    4ABE : =$CE                TK_DEEK		EQU TK_PEEK+1			; $CE
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 134 - 11/4/2023 8:40:20


    7748/    4ABE : =$CF                TK_LEEK		EQU TK_DEEK+1			; $CF
    7749/    4ABE : =$D0                TK_LEN		EQU TK_LEEK+1			; $D0
    7750/    4ABE : =$D1                TK_STRS		EQU TK_LEN+1			; $D1
    7751/    4ABE : =$D2                TK_VAL		EQU TK_STRS+1			; $D2
    7752/    4ABE : =$D3                TK_ASC		EQU TK_VAL+1			; $D3
    7753/    4ABE : =$D4                TK_UCASES		EQU TK_ASC+1			; $D4
    7754/    4ABE : =$D5                TK_LCASES		EQU TK_UCASES+1			; $D5
    7755/    4ABE : =$D6                TK_CHRS		EQU TK_LCASES+1			; $D6
    7756/    4ABE : =$D7                TK_HEXS		EQU TK_CHRS+1			; $D7
    7757/    4ABE : =$D8                TK_BINS		EQU TK_HEXS+1			; $D8
    7758/    4ABE : =$D9                TK_BITTST		EQU TK_BINS+1			; $D9
    7759/    4ABE : =$DA                TK_MAX		EQU TK_BITTST+1			; $DA
    7760/    4ABE : =$DB                TK_MIN		EQU TK_MAX+1			; $DB
    7761/    4ABE : =$DC                TK_RAM		EQU TK_MIN+1			; $DC
    7762/    4ABE : =$DD                TK_PI			EQU TK_RAM+1			; $DD
    7763/    4ABE : =$DE                TK_TWOPI		EQU TK_PI+1				; $DE
    7764/    4ABE : =$DF                TK_VPTR		EQU TK_TWOPI+1			; $DF
    7765/    4ABE : =$E0                TK_SADD		EQU TK_VPTR+1			; $E0
    7766/    4ABE : =$E1                TK_LEFTS		EQU TK_SADD+1			; $E1
    7767/    4ABE : =$E2                TK_RIGHTS		EQU TK_LEFTS+1			; $E2
    7768/    4ABE : =$E3                TK_MIDS		EQU TK_RIGHTS+1			; $E3
    7769/    4ABE : =$E4                TK_USINGS		EQU TK_MIDS+1			; $E4
    7770/    4ABE :                     
    7771/    4ABE :                     
    7772/    4ABE :                     ;************************************************************************************
    7773/    4ABE :                     ;
    7774/    4ABE :                     ; binary to unsigned decimal table
    7775/    4ABE :                     
    7776/    4ABE :                     Bin2dec
    7777/    4ABE : 3B9A CA00           	dc.l	$3B9ACA00					; 1000000000
    7778/    4AC2 : 05F5 E100           	dc.l	$05F5E100					; 100000000
    7779/    4AC6 : 0098 9680           	dc.l	$00989680					; 10000000
    7780/    4ACA : 000F 4240           	dc.l	$000F4240					; 1000000
    7781/    4ACE : 0001 86A0           	dc.l	$000186A0					; 100000
    7782/    4AD2 : 0000 2710           	dc.l	$00002710					; 10000
    7783/    4AD6 : 0000 03E8           	dc.l	$000003E8					; 1000
    7784/    4ADA : 0000 0064           	dc.l	$00000064					; 100
    7785/    4ADE : 0000 000A           	dc.l	$0000000A					; 10
    7786/    4AE2 : 0000 0000           	dc.l	$00000000					; 0 end marker
    7787/    4AE6 :                     
    7788/    4AE6 :                     LAB_RSED
    7789/    4AE6 : 332E 3232           	dc.l	$332E3232					; 858665522
    7790/    4AEA :                     
    7791/    4AEA :                     ; string to value exponent table
    7792/    4AEA :                     
    7793/    4AEA : FF00                	dc.w	255<<8					; 10**38
    7794/    4AEC : 9676 9951           	dc.l	$96769951
    7795/    4AF0 : FB00                	dc.w	251<<8					; 10**37
    7796/    4AF2 : F0BD C21B           	dc.l	$F0BDC21B
    7797/    4AF6 : F800                	dc.w	248<<8					; 10**36
    7798/    4AF8 : C097 CE7C           	dc.l	$C097CE7C
    7799/    4AFC : F500                	dc.w	245<<8					; 10**35
    7800/    4AFE : 9A13 0B96           	dc.l	$9A130B96
    7801/    4B02 : F100                	dc.w	241<<8					; 10**34
    7802/    4B04 : F684 DF57           	dc.l	$F684DF57
    7803/    4B08 : EE00                	dc.w	238<<8					; 10**33
    7804/    4B0A : C537 1912           	dc.l	$C5371912
    7805/    4B0E : EB00                	dc.w	235<<8					; 10**32
    7806/    4B10 : 9DC5 ADA8           	dc.l	$9DC5ADA8
    7807/    4B14 : E700                	dc.w	231<<8					; 10**31
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 135 - 11/4/2023 8:40:20


    7808/    4B16 : FC6F 7C40           	dc.l	$FC6F7C40
    7809/    4B1A : E400                	dc.w	228<<8					; 10**30
    7810/    4B1C : C9F2 C9CD           	dc.l	$C9F2C9CD
    7811/    4B20 : E100                	dc.w	225<<8					; 10**29
    7812/    4B22 : A18F 07D7           	dc.l	$A18F07D7
    7813/    4B26 : DE00                	dc.w	222<<8					; 10**28
    7814/    4B28 : 813F 3979           	dc.l	$813F3979
    7815/    4B2C : DA00                	dc.w	218<<8					; 10**27
    7816/    4B2E : CECB 8F28           	dc.l	$CECB8F28
    7817/    4B32 : D700                	dc.w	215<<8					; 10**26
    7818/    4B34 : A56F A5BA           	dc.l	$A56FA5BA
    7819/    4B38 : D400                	dc.w	212<<8					; 10**25
    7820/    4B3A : 8459 5161           	dc.l	$84595161
    7821/    4B3E : D000                	dc.w	208<<8					; 10**24
    7822/    4B40 : D3C2 1BCF           	dc.l	$D3C21BCF
    7823/    4B44 : CD00                	dc.w	205<<8					; 10**23
    7824/    4B46 : A968 163F           	dc.l	$A968163F
    7825/    4B4A : CA00                	dc.w	202<<8					; 10**22
    7826/    4B4C : 8786 7832           	dc.l	$87867832
    7827/    4B50 : C600                	dc.w	198<<8					; 10**21
    7828/    4B52 : D8D7 26B7           	dc.l	$D8D726B7
    7829/    4B56 : C300                	dc.w	195<<8					; 10**20
    7830/    4B58 : AD78 EBC6           	dc.l	$AD78EBC6
    7831/    4B5C : C000                	dc.w	192<<8					; 10**19
    7832/    4B5E : 8AC7 2305           	dc.l	$8AC72305
    7833/    4B62 : BC00                	dc.w	188<<8					; 10**18
    7834/    4B64 : DE0B 6B3A           	dc.l	$DE0B6B3A
    7835/    4B68 : B900                	dc.w	185<<8					; 10**17
    7836/    4B6A : B1A2 BC2F           	dc.l	$B1A2BC2F
    7837/    4B6E : B600                	dc.w	182<<8					; 10**16
    7838/    4B70 : 8E1B C9BF           	dc.l	$8E1BC9BF
    7839/    4B74 : B200                	dc.w	178<<8					; 10**15
    7840/    4B76 : E35F A932           	dc.l	$E35FA932
    7841/    4B7A : AF00                	dc.w	175<<8					; 10**14
    7842/    4B7C : B5E6 20F5           	dc.l	$B5E620F5
    7843/    4B80 : AC00                	dc.w	172<<8					; 10**13
    7844/    4B82 : 9184 E72A           	dc.l	$9184E72A
    7845/    4B86 : A800                	dc.w	168<<8					; 10**12
    7846/    4B88 : E8D4 A510           	dc.l	$E8D4A510
    7847/    4B8C : A500                	dc.w	165<<8					; 10**11
    7848/    4B8E : BA43 B740           	dc.l	$BA43B740
    7849/    4B92 : A200                	dc.w	162<<8					; 10**10
    7850/    4B94 : 9502 F900           	dc.l	$9502F900
    7851/    4B98 : 9E00                	dc.w	158<<8					; 10**9
    7852/    4B9A : EE6B 2800           	dc.l	$EE6B2800
    7853/    4B9E : 9B00                	dc.w	155<<8					; 10**8
    7854/    4BA0 : BEBC 2000           	dc.l	$BEBC2000
    7855/    4BA4 : 9800                	dc.w	152<<8					; 10**7
    7856/    4BA6 : 9896 8000           	dc.l	$98968000
    7857/    4BAA : 9400                	dc.w	148<<8					; 10**6
    7858/    4BAC : F424 0000           	dc.l	$F4240000
    7859/    4BB0 : 9100                	dc.w	145<<8					; 10**5
    7860/    4BB2 : C350 0000           	dc.l	$C3500000
    7861/    4BB6 : 8E00                	dc.w	142<<8					; 10**4
    7862/    4BB8 : 9C40 0000           	dc.l	$9C400000
    7863/    4BBC : 8A00                	dc.w	138<<8					; 10**3
    7864/    4BBE : FA00 0000           	dc.l	$FA000000
    7865/    4BC2 : 8700                	dc.w	135<<8					; 10**2
    7866/    4BC4 : C800 0000           	dc.l	$C8000000
    7867/    4BC8 : 8400                	dc.w	132<<8					; 10**1
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 136 - 11/4/2023 8:40:20


    7868/    4BCA : A000 0000           	dc.l	$A0000000
    7869/    4BCE :                     LAB_P_10
    7870/    4BCE : 8100                	dc.w	129<<8					; 10**0
    7871/    4BD0 : 8000 0000           	dc.l	$80000000
    7872/    4BD4 : 7D00                	dc.w	125<<8					; 10**-1
    7873/    4BD6 : CCCC CCCD           	dc.l	$CCCCCCCD
    7874/    4BDA : 7A00                	dc.w	122<<8					; 10**-2
    7875/    4BDC : A3D7 0A3D           	dc.l	$A3D70A3D
    7876/    4BE0 : 7700                	dc.w	119<<8					; 10**-3
    7877/    4BE2 : 8312 6E98           	dc.l	$83126E98
    7878/    4BE6 : 7300                	dc.w	115<<8					; 10**-4
    7879/    4BE8 : D1B7 1759           	dc.l	$D1B71759
    7880/    4BEC : 7000                	dc.w	112<<8					; 10**-5
    7881/    4BEE : A7C5 AC47           	dc.l	$A7C5AC47
    7882/    4BF2 : 6D00                	dc.w	109<<8					; 10**-6
    7883/    4BF4 : 8637 BD06           	dc.l	$8637BD06
    7884/    4BF8 : 6900                	dc.w	105<<8					; 10**-7
    7885/    4BFA : D6BF 94D6           	dc.l	$D6BF94D6
    7886/    4BFE : 6600                	dc.w	102<<8					; 10**-8
    7887/    4C00 : ABCC 7712           	dc.l	$ABCC7712
    7888/    4C04 : 6300                	dc.w	99<<8						; 10**-9
    7889/    4C06 : 8970 5F41           	dc.l	$89705F41
    7890/    4C0A : 5F00                	dc.w	95<<8						; 10**-10
    7891/    4C0C : DBE6 FECF           	dc.l	$DBE6FECF
    7892/    4C10 : 5C00                	dc.w	92<<8						; 10**-11
    7893/    4C12 : AFEB FF0C           	dc.l	$AFEBFF0C
    7894/    4C16 : 5900                	dc.w	89<<8						; 10**-12
    7895/    4C18 : 8CBC CC09           	dc.l	$8CBCCC09
    7896/    4C1C : 5500                	dc.w	85<<8						; 10**-13
    7897/    4C1E : E12E 1342           	dc.l	$E12E1342
    7898/    4C22 : 5200                	dc.w	82<<8						; 10**-14
    7899/    4C24 : B424 DC35           	dc.l	$B424DC35
    7900/    4C28 : 4F00                	dc.w	79<<8						; 10**-15
    7901/    4C2A : 901D 7CF7           	dc.l	$901D7CF7
    7902/    4C2E : 4B00                	dc.w	75<<8						; 10**-16
    7903/    4C30 : E695 94BF           	dc.l	$E69594BF
    7904/    4C34 : 4800                	dc.w	72<<8						; 10**-17
    7905/    4C36 : B877 AA32           	dc.l	$B877AA32
    7906/    4C3A : 4500                	dc.w	69<<8						; 10**-18
    7907/    4C3C : 9392 EE8F           	dc.l	$9392EE8F
    7908/    4C40 : 4100                	dc.w	65<<8						; 10**-19
    7909/    4C42 : EC1E 4A7E           	dc.l	$EC1E4A7E
    7910/    4C46 : 3E00                	dc.w	62<<8						; 10**-20
    7911/    4C48 : BCE5 0865           	dc.l	$BCE50865
    7912/    4C4C : 3B00                	dc.w	59<<8						; 10**-21
    7913/    4C4E : 971D A050           	dc.l	$971DA050
    7914/    4C52 : 3700                	dc.w	55<<8						; 10**-22
    7915/    4C54 : F1C9 0081           	dc.l	$F1C90081
    7916/    4C58 : 3400                	dc.w	52<<8						; 10**-23
    7917/    4C5A : C16D 9A01           	dc.l	$C16D9A01
    7918/    4C5E : 3100                	dc.w	49<<8						; 10**-24
    7919/    4C60 : 9ABE 14CD           	dc.l	$9ABE14CD
    7920/    4C64 : 2D00                	dc.w	45<<8						; 10**-25
    7921/    4C66 : F796 87AE           	dc.l	$F79687AE
    7922/    4C6A : 2A00                	dc.w	42<<8						; 10**-26
    7923/    4C6C : C612 0625           	dc.l	$C6120625
    7924/    4C70 : 2700                	dc.w	39<<8						; 10**-27
    7925/    4C72 : 9E74 D1B8           	dc.l	$9E74D1B8
    7926/    4C76 : 2300                	dc.w	35<<8						; 10**-28
    7927/    4C78 : FD87 B5F3           	dc.l	$FD87B5F3
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 137 - 11/4/2023 8:40:20


    7928/    4C7C : 2000                	dc.w	32<<8						; 10**-29
    7929/    4C7E : CAD2 F7F5           	dc.l	$CAD2F7F5
    7930/    4C82 : 1D00                	dc.w	29<<8						; 10**-30
    7931/    4C84 : A242 5FF7           	dc.l	$A2425FF7
    7932/    4C88 : 1A00                	dc.w	26<<8						; 10**-31
    7933/    4C8A : 81CE B32C           	dc.l	$81CEB32C
    7934/    4C8E : 1600                	dc.w	22<<8						; 10**-32
    7935/    4C90 : CFB1 1EAD           	dc.l	$CFB11EAD
    7936/    4C94 : 1300                	dc.w	19<<8						; 10**-33
    7937/    4C96 : A627 4BBE           	dc.l	$A6274BBE
    7938/    4C9A : 1000                	dc.w	16<<8						; 10**-34
    7939/    4C9C : 84EC 3C98           	dc.l	$84EC3C98
    7940/    4CA0 : 0C00                	dc.w	12<<8						; 10**-35
    7941/    4CA2 : D4AD 2DC0           	dc.l	$D4AD2DC0
    7942/    4CA6 : 0900                	dc.w	9<<8						; 10**-36
    7943/    4CA8 : AA24 2499           	dc.l	$AA242499
    7944/    4CAC : 0600                	dc.w	6<<8						; 10**-37
    7945/    4CAE : 881C EA14           	dc.l	$881CEA14
    7946/    4CB2 : 0200                	dc.w	2<<8						; 10**-38
    7947/    4CB4 : D9C7 DCED           	dc.l	$D9C7DCED
    7948/    4CB8 :                     
    7949/    4CB8 :                     
    7950/    4CB8 :                     ;************************************************************************************
    7951/    4CB8 :                     ;
    7952/    4CB8 :                     ; table of constants for cordic SIN/COS/TAN calculations
    7953/    4CB8 :                     ; constants are un normalised fractions and are atn(2^-i)/2pi
    7954/    4CB8 :                     
    7955/    4CB8 : 4DBA 76D4           	dc.l	$4DBA76D4					; SIN/COS multiply constant
    7956/    4CBC :                     TAB_SNCO
    7957/    4CBC : 2000 0000           	dc.l	$20000000					; atn(2^0)/2pi
    7958/    4CC0 : 12E4 051E           	dc.l	$12E4051E					; atn(2^1)/2pi
    7959/    4CC4 : 09FB 385C           	dc.l	$09FB385C					; atn(2^2)/2pi
    7960/    4CC8 : 0511 11D5           	dc.l	$051111D5					; atn(2^3)/2pi
    7961/    4CCC : 028B 0D44           	dc.l	$028B0D44					; atn(2^4)/2pi
    7962/    4CD0 : 0145 D7E2           	dc.l	$0145D7E2					; atn(2^5)/2pi
    7963/    4CD4 : 00A2 F61F           	dc.l	$00A2F61F					; atn(2^6)/2pi
    7964/    4CD8 : 0051 7C56           	dc.l	$00517C56					; atn(2^7)/2pi
    7965/    4CDC : 0028 BE54           	dc.l	$0028BE54					; atn(2^8)/2pi
    7966/    4CE0 : 0014 5F2F           	dc.l	$00145F2F					; atn(2^9)/2pi
    7967/    4CE4 : 000A 2F99           	dc.l	$000A2F99					; atn(2^10)/2pi
    7968/    4CE8 : 0005 17CD           	dc.l	$000517CD					; atn(2^11)/2pi
    7969/    4CEC : 0002 8BE7           	dc.l	$00028BE7					; atn(2^12)/2pi
    7970/    4CF0 : 0001 45F4           	dc.l	$000145F4					; atn(2^13)/2pi
    7971/    4CF4 : 0000 A2FA           	dc.l	$0000A2FA					; atn(2^14)/2pi
    7972/    4CF8 : 0000 517D           	dc.l	$0000517D					; atn(2^15)/2pi
    7973/    4CFC : 0000 28BF           	dc.l	$000028BF					; atn(2^16)/2pi
    7974/    4D00 : 0000 1460           	dc.l	$00001460					; atn(2^17)/2pi
    7975/    4D04 : 0000 0A30           	dc.l	$00000A30					; atn(2^18)/2pi
    7976/    4D08 : 0000 0518           	dc.l	$00000518					; atn(2^19)/2pi
    7977/    4D0C : 0000 028C           	dc.l	$0000028C					; atn(2^20)/2pi
    7978/    4D10 : 0000 0146           	dc.l	$00000146					; atn(2^21)/2pi
    7979/    4D14 : 0000 00A3           	dc.l	$000000A3					; atn(2^22)/2pi
    7980/    4D18 : 0000 0052           	dc.l	$00000052					; atn(2^23)/2pi
    7981/    4D1C : 0000 0029           	dc.l	$00000029					; atn(2^24)/2pi
    7982/    4D20 : 0000 0015           	dc.l	$00000015					; atn(2^25)/2pi
    7983/    4D24 : 0000 000B           	dc.l	$0000000B					; atn(2^26)/2pi
    7984/    4D28 : 0000 0006           	dc.l	$00000006					; atn(2^27)/2pi
    7985/    4D2C : 0000 0003           	dc.l	$00000003					; atn(2^28)/2pi
    7986/    4D30 : 0000 0002           	dc.l	$00000002					; atn(2^29)/2pi
    7987/    4D34 : 0000 0001           	dc.l	$00000001					; atn(2^30)/2pi
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 138 - 11/4/2023 8:40:20


    7988/    4D38 : 0000 0001           	dc.l	$00000001					; atn(2^31)/2pi
    7989/    4D3C :                     
    7990/    4D3C :                     
    7991/    4D3C :                     ;************************************************************************************
    7992/    4D3C :                     ;
    7993/    4D3C :                     ; table of constants for cordic ATN calculation
    7994/    4D3C :                     ; constants are normalised to two integer bits and are atn(2^-i)
    7995/    4D3C :                     
    7996/    4D3C :                     TAB_ATNC
    7997/    4D3C : 1DAC 6705           	dc.l	$1DAC6705					; atn(2^-1)
    7998/    4D40 : 0FAD BAFD           	dc.l	$0FADBAFD					; atn(2^-2)
    7999/    4D44 : 07F5 6EA7           	dc.l	$07F56EA7					; atn(2^-3)
    8000/    4D48 : 03FE AB77           	dc.l	$03FEAB77					; atn(2^-4)
    8001/    4D4C : 01FF D55C           	dc.l	$01FFD55C					; atn(2^-5)
    8002/    4D50 : 00FF FAAB           	dc.l	$00FFFAAB					; atn(2^-6)
    8003/    4D54 : 007F FF55           	dc.l	$007FFF55					; atn(2^-7)
    8004/    4D58 : 003F FFEB           	dc.l	$003FFFEB					; atn(2^-8)
    8005/    4D5C : 001F FFFD           	dc.l	$001FFFFD					; atn(2^-9)
    8006/    4D60 : 0010 0000           	dc.l	$00100000					; atn(2^-10)
    8007/    4D64 : 0008 0000           	dc.l	$00080000					; atn(2^-11)
    8008/    4D68 : 0004 0000           	dc.l	$00040000					; atn(2^-12)
    8009/    4D6C : 0002 0000           	dc.l	$00020000					; atn(2^-13)
    8010/    4D70 : 0001 0000           	dc.l	$00010000					; atn(2^-14)
    8011/    4D74 : 0000 8000           	dc.l	$00008000					; atn(2^-15)
    8012/    4D78 : 0000 4000           	dc.l	$00004000					; atn(2^-16)
    8013/    4D7C : 0000 2000           	dc.l	$00002000					; atn(2^-17)
    8014/    4D80 : 0000 1000           	dc.l	$00001000					; atn(2^-18)
    8015/    4D84 : 0000 0800           	dc.l	$00000800					; atn(2^-19)
    8016/    4D88 : 0000 0400           	dc.l	$00000400					; atn(2^-20)
    8017/    4D8C : 0000 0200           	dc.l	$00000200					; atn(2^-21)
    8018/    4D90 : 0000 0100           	dc.l	$00000100					; atn(2^-22)
    8019/    4D94 : 0000 0080           	dc.l	$00000080					; atn(2^-23)
    8020/    4D98 : 0000 0040           	dc.l	$00000040					; atn(2^-24)
    8021/    4D9C : 0000 0020           	dc.l	$00000020					; atn(2^-25)
    8022/    4DA0 : 0000 0010           	dc.l	$00000010					; atn(2^-26)
    8023/    4DA4 : 0000 0008           	dc.l	$00000008					; atn(2^-27)
    8024/    4DA8 : 0000 0004           	dc.l	$00000004					; atn(2^-28)
    8025/    4DAC : 0000 0002           	dc.l	$00000002					; atn(2^-29)
    8026/    4DB0 : 0000 0001           	dc.l	$00000001					; atn(2^-30)
    8027/    4DB4 :                     LAB_1D96
    8028/    4DB4 : 0000 0000           	dc.l	$00000000					; atn(2^-31)
    8029/    4DB8 : 0000 0000           	dc.l	$00000000					; atn(2^-32)
    8030/    4DBC :                     
    8031/    4DBC :                     ; constants are normalised to n integer bits and are tanh(2^-i)
    8032/    4DBC : =$2                 n	equ	2
    8033/    4DBC :                     TAB_HTHET
    8034/    4DBC : 2327 D4F4           	dc.l	$2327d4f4				; atnh(2^-1) .549306144
    8035/    4DC0 : 1058 AEFA           	dc.l	$1058aefa				; atnh(2^-2) .255412812
    8036/    4DC4 : 080A C48E           	dc.l	$080ac48e				; atnh(2^-3)
    8037/    4DC8 : 0401 5622           	dc.l	$04015622				; atnh(2^-4)
    8038/    4DCC : 0200 2AB0           	dc.l	$02002ab0				; atnh(2^-5)
    8039/    4DD0 : 0100 0554           	dc.l	$01000554				; atnh(2^-6)
    8040/    4DD4 : 0080 00AA           	dc.l	$008000aa				; atnh(2^-7)
    8041/    4DD8 : 0040 0014           	dc.l	$00400014				; atnh(2^-8)
    8042/    4DDC : 0020 0002           	dc.l	$00200002				; atnh(2^-9)
    8043/    4DE0 : 0010 0000           	dc.l	$00100000				; atnh(2^-10)
    8044/    4DE4 : 0008 0000           	dc.l	$00080000				; atnh(2^-11)
    8045/    4DE8 : 0004 0000           	dc.l	$00040000				; atnh(2^-12)
    8046/    4DEC : 0002 0000           	dc.l	$00020000				; atnh(2^-13)
    8047/    4DF0 : 0001 0000           	dc.l	$00010000				; atnh(2^-14)
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 139 - 11/4/2023 8:40:20


    8048/    4DF4 : 0000 8000           	dc.l	$00008000				; atnh(2^-15)
    8049/    4DF8 : 0000 4000           	dc.l	$00004000				; atnh(2^-16)
    8050/    4DFC : 0000 2000           	dc.l	$00002000				; atnh(2^-17)
    8051/    4E00 : 0000 1000           	dc.l	$00001000				; atnh(2^-18)
    8052/    4E04 : 0000 0800           	dc.l	$00000800				; atnh(2^-19)
    8053/    4E08 : 0000 0400           	dc.l	$00000400				; atnh(2^-20)
    8054/    4E0C : 0000 0200           	dc.l	$00000200				; atnh(2^-21)
    8055/    4E10 : 0000 0100           	dc.l	$00000100				; atnh(2^-22)
    8056/    4E14 : 0000 0080           	dc.l	$00000080				; atnh(2^-23)
    8057/    4E18 : 0000 0040           	dc.l	$00000040				; atnh(2^-24)
    8058/    4E1C : 0000 0020           	dc.l	$00000020				; atnh(2^-25)
    8059/    4E20 : 0000 0010           	dc.l	$00000010				; atnh(2^-26)
    8060/    4E24 : 0000 0008           	dc.l	$00000008				; atnh(2^-27)
    8061/    4E28 : 0000 0004           	dc.l	$00000004				; atnh(2^-28)
    8062/    4E2C : 0000 0002           	dc.l	$00000002				; atnh(2^-29)
    8063/    4E30 : 0000 0001           	dc.l	$00000001				; atnh(2^-30)
    8064/    4E34 : 0000 0000           	dc.l	$00000000				; atnh(2^-31)
    8065/    4E38 : 0000 0000           	dc.l	$00000000				; atnh(2^-32)
    8066/    4E3C : =$26A3D110          KFCTSEED	equ	$26A3D110			; $26A3D110
    8067/    4E3C :                     
    8068/    4E3C :                     
    8069/    4E3C :                     ;************************************************************************************
    8070/    4E3C :                     ;
    8071/    4E3C :                     ; command vector table
    8072/    4E3C :                     
    8073/    4E3C :                     LAB_CTBL
    8074/    4E3C : D79E                	dc.w	LAB_END-LAB_CTBL				; END
    8075/    4E3E : D6D2                	dc.w	LAB_FOR-LAB_CTBL				; FOR
    8076/    4E40 : DD44                	dc.w	LAB_NEXT-LAB_CTBL				; NEXT
    8077/    4E42 : D8F2                	dc.w	LAB_DATA-LAB_CTBL				; DATA
    8078/    4E44 : DC38                	dc.w	LAB_INPUT-LAB_CTBL			; INPUT
    8079/    4E46 : E116                	dc.w	LAB_DIM-LAB_CTBL				; DIM
    8080/    4E48 : DC5E                	dc.w	LAB_READ-LAB_CTBL				; READ
    8081/    4E4A : DA6A                	dc.w	LAB_LET-LAB_CTBL				; LET
    8082/    4E4C : DA06                	dc.w	LAB_DEC-LAB_CTBL				; DEC	
    8083/    4E4E : D85A                	dc.w	LAB_GOTO-LAB_CTBL				; GOTO
    8084/    4E50 : D822                	dc.w	LAB_RUN-LAB_CTBL				; RUN
    8085/    4E52 : D91A                	dc.w	LAB_IF-LAB_CTBL				; IF
    8086/    4E54 : D7CC                	dc.w	LAB_RESTORE-LAB_CTBL			; RESTORE
    8087/    4E56 : D848                	dc.w	LAB_GOSUB-LAB_CTBL			; GOSUB
    8088/    4E58 : D8DE                	dc.w	LAB_RETURN-LAB_CTBL			; RETURN
    8089/    4E5A : D98C                	dc.w	LAB_REM-LAB_CTBL				; REM
    8090/    4E5C : D7A6                	dc.w	LAB_STOP-LAB_CTBL				; STOP
    8091/    4E5E : D994                	dc.w	LAB_ON-LAB_CTBL				; ON
    8092/    4E60 : D7FA                	dc.w	LAB_NULL-LAB_CTBL				; NULL
    8093/    4E62 : DA0C                	dc.w	LAB_INC-LAB_CTBL				; INC	
    8094/    4E64 : EA1E                	dc.w	LAB_WAIT-LAB_CTBL				; WAIT
    8095/    4E66 : EA0C                	dc.w	LAB_LOAD-LAB_CTBL				; LOAD
    8096/    4E68 : EA10                	dc.w	LAB_SAVE-LAB_CTBL				; SAVE
    8097/    4E6A : E4A6                	dc.w	LAB_DEF-LAB_CTBL				; DEF
    8098/    4E6C : E98C                	dc.w	LAB_POKE-LAB_CTBL				; POKE
    8099/    4E6E : E9BC                	dc.w	LAB_DOKE-LAB_CTBL				; DOKE
    8100/    4E70 : E9C2                	dc.w	LAB_LOKE-LAB_CTBL				; LOKE
    8101/    4E72 : EA14                	dc.w	LAB_CALL-LAB_CTBL				; CALL
    8102/    4E74 : D836                	dc.w	LAB_DO-LAB_CTBL				; DO	
    8103/    4E76 : D888                	dc.w	LAB_LOOP-LAB_CTBL				; LOOP
    8104/    4E78 : DAFE                	dc.w	LAB_PRINT-LAB_CTBL			; PRINT
    8105/    4E7A : D804                	dc.w	LAB_CONT-LAB_CTBL				; CONT
    8106/    4E7C : D61C                	dc.w	LAB_LIST-LAB_CTBL				; LIST
    8107/    4E7E : D618                	dc.w	LAB_CLEAR-LAB_CTBL			; CLEAR
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 140 - 11/4/2023 8:40:20


    8108/    4E80 : D5C6                	dc.w	LAB_NEW-LAB_CTBL				; NEW
    8109/    4E82 : F954                	dc.w	LAB_WDTH-LAB_CTBL				; WIDTH
    8110/    4E84 : DAC4                	dc.w	LAB_GET-LAB_CTBL				; GET
    8111/    4E86 : E9D6                	dc.w	LAB_SWAP-LAB_CTBL				; SWAP
    8112/    4E88 : F49E                	dc.w	LAB_BITSET-LAB_CTBL			; BITSET
    8113/    4E8A : F4AE                	dc.w	LAB_BITCLR-LAB_CTBL			; BITCLR
    8114/    4E8C :                     
    8115/    4E8C :                     
    8116/    4E8C :                     ;************************************************************************************
    8117/    4E8C :                     ;
    8118/    4E8C :                     ; function pre process routine table
    8119/    4E8C :                     
    8120/    4E8C :                     LAB_FTPP
    8121/    4E8C : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; SGN(n)	process numeric expression in ()
    8122/    4E8E : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; INT(n)		"
    8123/    4E90 : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; ABS(n)		"
    8124/    4E92 : DDC4                	dc.w	LAB_EVEZ-LAB_FTPP				; USR(x)	process any expression
    8125/    4E94 : DF0C                	dc.w	LAB_1BF7-LAB_FTPP				; FRE(x)	process any expression in ()
    8126/    4E96 : DF0C                	dc.w	LAB_1BF7-LAB_FTPP				; POS(x)		"
    8127/    4E98 : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; SQR(n)	process numeric expression in ()
    8128/    4E9A : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; RND(n)		"
    8129/    4E9C : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; LOG(n)		"
    8130/    4E9E : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; EXP(n)		"
    8131/    4EA0 : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; COS(n)		"
    8132/    4EA2 : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; SIN(n)		"
    8133/    4EA4 : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; TAN(n)		"
    8134/    4EA6 : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; ATN(n)		"
    8135/    4EA8 : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; PEEK(n)		"
    8136/    4EAA : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; DEEK(n)		"
    8137/    4EAC : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; LEEK(n)		"
    8138/    4EAE : DFB6                	dc.w	LAB_PPFS-LAB_FTPP				; LEN($)	process string expression in ()
    8139/    4EB0 : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; STR$(n)	process numeric expression in ()
    8140/    4EB2 : DFB6                	dc.w	LAB_PPFS-LAB_FTPP				; VAL($)	process string expression in ()
    8141/    4EB4 : DFB6                	dc.w	LAB_PPFS-LAB_FTPP				; ASC($)		"
    8142/    4EB6 : DFB6                	dc.w	LAB_PPFS-LAB_FTPP				; UCASE$($)		"
    8143/    4EB8 : DFB6                	dc.w	LAB_PPFS-LAB_FTPP				; LCASE$($)		"
    8144/    4EBA : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; CHR$(n)	process numeric expression in ()
    8145/    4EBC : DFFE                	dc.w	LAB_BHSS-LAB_FTPP				; HEX$()	bin/hex pre process
    8146/    4EBE : DFFE                	dc.w	LAB_BHSS-LAB_FTPP				; BIN$()		"
    8147/    4EC0 : 0000                	dc.w	$0000						; BITTST()	none
    8148/    4EC2 : 0000                	dc.w	$0000						; MAX()		"
    8149/    4EC4 : 0000                	dc.w	$0000						; MIN()		"
    8150/    4EC6 : DFD2                	dc.w	LAB_PPBI-LAB_FTPP				; RAMBASE	advance pointer
    8151/    4EC8 : DFD2                	dc.w	LAB_PPBI-LAB_FTPP				; PI			"
    8152/    4ECA : DFD2                	dc.w	LAB_PPBI-LAB_FTPP				; TWOPI		"
    8153/    4ECC : 0000                	dc.w	$0000						; VARPTR()	none
    8154/    4ECE : 0000                	dc.w	$0000						; SADD()		"
    8155/    4ED0 : DFDC                	dc.w	LAB_LRMS-LAB_FTPP				; LEFT$()	process string expression
    8156/    4ED2 : DFDC                	dc.w	LAB_LRMS-LAB_FTPP				; RIGHT$()		"
    8157/    4ED4 : DFDC                	dc.w	LAB_LRMS-LAB_FTPP				; MID$()		"
    8158/    4ED6 : DDC4                	dc.w	LAB_EVEZ-LAB_FTPP				; USING$(x)	process any expression
    8159/    4ED8 :                     
    8160/    4ED8 :                     
    8161/    4ED8 :                     ;************************************************************************************
    8162/    4ED8 :                     ;
    8163/    4ED8 :                     ; action addresses for functions
    8164/    4ED8 :                     
    8165/    4ED8 :                     LAB_FTBL
    8166/    4ED8 : ED4A                	dc.w	LAB_SGN-LAB_FTBL				; SGN()
    8167/    4EDA : EDCE                	dc.w	LAB_INT-LAB_FTBL				; INT()
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 141 - 11/4/2023 8:40:20


    8168/    4EDC : ED5C                	dc.w	LAB_ABS-LAB_FTBL				; ABS()
    8169/    4EDE : E968                	dc.w	LAB_USR-LAB_FTBL				; USR()
    8170/    4EE0 : E3C2                	dc.w	LAB_FRE-LAB_FTBL				; FRE()
    8171/    4EE2 : E3F4                	dc.w	LAB_POS-LAB_FTBL				; POS()
    8172/    4EE4 : F938                	dc.w	LAB_SQR-LAB_FTBL				; SQR()
    8173/    4EE6 : F21C                	dc.w	LAB_RND-LAB_FTBL				; RND()
    8174/    4EE8 : EA6C                	dc.w	LAB_LOG-LAB_FTBL				; LOG()
    8175/    4EEA : F102                	dc.w	LAB_EXP-LAB_FTBL				; EXP()
    8176/    4EEC : F270                	dc.w	LAB_COS-LAB_FTBL				; COS()
    8177/    4EEE : F288                	dc.w	LAB_SIN-LAB_FTBL				; SIN()
    8178/    4EF0 : F24E                	dc.w	LAB_TAN-LAB_FTBL				; TAN()
    8179/    4EF2 : F34E                	dc.w	LAB_ATN-LAB_FTBL				; ATN()
    8180/    4EF4 : E8E4                	dc.w	LAB_PEEK-LAB_FTBL				; PEEK()
    8181/    4EF6 : E8F6                	dc.w	LAB_DEEK-LAB_FTBL				; DEEK()
    8182/    4EF8 : E90C                	dc.w	LAB_LEEK-LAB_FTBL				; LEEK()
    8183/    4EFA : E826                	dc.w	LAB_LENS-LAB_FTBL				; LEN()
    8184/    4EFC : E4EA                	dc.w	LAB_STRS-LAB_FTBL				; STR$()
    8185/    4EFE : E86C                	dc.w	LAB_VAL-LAB_FTBL				; VAL()
    8186/    4F00 : E82E                	dc.w	LAB_ASC-LAB_FTBL				; ASC()
    8187/    4F02 : E7DC                	dc.w	LAB_UCASE-LAB_FTBL			; UCASE$()
    8188/    4F04 : E7AC                	dc.w	LAB_LCASE-LAB_FTBL			; LCASE$()
    8189/    4F06 : E714                	dc.w	LAB_CHRS-LAB_FTBL				; CHR$()
    8190/    4F08 : F7DA                	dc.w	LAB_HEXS-LAB_FTBL				; HEX$()
    8191/    4F0A : F788                	dc.w	LAB_BINS-LAB_FTBL				; BIN$()
    8192/    4F0C : F422                	dc.w	LAB_BTST-LAB_FTBL				; BITTST()
    8193/    4F0E : F846                	dc.w	LAB_MAX-LAB_FTBL				; MAX()
    8194/    4F10 : F85C                	dc.w	LAB_MIN-LAB_FTBL				; MIN()
    8195/    4F12 : F9AA                	dc.w	LAB_RAM-LAB_FTBL				; RAMBASE
    8196/    4F14 : F9B4                	dc.w	LAB_PI-LAB_FTBL				; PI
    8197/    4F16 : F9C4                	dc.w	LAB_TWOPI-LAB_FTBL			; TWOPI
    8198/    4F18 : F99A                	dc.w	LAB_VARPTR-LAB_FTBL			; VARPTR()
    8199/    4F1A : E80E                	dc.w	LAB_SADD-LAB_FTBL				; SADD()
    8200/    4F1C : E724                	dc.w	LAB_LEFT-LAB_FTBL				; LEFT$()
    8201/    4F1E : E738                	dc.w	LAB_RIGHT-LAB_FTBL			; RIGHT$()
    8202/    4F20 : E768                	dc.w	LAB_MIDS-LAB_FTBL				; MID$()
    8203/    4F22 : F450                	dc.w	LAB_USINGS-LAB_FTBL			; USING$()
    8204/    4F24 :                     
    8205/    4F24 :                     
    8206/    4F24 :                     ;************************************************************************************
    8207/    4F24 :                     ;
    8208/    4F24 :                     ; hierarchy and action addresses for operator
    8209/    4F24 :                     
    8210/    4F24 :                     LAB_OPPT
    8211/    4F24 : 0079                	dc.w	$0079						; +
    8212/    4F26 : E96E                	dc.w	LAB_ADD-LAB_OPPT
    8213/    4F28 : 0079                	dc.w	$0079						; -
    8214/    4F2A : E95A                	dc.w	LAB_SUBTRACT-LAB_OPPT
    8215/    4F2C : 007B                	dc.w	$007B						; *
    8216/    4F2E : EB12                	dc.w	LAB_MULTIPLY-LAB_OPPT
    8217/    4F30 : 007B                	dc.w	$007B						; /
    8218/    4F32 : EB9E                	dc.w	LAB_DIVIDE-LAB_OPPT
    8219/    4F34 : 007F                	dc.w	$007F						; ^
    8220/    4F36 : F000                	dc.w	LAB_POWER-LAB_OPPT
    8221/    4F38 : 0050                	dc.w	$0050						; AND
    8222/    4F3A : DFA6                	dc.w	LAB_AND-LAB_OPPT
    8223/    4F3C : 0046                	dc.w	$0046						; EOR
    8224/    4F3E : DF96                	dc.w	LAB_EOR-LAB_OPPT
    8225/    4F40 : 0046                	dc.w	$0046						; OR
    8226/    4F42 : DF9E                	dc.w	LAB_OR-LAB_OPPT
    8227/    4F44 : 0056                	dc.w	$0056						; >>
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 142 - 11/4/2023 8:40:20


    8228/    4F46 : E04A                	dc.w	LAB_RSHIFT-LAB_OPPT
    8229/    4F48 : 0056                	dc.w	$0056						; <<
    8230/    4F4A : E03A                	dc.w	LAB_LSHIFT-LAB_OPPT
    8231/    4F4C : 007D                	dc.w	$007D						; >
    8232/    4F4E : F064                	dc.w	LAB_GTHAN-LAB_OPPT			; used to evaluate -n
    8233/    4F50 : 005A                	dc.w	$005A						; =
    8234/    4F52 : DFBC                	dc.w	LAB_EQUAL-LAB_OPPT			; used to evaluate NOT
    8235/    4F54 : 0064                	dc.w	$0064						; <
    8236/    4F56 : DFC6                	dc.w	LAB_LTHAN-LAB_OPPT
    8237/    4F58 :                     
    8238/    4F58 :                     
    8239/    4F58 :                     ;************************************************************************************
    8240/    4F58 :                     ;
    8241/    4F58 :                     ; misc constants
    8242/    4F58 :                     
    8243/    4F58 :                     ; This table is used in converting numbers to ASCII.
    8244/    4F58 :                     ; first four entries for expansion to 9.25 digits
    8245/    4F58 :                     
    8246/    4F58 :                     LAB_2A9A
    8247/    4F58 : FFF0 BDC0           	dc.l	$FFF0BDC0					; -1000000
    8248/    4F5C : 0001 86A0           	dc.l	$000186A0					; 100000
    8249/    4F60 : FFFF D8F0           	dc.l	$FFFFD8F0					; -10000
    8250/    4F64 : 0000 03E8           	dc.l	$000003E8					; 1000
    8251/    4F68 : FFFF FF9C           	dc.l	$FFFFFF9C					; -100
    8252/    4F6C : 0000 000A           	dc.l	$0000000A					; 10
    8253/    4F70 : FFFF FFFF           	dc.l	$FFFFFFFF					; -1
    8254/    4F74 :                     LAB_2A9B
    8255/    4F74 :                     
    8256/    4F74 :                     
    8257/    4F74 :                     ;************************************************************************************
    8258/    4F74 :                     ;
    8259/    4F74 :                     ; new keyword tables
    8260/    4F74 :                     
    8261/    4F74 :                     ; offsets to keyword tables
    8262/    4F74 :                     
    8263/    4F74 :                     TAB_CHRT
    8264/    4F74 : 0000                	dc.w	TAB_STAR-TAB_STAR				; "*"	$2A
    8265/    4F76 : 0002                	dc.w	TAB_PLUS-TAB_STAR				; "+"	$2B
    8266/    4F78 : FFFF                	dc.w	-1						; "," $2C no keywords
    8267/    4F7A : 0004                	dc.w	TAB_MNUS-TAB_STAR				; "-"	$2D
    8268/    4F7C : FFFF                	dc.w	-1						; "." $2E no keywords
    8269/    4F7E : 0006                	dc.w	TAB_SLAS-TAB_STAR				; "/"	$2F
    8270/    4F80 : FFFF                	dc.w	-1						; "0" $30 no keywords
    8271/    4F82 : FFFF                	dc.w	-1						; "1" $31 no keywords
    8272/    4F84 : FFFF                	dc.w	-1						; "2" $32 no keywords
    8273/    4F86 : FFFF                	dc.w	-1						; "3" $33 no keywords
    8274/    4F88 : FFFF                	dc.w	-1						; "4" $34 no keywords
    8275/    4F8A : FFFF                	dc.w	-1						; "5" $35 no keywords
    8276/    4F8C : FFFF                	dc.w	-1						; "6" $36 no keywords
    8277/    4F8E : FFFF                	dc.w	-1						; "7" $37 no keywords
    8278/    4F90 : FFFF                	dc.w	-1						; "8" $38 no keywords
    8279/    4F92 : FFFF                	dc.w	-1						; "9" $39 no keywords
    8280/    4F94 : FFFF                	dc.w	-1						; ";" $3A no keywords
    8281/    4F96 : FFFF                	dc.w	-1						; ":" $3B no keywords
    8282/    4F98 : 0008                	dc.w	TAB_LESS-TAB_STAR				; "<"	$3C
    8283/    4F9A : 000C                	dc.w	TAB_EQUL-TAB_STAR				; "="	$3D
    8284/    4F9C : 000E                	dc.w	TAB_MORE-TAB_STAR				; ">"	$3E
    8285/    4F9E : 0012                	dc.w	TAB_QEST-TAB_STAR				; "?"	$3F
    8286/    4FA0 : FFFF                	dc.w	-1						; "@" $40 no keywords
    8287/    4FA2 : 0014                	dc.w	TAB_ASCA-TAB_STAR				; "A"	$41
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 143 - 11/4/2023 8:40:20


    8288/    4FA4 : 0024                	dc.w	TAB_ASCB-TAB_STAR				; "B"	$42
    8289/    4FA6 : 003D                	dc.w	TAB_ASCC-TAB_STAR				; "C"	$43
    8290/    4FA8 : 0054                	dc.w	TAB_ASCD-TAB_STAR				; "D"	$44
    8291/    4FAA : 006D                	dc.w	TAB_ASCE-TAB_STAR				; "E"	$45
    8292/    4FAC : 007C                	dc.w	TAB_ASCF-TAB_STAR				; "F"	$46
    8293/    4FAE : 0086                	dc.w	TAB_ASCG-TAB_STAR				; "G"	$47
    8294/    4FB0 : 0093                	dc.w	TAB_ASCH-TAB_STAR				; "H"	$48
    8295/    4FB2 : 0099                	dc.w	TAB_ASCI-TAB_STAR				; "I"	$49
    8296/    4FB4 : FFFF                	dc.w	-1						; "J" $4A no keywords
    8297/    4FB6 : FFFF                	dc.w	-1						; "K" $4B no keywords
    8298/    4FB8 : 00A8                	dc.w	TAB_ASCL-TAB_STAR				; "L"	$4C
    8299/    4FBA : 00D6                	dc.w	TAB_ASCM-TAB_STAR				; "M"	$4D
    8300/    4FBC : 00E4                	dc.w	TAB_ASCN-TAB_STAR				; "N"	$4E
    8301/    4FBE : 00F3                	dc.w	TAB_ASCO-TAB_STAR				; "O"	$4F
    8302/    4FC0 : 00F8                	dc.w	TAB_ASCP-TAB_STAR				; "P"	$50
    8303/    4FC2 : FFFF                	dc.w	-1						; "Q" $51 no keywords
    8304/    4FC4 : 010D                	dc.w	TAB_ASCR-TAB_STAR				; "R"	$52
    8305/    4FC6 : 0137                	dc.w	TAB_ASCS-TAB_STAR				; "S"	$53
    8306/    4FC8 : 0162                	dc.w	TAB_ASCT-TAB_STAR				; "T"	$54
    8307/    4FCA : 0176                	dc.w	TAB_ASCU-TAB_STAR				; "U"	$55
    8308/    4FCC : 018E                	dc.w	TAB_ASCV-TAB_STAR				; "V"	$56
    8309/    4FCE : 019A                	dc.w	TAB_ASCW-TAB_STAR				; "W"	$57
    8310/    4FD0 : FFFF                	dc.w	-1						; "X" $58 no keywords
    8311/    4FD2 : FFFF                	dc.w	-1						; "Y" $59 no keywords
    8312/    4FD4 : FFFF                	dc.w	-1						; "Z" $5A no keywords
    8313/    4FD6 : FFFF                	dc.w	-1						; "[" $5B no keywords
    8314/    4FD8 : FFFF                	dc.w	-1						; "\" $5C no keywords
    8315/    4FDA : FFFF                	dc.w	-1						; "]" $5D no keywords
    8316/    4FDC : 01A9                	dc.w	TAB_POWR-TAB_STAR				; "^"	$5E
    8317/    4FDE :                     
    8318/    4FDE :                     
    8319/    4FDE :                     ;************************************************************************************
    8320/    4FDE :                     ;
    8321/    4FDE :                     ; Table of Basic keywords for LIST command
    8322/    4FDE :                     ; [byte]first character,[byte]remaining length -1
    8323/    4FDE :                     ; [word]offset from table start
    8324/    4FDE :                     
    8325/    4FDE :                     LAB_KEYT
    8326/    4FDE : 4501                	dc.b	'E',1
    8327/    4FE0 : 0071                	dc.w	KEY_END-TAB_STAR				; END
    8328/    4FE2 : 4601                	dc.b	'F',1
    8329/    4FE4 : 007C                	dc.w	KEY_FOR-TAB_STAR				; FOR
    8330/    4FE6 : 4E02                	dc.b	'N',2
    8331/    4FE8 : 00E7                	dc.w	KEY_NEXT-TAB_STAR				; NEXT
    8332/    4FEA : 4402                	dc.b	'D',2
    8333/    4FEC : 0054                	dc.w	KEY_DATA-TAB_STAR				; DATA
    8334/    4FEE : 4903                	dc.b	'I',3
    8335/    4FF0 : 009E                	dc.w	KEY_INPUT-TAB_STAR			; INPUT
    8336/    4FF2 : 4401                	dc.b	'D',1
    8337/    4FF4 : 0063                	dc.w	KEY_DIM-TAB_STAR				; DIM
    8338/    4FF6 : 5202                	dc.b	'R',2
    8339/    4FF8 : 0114                	dc.w	KEY_READ-TAB_STAR				; READ
    8340/    4FFA : 4C01                	dc.b	'L',1
    8341/    4FFC : 00BE                	dc.w	KEY_LET-TAB_STAR				; LET
    8342/    4FFE : 4401                	dc.b	'D',1
    8343/    5000 : 0058                	dc.w	KEY_DEC-TAB_STAR				; DEC
    8344/    5002 : 4702                	dc.b	'G',2
    8345/    5004 : 0089                	dc.w	KEY_GOTO-TAB_STAR				; GOTO
    8346/    5006 : 5201                	dc.b	'R',1
    8347/    5008 : 0133                	dc.w	KEY_RUN-TAB_STAR				; RUN
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 144 - 11/4/2023 8:40:20


    8348/    500A : 4900                	dc.b	'I',0
    8349/    500C : 0099                	dc.w	KEY_IF-TAB_STAR				; IF
    8350/    500E : 5205                	dc.b	'R',5
    8351/    5010 : 011B                	dc.w	KEY_RESTORE-TAB_STAR			; RESTORE
    8352/    5012 : 4703                	dc.b	'G',3
    8353/    5014 : 008D                	dc.w	KEY_GOSUB-TAB_STAR			; GOSUB
    8354/    5016 : 5204                	dc.b	'R',4
    8355/    5018 : 0122                	dc.w	KEY_RETURN-TAB_STAR			; RETURN
    8356/    501A : 5201                	dc.b	'R',1
    8357/    501C : 0118                	dc.w	KEY_REM-TAB_STAR				; REM
    8358/    501E : 5302                	dc.b	'S',2
    8359/    5020 : 0154                	dc.w	KEY_STOP-TAB_STAR				; STOP
    8360/    5022 : 4F00                	dc.b	'O',0
    8361/    5024 : 00F3                	dc.w	KEY_ON-TAB_STAR				; ON
    8362/    5026 : 4E02                	dc.b	'N',2
    8363/    5028 : 00EE                	dc.w	KEY_NULL-TAB_STAR				; NULL
    8364/    502A : 4901                	dc.b	'I',1
    8365/    502C : 009B                	dc.w	KEY_INC-TAB_STAR				; INC
    8366/    502E : 5702                	dc.b	'W',2
    8367/    5030 : 019A                	dc.w	KEY_WAIT-TAB_STAR				; WAIT
    8368/    5032 : 4C02                	dc.b	'L',2
    8369/    5034 : 00C5                	dc.w	KEY_LOAD-TAB_STAR				; LOAD
    8370/    5036 : 5302                	dc.b	'S',2
    8371/    5038 : 013C                	dc.w	KEY_SAVE-TAB_STAR				; SAVE
    8372/    503A : 4401                	dc.b	'D',1
    8373/    503C : 0060                	dc.w	KEY_DEF-TAB_STAR				; DEF
    8374/    503E : 5002                	dc.b	'P',2
    8375/    5040 : 00FF                	dc.w	KEY_POKE-TAB_STAR				; POKE
    8376/    5042 : 4402                	dc.b	'D',2
    8377/    5044 : 0066                	dc.w	KEY_DOKE-TAB_STAR				; DOKE
    8378/    5046 : 4C02                	dc.b	'L',2
    8379/    5048 : 00CD                	dc.w	KEY_LOKE-TAB_STAR				; LOKE
    8380/    504A : 4302                	dc.b	'C',2
    8381/    504C : 003D                	dc.w	KEY_CALL-TAB_STAR				; CALL
    8382/    504E : 4400                	dc.b	'D',0
    8383/    5050 : 006A                	dc.w	KEY_DO-TAB_STAR				; DO
    8384/    5052 : 4C02                	dc.b	'L',2
    8385/    5054 : 00D1                	dc.w	KEY_LOOP-TAB_STAR				; LOOP
    8386/    5056 : 5003                	dc.b	'P',3
    8387/    5058 : 0107                	dc.w	KEY_PRINT-TAB_STAR			; PRINT
    8388/    505A : 4302                	dc.b	'C',2
    8389/    505C : 004B                	dc.w	KEY_CONT-TAB_STAR				; CONT
    8390/    505E : 4C02                	dc.b	'L',2
    8391/    5060 : 00C1                	dc.w	KEY_LIST-TAB_STAR				; LIST
    8392/    5062 : 4303                	dc.b	'C',3
    8393/    5064 : 0046                	dc.w	KEY_CLEAR-TAB_STAR			; CLEAR
    8394/    5066 : 4E01                	dc.b	'N',1
    8395/    5068 : 00E4                	dc.w	KEY_NEW-TAB_STAR				; NEW
    8396/    506A : 5703                	dc.b	'W',3
    8397/    506C : 01A3                	dc.w	KEY_WIDTH-TAB_STAR			; WIDTH
    8398/    506E : 4701                	dc.b	'G',1
    8399/    5070 : 0086                	dc.w	KEY_GET-TAB_STAR				; GET
    8400/    5072 : 5302                	dc.b	'S',2
    8401/    5074 : 015D                	dc.w	KEY_SWAP-TAB_STAR				; SWAP
    8402/    5076 : 4204                	dc.b	'B',4
    8403/    5078 : 002F                	dc.w	KEY_BITSET-TAB_STAR			; BITSET
    8404/    507A : 4204                	dc.b	'B',4
    8405/    507C : 0029                	dc.w	KEY_BITCLR-TAB_STAR			; BITCLR
    8406/    507E : 5402                	dc.b	'T',2
    8407/    5080 : 0162                	dc.w	KEY_TAB-TAB_STAR				; TAB(
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 145 - 11/4/2023 8:40:20


    8408/    5082 : 4502                	dc.b	'E',2
    8409/    5084 : 006D                	dc.w	KEY_ELSE-TAB_STAR				; ELSE
    8410/    5086 : 5400                	dc.b	'T',0
    8411/    5088 : 016E                	dc.w	KEY_TO-TAB_STAR				; TO
    8412/    508A : 4600                	dc.b	'F',0
    8413/    508C : 007F                	dc.w	KEY_FN-TAB_STAR				; FN
    8414/    508E : 5302                	dc.b	'S',2
    8415/    5090 : 0148                	dc.w	KEY_SPC-TAB_STAR				; SPC(
    8416/    5092 : 5402                	dc.b	'T',2
    8417/    5094 : 016A                	dc.w	KEY_THEN-TAB_STAR				; THEN
    8418/    5096 : 4E01                	dc.b	'N',1
    8419/    5098 : 00EB                	dc.w	KEY_NOT-TAB_STAR				; NOT
    8420/    509A : 5302                	dc.b	'S',2
    8421/    509C : 0150                	dc.w	KEY_STEP-TAB_STAR				; STEP
    8422/    509E : 5503                	dc.b	'U',3
    8423/    50A0 : 017D                	dc.w	KEY_UNTIL-TAB_STAR			; UNTIL
    8424/    50A2 : 5703                	dc.b	'W',3
    8425/    50A4 : 019E                	dc.w	KEY_WHILE-TAB_STAR			; WHILE
    8426/    50A6 :                     
    8427/    50A6 : 2BFF                	dc.b	'+',-1
    8428/    50A8 : 0002                	dc.w	KEY_PLUS-TAB_STAR				; +
    8429/    50AA : 2DFF                	dc.b	'-',-1
    8430/    50AC : 0004                	dc.w	KEY_MINUS-TAB_STAR			; -
    8431/    50AE : 2AFF                	dc.b	'*',-1
    8432/    50B0 : 0000                	dc.w	KEY_MULT-TAB_STAR				; *
    8433/    50B2 : 2FFF                	dc.b	'/',-1
    8434/    50B4 : 0006                	dc.w	KEY_DIV-TAB_STAR				; /
    8435/    50B6 : 5EFF                	dc.b	'^',-1
    8436/    50B8 : 01A9                	dc.w	KEY_POWER-TAB_STAR			; ^
    8437/    50BA : 4101                	dc.b	'A',1
    8438/    50BC : 0018                	dc.w	KEY_AND-TAB_STAR				; AND
    8439/    50BE : 4501                	dc.b	'E',1
    8440/    50C0 : 0074                	dc.w	KEY_EOR-TAB_STAR				; EOR
    8441/    50C2 : 4F00                	dc.b	'O',0
    8442/    50C4 : 00F5                	dc.w	KEY_OR-TAB_STAR				; OR
    8443/    50C6 : 3E00                	dc.b	'>',0
    8444/    50C8 : 000E                	dc.w	KEY_RSHIFT-TAB_STAR			; >>
    8445/    50CA : 3C00                	dc.b	'<',0
    8446/    50CC : 0008                	dc.w	KEY_LSHIFT-TAB_STAR			; <<
    8447/    50CE : 3EFF                	dc.b	'>',-1
    8448/    50D0 : 0010                	dc.w	KEY_GT-TAB_STAR				; >
    8449/    50D2 : 3DFF                	dc.b	'=',-1
    8450/    50D4 : 000C                	dc.w	KEY_EQUAL-TAB_STAR			; =
    8451/    50D6 : 3CFF                	dc.b	'<',-1
    8452/    50D8 : 000A                	dc.w	KEY_LT-TAB_STAR				; <
    8453/    50DA :                     
    8454/    50DA : 5302                	dc.b	'S',2
    8455/    50DC : 0140                	dc.w	KEY_SGN-TAB_STAR				; SGN(
    8456/    50DE : 4902                	dc.b	'I',2
    8457/    50E0 : 00A3                	dc.w	KEY_INT-TAB_STAR				; INT(
    8458/    50E2 : 4102                	dc.b	'A',2
    8459/    50E4 : 0014                	dc.w	KEY_ABS-TAB_STAR				; ABS(
    8460/    50E6 : 5502                	dc.b	'U',2
    8461/    50E8 : 0189                	dc.w	KEY_USR-TAB_STAR				; USR(
    8462/    50EA : 4602                	dc.b	'F',2
    8463/    50EC : 0081                	dc.w	KEY_FRE-TAB_STAR				; FRE(
    8464/    50EE : 5002                	dc.b	'P',2
    8465/    50F0 : 0103                	dc.w	KEY_POS-TAB_STAR				; POS(
    8466/    50F2 : 5302                	dc.b	'S',2
    8467/    50F4 : 014C                	dc.w	KEY_SQR-TAB_STAR				; SQR(
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 146 - 11/4/2023 8:40:20


    8468/    50F6 : 5202                	dc.b	'R',2
    8469/    50F8 : 012F                	dc.w	KEY_RND-TAB_STAR				; RND(
    8470/    50FA : 4C02                	dc.b	'L',2
    8471/    50FC : 00C9                	dc.w	KEY_LOG-TAB_STAR				; LOG(
    8472/    50FE : 4502                	dc.b	'E',2
    8473/    5100 : 0077                	dc.w	KEY_EXP-TAB_STAR				; EXP(
    8474/    5102 : 4302                	dc.b	'C',2
    8475/    5104 : 004F                	dc.w	KEY_COS-TAB_STAR				; COS(
    8476/    5106 : 5302                	dc.b	'S',2
    8477/    5108 : 0144                	dc.w	KEY_SIN-TAB_STAR				; SIN(
    8478/    510A : 5402                	dc.b	'T',2
    8479/    510C : 0166                	dc.w	KEY_TAN-TAB_STAR				; TAN(
    8480/    510E : 4102                	dc.b	'A',2
    8481/    5110 : 001F                	dc.w	KEY_ATN-TAB_STAR				; ATN(
    8482/    5112 : 5003                	dc.b	'P',3
    8483/    5114 : 00F8                	dc.w	KEY_PEEK-TAB_STAR				; PEEK(
    8484/    5116 : 4403                	dc.b	'D',3
    8485/    5118 : 005B                	dc.w	KEY_DEEK-TAB_STAR				; DEEK(
    8486/    511A : 4C03                	dc.b	'L',3
    8487/    511C : 00AF                	dc.w	KEY_LEEK-TAB_STAR				; LEEK(
    8488/    511E : 4C02                	dc.b	'L',2
    8489/    5120 : 00BA                	dc.w	KEY_LEN-TAB_STAR				; LEN(
    8490/    5122 : 5303                	dc.b	'S',3
    8491/    5124 : 0158                	dc.w	KEY_STRS-TAB_STAR				; STR$(
    8492/    5126 : 5602                	dc.b	'V',2
    8493/    5128 : 018E                	dc.w	KEY_VAL-TAB_STAR				; VAL(
    8494/    512A : 4102                	dc.b	'A',2
    8495/    512C : 001B                	dc.w	KEY_ASC-TAB_STAR				; ASC(
    8496/    512E : 5505                	dc.b	'U',5
    8497/    5130 : 0176                	dc.w	KEY_UCASES-TAB_STAR			; UCASE$(
    8498/    5132 : 4C05                	dc.b	'L',5
    8499/    5134 : 00A8                	dc.w	KEY_LCASES-TAB_STAR			; LCASE$(
    8500/    5136 : 4303                	dc.b	'C',3
    8501/    5138 : 0041                	dc.w	KEY_CHRS-TAB_STAR				; CHR$(
    8502/    513A : 4803                	dc.b	'H',3
    8503/    513C : 0093                	dc.w	KEY_HEXS-TAB_STAR				; HEX$(
    8504/    513E : 4203                	dc.b	'B',3
    8505/    5140 : 0024                	dc.w	KEY_BINS-TAB_STAR				; BIN$(
    8506/    5142 : 4205                	dc.b	'B',5
    8507/    5144 : 0035                	dc.w	KEY_BITTST-TAB_STAR			; BITTST(
    8508/    5146 : 4D02                	dc.b	'M',2
    8509/    5148 : 00D6                	dc.w	KEY_MAX-TAB_STAR				; MAX(
    8510/    514A : 4D02                	dc.b	'M',2
    8511/    514C : 00DF                	dc.w	KEY_MIN-TAB_STAR				; MIN(
    8512/    514E : 5205                	dc.b	'R',5
    8513/    5150 : 010D                	dc.w	KEY_RAM-TAB_STAR				; RAMBASE
    8514/    5152 : 5000                	dc.b	'P',0
    8515/    5154 : 00FD                	dc.w	KEY_PI-TAB_STAR				; PI
    8516/    5156 : 5403                	dc.b	'T',3
    8517/    5158 : 0170                	dc.w	KEY_TWOPI-TAB_STAR			; TWOPI
    8518/    515A : 5605                	dc.b	'V',5
    8519/    515C : 0192                	dc.w	KEY_VPTR-TAB_STAR				; VARPTR(
    8520/    515E : 5303                	dc.b	'S',3
    8521/    5160 : 0137                	dc.w	KEY_SADD-TAB_STAR				; SADD(
    8522/    5162 : 4C04                	dc.b	'L',4
    8523/    5164 : 00B4                	dc.w	KEY_LEFTS-TAB_STAR			; LEFT$(
    8524/    5166 : 5205                	dc.b	'R',5
    8525/    5168 : 0128                	dc.w	KEY_RIGHTS-TAB_STAR			; RIGHT$(
    8526/    516A : 4D03                	dc.b	'M',3
    8527/    516C : 00DA                	dc.w	KEY_MIDS-TAB_STAR				; MID$(
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 147 - 11/4/2023 8:40:20


    8528/    516E : 5505                	dc.b	'U',5
    8529/    5170 : 0182                	dc.w	KEY_USINGS-TAB_STAR			; USING$(
    8530/    5172 :                     
    8531/    5172 :                     
    8532/    5172 :                     ;************************************************************************************
    8533/    5172 :                     ;
    8534/    5172 :                     ; BASIC error messages
    8535/    5172 :                     
    8536/    5172 :                     LAB_BAER
    8537/    5172 : 0030                	dc.w	LAB_NF-LAB_BAER				; $00 NEXT without FOR
    8538/    5174 : 0041                	dc.w	LAB_SN-LAB_BAER				; $02 syntax
    8539/    5176 : 0048                	dc.w	LAB_RG-LAB_BAER				; $04 RETURN without GOSUB
    8540/    5178 : 005D                	dc.w	LAB_OD-LAB_BAER				; $06 out of data
    8541/    517A : 0069                	dc.w	LAB_FC-LAB_BAER				; $08 function call
    8542/    517C : 0077                	dc.w	LAB_OV-LAB_BAER				; $0A overflow
    8543/    517E : 0080                	dc.w	LAB_OM-LAB_BAER				; $0C out of memory
    8544/    5180 : 008E                	dc.w	LAB_US-LAB_BAER				; $0E undefined statement
    8545/    5182 : 00A2                	dc.w	LAB_BS-LAB_BAER				; $10 array bounds
    8546/    5184 : 00AF                	dc.w	LAB_DD-LAB_BAER				; $12 double dimension array
    8547/    5186 : 00C0                	dc.w	LAB_D0-LAB_BAER				; $14 divide by 0
    8548/    5188 : 00CF                	dc.w	LAB_ID-LAB_BAER				; $16 illegal direct
    8549/    518A : 00DE                	dc.w	LAB_TM-LAB_BAER				; $18 type mismatch
    8550/    518C : 00EC                	dc.w	LAB_LS-LAB_BAER				; $1A long string
    8551/    518E : 00FC                	dc.w	LAB_ST-LAB_BAER				; $1C string too complex
    8552/    5190 : 010F                	dc.w	LAB_CN-LAB_BAER				; $1E continue error
    8553/    5192 : 011E                	dc.w	LAB_UF-LAB_BAER				; $20 undefined function
    8554/    5194 : 0131                	dc.w	LAB_LD-LAB_BAER				; $22 LOOP without DO
    8555/    5196 : 0141                	dc.w	LAB_UV-LAB_BAER				; $24 undefined variable
    8556/    5198 : 0154                	dc.w	LAB_UA-LAB_BAER				; $26 undimensioned array
    8557/    519A : 0168                	dc.w	LAB_WD-LAB_BAER				; $28 wrong dimensions
    8558/    519C : 0179                	dc.w	LAB_AD-LAB_BAER				; $2A address
    8559/    519E : 0181                	dc.w	LAB_FO-LAB_BAER				; $2C format
    8560/    51A0 : 0188                	dc.w	LAB_NI-LAB_BAER				; $2E not implemented
    8561/    51A2 :                     
    8562/    51A2 : 4E45 5854 2077      LAB_NF	dc.b	'NEXT without FOR',$00
             51A8 : 6974 686F 7574 
             51AE : 2046 4F52 00       
    8563/    51B3 : 5379 6E74 6178 00   LAB_SN	dc.b	'Syntax',$00
    8564/    51BA : 5245 5455 524E      LAB_RG	dc.b	'RETURN without GOSUB',$00
             51C0 : 2077 6974 686F 
             51C6 : 7574 2047 4F53 
             51CC : 5542 00          
    8565/    51CF : 4F75 7420 6F66      LAB_OD	dc.b	'Out of DATA',$00
             51D5 : 2044 4154 4100    
    8566/    51DB : 4675 6E63 7469      LAB_FC	dc.b	'Function call',$00
             51E1 : 6F6E 2063 616C 
             51E7 : 6C00             
    8567/    51E9 : 4F76 6572 666C      LAB_OV	dc.b	'Overflow',$00
             51EF : 6F77 00          
    8568/    51F2 : 4F75 7420 6F66      LAB_OM	dc.b	'Out of memory',$00
             51F8 : 206D 656D 6F72 
             51FE : 7900             
    8569/    5200 : 556E 6465 6669      LAB_US	dc.b	'Undefined statement',$00
             5206 : 6E65 6420 7374 
             520C : 6174 656D 656E 
             5212 : 7400             
    8570/    5214 : 4172 7261 7920      LAB_BS	dc.b	'Array bounds',$00
             521A : 626F 756E 6473 00 
    8571/    5221 : 446F 7562 6C65      LAB_DD	dc.b	'Double dimension',$00
             5227 : 2064 696D 656E 
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 148 - 11/4/2023 8:40:20


             522D : 7369 6F6E 00       
    8572/    5232 : 4469 7669 6465      LAB_D0	dc.b	'Divide by zero',$00
             5238 : 2062 7920 7A65 
             523E : 726F 00          
    8573/    5241 : 496C 6C65 6761      LAB_ID	dc.b	'Illegal direct',$00
             5247 : 6C20 6469 7265 
             524D : 6374 00          
    8574/    5250 : 5479 7065 206D      LAB_TM	dc.b	'Type mismatch',$00
             5256 : 6973 6D61 7463 
             525C : 6800             
    8575/    525E : 5374 7269 6E67      LAB_LS	dc.b	'String too long',$00
             5264 : 2074 6F6F 206C 
             526A : 6F6E 6700          
    8576/    526E : 5374 7269 6E67      LAB_ST	dc.b	'String too complex',$00
             5274 : 2074 6F6F 2063 
             527A : 6F6D 706C 6578 00 
    8577/    5281 : 4361 6E27 7420      LAB_CN	dc.b	"Can't continue",$00
             5287 : 636F 6E74 696E 
             528D : 7565 00          
    8578/    5290 : 556E 6465 6669      LAB_UF	dc.b	'Undefined function',$00
             5296 : 6E65 6420 6675 
             529C : 6E63 7469 6F6E 00 
    8579/    52A3 : 4C4F 4F50 2077      LAB_LD	dc.b	'LOOP without DO',$00
             52A9 : 6974 686F 7574 
             52AF : 2044 4F00          
    8580/    52B3 : 556E 6465 6669      LAB_UV	dc.b	'Undefined variable',$00
             52B9 : 6E65 6420 7661 
             52BF : 7269 6162 6C65 00 
    8581/    52C6 : 556E 6469 6D65      LAB_UA	dc.b	'Undimensioned array',$00
             52CC : 6E73 696F 6E65 
             52D2 : 6420 6172 7261 
             52D8 : 7900             
    8582/    52DA : 5772 6F6E 6720      LAB_WD	dc.b	'Wrong dimensions',$00
             52E0 : 6469 6D65 6E73 
             52E6 : 696F 6E73 00       
    8583/    52EB : 4164 6472 6573      LAB_AD	dc.b	'Address',$00
             52F1 : 7300             
    8584/    52F3 : 466F 726D 6174 00   LAB_FO	dc.b	'Format',$00
    8585/    52FA : 4E6F 7420 696D      LAB_NI  dc.b    'Not implemented',$00
             5300 : 706C 656D 656E 
             5306 : 7465 6400          
    8586/    530A :                     
    8587/    530A :                     
    8588/    530A :                     ;************************************************************************************
    8589/    530A :                     ;
    8590/    530A :                     ; keyword table for line (un)crunching
    8591/    530A :                     
    8592/    530A :                     ; [keyword,token
    8593/    530A :                     ; [keyword,token]]
    8594/    530A :                     ; end marker (#$00)
    8595/    530A :                     
    8596/    530A :                     TAB_STAR
    8597/    530A :                     KEY_MULT
    8598/    530A : B400                	dc.b TK_MULT,$00					; *
    8599/    530C :                     TAB_PLUS
    8600/    530C :                     KEY_PLUS
    8601/    530C : B200                	dc.b TK_PLUS,$00					; +
    8602/    530E :                     TAB_MNUS
    8603/    530E :                     KEY_MINUS
    8604/    530E : B300                	dc.b TK_MINUS,$00					; -
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 149 - 11/4/2023 8:40:20


    8605/    5310 :                     TAB_SLAS
    8606/    5310 :                     KEY_DIV
    8607/    5310 : B500                	dc.b TK_DIV,$00					; /
    8608/    5312 :                     TAB_LESS
    8609/    5312 :                     KEY_LSHIFT
    8610/    5312 : 3CBB                	dc.b	'<',TK_LSHIFT				; <<
    8611/    5314 :                     KEY_LT
    8612/    5314 : BE                  	dc.b TK_LT						; <
    8613/    5315 : 00                  	dc.b	$00
    8614/    5316 :                     TAB_EQUL
    8615/    5316 :                     KEY_EQUAL
    8616/    5316 : BD00                	dc.b TK_EQUAL,$00					; =
    8617/    5318 :                     TAB_MORE
    8618/    5318 :                     KEY_RSHIFT
    8619/    5318 : 3EBA                	dc.b	'>',TK_RSHIFT				; >>
    8620/    531A :                     KEY_GT
    8621/    531A : BC                  	dc.b TK_GT						; >
    8622/    531B : 00                  	dc.b	$00
    8623/    531C :                     TAB_QEST
    8624/    531C : 9E00                	dc.b TK_PRINT,$00					; ?
    8625/    531E :                     TAB_ASCA
    8626/    531E :                     KEY_ABS
    8627/    531E : 4253 28C1           	dc.b	'BS(',TK_ABS				; ABS(
    8628/    5322 :                     KEY_AND
    8629/    5322 : 4E44 B7             	dc.b	'ND',TK_AND					; AND
    8630/    5325 :                     KEY_ASC
    8631/    5325 : 5343 28D3           	dc.b	'SC(',TK_ASC				; ASC(
    8632/    5329 :                     KEY_ATN
    8633/    5329 : 544E 28CC           	dc.b	'TN(',TK_ATN				; ATN(
    8634/    532D : 00                  	dc.b	$00
    8635/    532E :                     TAB_ASCB
    8636/    532E :                     KEY_BINS
    8637/    532E : 494E 2428 D8        	dc.b	'IN$(',TK_BINS				; BIN$(
    8638/    5333 :                     KEY_BITCLR
    8639/    5333 : 4954 434C 52A7      	dc.b	'ITCLR',TK_BITCLR				; BITCLR
    8640/    5339 :                     KEY_BITSET
    8641/    5339 : 4954 5345 54A6      	dc.b	'ITSET',TK_BITSET				; BITSET
    8642/    533F :                     KEY_BITTST
    8643/    533F : 4954 5453 5428 D9   	dc.b	'ITTST(',TK_BITTST			; BITTST(
    8644/    5346 : 00                  	dc.b	$00
    8645/    5347 :                     TAB_ASCC
    8646/    5347 :                     KEY_CALL
    8647/    5347 : 414C 4C9B           	dc.b	'ALL',TK_CALL				; CALL
    8648/    534B :                     KEY_CHRS
    8649/    534B : 4852 2428 D6        	dc.b	'HR$(',TK_CHRS				; CHR$(
    8650/    5350 :                     KEY_CLEAR
    8651/    5350 : 4C45 4152 A1        	dc.b	'LEAR',TK_CLEAR				; CLEAR
    8652/    5355 :                     KEY_CONT
    8653/    5355 : 4F4E 549F           	dc.b	'ONT',TK_CONT				; CONT
    8654/    5359 :                     KEY_COS
    8655/    5359 : 4F53 28C9           	dc.b	'OS(',TK_COS				; COS(
    8656/    535D : 00                  	dc.b	$00
    8657/    535E :                     TAB_ASCD
    8658/    535E :                     KEY_DATA
    8659/    535E : 4154 4183           	dc.b	'ATA',TK_DATA				; DATA
    8660/    5362 :                     KEY_DEC
    8661/    5362 : 4543 88             	dc.b	'EC',TK_DEC					; DEC
    8662/    5365 :                     KEY_DEEK
    8663/    5365 : 4545 4B28 CE        	dc.b	'EEK(',TK_DEEK				; DEEK(
    8664/    536A :                     KEY_DEF
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 150 - 11/4/2023 8:40:20


    8665/    536A : 4546 97             	dc.b	'EF',TK_DEF					; DEF
    8666/    536D :                     KEY_DIM
    8667/    536D : 494D 85             	dc.b	'IM',TK_DIM					; DIM
    8668/    5370 :                     KEY_DOKE
    8669/    5370 : 4F4B 4599           	dc.b	'OKE',TK_DOKE				; DOKE
    8670/    5374 :                     KEY_DO
    8671/    5374 : 4F9C                	dc.b	'O',TK_DO					; DO
    8672/    5376 : 00                  	dc.b	$00
    8673/    5377 :                     TAB_ASCE
    8674/    5377 :                     KEY_ELSE
    8675/    5377 : 4C53 45A9           	dc.b	'LSE',TK_ELSE				; ELSE
    8676/    537B :                     KEY_END
    8677/    537B : 4E44 80             	dc.b	'ND',TK_END					; END
    8678/    537E :                     KEY_EOR
    8679/    537E : 4F52 B8             	dc.b	'OR',TK_EOR					; EOR
    8680/    5381 :                     KEY_EXP
    8681/    5381 : 5850 28C8           	dc.b	'XP(',TK_EXP				; EXP(
    8682/    5385 : 00                  	dc.b	$00
    8683/    5386 :                     TAB_ASCF
    8684/    5386 :                     KEY_FOR
    8685/    5386 : 4F52 81             	dc.b	'OR',TK_FOR					; FOR
    8686/    5389 :                     KEY_FN
    8687/    5389 : 4EAB                	dc.b	'N',TK_FN					; FN
    8688/    538B :                     KEY_FRE
    8689/    538B : 5245 28C3           	dc.b	'RE(',TK_FRE				; FRE(
    8690/    538F : 00                  	dc.b	$00
    8691/    5390 :                     TAB_ASCG
    8692/    5390 :                     KEY_GET
    8693/    5390 : 4554 A4             	dc.b	'ET',TK_GET					; GET
    8694/    5393 :                     KEY_GOTO
    8695/    5393 : 4F54 4F89           	dc.b	'OTO',TK_GOTO				; GOTO
    8696/    5397 :                     KEY_GOSUB
    8697/    5397 : 4F53 5542 8D        	dc.b	'OSUB',TK_GOSUB				; GOSUB
    8698/    539C : 00                  	dc.b	$00
    8699/    539D :                     TAB_ASCH
    8700/    539D :                     KEY_HEXS
    8701/    539D : 4558 2428 D700      	dc.b	'EX$(',TK_HEXS,$00			; HEX$(
    8702/    53A3 :                     TAB_ASCI
    8703/    53A3 :                     KEY_IF
    8704/    53A3 : 468B                	dc.b	'F',TK_IF					; IF
    8705/    53A5 :                     KEY_INC
    8706/    53A5 : 4E43 93             	dc.b	'NC',TK_INC					; INC
    8707/    53A8 :                     KEY_INPUT
    8708/    53A8 : 4E50 5554 84        	dc.b	'NPUT',TK_INPUT				; INPUT
    8709/    53AD :                     KEY_INT
    8710/    53AD : 4E54 28C0           	dc.b	'NT(',TK_INT				; INT(
    8711/    53B1 : 00                  	dc.b	$00
    8712/    53B2 :                     TAB_ASCL
    8713/    53B2 :                     KEY_LCASES
    8714/    53B2 : 4341 5345 2428 D5   	dc.b	'CASE$(',TK_LCASES			; LCASE$(
    8715/    53B9 :                     KEY_LEEK
    8716/    53B9 : 4545 4B28 CF        	dc.b	'EEK(',TK_LEEK				; LEEK(
    8717/    53BE :                     KEY_LEFTS
    8718/    53BE : 4546 5424 28E1      	dc.b	'EFT$(',TK_LEFTS				; LEFT$(
    8719/    53C4 :                     KEY_LEN
    8720/    53C4 : 454E 28D0           	dc.b	'EN(',TK_LEN				; LEN(
    8721/    53C8 :                     KEY_LET
    8722/    53C8 : 4554 87             	dc.b	'ET',TK_LET					; LET
    8723/    53CB :                     KEY_LIST
    8724/    53CB : 4953 54A0           	dc.b	'IST',TK_LIST				; LIST
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 151 - 11/4/2023 8:40:20


    8725/    53CF :                     KEY_LOAD
    8726/    53CF : 4F41 4495           	dc.b	'OAD',TK_LOAD				; LOAD
    8727/    53D3 :                     KEY_LOG
    8728/    53D3 : 4F47 28C7           	dc.b	'OG(',TK_LOG				; LOG(
    8729/    53D7 :                     KEY_LOKE
    8730/    53D7 : 4F4B 459A           	dc.b	'OKE',TK_LOKE				; LOKE
    8731/    53DB :                     KEY_LOOP
    8732/    53DB : 4F4F 509D           	dc.b	'OOP',TK_LOOP				; LOOP
    8733/    53DF : 00                  	dc.b	$00
    8734/    53E0 :                     TAB_ASCM
    8735/    53E0 :                     KEY_MAX
    8736/    53E0 : 4158 28DA           	dc.b	'AX(',TK_MAX				; MAX(
    8737/    53E4 :                     KEY_MIDS
    8738/    53E4 : 4944 2428 E3        	dc.b	'ID$(',TK_MIDS				; MID$(
    8739/    53E9 :                     KEY_MIN
    8740/    53E9 : 494E 28DB           	dc.b	'IN(',TK_MIN				; MIN(
    8741/    53ED : 00                  	dc.b	$00
    8742/    53EE :                     TAB_ASCN
    8743/    53EE :                     KEY_NEW
    8744/    53EE : 4557 A2             	dc.b	'EW',TK_NEW					; NEW
    8745/    53F1 :                     KEY_NEXT
    8746/    53F1 : 4558 5482           	dc.b	'EXT',TK_NEXT				; NEXT
    8747/    53F5 :                     KEY_NOT
    8748/    53F5 : 4F54 AE             	dc.b	'OT',TK_NOT					; NOT
    8749/    53F8 :                     KEY_NULL
    8750/    53F8 : 554C 4C92           	dc.b	'ULL',TK_NULL				; NULL
    8751/    53FC : 00                  	dc.b	$00
    8752/    53FD :                     TAB_ASCO
    8753/    53FD :                     KEY_ON
    8754/    53FD : 4E91                	dc.b	'N',TK_ON					; ON
    8755/    53FF :                     KEY_OR
    8756/    53FF : 52B9                	dc.b	'R',TK_OR					; OR
    8757/    5401 : 00                  	dc.b	$00
    8758/    5402 :                     TAB_ASCP
    8759/    5402 :                     KEY_PEEK
    8760/    5402 : 4545 4B28 CD        	dc.b	'EEK(',TK_PEEK				; PEEK(
    8761/    5407 :                     KEY_PI
    8762/    5407 : 49DD                	dc.b	'I',TK_PI					; PI
    8763/    5409 :                     KEY_POKE
    8764/    5409 : 4F4B 4598           	dc.b	'OKE',TK_POKE				; POKE
    8765/    540D :                     KEY_POS
    8766/    540D : 4F53 28C4           	dc.b	'OS(',TK_POS				; POS(
    8767/    5411 :                     KEY_PRINT
    8768/    5411 : 5249 4E54 9E        	dc.b	'RINT',TK_PRINT				; PRINT
    8769/    5416 : 00                  	dc.b	$00
    8770/    5417 :                     TAB_ASCR
    8771/    5417 :                     KEY_RAM
    8772/    5417 : 414D 4241 5345 DC   	dc.b	'AMBASE',TK_RAM				; RAMBASE
    8773/    541E :                     KEY_READ
    8774/    541E : 4541 4486           	dc.b	'EAD',TK_READ				; READ
    8775/    5422 :                     KEY_REM
    8776/    5422 : 454D 8F             	dc.b	'EM',TK_REM					; REM
    8777/    5425 :                     KEY_RESTORE
    8778/    5425 : 4553 544F 5245 8C   	dc.b	'ESTORE',TK_RESTORE			; RESTORE
    8779/    542C :                     KEY_RETURN
    8780/    542C : 4554 5552 4E8E      	dc.b	'ETURN',TK_RETURN				; RETURN
    8781/    5432 :                     KEY_RIGHTS
    8782/    5432 : 4947 4854 2428 E2   	dc.b	'IGHT$(',TK_RIGHTS			; RIGHT$(
    8783/    5439 :                     KEY_RND
    8784/    5439 : 4E44 28C6           	dc.b	'ND(',TK_RND				; RND(
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 152 - 11/4/2023 8:40:20


    8785/    543D :                     KEY_RUN
    8786/    543D : 554E 8A             	dc.b	'UN',TK_RUN					; RUN
    8787/    5440 : 00                  	dc.b	$00
    8788/    5441 :                     TAB_ASCS
    8789/    5441 :                     KEY_SADD
    8790/    5441 : 4144 4428 E0        	dc.b	'ADD(',TK_SADD				; SADD(
    8791/    5446 :                     KEY_SAVE
    8792/    5446 : 4156 4596           	dc.b	'AVE',TK_SAVE				; SAVE
    8793/    544A :                     KEY_SGN
    8794/    544A : 474E 28BF           	dc.b	'GN(',TK_SGN				; SGN(
    8795/    544E :                     KEY_SIN
    8796/    544E : 494E 28CA           	dc.b	'IN(',TK_SIN				; SIN(
    8797/    5452 :                     KEY_SPC
    8798/    5452 : 5043 28AC           	dc.b	'PC(',TK_SPC				; SPC(
    8799/    5456 :                     KEY_SQR
    8800/    5456 : 5152 28C5           	dc.b	'QR(',TK_SQR				; SQR(
    8801/    545A :                     KEY_STEP
    8802/    545A : 5445 50AF           	dc.b	'TEP',TK_STEP				; STEP
    8803/    545E :                     KEY_STOP
    8804/    545E : 544F 5090           	dc.b	'TOP',TK_STOP				; STOP
    8805/    5462 :                     KEY_STRS
    8806/    5462 : 5452 2428 D1        	dc.b	'TR$(',TK_STRS				; STR$(
    8807/    5467 :                     KEY_SWAP
    8808/    5467 : 5741 50A5           	dc.b	'WAP',TK_SWAP				; SWAP
    8809/    546B : 00                  	dc.b	$00
    8810/    546C :                     TAB_ASCT
    8811/    546C :                     KEY_TAB
    8812/    546C : 4142 28A8           	dc.b	'AB(',TK_TAB				; TAB(
    8813/    5470 :                     KEY_TAN
    8814/    5470 : 414E 28CB           	dc.b	'AN(',TK_TAN				; TAN
    8815/    5474 :                     KEY_THEN
    8816/    5474 : 4845 4EAD           	dc.b	'HEN',TK_THEN				; THEN
    8817/    5478 :                     KEY_TO
    8818/    5478 : 4FAA                	dc.b	'O',TK_TO					; TO
    8819/    547A :                     KEY_TWOPI
    8820/    547A : 574F 5049 DE        	dc.b	'WOPI',TK_TWOPI				; TWOPI
    8821/    547F : 00                  	dc.b	$00
    8822/    5480 :                     TAB_ASCU
    8823/    5480 :                     KEY_UCASES
    8824/    5480 : 4341 5345 2428 D4   	dc.b	'CASE$(',TK_UCASES			; UCASE$(
    8825/    5487 :                     KEY_UNTIL
    8826/    5487 : 4E54 494C B0        	dc.b	'NTIL',TK_UNTIL				; UNTIL
    8827/    548C :                     KEY_USINGS
    8828/    548C : 5349 4E47 2428 E4   	dc.b	'SING$(',TK_USINGS			; USING$(
    8829/    5493 :                     KEY_USR
    8830/    5493 : 5352 28C2           	dc.b	'SR(',TK_USR				; USR(
    8831/    5497 : 00                  	dc.b	$00
    8832/    5498 :                     TAB_ASCV
    8833/    5498 :                     KEY_VAL
    8834/    5498 : 414C 28D2           	dc.b	'AL(',TK_VAL				; VAL(
    8835/    549C :                     KEY_VPTR
    8836/    549C : 4152 5054 5228 DF   	dc.b	'ARPTR(',TK_VPTR				; VARPTR(
    8837/    54A3 : 00                  	dc.b	$00
    8838/    54A4 :                     TAB_ASCW
    8839/    54A4 :                     KEY_WAIT
    8840/    54A4 : 4149 5494           	dc.b	'AIT',TK_WAIT				; WAIT
    8841/    54A8 :                     KEY_WHILE
    8842/    54A8 : 4849 4C45 B1        	dc.b	'HILE',TK_WHILE				; WHILE
    8843/    54AD :                     KEY_WIDTH
    8844/    54AD : 4944 5448 A3        	dc.b	'IDTH',TK_WIDTH				; WIDTH
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 153 - 11/4/2023 8:40:20


    8845/    54B2 : 00                  	dc.b	$00
    8846/    54B3 :                     TAB_POWR
    8847/    54B3 :                     KEY_POWER
    8848/    54B3 : B600                	dc.b	TK_POWER,$00				; ^
    8849/    54B5 :                     
    8850/    54B5 :                     
    8851/    54B5 :                     ;************************************************************************************
    8852/    54B5 :                     ;
    8853/    54B5 :                     ; just messages
    8854/    54B5 :                     
    8855/    54B5 :                     LAB_BMSG
    8856/    54B5 : 0D0A 4272 6561      	dc.b	$0D,$0A,'Break',$00
             54BB : 6B00             
    8857/    54BD :                     LAB_EMSG
    8858/    54BD : 2045 7272 6F72 00   	dc.b	' Error',$00
    8859/    54C4 :                     LAB_LMSG
    8860/    54C4 : 2069 6E20 6C69      	dc.b	' in line ',$00
             54CA : 6E65 2000          
    8861/    54CE :                     LAB_IMSG
    8862/    54CE : 4578 7472 6120      	dc.b	'Extra ignored',$0D,$0A,$00
             54D4 : 6967 6E6F 7265 
             54DA : 640D 0A00          
    8863/    54DE :                     LAB_REDO
    8864/    54DE : 5265 646F 2066      	dc.b	'Redo from start',$0D,$0A,$00
             54E4 : 726F 6D20 7374 
             54EA : 6172 740D 0A00    
    8865/    54F0 :                     LAB_RMSG
    8866/    54F0 : 0D0A 5265 6164      	dc.b	$0D,$0A,'Ready',$0D,$0A,$00
             54F6 : 790D 0A00          
    8867/    54FA :                     LAB_SMSG
    8868/    54FA : 2042 7974 6573      	dc.b	' Bytes free',$0D,$0A,$0A
             5500 : 2066 7265 650D 
             5506 : 0A0A             
    8869/    5508 : 456E 6861 6E63      	dc.b	'Enhanced 68k BASIC Version 3.54',$0D,$0A,$00
             550E : 6564 2036 386B 
             5514 : 2042 4153 4943 
             551A : 2056 6572 7369 
             5520 : 6F6E 2033 2E35 
             5526 : 340D 0A00          
    8870/    552A :                     
    8871/    552A : FFFF FFFF FFFF      	DC.B	[TBSC_CS-*]$FF
             5530 : FFFF FFFF FFFF 
             5536 : FFFF FFFF FFFF 
             553C : FFFF FFFF FFFF 
             5542 : FFFF FFFF FFFF 
             5548 : FFFF FFFF FFFF 
             554E : FFFF FFFF FFFF 
             5554 : FFFF FFFF FFFF 
             555A : FFFF FFFF FFFF 
             5560 : FFFF FFFF FFFF 
             5566 : FFFF FFFF FFFF 
             556C : FFFF FFFF FFFF 
             5572 : FFFF FFFF FFFF 
             5578 : FFFF FFFF FFFF 
             557E : FFFF FFFF FFFF 
             5584 : FFFF FFFF FFFF 
             558A : FFFF FFFF FFFF 
             5590 : FFFF FFFF FFFF 
             5596 : FFFF FFFF FFFF 
             559C : FFFF FFFF FFFF 
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 154 - 11/4/2023 8:40:20


             55A2 : FFFF FFFF FFFF 
             55A8 : FFFF FFFF FFFF 
             55AE : FFFF FFFF FFFF 
             55B4 : FFFF FFFF FFFF 
             55BA : FFFF FFFF FFFF 
             55C0 : FFFF FFFF FFFF 
             55C6 : FFFF FFFF FFFF 
             55CC : FFFF FFFF FFFF 
             55D2 : FFFF FFFF FFFF 
             55D8 : FFFF FFFF FFFF 
             55DE : FFFF FFFF FFFF 
             55E4 : FFFF FFFF FFFF 
             55EA : FFFF FFFF FFFF 
             55F0 : FFFF FFFF FFFF 
             55F6 : FFFF FFFF FFFF 
             55FC : FFFF FFFF FFFF 
             5602 : FFFF FFFF FFFF 
             5608 : FFFF FFFF FFFF 
             560E : FFFF FFFF FFFF 
             5614 : FFFF FFFF FFFF 
             561A : FFFF FFFF FFFF 
             5620 : FFFF FFFF FFFF 
             5626 : FFFF FFFF FFFF 
             562C : FFFF FFFF FFFF 
             5632 : FFFF FFFF FFFF 
             5638 : FFFF FFFF FFFF 
             563E : FFFF FFFF FFFF 
             5644 : FFFF FFFF FFFF 
             564A : FFFF FFFF FFFF 
             5650 : FFFF FFFF FFFF 
             5656 : FFFF FFFF FFFF 
             565C : FFFF FFFF FFFF 
             5662 : FFFF FFFF FFFF 
             5668 : FFFF FFFF FFFF 
             566E : FFFF FFFF FFFF 
             5674 : FFFF FFFF FFFF 
             567A : FFFF FFFF FFFF 
             5680 : FFFF FFFF FFFF 
             5686 : FFFF FFFF FFFF 
             568C : FFFF FFFF FFFF 
             5692 : FFFF FFFF FFFF 
             5698 : FFFF FFFF FFFF 
             569E : FFFF FFFF FFFF 
             56A4 : FFFF FFFF FFFF 
             56AA : FFFF FFFF FFFF 
             56B0 : FFFF FFFF FFFF 
             56B6 : FFFF FFFF FFFF 
             56BC : FFFF FFFF FFFF 
             56C2 : FFFF FFFF FFFF 
             56C8 : FFFF FFFF FFFF 
             56CE : FFFF FFFF FFFF 
             56D4 : FFFF FFFF FFFF 
             56DA : FFFF FFFF FFFF 
             56E0 : FFFF FFFF FFFF 
             56E6 : FFFF FFFF FFFF 
             56EC : FFFF FFFF FFFF 
             56F2 : FFFF FFFF FFFF 
             56F8 : FFFF FFFF FFFF 
             56FE : FFFF FFFF FFFF 
             5704 : FFFF FFFF FFFF 
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 155 - 11/4/2023 8:40:20


             570A : FFFF FFFF FFFF 
             5710 : FFFF FFFF FFFF 
             5716 : FFFF FFFF FFFF 
             571C : FFFF FFFF FFFF 
             5722 : FFFF FFFF FFFF 
             5728 : FFFF FFFF FFFF 
             572E : FFFF FFFF FFFF 
             5734 : FFFF FFFF FFFF 
             573A : FFFF FFFF FFFF 
             5740 : FFFF FFFF FFFF 
             5746 : FFFF FFFF FFFF 
             574C : FFFF FFFF FFFF 
             5752 : FFFF FFFF FFFF 
             5758 : FFFF FFFF FFFF 
             575E : FFFF FFFF FFFF 
             5764 : FFFF FFFF FFFF 
             576A : FFFF FFFF FFFF 
             5770 : FFFF FFFF FFFF 
             5776 : FFFF FFFF FFFF 
             577C : FFFF FFFF FFFF 
             5782 : FFFF FFFF FFFF 
             5788 : FFFF FFFF FFFF 
             578E : FFFF FFFF FFFF 
             5794 : FFFF FFFF FFFF 
             579A : FFFF FFFF FFFF 
             57A0 : FFFF FFFF FFFF 
             57A6 : FFFF FFFF FFFF 
             57AC : FFFF FFFF FFFF 
             57B2 : FFFF FFFF FFFF 
             57B8 : FFFF FFFF FFFF 
             57BE : FFFF FFFF FFFF 
             57C4 : FFFF FFFF FFFF 
             57CA : FFFF FFFF FFFF 
             57D0 : FFFF FFFF FFFF 
             57D6 : FFFF FFFF FFFF 
             57DC : FFFF FFFF FFFF 
             57E2 : FFFF FFFF FFFF 
             57E8 : FFFF FFFF FFFF 
             57EE : FFFF FFFF FFFF 
             57F4 : FFFF FFFF FFFF 
             57FA : FFFF FFFF FFFF 
             5800 : FFFF FFFF FFFF 
             5806 : FFFF FFFF FFFF 
             580C : FFFF FFFF FFFF 
             5812 : FFFF FFFF FFFF 
             5818 : FFFF FFFF FFFF 
             581E : FFFF FFFF FFFF 
             5824 : FFFF FFFF FFFF 
             582A : FFFF FFFF FFFF 
             5830 : FFFF FFFF FFFF 
             5836 : FFFF FFFF FFFF 
             583C : FFFF FFFF FFFF 
             5842 : FFFF FFFF FFFF 
             5848 : FFFF FFFF FFFF 
             584E : FFFF FFFF FFFF 
             5854 : FFFF FFFF FFFF 
             585A : FFFF FFFF FFFF 
             5860 : FFFF FFFF FFFF 
             5866 : FFFF FFFF FFFF 
             586C : FFFF FFFF FFFF 
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 156 - 11/4/2023 8:40:20


             5872 : FFFF FFFF FFFF 
             5878 : FFFF FFFF FFFF 
             587E : FFFF FFFF FFFF 
             5884 : FFFF FFFF FFFF 
             588A : FFFF FFFF FFFF 
             5890 : FFFF FFFF FFFF 
             5896 : FFFF FFFF FFFF 
             589C : FFFF FFFF FFFF 
             58A2 : FFFF FFFF FFFF 
             58A8 : FFFF FFFF FFFF 
             58AE : FFFF FFFF FFFF 
             58B4 : FFFF FFFF FFFF 
             58BA : FFFF FFFF FFFF 
             58C0 : FFFF FFFF FFFF 
             58C6 : FFFF FFFF FFFF 
             58CC : FFFF FFFF FFFF 
             58D2 : FFFF FFFF FFFF 
             58D8 : FFFF FFFF FFFF 
             58DE : FFFF FFFF FFFF 
             58E4 : FFFF FFFF FFFF 
             58EA : FFFF FFFF FFFF 
             58F0 : FFFF FFFF FFFF 
             58F6 : FFFF FFFF FFFF 
             58FC : FFFF FFFF FFFF 
             5902 : FFFF FFFF FFFF 
             5908 : FFFF FFFF FFFF 
             590E : FFFF FFFF FFFF 
             5914 : FFFF FFFF FFFF 
             591A : FFFF FFFF FFFF 
             5920 : FFFF FFFF FFFF 
             5926 : FFFF FFFF FFFF 
             592C : FFFF FFFF FFFF 
             5932 : FFFF FFFF FFFF 
             5938 : FFFF FFFF FFFF 
             593E : FFFF FFFF FFFF 
             5944 : FFFF FFFF FFFF 
             594A : FFFF FFFF FFFF 
             5950 : FFFF FFFF FFFF 
             5956 : FFFF FFFF FFFF 
             595C : FFFF FFFF FFFF 
             5962 : FFFF FFFF FFFF 
             5968 : FFFF FFFF FFFF 
             596E : FFFF FFFF FFFF 
             5974 : FFFF FFFF FFFF 
             597A : FFFF FFFF FFFF 
             5980 : FFFF FFFF FFFF 
             5986 : FFFF FFFF FFFF 
             598C : FFFF FFFF FFFF 
             5992 : FFFF FFFF FFFF 
             5998 : FFFF FFFF FFFF 
             599E : FFFF FFFF FFFF 
             59A4 : FFFF FFFF FFFF 
             59AA : FFFF FFFF FFFF 
             59B0 : FFFF FFFF FFFF 
             59B6 : FFFF FFFF FFFF 
             59BC : FFFF FFFF FFFF 
             59C2 : FFFF FFFF FFFF 
             59C8 : FFFF FFFF FFFF 
             59CE : FFFF FFFF FFFF 
             59D4 : FFFF FFFF FFFF 
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 157 - 11/4/2023 8:40:20


             59DA : FFFF FFFF FFFF 
             59E0 : FFFF FFFF FFFF 
             59E6 : FFFF FFFF FFFF 
             59EC : FFFF FFFF FFFF 
             59F2 : FFFF FFFF FFFF 
             59F8 : FFFF FFFF FFFF 
             59FE : FFFF FFFF FFFF 
             5A04 : FFFF FFFF FFFF 
             5A0A : FFFF FFFF FFFF 
             5A10 : FFFF FFFF FFFF 
             5A16 : FFFF FFFF FFFF 
             5A1C : FFFF FFFF FFFF 
             5A22 : FFFF FFFF FFFF 
             5A28 : FFFF FFFF FFFF 
             5A2E : FFFF FFFF FFFF 
             5A34 : FFFF FFFF FFFF 
             5A3A : FFFF FFFF FFFF 
             5A40 : FFFF FFFF FFFF 
             5A46 : FFFF FFFF FFFF 
             5A4C : FFFF FFFF FFFF 
             5A52 : FFFF FFFF FFFF 
             5A58 : FFFF FFFF FFFF 
             5A5E : FFFF FFFF FFFF 
             5A64 : FFFF FFFF FFFF 
             5A6A : FFFF FFFF FFFF 
             5A70 : FFFF FFFF FFFF 
             5A76 : FFFF FFFF FFFF 
             5A7C : FFFF FFFF FFFF 
             5A82 : FFFF FFFF FFFF 
             5A88 : FFFF FFFF FFFF 
             5A8E : FFFF FFFF FFFF 
             5A94 : FFFF FFFF FFFF 
             5A9A : FFFF FFFF FFFF 
             5AA0 : FFFF FFFF FFFF 
             5AA6 : FFFF FFFF FFFF 
             5AAC : FFFF FFFF FFFF 
             5AB2 : FFFF FFFF FFFF 
             5AB8 : FFFF FFFF FFFF 
             5ABE : FFFF FFFF FFFF 
             5AC4 : FFFF FFFF FFFF 
             5ACA : FFFF FFFF FFFF 
             5AD0 : FFFF FFFF FFFF 
             5AD6 : FFFF FFFF FFFF 
             5ADC : FFFF FFFF FFFF 
             5AE2 : FFFF FFFF FFFF 
             5AE8 : FFFF FFFF FFFF 
             5AEE : FFFF FFFF FFFF 
             5AF4 : FFFF FFFF FFFF 
             5AFA : FFFF FFFF FFFF 
             5B00 : FFFF FFFF FFFF 
             5B06 : FFFF FFFF FFFF 
             5B0C : FFFF FFFF FFFF 
             5B12 : FFFF FFFF FFFF 
             5B18 : FFFF FFFF FFFF 
             5B1E : FFFF FFFF FFFF 
             5B24 : FFFF FFFF FFFF 
             5B2A : FFFF FFFF FFFF 
             5B30 : FFFF FFFF FFFF 
             5B36 : FFFF FFFF FFFF 
             5B3C : FFFF FFFF FFFF 
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 158 - 11/4/2023 8:40:20


             5B42 : FFFF FFFF FFFF 
             5B48 : FFFF FFFF FFFF 
             5B4E : FFFF FFFF FFFF 
             5B54 : FFFF FFFF FFFF 
             5B5A : FFFF FFFF FFFF 
             5B60 : FFFF FFFF FFFF 
             5B66 : FFFF FFFF FFFF 
             5B6C : FFFF FFFF FFFF 
             5B72 : FFFF FFFF FFFF 
             5B78 : FFFF FFFF FFFF 
             5B7E : FFFF FFFF FFFF 
             5B84 : FFFF FFFF FFFF 
             5B8A : FFFF FFFF FFFF 
             5B90 : FFFF FFFF FFFF 
             5B96 : FFFF FFFF FFFF 
             5B9C : FFFF FFFF FFFF 
             5BA2 : FFFF FFFF FFFF 
             5BA8 : FFFF FFFF FFFF 
             5BAE : FFFF FFFF FFFF 
             5BB4 : FFFF FFFF FFFF 
             5BBA : FFFF FFFF FFFF 
             5BC0 : FFFF FFFF FFFF 
             5BC6 : FFFF FFFF FFFF 
             5BCC : FFFF FFFF FFFF 
             5BD2 : FFFF FFFF FFFF 
             5BD8 : FFFF FFFF FFFF 
             5BDE : FFFF FFFF FFFF 
             5BE4 : FFFF FFFF FFFF 
             5BEA : FFFF FFFF FFFF 
             5BF0 : FFFF FFFF FFFF 
             5BF6 : FFFF FFFF FFFF 
             5BFC : FFFF FFFF FFFF 
             5C02 : FFFF FFFF FFFF 
             5C08 : FFFF FFFF FFFF 
             5C0E : FFFF FFFF FFFF 
             5C14 : FFFF FFFF FFFF 
             5C1A : FFFF FFFF FFFF 
             5C20 : FFFF FFFF FFFF 
             5C26 : FFFF FFFF FFFF 
             5C2C : FFFF FFFF FFFF 
             5C32 : FFFF FFFF FFFF 
             5C38 : FFFF FFFF FFFF 
             5C3E : FFFF FFFF FFFF 
             5C44 : FFFF FFFF FFFF 
             5C4A : FFFF FFFF FFFF 
             5C50 : FFFF FFFF FFFF 
             5C56 : FFFF FFFF FFFF 
             5C5C : FFFF FFFF FFFF 
             5C62 : FFFF FFFF FFFF 
             5C68 : FFFF FFFF FFFF 
             5C6E : FFFF FFFF FFFF 
             5C74 : FFFF FFFF FFFF 
             5C7A : FFFF FFFF FFFF 
             5C80 : FFFF FFFF FFFF 
             5C86 : FFFF FFFF FFFF 
             5C8C : FFFF FFFF FFFF 
             5C92 : FFFF FFFF FFFF 
             5C98 : FFFF FFFF FFFF 
             5C9E : FFFF FFFF FFFF 
             5CA4 : FFFF FFFF FFFF 
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 159 - 11/4/2023 8:40:20


             5CAA : FFFF FFFF FFFF 
             5CB0 : FFFF FFFF FFFF 
             5CB6 : FFFF FFFF FFFF 
             5CBC : FFFF FFFF FFFF 
             5CC2 : FFFF FFFF FFFF 
             5CC8 : FFFF FFFF FFFF 
             5CCE : FFFF FFFF FFFF 
             5CD4 : FFFF FFFF FFFF 
             5CDA : FFFF FFFF FFFF 
             5CE0 : FFFF FFFF FFFF 
             5CE6 : FFFF FFFF FFFF 
             5CEC : FFFF FFFF FFFF 
             5CF2 : FFFF FFFF FFFF 
             5CF8 : FFFF FFFF FFFF 
             5CFE : FFFF FFFF FFFF 
             5D04 : FFFF FFFF FFFF 
             5D0A : FFFF FFFF FFFF 
             5D10 : FFFF FFFF FFFF 
             5D16 : FFFF FFFF FFFF 
             5D1C : FFFF FFFF FFFF 
             5D22 : FFFF FFFF FFFF 
             5D28 : FFFF FFFF FFFF 
             5D2E : FFFF FFFF FFFF 
             5D34 : FFFF FFFF FFFF 
             5D3A : FFFF FFFF FFFF 
             5D40 : FFFF FFFF FFFF 
             5D46 : FFFF FFFF FFFF 
             5D4C : FFFF FFFF FFFF 
             5D52 : FFFF FFFF FFFF 
             5D58 : FFFF FFFF FFFF 
             5D5E : FFFF FFFF FFFF 
             5D64 : FFFF FFFF FFFF 
             5D6A : FFFF FFFF FFFF 
             5D70 : FFFF FFFF FFFF 
             5D76 : FFFF FFFF FFFF 
             5D7C : FFFF FFFF FFFF 
             5D82 : FFFF FFFF FFFF 
             5D88 : FFFF FFFF FFFF 
             5D8E : FFFF FFFF FFFF 
             5D94 : FFFF FFFF FFFF 
             5D9A : FFFF FFFF FFFF 
             5DA0 : FFFF FFFF FFFF 
             5DA6 : FFFF FFFF FFFF 
             5DAC : FFFF FFFF FFFF 
             5DB2 : FFFF FFFF FFFF 
             5DB8 : FFFF FFFF FFFF 
             5DBE : FFFF FFFF FFFF 
             5DC4 : FFFF FFFF FFFF 
             5DCA : FFFF FFFF FFFF 
             5DD0 : FFFF FFFF FFFF 
             5DD6 : FFFF FFFF FFFF 
             5DDC : FFFF FFFF FFFF 
             5DE2 : FFFF FFFF FFFF 
             5DE8 : FFFF FFFF FFFF 
             5DEE : FFFF FFFF FFFF 
             5DF4 : FFFF FFFF FFFF 
             5DFA : FFFF FFFF FFFF 
             5E00 : FFFF FFFF FFFF 
             5E06 : FFFF FFFF FFFF 
             5E0C : FFFF FFFF FFFF 
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 160 - 11/4/2023 8:40:20


             5E12 : FFFF FFFF FFFF 
             5E18 : FFFF FFFF FFFF 
             5E1E : FFFF FFFF FFFF 
             5E24 : FFFF FFFF FFFF 
             5E2A : FFFF FFFF FFFF 
             5E30 : FFFF FFFF FFFF 
             5E36 : FFFF FFFF FFFF 
             5E3C : FFFF FFFF FFFF 
             5E42 : FFFF FFFF FFFF 
             5E48 : FFFF FFFF FFFF 
             5E4E : FFFF FFFF FFFF 
             5E54 : FFFF FFFF FFFF 
             5E5A : FFFF FFFF FFFF 
             5E60 : FFFF FFFF FFFF 
             5E66 : FFFF FFFF FFFF 
             5E6C : FFFF FFFF FFFF 
             5E72 : FFFF FFFF FFFF 
             5E78 : FFFF FFFF FFFF 
             5E7E : FFFF FFFF FFFF 
             5E84 : FFFF FFFF FFFF 
             5E8A : FFFF FFFF FFFF 
             5E90 : FFFF FFFF FFFF 
             5E96 : FFFF FFFF FFFF 
             5E9C : FFFF FFFF FFFF 
             5EA2 : FFFF FFFF FFFF 
             5EA8 : FFFF FFFF FFFF 
             5EAE : FFFF FFFF FFFF 
             5EB4 : FFFF FFFF FFFF 
             5EBA : FFFF FFFF FFFF 
             5EC0 : FFFF FFFF FFFF 
             5EC6 : FFFF FFFF FFFF 
             5ECC : FFFF FFFF FFFF 
             5ED2 : FFFF FFFF FFFF 
             5ED8 : FFFF FFFF FFFF 
             5EDE : FFFF FFFF FFFF 
             5EE4 : FFFF FFFF FFFF 
             5EEA : FFFF FFFF FFFF 
             5EF0 : FFFF FFFF FFFF 
             5EF6 : FFFF FFFF FFFF 
             5EFC : FFFF FFFF FFFF 
             5F02 : FFFF FFFF FFFF 
             5F08 : FFFF FFFF FFFF 
             5F0E : FFFF FFFF FFFF 
             5F14 : FFFF FFFF FFFF 
             5F1A : FFFF FFFF FFFF 
             5F20 : FFFF FFFF FFFF 
             5F26 : FFFF FFFF FFFF 
             5F2C : FFFF FFFF FFFF 
             5F32 : FFFF FFFF FFFF 
             5F38 : FFFF FFFF FFFF 
             5F3E : FFFF FFFF FFFF 
             5F44 : FFFF FFFF FFFF 
             5F4A : FFFF FFFF FFFF 
             5F50 : FFFF FFFF FFFF 
             5F56 : FFFF FFFF FFFF 
             5F5C : FFFF FFFF FFFF 
             5F62 : FFFF FFFF FFFF 
             5F68 : FFFF FFFF FFFF 
             5F6E : FFFF FFFF FFFF 
             5F74 : FFFF FFFF FFFF 
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 161 - 11/4/2023 8:40:20


             5F7A : FFFF FFFF FFFF 
             5F80 : FFFF FFFF FFFF 
             5F86 : FFFF FFFF FFFF 
             5F8C : FFFF FFFF FFFF 
             5F92 : FFFF FFFF FFFF 
             5F98 : FFFF FFFF FFFF 
             5F9E : FFFF FFFF FFFF 
             5FA4 : FFFF FFFF FFFF 
             5FAA : FFFF FFFF FFFF 
             5FB0 : FFFF FFFF FFFF 
             5FB6 : FFFF FFFF FFFF 
             5FBC : FFFF FFFF FFFF 
             5FC2 : FFFF FFFF FFFF 
             5FC8 : FFFF FFFF FFFF 
             5FCE : FFFF FFFF FFFF 
             5FD4 : FFFF FFFF FFFF 
             5FDA : FFFF FFFF FFFF 
             5FE0 : FFFF FFFF FFFF 
             5FE6 : FFFF FFFF FFFF 
             5FEC : FFFF FFFF FFFF 
             5FF2 : FFFF FFFF FFFF 
             5FF8 : FFFF FFFF FFFF 
             5FFE : FFFF             
    8872/    6000 :                     
    8873/    6000 :                     ;************************************************************************************
    8874/    6000 :                     ;
    8875/    6000 :                     ; This lot is in RAM
    8876/    6000 :                     
    8877/    6000 :                     ;    		ORG     ram_addr	; start of RAM
    8878/    6000 :                     ; 
    8879/    6000 :                     ;ram_strt	ds.l	$100		; allow 1K for the stack, this should be plenty
    8880/    6000 :                     ;								; for any BASIC program that doesn't do something
    8881/    6000 :                     ;								; silly, it could even be much less.
    8882/    6000 :                     ;ram_base
    8883/    6000 :                     ;LAB_WARM	ds.w	1			; BASIC warm start entry point
    8884/    6000 :                     ;Wrmjpv		ds.l	1			; BASIC warm start jump vector
    8885/    6000 :                     ;
    8886/    6000 :                     ;Usrjmp		ds.w	1			; USR function JMP address
    8887/    6000 :                     ;Usrjpv		ds.l	1			; USR function JMP vector
    8888/    6000 :                     ;
    8889/    6000 :                     ;; system dependant i/o vectors
    8890/    6000 :                     ;; these are in RAM and are set at start-up
    8891/    6000 :                     ;
    8892/    6000 :                     ;V_INPT		ds.w	1			; non halting scan input device entry point
    8893/    6000 :                     ;V_INPTv		ds.l	1			; non halting scan input device jump vector
    8894/    6000 :                     ;
    8895/    6000 :                     ;V_OUTP		ds.w	1			; send byte to output device entry point
    8896/    6000 :                     ;V_OUTPv		ds.l	1			; send byte to output device jump vector
    8897/    6000 :                     ;
    8898/    6000 :                     ;V_LOAD		ds.w	1			; load BASIC program entry point
    8899/    6000 :                     ;V_LOADv		ds.l	1			; load BASIC program jump vector
    8900/    6000 :                     ;
    8901/    6000 :                     ;V_SAVE		ds.w	1			; save BASIC program entry point
    8902/    6000 :                     ;V_SAVEv		ds.l	1			; save BASIC program jump vector
    8903/    6000 :                     ;
    8904/    6000 :                     ;V_CTLC		ds.w	1			; save CTRL-C check entry point
    8905/    6000 :                     ;V_CTLCv		ds.l	1			; save CTRL-C check jump vector
    8906/    6000 :                     ;
    8907/    6000 :                     ;Itemp		ds.l	1			; temporary integer	(for GOTO etc)
    8908/    6000 :                     ;
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 162 - 11/4/2023 8:40:20


    8909/    6000 :                     ;Smeml		ds.l	1			; start of memory		(start of program)
    8910/    6000 :                     ;
    8911/    6000 :                     ;; the program is stored as a series of lines each line having the following format
    8912/    6000 :                     ;;
    8913/    6000 :                     ;;		ds.l	1			; pointer to the next line or $00000000 if [EOT]
    8914/    6000 :                     ;;		ds.l	1			; line number
    8915/    6000 :                     ;;		ds.b	n			; program bytes
    8916/    6000 :                     ;;		dc.b	$00			; [EOL] marker, there will be a second $00 byte, if
    8917/    6000 :                     ;;						; needed, to pad the line to an even number of bytes
    8918/    6000 :                     ;
    8919/    6000 :                     ;Sfncl		ds.l	1			; start of functions	(end of Program)
    8920/    6000 :                     ;
    8921/    6000 :                     ;; the functions are stored as function name, function execute pointer and function
    8922/    6000 :                     ;; variable name
    8923/    6000 :                     ;;
    8924/    6000 :                     ;;		ds.l	1			; name
    8925/    6000 :                     ;;		ds.l	1			; execute pointer
    8926/    6000 :                     ;;		ds.l	1			; function variable
    8927/    6000 :                     ;
    8928/    6000 :                     ;Svarl		ds.l	1			; start of variables	(end of functions)
    8929/    6000 :                     ;
    8930/    6000 :                     ;; the variables are stored as variable name, variable value
    8931/    6000 :                     ;;
    8932/    6000 :                     ;;		ds.l	1			; name
    8933/    6000 :                     ;;		ds.l	1			; packed float or integer value
    8934/    6000 :                     ;
    8935/    6000 :                     ;Sstrl		ds.l	1			; start of strings	(end of variables)
    8936/    6000 :                     ;
    8937/    6000 :                     ;; the strings are stored as string name, string pointer and string length
    8938/    6000 :                     ;;
    8939/    6000 :                     ;;		ds.l	1			; name
    8940/    6000 :                     ;;		ds.l	1			; string pointer
    8941/    6000 :                     ;;		ds.w	1			; string length
    8942/    6000 :                     ;
    8943/    6000 :                     ;Sarryl		ds.l	1			; start of arrays		(end of strings)
    8944/    6000 :                     ;
    8945/    6000 :                     ;; the arrays are stored as array name, array size, array dimensions count, array
    8946/    6000 :                     ;; dimensions upper bounds and array elements
    8947/    6000 :                     ;;
    8948/    6000 :                     ;;		ds.l	1			; name
    8949/    6000 :                     ;;		ds.l	1			; size including this header
    8950/    6000 :                     ;;		ds.w	1			; dimensions count
    8951/    6000 :                     ;;		ds.w	1			; 1st dimension upper bound
    8952/    6000 :                     ;;		ds.w	1			; 2nd dimension upper bound
    8953/    6000 :                     ;;		...				; ...
    8954/    6000 :                     ;;		ds.w	1			; nth dimension upper bound
    8955/    6000 :                     ;;
    8956/    6000 :                     ;; then (i1+1)*(i2+1)...*(in+1) of either ..
    8957/    6000 :                     ;;
    8958/    6000 :                     ;;		ds.l	1			; packed float or integer value
    8959/    6000 :                     ;;
    8960/    6000 :                     ;; .. if float or integer, or ..
    8961/    6000 :                     ;;
    8962/    6000 :                     ;;		ds.l	1			; string pointer
    8963/    6000 :                     ;;		ds.w	1			; string length
    8964/    6000 :                     ;;
    8965/    6000 :                     ;; .. if string
    8966/    6000 :                     ;
    8967/    6000 :                     ;Earryl		ds.l	1			; end of arrays		(start of free mem)
    8968/    6000 :                     ;Sstorl		ds.l	1			; string storage		(moving down)
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 163 - 11/4/2023 8:40:20


    8969/    6000 :                     ;Ememl		ds.l	1			; end of memory		(upper bound of RAM)
    8970/    6000 :                     ;Sutill		ds.l	1			; string utility ptr
    8971/    6000 :                     ;Clinel		ds.l	1			; current line		(Basic line number)
    8972/    6000 :                     ;Blinel		ds.l	1			; break line		(Basic line number)
    8973/    6000 :                     ;
    8974/    6000 :                     ;Cpntrl		ds.l	1			; continue pointer
    8975/    6000 :                     ;Dlinel		ds.l	1			; current DATA line
    8976/    6000 :                     ;Dptrl		ds.l	1			; DATA pointer
    8977/    6000 :                     ;Rdptrl		ds.l	1			; read pointer
    8978/    6000 :                     ;Varname		ds.l	1			; current var name
    8979/    6000 :                     ;Cvaral		ds.l	1			; current var address
    8980/    6000 :                     ;Lvarpl		ds.l	1			; variable pointer for LET and FOR/NEXT
    8981/    6000 :                     ;
    8982/    6000 :                     ;des_sk_e	ds.l	6			; descriptor stack end address
    8983/    6000 :                     ;des_sk							; descriptor stack start address
    8984/    6000 :                     ;								; use a4 for the descriptor pointer
    8985/    6000 :                     ;			ds.w	1			
    8986/    6000 :                     ;Ibuffs		ds.l	$40			; start of input buffer
    8987/    6000 :                     ;Ibuffe
    8988/    6000 :                     ;								; end of input buffer
    8989/    6000 :                     ;
    8990/    6000 :                     ;FAC1_m		ds.l	1			; FAC1 mantissa1
    8991/    6000 :                     ;FAC1_e		ds.w	1			; FAC1 exponent
    8992/    6000 :                     ;FAC1_s		EQU	FAC1_e+1		; FAC1 sign (b7)
    8993/    6000 :                     ;			ds.w	1			
    8994/    6000 :                     ;
    8995/    6000 :                     ;FAC2_m		ds.l	1			; FAC2 mantissa1
    8996/    6000 :                     ;FAC2_e		ds.l	1			; FAC2 exponent
    8997/    6000 :                     ;FAC2_s		EQU	FAC2_e+1		; FAC2 sign (b7)
    8998/    6000 :                     ;FAC_sc		EQU	FAC2_e+2		; FAC sign comparison, Acc#1 vs #2
    8999/    6000 :                     ;flag		EQU	FAC2_e+3		; flag byte for divide routine
    9000/    6000 :                     ;
    9001/    6000 :                     ;PRNlword	ds.l	1			; PRNG seed long word
    9002/    6000 :                     ;
    9003/    6000 :                     ;ut1_pl		ds.l	1			; utility pointer 1
    9004/    6000 :                     ;
    9005/    6000 :                     ;Asptl		ds.l	1			; array size/pointer
    9006/    6000 :                     ;Astrtl		ds.l	1			; array start pointer
    9007/    6000 :                     ;
    9008/    6000 :                     ;numexp		EQU	Astrtl			; string to float number exponent count
    9009/    6000 :                     ;expcnt		EQU	Astrtl+1		; string to float exponent count
    9010/    6000 :                     ;
    9011/    6000 :                     ;expneg		EQU	Astrtl+3		; string to float eval exponent -ve flag
    9012/    6000 :                     ;
    9013/    6000 :                     ;func_l		ds.l	1			; function pointer
    9014/    6000 :                     ;
    9015/    6000 :                     ;
    9016/    6000 :                     ;								; these two need to be a word aligned pair !
    9017/    6000 :                     ;Defdim		ds.w	1			; default DIM flag
    9018/    6000 :                     ;cosout		EQU	Defdim			; flag which CORDIC output (re-use byte)
    9019/    6000 :                     ;Dtypef		EQU	Defdim+1		; data type flag, $80=string, $40=integer, $00=float
    9020/    6000 :                     ;
    9021/    6000 :                     ;
    9022/    6000 :                     ;Binss		ds.l	4			; number to bin string start (32 chrs)
    9023/    6000 :                     ;
    9024/    6000 :                     ;Decss		ds.l	1			; number to decimal string start (16 chrs)
    9025/    6000 :                     ;			ds.w	1
    9026/    6000 :                     ;Usdss		ds.w	1			; unsigned decimal string start (10 chrs)
    9027/    6000 :                     ;
    9028/    6000 :                     ;Hexss		ds.l	2			; number to hex string start (8 chrs)
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 164 - 11/4/2023 8:40:20


    9029/    6000 :                     ;
    9030/    6000 :                     ;BHsend		ds.w	1			; bin/decimal/hex string end
    9031/    6000 :                     ;
    9032/    6000 :                     ;
    9033/    6000 :                     ;prstk		ds.b	1			; stacked function index
    9034/    6000 :                     ;
    9035/    6000 :                     ;tpower		ds.b	1			; remember CORDIC power
    9036/    6000 :                     ;
    9037/    6000 :                     ;Asrch		ds.b	1			; scan-between-quotes flag, alt search character
    9038/    6000 :                     ;
    9039/    6000 :                     ;Dimcnt		ds.b	1			; # of dimensions
    9040/    6000 :                     ;
    9041/    6000 :                     ;Breakf		ds.b	1			; break flag, $00=END else=break
    9042/    6000 :                     ;Oquote		ds.b	1			; open quote flag (Flag: DATA; LIST; memory)
    9043/    6000 :                     ;Gclctd		ds.b	1			; garbage collected flag
    9044/    6000 :                     ;Sufnxf		ds.b	1			; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
    9045/    6000 :                     ;Imode		ds.b	1			; input mode flag, $00=INPUT, $98=READ
    9046/    6000 :                     ;
    9047/    6000 :                     ;Cflag		ds.b	1			; comparison evaluation flag
    9048/    6000 :                     ;
    9049/    6000 :                     ;TabSiz		ds.b	1			; TAB step size
    9050/    6000 :                     ;
    9051/    6000 :                     ;comp_f		ds.b	1			; compare function flag, bits 0,1 and 2 used
    9052/    6000 :                     ;								; bit 2 set if >
    9053/    6000 :                     ;								; bit 1 set if =
    9054/    6000 :                     ;								; bit 0 set if <
    9055/    6000 :                     ;
    9056/    6000 :                     ;Nullct		ds.b	1			; nulls output after each line
    9057/    6000 :                     ;TPos		ds.b	1			; BASIC terminal position byte
    9058/    6000 :                     ;TWidth		ds.b	1			; BASIC terminal width byte
    9059/    6000 :                     ;Iclim		ds.b	1			; input column limit
    9060/    6000 :                     ;ccflag		ds.b	1			; CTRL-C check flag
    9061/    6000 :                     ;ccbyte		ds.b	1			; CTRL-C last received byte
    9062/    6000 :                     ;ccnull		ds.b	1			; CTRL-C last received byte 'life' timer
    9063/    6000 :                     ;
    9064/    6000 :                     ;
    9065/    6000 :                     ;prg_strt
    9066/    6000 :                     
    9067/    6000 :                     ;************************************************************************************
    9068/    6000 :                     ; EhBASIC keywords quick reference list												*
    9069/    6000 :                     ;************************************************************************************
    9070/    6000 :                     
    9071/    6000 :                     ; glossary
    9072/    6000 :                     
    9073/    6000 :                     ;		<.>		  required
    9074/    6000 :                     ;		{.|.}		  one of required
    9075/    6000 :                     ;		[.]		  optional
    9076/    6000 :                     ;		...		  may repeat as last
    9077/    6000 :                     
    9078/    6000 :                     ;		any		= anything
    9079/    6000 :                     ;		num		= number
    9080/    6000 :                     ;		state		= statement
    9081/    6000 :                     ;		n		= positive integer
    9082/    6000 :                     ;		str		= string
    9083/    6000 :                     ;		var		= variable
    9084/    6000 :                     ;		nvar		= numeric variable
    9085/    6000 :                     ;		svar		= string variable
    9086/    6000 :                     ;		expr		= expression
    9087/    6000 :                     ;		nexpr		= numeric expression
    9088/    6000 :                     ;		sexpr		= string expression
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 165 - 11/4/2023 8:40:20


    9089/    6000 :                     
    9090/    6000 :                     ; statement separator
    9091/    6000 :                     
    9092/    6000 :                     ; :			. [<state>] : [<state>]							; done
    9093/    6000 :                     
    9094/    6000 :                     ; number bases
    9095/    6000 :                     
    9096/    6000 :                     ; %			. %<binary num>								; done
    9097/    6000 :                     ; $			. $<hex num>								; done
    9098/    6000 :                     
    9099/    6000 :                     ; commands
    9100/    6000 :                     
    9101/    6000 :                     ; END		. END										; done
    9102/    6000 :                     ; FOR		. FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]	; done
    9103/    6000 :                     ; NEXT		. NEXT [<nvar>[,<nvar>]...]						; done
    9104/    6000 :                     ; DATA		. DATA [{num|["]str["]}[,{num|["]str["]}]...]	; done
    9105/    6000 :                     ; INPUT		. INPUT [<">str<">;] <var>[,<var>[,<var>]...]	; done
    9106/    6000 :                     ; DIM		. DIM <var>(<nexpr>[,<nexpr>[,<nexpr>]])		; done
    9107/    6000 :                     ; READ		. READ <var>[,<var>[,<var>]...]				; done
    9108/    6000 :                     ; LET		. [LET] <var>=<expr>						; done
    9109/    6000 :                     ; DEC		. DEC <nvar>[,<nvar>[,<nvar>]...]			; done
    9110/    6000 :                     ; GOTO		. GOTO <n>									; done
    9111/    6000 :                     ; RUN		. RUN [<n>]									; done
    9112/    6000 :                     ; IF		. IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]	; done
    9113/    6000 :                     ; RESTORE	. RESTORE [<n>]								; done
    9114/    6000 :                     ; GOSUB		. GOSUB <n>									; done
    9115/    6000 :                     ; RETURN	. RETURN									; done
    9116/    6000 :                     ; REM		. REM [<any>]								; done
    9117/    6000 :                     ; STOP		. STOP										; done
    9118/    6000 :                     ; ON		. ON <nexpr>{GOTO|GOSUB}<n>[,<n>[,<n>]...]	; done
    9119/    6000 :                     ; NULL		. NULL <nexpr>								; done
    9120/    6000 :                     ; INC		. INC <nvar>[,<nvar>[,<nvar>]...]			; done
    9121/    6000 :                     ; WAIT		. WAIT <nexpr>,<nexpr>[,<nexpr>]			; done
    9122/    6000 :                     ; LOAD		. LOAD [<sexpr>]							; done for sim
    9123/    6000 :                     ; SAVE		. SAVE [<sexpr>][,[<n>][-<n>]]				; done for sim
    9124/    6000 :                     ; DEF		. DEF FN<var>(<var>)=<expr>					; done
    9125/    6000 :                     ; POKE		. POKE <nexpr>,<nexpr>						; done
    9126/    6000 :                     ; DOKE		. DOKE <nexpr>,<nexpr>						; done
    9127/    6000 :                     ; LOKE		. LOKE <nexpr>,<nexpr>						; done
    9128/    6000 :                     ; CALL		. CALL <nexpr>								; done
    9129/    6000 :                     ; DO		. DO										; done
    9130/    6000 :                     ; LOOP		. LOOP [{WHILE|UNTIL}<nexpr>]				; done
    9131/    6000 :                     ; PRINT		. PRINT [{;|,}][<expr>][{;|,}[<expr>]...]	; done
    9132/    6000 :                     ; CONT		. CONT										; done
    9133/    6000 :                     ; LIST		. LIST [<n>][-<n>]							; done
    9134/    6000 :                     ; CLEAR		. CLEAR										; done
    9135/    6000 :                     ; NEW		. NEW										; done
    9136/    6000 :                     ; WIDTH		. WIDTH [<n>][,<n>]							; done
    9137/    6000 :                     ; GET		. GET <var>									; done
    9138/    6000 :                     ; SWAP		. SWAP <var>,<var>							; done
    9139/    6000 :                     ; BITSET	. BITSET <nexpr>,<nexpr>					; done
    9140/    6000 :                     ; BITCLR	. BITCLR <nexpr>,<nexpr>					; done
    9141/    6000 :                     
    9142/    6000 :                     ; sub commands (may not start a statement)
    9143/    6000 :                     
    9144/    6000 :                     ; TAB		. TAB(<nexpr>)								; done
    9145/    6000 :                     ; ELSE		. IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]	; done
    9146/    6000 :                     ; TO		. FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]			; done
    9147/    6000 :                     ; FN		. FN <var>(<expr>)							; done
    9148/    6000 :                     ; SPC		. SPC(<nexpr>)								; done
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 166 - 11/4/2023 8:40:20


    9149/    6000 :                     ; THEN		. IF <nexpr> {THEN <{n|comm}>|GOTO <n>}		; done
    9150/    6000 :                     ; NOT		. NOT <nexpr>								; done
    9151/    6000 :                     ; STEP		. FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]			; done
    9152/    6000 :                     ; UNTIL		. LOOP [{WHILE|UNTIL}<nexpr>]				; done
    9153/    6000 :                     ; WHILE		. LOOP [{WHILE|UNTIL}<nexpr>]				; done
    9154/    6000 :                     
    9155/    6000 :                     ; operators
    9156/    6000 :                     
    9157/    6000 :                     ; +			. [expr] + <expr>							; done
    9158/    6000 :                     ; -			. [nexpr] - <nexpr>							; done
    9159/    6000 :                     ; *			. <nexpr>	; <nexpr>						; done fast hardware
    9160/    6000 :                     ; /			. <nexpr> / <nexpr>							; done fast hardware
    9161/    6000 :                     ; ^			. <nexpr> ^ <nexpr>							; done
    9162/    6000 :                     ; AND		. <nexpr> AND <nexpr>						; done
    9163/    6000 :                     ; EOR		. <nexpr> EOR <nexpr>						; done
    9164/    6000 :                     ; OR		. <nexpr> OR <nexpr>						; done
    9165/    6000 :                     ; >>		. <nexpr> >> <nexpr>						; done
    9166/    6000 :                     ; <<		. <nexpr> << <nexpr>						; done
    9167/    6000 :                     
    9168/    6000 :                     ; compare functions
    9169/    6000 :                     
    9170/    6000 :                     ; <			. <expr> < <expr>							; done
    9171/    6000 :                     ; =			. <expr> = <expr>							; done
    9172/    6000 :                     ; >			. <expr> > <expr>							; done
    9173/    6000 :                     
    9174/    6000 :                     ; functions
    9175/    6000 :                     
    9176/    6000 :                     ; SGN		. SGN(<nexpr>)								; done
    9177/    6000 :                     ; INT		. INT(<nexpr>)								; done
    9178/    6000 :                     ; ABS		. ABS(<nexpr>)								; done
    9179/    6000 :                     ; USR		. USR(<expr>)								; done
    9180/    6000 :                     ; FRE		. FRE(<expr>)								; done
    9181/    6000 :                     ; POS		. POS(<expr>)								; done
    9182/    6000 :                     ; SQR		. SQR(<nexpr>)								; done fast shift/sub
    9183/    6000 :                     ; RND		. RND(<nexpr>)								; done 32 bit PRNG
    9184/    6000 :                     ; LOG		. LOG(<nexpr>)								; done fast cordic
    9185/    6000 :                     ; EXP		. EXP(<nexpr>)								; done fast cordic
    9186/    6000 :                     ; COS		. COS(<nexpr>)								; done fast cordic
    9187/    6000 :                     ; SIN		. SIN(<nexpr>)								; done fast cordic
    9188/    6000 :                     ; TAN		. TAN(<nexpr>)								; done fast cordic
    9189/    6000 :                     ; ATN		. ATN(<nexpr>)								; done fast cordic
    9190/    6000 :                     ; PEEK		. PEEK(<nexpr>)								; done
    9191/    6000 :                     ; DEEK		. DEEK(<nexpr>)								; done
    9192/    6000 :                     ; LEEK		. LEEK(<nexpr>)								; done
    9193/    6000 :                     ; LEN		. LEN(<sexpr>)								; done
    9194/    6000 :                     ; STR$		. STR$(<nexpr>)								; done
    9195/    6000 :                     ; VAL		. VAL(<sexpr>)								; done
    9196/    6000 :                     ; ASC		. ASC(<sexpr>)								; done
    9197/    6000 :                     ; UCASE$	. UCASE$(<sexpr>)							; done
    9198/    6000 :                     ; LCASE$	. LCASE$(<sexpr>)							; done
    9199/    6000 :                     ; CHR$		. CHR$(<nexpr>)								; done
    9200/    6000 :                     ; HEX$		. HEX$(<nexpr>)								; done
    9201/    6000 :                     ; BIN$		. BIN$(<nexpr>)								; done
    9202/    6000 :                     ; BTST		. BTST(<nexpr>,<nexpr>)						; done
    9203/    6000 :                     ; MAX		. MAX(<nexpr>[,<nexpr>[,<nexpr>]...])		; done
    9204/    6000 :                     ; MIN		. MIN(<nexpr>[,<nexpr>[,<nexpr>]...])		; done
    9205/    6000 :                     ; PI		. PI										; done
    9206/    6000 :                     ; TWOPI		. TWOPI										; done
    9207/    6000 :                     ; VARPTR	. VARPTR(<var>)								; done
    9208/    6000 :                     ; SADD		. SADD(<svar>)								; done
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 167 - 11/4/2023 8:40:20


    9209/    6000 :                     ; LEFT$		. LEFT$(<sexpr>,<nexpr>)					; done
    9210/    6000 :                     ; RIGHT$	. RIGHT$(<sexpr>,<nexpr>)					; done
    9211/    6000 :                     ; MID$		. MID$(<sexpr>,<nexpr>[,<nexpr>])			; done
    9212/    6000 :                     ; USING$	. USING$(<sexpr>,<nexpr>[,<nexpr>]...])		; done
    9213/    6000 :                     
    9214/    6000 :                     
    9215/    6000 :                     ;************************************************************************************
    9216/    6000 :                     
    9217/    6000 :                     	END	code_start
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 168 - 11/4/2023 8:40:20


  Symbol Table (* = unused):
  --------------------------

 AC1GTAC2 :                    3AFA C |  ACIAC :                       E001 - |
 ACIAD :                       E000 - |
*ARCHITECTURE :                                        "i386-unknown-win32" - |
 ASPTL :                        5A8 C |  ASRCH :                        5DA C |
 ASTRTL :                       5AC C |  BHSEND :                       5D6 C |
 BIN2DEC :                     4ABE C |  BINPR :                       46A4 C |
 BINSS :                        5B6 C |  BLINEL :                       456 C |
 BREAKF :                       5DC C | *CASESENSITIVE :                  0 - |
 CCBYTE :                       5E9 C |  CCFLAG :                       5E8 C |
 CCNULL :                       5EA C |  CFLAG :                        5E1 C |
 CLINEL :                       452 C |  CO0 :                         2010 C |
 CODE_START :                  2054 C |  COMP_F :                       5E3 C |
*CONSTPI :        3.141592653589793 - |  COSOUT :                       5B4 - |
 CPNTRL :                       45A C | *CVARAL :                       46E C |
 D1X02 :                       4A98 C |  D1X10 :                       4AAE C |
 D1X16 :                       4A8A C | *DATE :                 "11/4/2023" - |
 DECSS :                        5C6 C |  DEFDIM :                       5B4 C |
 DES_SK :                       48E C |  DES_SK_E :                     476 C |
 DIMCNT :                       5DB C |  DLINEL :                       45E C |
 DOCMP :                       26FA C |  DOREST :                      26E6 C |
 DPTRL :                        462 C |  DTYPEF :                       5B5 - |
 EARRYL :                       442 C |  EBSC_CS :                     2000 - |
 EMEML :                        44A C |  ENDBHS :                      467E C |
 EXPCNT :                       5AD - |  EXPNEG :                       5AF - |
 FAC1_E :                       594 C |  FAC1_M :                       590 C |
 FAC1_S :                       595 - |  FAC2_E :                       59C C |
 FAC2_M :                       598 C |  FAC2_S :                       59D - |
 FAC_SC :                       59E - | *FALSE :                          0 - |
 FEND :                           8 - |  FLAG :                         59F - |
*FLASH_SUPPORT :                  0 - |  FSD :                            0 - |
 FSDC :                           A - |  FSDPI :                          8 - |
 FSLI :                           6 - |  FSTI :                           4 - |
*FULLPMMU :                       1 - |  FUNC_L :                       5B0 C |
 GCLCTD :                       5DE C |  GETFIRST :                    2ED2 C |
 GETPAIR :                     2F8E C |  GOPR :                        46AE C |
*HAS64 :                          0 - | *HASFPU :                         0 - |
*HASPMMU :                        0 - |  HEXSS :                        5CE C |
 IBUFFE :                       590 C |  IBUFFS :                       490 C |
 ICLIM :                        5E7 C |  IMODE :                        5E0 C |
 INGET :                       4702 C | *INSUPMODE :                      1 - |
 ITEMP :                        42A C |  KEY_ABS :                     531E C |
 KEY_AND :                     5322 C |  KEY_ASC :                     5325 C |
 KEY_ATN :                     5329 C |  KEY_BINS :                    532E C |
 KEY_BITCLR :                  5333 C |  KEY_BITSET :                  5339 C |
 KEY_BITTST :                  533F C |  KEY_CALL :                    5347 C |
 KEY_CHRS :                    534B C |  KEY_CLEAR :                   5350 C |
 KEY_CONT :                    5355 C |  KEY_COS :                     5359 C |
 KEY_DATA :                    535E C |  KEY_DEC :                     5362 C |
 KEY_DEEK :                    5365 C |  KEY_DEF :                     536A C |
 KEY_DIM :                     536D C |  KEY_DIV :                     5310 C |
 KEY_DO :                      5374 C |  KEY_DOKE :                    5370 C |
 KEY_ELSE :                    5377 C |  KEY_END :                     537B C |
 KEY_EOR :                     537E C |  KEY_EQUAL :                   5316 C |
 KEY_EXP :                     5381 C |  KEY_FN :                      5389 C |
 KEY_FOR :                     5386 C |  KEY_FRE :                     538B C |
 KEY_GET :                     5390 C |  KEY_GOSUB :                   5397 C |
 KEY_GOTO :                    5393 C |  KEY_GT :                      531A C |
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 169 - 11/4/2023 8:40:20


 KEY_HEXS :                    539D C |  KEY_IF :                      53A3 C |
 KEY_INC :                     53A5 C |  KEY_INPUT :                   53A8 C |
 KEY_INT :                     53AD C |  KEY_LCASES :                  53B2 C |
 KEY_LEEK :                    53B9 C |  KEY_LEFTS :                   53BE C |
 KEY_LEN :                     53C4 C |  KEY_LET :                     53C8 C |
 KEY_LIST :                    53CB C |  KEY_LOAD :                    53CF C |
 KEY_LOG :                     53D3 C |  KEY_LOKE :                    53D7 C |
 KEY_LOOP :                    53DB C |  KEY_LSHIFT :                  5312 C |
 KEY_LT :                      5314 C |  KEY_MAX :                     53E0 C |
 KEY_MIDS :                    53E4 C |  KEY_MIN :                     53E9 C |
 KEY_MINUS :                   530E C |  KEY_MULT :                    530A C |
 KEY_NEW :                     53EE C |  KEY_NEXT :                    53F1 C |
 KEY_NOT :                     53F5 C |  KEY_NULL :                    53F8 C |
 KEY_ON :                      53FD C |  KEY_OR :                      53FF C |
 KEY_PEEK :                    5402 C |  KEY_PI :                      5407 C |
 KEY_PLUS :                    530C C |  KEY_POKE :                    5409 C |
 KEY_POS :                     540D C |  KEY_POWER :                   54B3 C |
 KEY_PRINT :                   5411 C |  KEY_RAM :                     5417 C |
 KEY_READ :                    541E C |  KEY_REM :                     5422 C |
 KEY_RESTORE :                 5425 C |  KEY_RETURN :                  542C C |
 KEY_RIGHTS :                  5432 C |  KEY_RND :                     5439 C |
 KEY_RSHIFT :                  5318 C |  KEY_RUN :                     543D C |
 KEY_SADD :                    5441 C |  KEY_SAVE :                    5446 C |
 KEY_SGN :                     544A C |  KEY_SIN :                     544E C |
 KEY_SPC :                     5452 C |  KEY_SQR :                     5456 C |
 KEY_STEP :                    545A C |  KEY_STOP :                    545E C |
 KEY_STRS :                    5462 C |  KEY_SWAP :                    5467 C |
 KEY_TAB :                     546C C |  KEY_TAN :                     5470 C |
 KEY_THEN :                    5474 C |  KEY_TO :                      5478 C |
 KEY_TWOPI :                   547A C |  KEY_UCASES :                  5480 C |
 KEY_UNTIL :                   5487 C |  KEY_USINGS :                  548C C |
 KEY_USR :                     5493 C |  KEY_VAL :                     5498 C |
 KEY_VPTR :                    549C C |  KEY_WAIT :                    54A4 C |
 KEY_WHILE :                   54A8 C |  KEY_WIDTH :                   54AD C |
 KFCTSEED :                26A3D110 - |  LAB_11A5 :                    2BA0 C |
 LAB_11A6 :                    2BA2 C |  LAB_11BD :                    2BAE C |
 LAB_1269 :                    218A C |  LAB_1274 :                    2198 C |
 LAB_127D :                    21A0 C |  LAB_127E :                    21AE C |
 LAB_1295 :                    21C2 C |  LAB_12AE :                    21E4 C |
 LAB_12B0 :                    21E6 C |  LAB_12E6 :                    2206 C |
 LAB_12FF :                    2238 C |  LAB_1301 :                    223A C |
 LAB_1303 :                    2258 C |  LAB_1325 :                    2270 C |
 LAB_132E :                    2260 C |  LAB_1330 :                    2262 C |
 LAB_134B :                    227E C |  LAB_1357 :                    229C C |
 LAB_1359 :                    22A2 C |  LAB_1374 :                    22C2 C |
 LAB_1378 :                    22C8 C |  LAB_137F :                    22D4 C |
 LAB_138E :                    22DA C |  LAB_1392 :                    22DE C |
 LAB_13A6 :                    2312 C |  LAB_13AC :                    231A C |
 LAB_13C6 :                    2344 C |  LAB_13CC :                    234A C |
 LAB_13D6 :                    236C C |  LAB_13D8 :                    2372 C |
 LAB_13EA :                    237E C |  LAB_13EC :                    2380 C |
 LAB_13FF :                    2398 C |  LAB_1401 :                    239C C |
 LAB_1408 :                    23A8 C |  LAB_1410 :                    23B4 C |
 LAB_1417 :                    23BE C |  LAB_141B :                    23C0 C |
 LAB_141F :                    23D0 C |  LAB_142A :                    23D6 C |
 LAB_142C :                    23E2 C |  LAB_145E :                    23FC C |
 LAB_145F :                    23EE C |  LAB_1463 :                    2404 C |
 LAB_1477 :                    2410 C |  LAB_147A :                    2416 C |
*LAB_1480 :                    2430 C |  LAB_1491 :                    243A C |
 LAB_14BD :                    246C C |  LAB_14C0 :                    2470 C |
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 170 - 11/4/2023 8:40:20


 LAB_14D4 :                    2490 C | *LAB_14E2 :                    24AC C |
 LAB_150C :                    24BA C |  LAB_1519 :                    24CA C |
 LAB_152E :                    24D6 C |  LAB_1540 :                    2502 C |
 LAB_15B3 :                    2562 C |  LAB_15C2 :                    258C C |
 LAB_15D1 :                    2598 C |  LAB_15DC :                    2574 C |
 LAB_15F6 :                    2586 C |  LAB_15FF :                    25A6 C |
 LAB_1602 :                    25AA C |  LAB_1624 :                    262E C |
 LAB_1629 :                    25CE C |  LAB_1636 :                    25D2 C |
 LAB_1639 :                    25D8 C |  LAB_163B :                    25E4 C |
 LAB_1647 :                    25F0 C |  LAB_164F :                    25F6 C |
 LAB_16B0 :                    268E C |  LAB_16D0 :                    26B2 C |
 LAB_1723 :                    274C C |  LAB_1725 :                    2750 C |
 LAB_172C :                    273C C |  LAB_172D :                    2744 C |
 LAB_174B :                    2778 C |  LAB_174E :                    279C C |
 LAB_1750 :                    27A8 C |  LAB_1752 :                    27B4 C |
 LAB_1754 :                    27CC C | *LAB_1756 :                    27B8 C |
 LAB_176C :                    27EA C |  LAB_1773 :                    27F4 C |
 LAB_1785 :                    2810 C |  LAB_1786 :                    283C C |
 LAB_17B7 :                    2852 C |  LAB_17B8 :                    284E C |
 LAB_17D5 :                    28CE C |  LAB_17D6 :                    28D2 C |
*LAB_1810 :                    28E4 C |  LAB_1811 :                    28F4 C |
 LAB_1813 :                    28FA C |  LAB_1829 :                    2932 C |
 LAB_182C :                    2936 C |  LAB_1831 :                    293C C |
 LAB_185E :                    297C C |  LAB_1866 :                    2980 C |
 LAB_1880 :                    2A42 C |  LAB_1886 :                    2A4C C |
 LAB_188A :                    2A50 C |  LAB_188B :                    298E C |
 LAB_1898 :                    299C C |  LAB_18A2 :                    29A6 C |
 LAB_18B7 :                    29C8 C |  LAB_18B8 :                    29D4 C |
 LAB_18BD :                    29DA C |  LAB_18C3 :                    29E4 C |
 LAB_18C6 :                    29E8 C |  LAB_18CD :                    29F2 C |
 LAB_18E3 :                    29FC C |  LAB_18F0 :                    2A1C C |
 LAB_18F7 :                    2A2A C |  LAB_18F9 :                    2A2E C |
 LAB_1904 :                    2A54 C |  LAB_1913 :                    2A66 C |
 LAB_1934 :                    2A8C C |  LAB_1953 :                    2AA0 C |
 LAB_195B :                    2AA8 C | *LAB_1961 :                    2AB2 C |
 LAB_1984 :                    2AD2 C |  LAB_1985 :                    2AD6 C |
 LAB_1986 :                    2ADA C |  LAB_1999 :                    2AEE C |
 LAB_19B0 :                    2B00 C |  LAB_19B6 :                    2B10 C |
 LAB_19C2 :                    2B20 C |  LAB_19DD :                    2B34 C |
 LAB_19F6 :                    2B54 C |  LAB_1A03 :                    2B62 C |
 LAB_1A0E :                    2B72 C |  LAB_1A1B :                    2B78 C |
 LAB_1A46 :                    2B92 C |  LAB_1A90 :                    2C10 C |
 LAB_1A9B :                    2C1E C |  LAB_1ABA :                    2C48 C |
 LAB_1ACD :                    2C74 C |  LAB_1ADB :                    2C80 C |
 LAB_1ADE :                    2C84 C |  LAB_1AE0 :                    2C9A C |
 LAB_1AFA :                    2CB4 C |  LAB_1B0B :                    2CCA C |
 LAB_1B13 :                    2CD2 C |  LAB_1B1C :                    2CE2 C |
 LAB_1B1D :                    2CE4 C |  LAB_1B2A :                    2CF6 C |
 LAB_1B3C :                    2D12 C |  LAB_1B43 :                    2C58 C |
 LAB_1B78 :                    2D1E C |  LAB_1B7B :                    2D22 C |
 LAB_1B7D :                    2D24 C |  LAB_1B84 :                    2D2E C |
 LAB_1B86 :                    2D32 C |  LAB_1B9D :                    2D56 C |
 LAB_1BC1 :                    2D86 C |  LAB_1BD0 :                    2DF6 C |
 LAB_1BE7 :                    2E10 C |  LAB_1BF3 :                    2D92 C |
 LAB_1BF7 :                    2D98 C |  LAB_1BFB :                    2D9C C |
 LAB_1C01 :                    2DA4 C |  LAB_1C11 :                    2DCE C |
 LAB_1C13 :                    2DD4 C |  LAB_1C18 :                    2DDC C |
 LAB_1C19 :                    2DE0 C |  LAB_1C1A :                    2DF0 C |
 LAB_1C2A :                    2E4E C |  LAB_1CAE :                    2EF6 C |
 LAB_1CB5 :                    2F14 C |  LAB_1CD4 :                    2F1E C |
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 171 - 11/4/2023 8:40:20


 LAB_1CD5 :                    2F24 C |  LAB_1CD6 :                    2F26 C |
 LAB_1CDB :                    2F36 C |  LAB_1CE6 :                    2F28 C |
 LAB_1CF2 :                    2F38 C |  LAB_1CFE :                    2F4E C |
 LAB_1D10 :                    2FC6 C |  LAB_1D12 :                    2FCA C |
 LAB_1D2D :                    2FDC C |  LAB_1D2E :                    2FE8 C |
 LAB_1D44 :                    3004 C |  LAB_1D45 :                    3014 C |
 LAB_1D48 :                    3028 C |  LAB_1D49 :                    3030 C |
 LAB_1D4A :                    3034 C |  LAB_1D4B :                    3044 C |
 LAB_1D5D :                    304C C |  LAB_1D5E :                    3052 C |
 LAB_1D83 :                    2FB6 C |  LAB_1D8A :                    2FB0 C |
 LAB_1D94 :                    3066 C | *LAB_1D96 :                    4DB4 C |
*LAB_1D98 :                    3070 C |  LAB_1DAC :                    308A C |
 LAB_1DAE :                    308C C |  LAB_1DAF :                    3098 C |
 LAB_1DB0 :                    30A6 C |  LAB_1DB1 :                    30AA C |
 LAB_1DB2 :                    30AE C |  LAB_1DD7 :                    30C6 C |
 LAB_1DE6 :                    30E0 C |  LAB_1E17 :                    3122 C |
 LAB_1E1F :                    3128 C |  LAB_1E5C :                    3162 C |
 LAB_1E8D :                    317E C |  LAB_1EA1 :                    319A C |
 LAB_1EC0 :                    31C2 C |  LAB_1ED6 :                    31EE C |
 LAB_1ED8 :                    31FC C |  LAB_1EDF :                    31B6 C |
 LAB_1F07 :                    320E C |  LAB_1F28 :                    3228 C |
 LAB_1F2C :                    322E C |  LAB_1F5A :                    323C C |
 LAB_1F6A :                    3264 C |  LAB_1F6B :                    3270 C |
 LAB_1F7C :                    3276 C |  LAB_1FB4 :                    32A4 C |
 LAB_1FD0 :                    32D0 C |  LAB_201E :                    332A C |
 LAB_2043 :                    3378 C |  LAB_2044 :                    33AA C |
 LAB_2045 :                    33B4 C |  LAB_204S :                    337A C |
 LAB_204T :                    33A8 C |  LAB_20AE :                    33C6 C |
 LAB_20B4 :                    33CA C |  LAB_20BE :                    33D0 C |
 LAB_20C9 :                    33F4 C |  LAB_20CB :                    33E0 C |
 LAB_20D0 :                    33E8 C |  LAB_20D8 :                    33FE C |
 LAB_20E0 :                    3406 C |  LAB_2115 :                    3426 C |
 LAB_2117 :                    343E C |  LAB_2128 :                    3458 C |
 LAB_2137 :                    345C C |  LAB_214B :                    347C C |
 LAB_2161 :                    3492 C |  LAB_2176 :                    349A C |
 LAB_217E :                    34A8 C |  LAB_2183 :                    34C2 C |
 LAB_218B :                    34CA C |  LAB_218F :                    34CC C |
 LAB_21C2 :                    34D8 C |  LAB_21C4 :                    34DE C |
 LAB_21D1 :                    3512 C |  LAB_2206 :                    3518 C |
 LAB_2212 :                    3540 C |  LAB_2216 :                    3502 C |
 LAB_2240 :                    350A C |  LAB_224D :                    3546 C |
 LAB_224E :                    355C C |  LAB_229E :                    35A0 C |
 LAB_22A0 :                    35AC C |  LAB_22B6 :                    35BA C |
 LAB_22BA :                    35BE C |  LAB_22BD :                    35C8 C |
 LAB_22E6 :                    35E2 C | *LAB_2316 :                    3622 C |
 LAB_2317 :                    3624 C |  LAB_231C :                    3628 C |
 LAB_2358 :                    365C C |  LAB_2368 :                    367C C |
 LAB_2441 :                    3870 C |  LAB_2445 :                    3874 C |
 LAB_2467 :                    38C4 C |  LAB_2468 :                    38C8 C |
 LAB_249C :                    38B6 C |  LAB_24A8 :                    38CC C |
 LAB_24B4 :                    38F6 C |  LAB_24D0 :                    3902 C |
 LAB_24D5 :                    390E C |  LAB_24D6 :                    3928 C |
 LAB_24D7 :                    3936 C |  LAB_24D8 :                    393C C |
 LAB_24D9 :                    391C C |  LAB_24DA :                    3942 C |
 LAB_24F7 :                    38E6 C |  LAB_24F8 :                    38EC C |
 LAB_2778 :                    3BAA C |  LAB_277C :                    3BAC C |
 LAB_279B :                    3BD0 C |  LAB_27BA :                    3BDE C |
 LAB_27C3 :                    3BFA C |  LAB_27C4 :                    3C04 C |
 LAB_27CA :                    3C0A C |  LAB_27CE :                    3C12 C |
 LAB_27D0 :                    3C16 C |  LAB_27DB :                    3C24 C |
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 172 - 11/4/2023 8:40:20


 LAB_27F0 :                    3EE8 C |  LAB_27F1 :                    3EFE C |
 LAB_27F2 :                    3F04 C |  LAB_27F3 :                    3F06 C |
 LAB_27FA :                    3C3C C |  LAB_2828 :                    3C5C C |
*LAB_282E :                    3C62 C |  LAB_282F :                    3C64 C |
 LAB_2831 :                    3C68 C |  LAB_284G :                    3C8C C |
 LAB_284H :                    3C9E C |  LAB_284J :                    3CA0 C |
 LAB_284L :                    3C94 C |  LAB_2887 :                    48AC C |
 LAB_289A :                    48D6 C |  LAB_289C :                    48DC C |
 LAB_289D :                    48E2 C |  LAB_28FD :                    48FE C |
 LAB_28FE :                    4904 C |  LAB_28FF :                    490A C |
 LAB_2900 :                    4918 C |  LAB_2901 :                    491E C |
 LAB_2902 :                    4970 C |  LAB_2903 :                    4978 C |
 LAB_2904 :                    497A C |  LAB_2953 :                    3CC2 C |
 LAB_295E :                    3CCE C |  LAB_2967 :                    3CDA C |
 LAB_2968 :                    3CE2 C |  LAB_2969 :                    3CF4 C |
 LAB_296A :                    3CFE C |  LAB_2970 :                    3D14 C |
 LAB_2978 :                    3D24 C |  LAB_2989 :                    3D34 C |
 LAB_299C :                    3D88 C |  LAB_29A7 :                    3DB0 C |
 LAB_29B7 :                    3DC8 C |  LAB_29B9 :                    3D60 C |
 LAB_29C0 :                    3DD6 C |  LAB_29C3 :                    3DEE C |
 LAB_29D9 :                    3E0A C |  LAB_29E4 :                    3E1C C |
 LAB_29F7 :                    3E30 C |  LAB_29FB :                    3E34 C |
 LAB_29FD :                    3E3C C |  LAB_2A18 :                    3E4C C |
 LAB_2A1A :                    3E4E C |  LAB_2A21 :                    3E56 C |
 LAB_2A3B :                    3E78 C |  LAB_2A4B :                    3E86 C |
 LAB_2A58 :                    3E9A C |  LAB_2A68 :                    3EB2 C |
 LAB_2A74 :                    3EBE C |  LAB_2A89 :                    3EDA C |
 LAB_2A8C :                    3EDE C |  LAB_2A91 :                    3EE4 C |
 LAB_2A9A :                    4F58 C |  LAB_2A9B :                    4F74 C |
 LAB_2X01 :                    4936 C |  LAB_2X02 :                    493E C |
 LAB_2X03 :                    494C C |  LAB_2X04 :                    4952 C |
 LAB_2X05 :                    4968 C |  LAB_2Y01 :                    4988 C |
 LAB_2Y02 :                    4990 C |  LAB_2Y03 :                    499C C |
 LAB_2Y04 :                    49A2 C |  LAB_3216 :                    3B44 C |
 LAB_32_16 :                   3B42 C |  LAB_ABER :                    214C C |
 LAB_ABS :                     3C34 C |  LAB_AD :                      52EB C |
 LAB_ADD :                     3892 C |  LAB_ADER :                    2118 C |
 LAB_AND :                     2ECA C |  LAB_ASC :                     3706 C |
 LAB_ATCD :                    4288 C |  LAB_ATGO :                    4244 C |
 LAB_ATLE :                    4262 C |  LAB_ATN :                     4226 C |
 LAB_ATNP :                    4282 C |  LAB_AYFC :                    32B0 C |
 LAB_BAER :                    5172 C |  LAB_BHCB :                    2EB0 C |
 LAB_BHSS :                    2E8A C |  LAB_BINS :                    4660 C |
 LAB_BITCLR :                  42EA C |  LAB_BITSET :                  42DA C |
 LAB_BMSG :                    54B5 C |  LAB_BS :                      5214 C |
 LAB_BTST :                    42FA C |  LAB_CALL :                    3850 C |
 LAB_CASC :                    2FA0 C |  LAB_CATN :                    428E C |
*LAB_CAUC :                    2FA6 C |  LAB_CBIN :                    4A5C C |
 LAB_CBX1 :                    4A76 C |  LAB_CBXN :                    4A64 C |
 LAB_CCER :                    2130 C |  LAB_CHEX :                    49FA C |
 LAB_CHRS :                    35EC C |  LAB_CHX1 :                    4A20 C |
 LAB_CHX2 :                    4A44 C |  LAB_CHX3 :                    4A3C C |
 LAB_CHXX :                    4A02 C |  LAB_CKRN :                    32D8 C |
 LAB_CKTM :                    2C3A C |  LAB_CLEAR :                   2454 C |
 LAB_CN :                      5281 C |  LAB_COLD :                    2060 C |
 LAB_CONT :                    2640 C |  LAB_CORD :                    41B8 C |
 LAB_COS :                     4148 C |  LAB_CRLF :                    2986 C |
 LAB_CTBL :                    4E3C C |  LAB_CTNM :                    2C38 C |
 LAB_D0 :                      5232 C |  LAB_D002 :                    45C4 C |
 LAB_D00A :                    45D4 C |  LAB_D00E :                    45E4 C |
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 173 - 11/4/2023 8:40:20


 LAB_DATA :                    272E C |  LAB_DD :                      5221 C |
 LAB_DDER :                    2148 C |  LAB_DEC :                     2842 C |
 LAB_DECI :                    28A2 C |  LAB_DEEK :                    37CE C |
 LAB_DEF :                     32E2 C |  LAB_DIM :                     2F52 C |
 LAB_DIV0 :                    3B3C C |  LAB_DIVIDE :                  3AC2 C |
 LAB_DIVX :                    3B12 C |  LAB_DO :                      2672 C |
 LAB_DOKE :                    37F8 C |  LAB_DUPFMT :                  45AC C |
 LAB_DZER :                    2144 C |  LAB_EMSG :                    54BD C |
 LAB_END :                     25DA C |  LAB_EOR :                     2EBA C |
 LAB_EQUAL :                   2EE0 C |  LAB_ESML :                    405E C |
 LAB_EVBY :                    371E C |  LAB_EVEX :                    2C4E C |
 LAB_EVEZ :                    2C50 C |  LAB_EVIN :                    30EC C |
 LAB_EVIR :                    30FC C |  LAB_EVNM :                    2C36 C |
 LAB_EVPI :                    30F4 C |  LAB_EX1 :                     3F96 C |
 LAB_EXAD :                    40E8 C |  LAB_EXCC :                    40CE C |
 LAB_EXCM :                    4000 C |  LAB_EXNN :                    40BA C |
 LAB_EXOF :                    3FBA C |  LAB_EXOL :                    3FD0 C |
 LAB_EXOU :                    3FA6 C |  LAB_EXP :                     3FDA C |
 LAB_EXPL :                    40B4 C |  LAB_EXPS :                    4012 C |
 LAB_EXRN :                    40C0 C |  LAB_EXXF :                    4A4A C |
 LAB_FB95 :                    4712 C |  LAB_FBA0 :                    46F6 C |
 LAB_FC :                      51DB C |  LAB_FCER :                    215C C |
 LAB_FO :                      52F3 C |  LAB_FOER :                    2114 C |
 LAB_FOR :                     250E C |  LAB_FRE :                     329A C |
 LAB_FTBL :                    4ED8 C |  LAB_FTPP :                    4E8C C |
 LAB_FVAR :                    2FBE C |  LAB_GADB :                    3772 C |
 LAB_GADW :                    3786 C |  LAB_GARB :                    3472 C |
 LAB_GBYT :                    2DB0 C |  LAB_GEAD :                    37A6 C |
 LAB_GET :                     2900 C |  LAB_GETS :                    291A C |
 LAB_GFPN :                    2804 C |  LAB_GOSUB :                   2684 C |
 LAB_GOTO :                    2696 C |  LAB_GOTS :                    26A6 C |
 LAB_GSCH :                    2626 C |  LAB_GTBY :                    371A C |
 LAB_GTHAN :                   3F88 C |  LAB_GTWO :                    3730 C |
 LAB_GVAL :                    2D5C C |  LAB_GVAR :                    2FC0 C |
 LAB_HEXS :                    46B2 C |  LAB_ID :                      5241 C |
 LAB_IDER :                    2140 C |  LAB_IF :                      2756 C |
 LAB_IGBY :                    2DAE C |  LAB_IMSG :                    54CE C |
 LAB_INC :                     2848 C |  LAB_INCI :                    2898 C |
 LAB_INCT :                    288A C |  LAB_INLN :                    2292 C |
 LAB_INPUT :                   2A74 C |  LAB_INT :                     3CA6 C |
 LAB_IRTS :                    3CC0 C |  LAB_ISHN :                    4A1C C |
 LAB_KEYT :                    4FDE C |  LAB_LAAD :                    39BC C |
 LAB_LCASE :                   3684 C |  LAB_LD :                      52A3 C |
 LAB_LDER :                    2128 C |  LAB_LEEK :                    37E4 C |
 LAB_LEFT :                    35FC C |  LAB_LENS :                    36FE C |
 LAB_LET :                     28A6 C |  LAB_LIST :                    2458 C |
 LAB_LMSG :                    54C4 C |  LAB_LOAD :                    3848 C |
 LAB_LOCC :                    39C2 C |  LAB_LOCX :                    39DE C |
 LAB_LOG :                     3944 C |  LAB_LOKE :                    37FE C |
 LAB_LOLP :                    39CC C |  LAB_LONE :                    39FA C |
 LAB_LONN :                    39E2 C |  LAB_LOOP :                    26C4 C |
 LAB_LOWZ :                    3A34 C |  LAB_LOXO :                    3A00 C |
 LAB_LOXP :                    39F0 C |  LAB_LRMS :                    2E68 C |
 LAB_LS :                      525E C |  LAB_LSHIFT :                  2F5E C |
 LAB_LTHAN :                   2EEA C |  LAB_LTPF :                    41C8 C |
 LAB_LTPT :                    41D8 C |  LAB_LT_1 :                    3B50 C |
 LAB_MADD :                    3A62 C |  LAB_MAN1 :                    3B36 C |
 LAB_MAX :                     471E C |  LAB_MAXN :                    472A C |
 LAB_MIDS :                    3640 C |  LAB_MIN :                     4734 C |
 LAB_MINN :                    4740 C | *LAB_MKCHR :                   35F0 C |
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 174 - 11/4/2023 8:40:20


 LAB_MMEC :                    474A C |  LAB_MNOC :                    3A5C C |
 LAB_MUEX :                    3AB0 C | *LAB_MUF1 :                    3A8C C |
 LAB_MUF2 :                    3A96 C |  LAB_MUF3 :                    3AAC C |
 LAB_MULTIPLY :                3A36 C |  LAB_MUUF :                    3AB6 C |
 LAB_NB1T :                    3B88 C |  LAB_NEW :                     2402 C |
 LAB_NEXT :                    2B80 C |  LAB_NF :                      51A2 C |
 LAB_NFER :                    216C C |  LAB_NI :                      52FA C |
 LAB_NOST :                    292C C |  LAB_NSTT :                    47B0 C |
 LAB_NULL :                    2636 C |  LAB_OD :                      51CF C |
 LAB_ODER :                    2160 C |  LAB_OFER :                    2158 C |
 LAB_OM :                      51F2 C |  LAB_OMER :                    2154 C |
 LAB_ON :                      27D0 C |  LAB_OPPT :                    4F24 C |
 LAB_OR :                      2EC2 C |  LAB_OV :                      51E9 C |
 LAB_P004 :                    4602 C |  LAB_P008 :                    4618 C |
 LAB_P00C :                    4620 C |  LAB_P00E :                    462C C |
 LAB_P010 :                    4630 C |  LAB_P018 :                    464A C |
 LAB_P01A :                    464E C |  LAB_P01E :                    4656 C |
 LAB_PEEK :                    37BC C |  LAB_PFAC :                    3B92 C |
 LAB_PHFA :                    475A C |  LAB_PI :                      488C C |
 LAB_POKE :                    37C8 C |  LAB_POON :                    3F08 C |
 LAB_POS :                     32CC C |  LAB_POWER :                   3F24 C |
 LAB_POWP :                    3F56 C |  LAB_POZE :                    3F18 C |
 LAB_PPBI :                    2E5E C |  LAB_PPFN :                    2E50 C |
 LAB_PPFS :                    2E42 C |  LAB_PRINT :                   293A C |
 LAB_PRNA :                    29FE C |  LAB_PROCFO :                  45EA C |
 LAB_P_10 :                    4BCE C |  LAB_RAM :                     4882 C |
 LAB_READ :                    2A9A C |  LAB_REDO :                    54DE C |
 LAB_REM :                     27C8 C |  LAB_REMM :                    3B68 C |
 LAB_RESS :                    261A C |  LAB_RESTORE :                 2608 C |
 LAB_RET0 :                    49E8 C |  LAB_RETURN :                  271A C |
 LAB_RG :                      51BA C |  LAB_RGER :                    2164 C |
 LAB_RIGHT :                   3610 C |  LAB_RMSG :                    54F0 C |
 LAB_RND :                     40F4 C |  LAB_RSED :                    4AE6 C |
 LAB_RSHIFT :                  2F6E C |  LAB_RTN0 :                    49EA C |
 LAB_RTST :                    340C C |  LAB_RUN :                     265E C |
 LAB_RUNN :                    266C C |  LAB_SADD :                    36E6 C |
 LAB_SAVE :                    384C C |  LAB_SCCA :                    2DA6 C |
 LAB_SCER :                    2134 C |  LAB_SCGB :                    2DA0 C |
 LAB_SCL0 :                    41AE C |  LAB_SCLN :                    23F0 C |
 LAB_SCZE :                    41A0 C |  LAB_SET1 :                    3B1A C |
 LAB_SGBY :                    3716 C |  LAB_SGN :                     3C22 C |
 LAB_SIN :                     4160 C |  LAB_SLER :                    2138 C |
 LAB_SMSG :                    54FA C |  LAB_SN :                      51B3 C |
 LAB_SNBS :                    2734 C |  LAB_SNER :                    2168 C |
 LAB_SQE1 :                    4834 C |  LAB_SQE2 :                    483A C |
 LAB_SQNA :                    4862 C |  LAB_SQNS :                    484C C |
 LAB_SQR :                     4810 C |  LAB_SSLN :                    23E8 C |
 LAB_ST :                      526E C |  LAB_STOP :                    25E2 C |
 LAB_STRS :                    33C2 C |  LAB_SUBTRACT :                387E C |
 LAB_SVAR :                    2FBC C |  LAB_SVTB :                    47E2 C |
 LAB_SWAP :                    3812 C |  LAB_TAN :                     4126 C |
 LAB_TBSZ :                    47C2 C |  LAB_TM :                      5250 C |
 LAB_TMER :                    213C C |  LAB_TWOPI :                   489C C |
 LAB_U002 :                    4352 C |  LAB_U004 :                    43A8 C |
 LAB_U005 :                    43B8 C |  LAB_U006 :                    43BA C |
 LAB_U008 :                    43CE C |  LAB_U009 :                    43F0 C |
 LAB_U00A :                    43F8 C |  LAB_U00B :                    4402 C |
 LAB_U00C :                    4416 C |  LAB_U00D :                    441A C |
 LAB_U00E :                    442C C |  LAB_U00F :                    4438 C |
 LAB_U010 :                    443C C |  LAB_U014 :                    4442 C |
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 175 - 11/4/2023 8:40:20


 LAB_U018 :                    444A C |  LAB_U01C :                    4460 C |
 LAB_U020 :                    446C C |  LAB_U022 :                    4472 C |
 LAB_U026 :                    4482 C |  LAB_U02A :                    448C C |
 LAB_U02B :                    44A4 C |  LAB_U02C :                    44AA C |
 LAB_U02E :                    44BC C |  LAB_U030 :                    44C0 C |
 LAB_U034 :                    44D6 C |  LAB_U036 :                    44DC C |
 LAB_U038 :                    44E4 C |  LAB_U03C :                    44EC C |
 LAB_U03E :                    44F2 C |  LAB_U040 :                    450A C |
 LAB_U044 :                    451A C |  LAB_U046 :                    4542 C |
 LAB_U048 :                    4544 C |  LAB_U04A :                    454E C |
 LAB_U04C :                    4580 C |  LAB_UA :                      52C6 C |
 LAB_UCASE :                   36B4 C |  LAB_UDER :                    2120 C |
 LAB_UF :                      5290 C |  LAB_UFAC :                    3B76 C |
 LAB_UFER :                    212C C |  LAB_US :                      5200 C |
 LAB_USER :                    2150 C |  LAB_USINGS :                  4328 C |
 LAB_USR :                     3840 C |  LAB_UV :                      52B3 C |
 LAB_UVER :                    2124 C |  LAB_VAL :                     3744 C |
 LAB_VALZ :                    376C C | *LAB_VARCALL :                 4874 C |
 LAB_VARPTR :                  4872 C |  LAB_WAIT :                    385A C |
 LAB_WARM :                     400 C |  LAB_WD :                      52DA C |
 LAB_WDER :                    211C C |  LAB_WDLP :                    47F6 C |
 LAB_WDTH :                    4790 C |  LAB_XDIV :                    3B2A C |
 LAB_XERR :                    216E C |  LAB_XGADW :                   37A0 C |
 LC_LOOP :                     369A C | *LISTON :                         1 - |
 LOOPALWAYS :                  2700 C |  LOOPDONE :                    2714 C |
 LVARPL :                       472 C |  L_DDIV :                      3B70 C |
 L_DIVRND :                    3B1E C | *MACEXP :                         7 - |
 MAINLOOP :                    41F0 C | *MOMCPU :                     68000 - |
*MOMCPUNAME :               "68000" - | *N :                              2 - |
*NESTMAX :                      100 - |  NEXTA :                       4202 C |
 NEXTB1 :                      4670 C |  NEXTB2 :                      4696 C |
 NEXTH1 :                      46C2 C |  NEXTPRN :                     4102 C |
 NINC0 :                       410A C |  NINC1 :                       4110 C |
*NOBRK :                          0 - |  NOCHR :                       2042 C |
 NOLCASE :                     36DC C |  NOSHIFT :                     2F6A C |
 NOSTRING :                    36E2 C |  NOT2BIG :                     2F82 C |
 NOUCASE :                     36AC C | *NOVAR :                          0 - |
 NULLCT :                       5E4 C |  NUMEXP :                       5AC - |
 OFCHR :                        '#' - |  OQUOTE :                       5DD C |
 OUTLOOP :                     4210 C | *PADDING :                        1 - |
 PRG_STRT :                     5EC C |  PRNLWORD :                     5A0 C |
 PRSTK :                        5D8 C |  RAM_ADDR :                    8000 - |
 RAM_BASE :                     400 C |  RAM_SIZE :                    2000 - |
*RAM_STRT :                       0 C |  RDPTRL :                       466 C |
*RELAXED :                        0 - |  RTS_001 :                     2DCC C |
 RTS_005 :                     2452 C |  RTS_006 :                     2634 C |
 RTS_007 :                     2732 C |  RTS_007A :                    2748 C |
*RTS_008 :                     28FE C |  RTS_009 :                     29FA C |
 RTS_011 :                     3274 C |  RTS_012 :                     3544 C |
 RTS_013 :                     35B8 C |  RTS_015 :                     3810 C |
 RTS_016 :                     38EA C |  RTS_017 :                     3C08 C |
 RTS_020 :                     3F94 C |  RTS_021 :                     42D8 C |
 RTS_022 :                     4700 C |  RTS_023 :                     480E C |
 RTS_024 :                     4A5A C |  RTS_025 :                     4ABC C |
 SARRYL :                       43E C |  SFNCL :                        432 C |
 SMEML :                        42E C |  SSTORL :                       446 C |
 SSTRL :                        43A C |  SUBEXIT :                     421A C |
 SUBLOOP :                     41E8 C |  SUFNXF :                       5DF C |
 SUTILL :                       44E C |  SVARL :                        436 C |
 TABSIZ :                       5E2 C |  TAB_ASCA :                    531E C |
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 176 - 11/4/2023 8:40:20


 TAB_ASCB :                    532E C |  TAB_ASCC :                    5347 C |
 TAB_ASCD :                    535E C |  TAB_ASCE :                    5377 C |
 TAB_ASCF :                    5386 C |  TAB_ASCG :                    5390 C |
 TAB_ASCH :                    539D C |  TAB_ASCI :                    53A3 C |
 TAB_ASCL :                    53B2 C |  TAB_ASCM :                    53E0 C |
 TAB_ASCN :                    53EE C |  TAB_ASCO :                    53FD C |
 TAB_ASCP :                    5402 C |  TAB_ASCR :                    5417 C |
 TAB_ASCS :                    5441 C |  TAB_ASCT :                    546C C |
 TAB_ASCU :                    5480 C |  TAB_ASCV :                    5498 C |
 TAB_ASCW :                    54A4 C |  TAB_ATNC :                    4D3C C |
 TAB_CHRT :                    4F74 C |  TAB_EQUL :                    5316 C |
 TAB_HTHET :                   4DBC C |  TAB_LESS :                    5312 C |
 TAB_MNUS :                    530E C |  TAB_MORE :                    5318 C |
 TAB_PLUS :                    530C C |  TAB_POWR :                    54B3 C |
 TAB_QEST :                    531C C |  TAB_SLAS :                    5310 C |
 TAB_SNCO :                    4CBC C |  TAB_STAR :                    530A C |
 TBSC_CS :                     6000 - | *TIME :                   "8:40:20" - |
 TK_ABS :                        C1 - |  TK_AND :                        B7 - |
 TK_ASC :                        D3 - |  TK_ATN :                        CC - |
 TK_BINS :                       D8 - |  TK_BITCLR :                     A7 - |
 TK_BITSET :                     A6 - |  TK_BITTST :                     D9 - |
 TK_CALL :                       9B - |  TK_CHRS :                       D6 - |
 TK_CLEAR :                      A1 - |  TK_CONT :                       9F - |
 TK_COS :                        C9 - |  TK_DATA :                       83 - |
 TK_DEC :                        88 - |  TK_DEEK :                       CE - |
 TK_DEF :                        97 - |  TK_DIM :                        85 - |
 TK_DIV :                        B5 - |  TK_DO :                         9C - |
 TK_DOKE :                       99 - |  TK_ELSE :                       A9 - |
 TK_END :                        80 - |  TK_EOR :                        B8 - |
 TK_EQUAL :                      BD - |  TK_EXP :                        C8 - |
 TK_FN :                         AB - |  TK_FOR :                        81 - |
 TK_FRE :                        C3 - |  TK_GET :                        A4 - |
 TK_GOSUB :                      8D - |  TK_GOTO :                       89 - |
 TK_GT :                         BC - |  TK_HEXS :                       D7 - |
 TK_IF :                         8B - |  TK_INC :                        93 - |
 TK_INPUT :                      84 - |  TK_INT :                        C0 - |
 TK_LCASES :                     D5 - |  TK_LEEK :                       CF - |
 TK_LEFTS :                      E1 - |  TK_LEN :                        D0 - |
 TK_LET :                        87 - |  TK_LIST :                       A0 - |
 TK_LOAD :                       95 - |  TK_LOG :                        C7 - |
 TK_LOKE :                       9A - |  TK_LOOP :                       9D - |
 TK_LSHIFT :                     BB - |  TK_LT :                         BE - |
 TK_MAX :                        DA - |  TK_MIDS :                       E3 - |
 TK_MIN :                        DB - |  TK_MINUS :                      B3 - |
 TK_MULT :                       B4 - |  TK_NEW :                        A2 - |
 TK_NEXT :                       82 - |  TK_NOT :                        AE - |
 TK_NULL :                       92 - |  TK_ON :                         91 - |
 TK_OR :                         B9 - |  TK_PEEK :                       CD - |
 TK_PI :                         DD - |  TK_PLUS :                       B2 - |
 TK_POKE :                       98 - |  TK_POS :                        C4 - |
 TK_POWER :                      B6 - |  TK_PRINT :                      9E - |
 TK_RAM :                        DC - |  TK_READ :                       86 - |
 TK_REM :                        8F - |  TK_RESTORE :                    8C - |
 TK_RETURN :                     8E - |  TK_RIGHTS :                     E2 - |
 TK_RND :                        C6 - |  TK_RSHIFT :                     BA - |
 TK_RUN :                        8A - |  TK_SADD :                       E0 - |
 TK_SAVE :                       96 - |  TK_SGN :                        BF - |
 TK_SIN :                        CA - |  TK_SPC :                        AC - |
 TK_SQR :                        C5 - |  TK_STEP :                       AF - |
 TK_STOP :                       90 - |  TK_STRS :                       D1 - |
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 177 - 11/4/2023 8:40:20


 TK_SWAP :                       A5 - |  TK_TAB :                        A8 - |
 TK_TAN :                        CB - |  TK_THEN :                       AD - |
 TK_TO :                         AA - |  TK_TWOPI :                      DE - |
 TK_UCASES :                     D4 - |  TK_UNTIL :                      B0 - |
 TK_USINGS :                     E4 - |  TK_USR :                        C2 - |
 TK_VAL :                        D2 - |  TK_VPTR :                       DF - |
 TK_WAIT :                       94 - |  TK_WHILE :                      B1 - |
 TK_WIDTH :                      A3 - |  TOOBIG :                      2F88 C |
 TPOS :                         5E5 C |  TPOWER :                       5D9 C |
*TRUE :                           1 - |  TWIDTH :                       5E6 C |
 UC_LOOP :                     36CA C |  USDSS :                        5CC C |
 USRJMP :                       406 C | *USRJPV :                       408 C |
*UT1_PL :                       5A4 C |  VARNAME :                      46A C |
 VEC_CC :                      46DC C |  VEC_IN :                      2026 C |
 VEC_LD :                      2048 C |  VEC_OUT :                     200E C |
 VEC_SV :                      204E C | *VERSION :                     142F - |
 V_CTLC :                       424 C | *V_CTLCV :                      426 C |
 V_INPT :                       40C C | *V_INPTV :                      40E C |
 V_LOAD :                       418 C | *V_LOADV :                      41A C |
 V_OUTP :                       412 C | *V_OUTPV :                      414 C |
 V_SAVE :                       41E C | *V_SAVEV :                      420 C |
 WEXIT :                       47E6 C |  WRMJPV :                       402 C |

   1116 symbols
     47 unused symbols

 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 178 - 11/4/2023 8:40:20


  Code Pages:
  ----------

STANDARD (0 changed characters)

1 code page

0.34 seconds assembly time

   9433 lines source file
      6 passes
      0 errors
      0 warnings
