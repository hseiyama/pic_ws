 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 1 - 12/13/2023 15:59:9


    1/       0 :                        ;************************************************************************************
    2/       0 :                        ;										    										*
    3/       0 :                        ;	Enhanced BASIC for the Motorola MC680xx					    					*
    4/       0 :                        ;										    										*
    5/       0 :                        ;	This version is for the TS2 single board computer.		            			*
    6/       0 :                        ;	Jeff Tranter (tranter@pobox.com)					    						*
    7/       0 :                        ;										    										*
    8/       0 :                        ;************************************************************************************
    9/       0 :                        ;										    										*
   10/       0 :                        ;	Copyright(C) 2002-12 by Lee Davison. This program may be freely distributed 	*
   11/       0 :                        ;	for personal use only. All commercial rights are reserved.		    			*
   12/       0 :                        ;										    										*
   13/       0 :                        ;	More 68000 and other projects can be found on my website at ..		    		*
   14/       0 :                        ;										    										*
   15/       0 :                        ;	 http://mycorner.no-ip.org/index.html					    					*
   16/       0 :                        ;										    										*
   17/       0 :                        ;	mail : leeedavison@googlemail.com					    						*
   18/       0 :                        ;										    										*
   19/       0 :                        ;************************************************************************************
   20/       0 :                        
   21/       0 :                        ; Ver 3.54
   22/       0 :                        
   23/       0 :                        ; Ver 3.54 adds experimental support for LOAD/SAVE using Hobbytronics
   24/       0 :                        ; USB Flash Drive Host Board
   25/       0 :                        ; Ver 3.53 fixes math error that affected exponentiation ("^") and
   26/       0 :                        ;  EXP() function. Thanks to joelang for fix.
   27/       0 :                        ; Ver 3.52 stops USING$() from reading beyond the end of the format string
   28/       0 :                        ; Ver 3.51 fixes the UCASE$() and LCASE$() functions for null strings
   29/       0 :                        ; Ver 3.50 unary minus in concatenate generates a type mismatch error
   30/       0 :                        ; Ver 3.49 doesn't tokenise 'DEF' or 'DEC' within a hex value
   31/       0 :                        ; Ver 3.48 allows scientific notation underflow in the USING$() function
   32/       0 :                        ; Ver 3.47 traps the use of array elements as the FOR loop variable
   33/       0 :                        ; Ver 3.46 updates function and function variable handling
   34/       0 :                        
   35/       0 :                        ;************************************************************************************
   36/       0 :                        ;
   37/       0 :                        ; Ver 3.45 makes the handling of non existant variables consistent and gives the
   38/       0 :                        ; option of not returning an error for a non existant variable. If this is the
   39/       0 :                        ; behaviour you want just change novar to some non zero value
   40/       0 :                        
   41/       0 : =$0                    novar		EQU	0					; non existant variables cause errors
   42/       0 :                        
   43/       0 :                        ; Set the symbol FLASH_SUPPORT to 1 if you want to enable experimental
   44/       0 :                        ; support for LOAD/SAVE using a Hobbytronics USB Flash Drive Host
   45/       0 :                        ; Board.
   46/       0 :                        
   47/       0 : =$0                    FLASH_SUPPORT   EQU     0
   48/       0 :                        
   49/       0 :                        ;************************************************************************************
   50/       0 :                        
   51/       0 :                        ; Ver 3.44 adds overflow indication to the USING$() function
   52/       0 :                        ; Ver 3.43 removes an undocumented feature of concatenating null strings
   53/       0 :                        ; Ver 3.42 reimplements backspace so that characters are overwritten with [SPACE]
   54/       0 :                        ; Ver 3.41 removes undocumented features of the USING$() function
   55/       0 :                        ; Ver 3.40 adds the USING$() function
   56/       0 :                        ; Ver 3.33 adds the file requester to LOAD and SAVE
   57/       0 :                        ; Ver 3.32 adds the optional ELSE clause to IF .. THEN
   58/       0 :                        
   59/       0 :                        ;************************************************************************************
   60/       0 :                        ;
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 2 - 12/13/2023 15:59:9


   61/       0 :                        ; Version 3.25 adds the option to change the behaviour of INPUT so that a null
   62/       0 :                        ; response does not cause a program break. If this is the behaviour you want just
   63/       0 :                        ; change nobrk to some non zero value.
   64/       0 :                        
   65/       0 : =$0                    nobrk		EQU	0					; null response to INPUT causes a break
   66/       0 :                        
   67/       0 :                        
   68/       0 :                        ;************************************************************************************
   69/       0 :                        ;
   70/       0 :                        ; Version 3.xx replaces the fixed RAM addressing from previous versions with a RAM
   71/       0 :                        ; pointer in a3. this means that this could now be run as a task on a multitasking
   72/       0 :                        ; system where memory resources may change.
   73/       0 :                        
   74/       0 :                        
   75/       0 :                        ;************************************************************************************
   76/       0 :                        
   77/       0 :                        
   78/       0 :                        	CPU	68000
   79/       0 :                        	SUPMODE	ON
   80/       0 :                        
   81/       0 : =$3000                 EBSC_CS	EQU	$00003000	; Enhanced BASIC cold start
   82/       0 : =$6600                 TBSC_CS	EQU	$00006600	; Tiny BASIC cold start
   83/       0 :                        
   84/       0 :                        ;	ORG	$00000000
   85/       0 :                        ;
   86/       0 :                        ;INIVEC:
   87/       0 :                        ;	;; 0-7
   88/       0 :                        ;	DC.L	ram_addr+ram_base	; Reset: Initial SSP
   89/       0 :                        ;	DC.L	code_start			; Reset: Initial PC
   90/       0 :                        
   91/       0 :                        
   92/       0 :                        	INCLUDE	"basic68k.inc"
(1)    1/       0 :                     
(1)    2/       0 :                     ; This lot is in RAM
(1)    3/       0 :                     
(1)    4/       0 :                         		ORG     $0000			; start of RAM
(1)    5/       0 :                      
(1)    6/       0 :                     ram_strt	ds.l	$100		; allow 1K for the stack, this should be plenty
(1)    7/     400 :                     								; for any BASIC program that doesn't do something
(1)    8/     400 :                     								; silly, it could even be much less.
(1)    9/     400 :                     ram_base
(1)   10/     400 :                     LAB_WARM	ds.w	1			; BASIC warm start entry point
(1)   11/     402 :                     Wrmjpv		ds.l	1			; BASIC warm start jump vector
(1)   12/     406 :                     
(1)   13/     406 :                     Usrjmp		ds.w	1			; USR function JMP address
(1)   14/     408 :                     Usrjpv		ds.l	1			; USR function JMP vector
(1)   15/     40C :                     
(1)   16/     40C :                     ; system dependant i/o vectors
(1)   17/     40C :                     ; these are in RAM and are set at start-up
(1)   18/     40C :                     
(1)   19/     40C :                     V_INPT		ds.w	1			; non halting scan input device entry point
(1)   20/     40E :                     V_INPTv		ds.l	1			; non halting scan input device jump vector
(1)   21/     412 :                     
(1)   22/     412 :                     V_OUTP		ds.w	1			; send byte to output device entry point
(1)   23/     414 :                     V_OUTPv		ds.l	1			; send byte to output device jump vector
(1)   24/     418 :                     
(1)   25/     418 :                     V_LOAD		ds.w	1			; load BASIC program entry point
(1)   26/     41A :                     V_LOADv		ds.l	1			; load BASIC program jump vector
(1)   27/     41E :                     
(1)   28/     41E :                     V_SAVE		ds.w	1			; save BASIC program entry point
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm(basic68k.inc) - Page 3 - 12/13/2023 15:59:9


(1)   29/     420 :                     V_SAVEv		ds.l	1			; save BASIC program jump vector
(1)   30/     424 :                     
(1)   31/     424 :                     V_CTLC		ds.w	1			; save CTRL-C check entry point
(1)   32/     426 :                     V_CTLCv		ds.l	1			; save CTRL-C check jump vector
(1)   33/     42A :                     
(1)   34/     42A :                     Itemp		ds.l	1			; temporary integer	(for GOTO etc)
(1)   35/     42E :                     
(1)   36/     42E :                     Smeml		ds.l	1			; start of memory		(start of program)
(1)   37/     432 :                     
(1)   38/     432 :                     ; the program is stored as a series of lines each line having the following format
(1)   39/     432 :                     ;
(1)   40/     432 :                     ;		ds.l	1			; pointer to the next line or $00000000 if [EOT]
(1)   41/     432 :                     ;		ds.l	1			; line number
(1)   42/     432 :                     ;		ds.b	n			; program bytes
(1)   43/     432 :                     ;		dc.b	$00			; [EOL] marker, there will be a second $00 byte, if
(1)   44/     432 :                     ;						; needed, to pad the line to an even number of bytes
(1)   45/     432 :                     
(1)   46/     432 :                     Sfncl		ds.l	1			; start of functions	(end of Program)
(1)   47/     436 :                     
(1)   48/     436 :                     ; the functions are stored as function name, function execute pointer and function
(1)   49/     436 :                     ; variable name
(1)   50/     436 :                     ;
(1)   51/     436 :                     ;		ds.l	1			; name
(1)   52/     436 :                     ;		ds.l	1			; execute pointer
(1)   53/     436 :                     ;		ds.l	1			; function variable
(1)   54/     436 :                     
(1)   55/     436 :                     Svarl		ds.l	1			; start of variables	(end of functions)
(1)   56/     43A :                     
(1)   57/     43A :                     ; the variables are stored as variable name, variable value
(1)   58/     43A :                     ;
(1)   59/     43A :                     ;		ds.l	1			; name
(1)   60/     43A :                     ;		ds.l	1			; packed float or integer value
(1)   61/     43A :                     
(1)   62/     43A :                     Sstrl		ds.l	1			; start of strings	(end of variables)
(1)   63/     43E :                     
(1)   64/     43E :                     ; the strings are stored as string name, string pointer and string length
(1)   65/     43E :                     ;
(1)   66/     43E :                     ;		ds.l	1			; name
(1)   67/     43E :                     ;		ds.l	1			; string pointer
(1)   68/     43E :                     ;		ds.w	1			; string length
(1)   69/     43E :                     
(1)   70/     43E :                     Sarryl		ds.l	1			; start of arrays		(end of strings)
(1)   71/     442 :                     
(1)   72/     442 :                     ; the arrays are stored as array name, array size, array dimensions count, array
(1)   73/     442 :                     ; dimensions upper bounds and array elements
(1)   74/     442 :                     ;
(1)   75/     442 :                     ;		ds.l	1			; name
(1)   76/     442 :                     ;		ds.l	1			; size including this header
(1)   77/     442 :                     ;		ds.w	1			; dimensions count
(1)   78/     442 :                     ;		ds.w	1			; 1st dimension upper bound
(1)   79/     442 :                     ;		ds.w	1			; 2nd dimension upper bound
(1)   80/     442 :                     ;		...				; ...
(1)   81/     442 :                     ;		ds.w	1			; nth dimension upper bound
(1)   82/     442 :                     ;
(1)   83/     442 :                     ; then (i1+1)*(i2+1)...*(in+1) of either ..
(1)   84/     442 :                     ;
(1)   85/     442 :                     ;		ds.l	1			; packed float or integer value
(1)   86/     442 :                     ;
(1)   87/     442 :                     ; .. if float or integer, or ..
(1)   88/     442 :                     ;
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm(basic68k.inc) - Page 4 - 12/13/2023 15:59:9


(1)   89/     442 :                     ;		ds.l	1			; string pointer
(1)   90/     442 :                     ;		ds.w	1			; string length
(1)   91/     442 :                     ;
(1)   92/     442 :                     ; .. if string
(1)   93/     442 :                     
(1)   94/     442 :                     Earryl		ds.l	1			; end of arrays		(start of free mem)
(1)   95/     446 :                     Sstorl		ds.l	1			; string storage		(moving down)
(1)   96/     44A :                     Ememl		ds.l	1			; end of memory		(upper bound of RAM)
(1)   97/     44E :                     Sutill		ds.l	1			; string utility ptr
(1)   98/     452 :                     Clinel		ds.l	1			; current line		(Basic line number)
(1)   99/     456 :                     Blinel		ds.l	1			; break line		(Basic line number)
(1)  100/     45A :                     
(1)  101/     45A :                     Cpntrl		ds.l	1			; continue pointer
(1)  102/     45E :                     Dlinel		ds.l	1			; current DATA line
(1)  103/     462 :                     Dptrl		ds.l	1			; DATA pointer
(1)  104/     466 :                     Rdptrl		ds.l	1			; read pointer
(1)  105/     46A :                     Varname		ds.l	1			; current var name
(1)  106/     46E :                     Cvaral		ds.l	1			; current var address
(1)  107/     472 :                     Lvarpl		ds.l	1			; variable pointer for LET and FOR/NEXT
(1)  108/     476 :                     
(1)  109/     476 :                     des_sk_e	ds.l	6			; descriptor stack end address
(1)  110/     48E :                     des_sk							; descriptor stack start address
(1)  111/     48E :                     								; use a4 for the descriptor pointer
(1)  112/     48E :                     			ds.w	1			
(1)  113/     490 :                     Ibuffs		ds.l	$40			; start of input buffer
(1)  114/     590 :                     Ibuffe
(1)  115/     590 :                     								; end of input buffer
(1)  116/     590 :                     
(1)  117/     590 :                     FAC1_m		ds.l	1			; FAC1 mantissa1
(1)  118/     594 :                     FAC1_e		ds.w	1			; FAC1 exponent
(1)  119/     596 : =$595               FAC1_s		EQU	FAC1_e+1		; FAC1 sign (b7)
(1)  120/     596 :                     			ds.w	1			
(1)  121/     598 :                     
(1)  122/     598 :                     FAC2_m		ds.l	1			; FAC2 mantissa1
(1)  123/     59C :                     FAC2_e		ds.l	1			; FAC2 exponent
(1)  124/     5A0 : =$59D               FAC2_s		EQU	FAC2_e+1		; FAC2 sign (b7)
(1)  125/     5A0 : =$59E               FAC_sc		EQU	FAC2_e+2		; FAC sign comparison, Acc#1 vs #2
(1)  126/     5A0 : =$59F               flag		EQU	FAC2_e+3		; flag byte for divide routine
(1)  127/     5A0 :                     
(1)  128/     5A0 :                     PRNlword	ds.l	1			; PRNG seed long word
(1)  129/     5A4 :                     
(1)  130/     5A4 :                     ut1_pl		ds.l	1			; utility pointer 1
(1)  131/     5A8 :                     
(1)  132/     5A8 :                     Asptl		ds.l	1			; array size/pointer
(1)  133/     5AC :                     Astrtl		ds.l	1			; array start pointer
(1)  134/     5B0 :                     
(1)  135/     5B0 : =$5AC               numexp		EQU	Astrtl			; string to float number exponent count
(1)  136/     5B0 : =$5AD               expcnt		EQU	Astrtl+1		; string to float exponent count
(1)  137/     5B0 :                     
(1)  138/     5B0 : =$5AF               expneg		EQU	Astrtl+3		; string to float eval exponent -ve flag
(1)  139/     5B0 :                     
(1)  140/     5B0 :                     func_l		ds.l	1			; function pointer
(1)  141/     5B4 :                     
(1)  142/     5B4 :                     
(1)  143/     5B4 :                     								; these two need to be a word aligned pair !
(1)  144/     5B4 :                     Defdim		ds.w	1			; default DIM flag
(1)  145/     5B6 : =$5B4               cosout		EQU	Defdim			; flag which CORDIC output (re-use byte)
(1)  146/     5B6 : =$5B5               Dtypef		EQU	Defdim+1		; data type flag, $80=string, $40=integer, $00=float
(1)  147/     5B6 :                     
(1)  148/     5B6 :                     
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm(basic68k.inc) - Page 5 - 12/13/2023 15:59:9


(1)  149/     5B6 :                     Binss		ds.l	4			; number to bin string start (32 chrs)
(1)  150/     5C6 :                     
(1)  151/     5C6 :                     Decss		ds.l	1			; number to decimal string start (16 chrs)
(1)  152/     5CA :                     			ds.w	1
(1)  153/     5CC :                     Usdss		ds.w	1			; unsigned decimal string start (10 chrs)
(1)  154/     5CE :                     
(1)  155/     5CE :                     Hexss		ds.l	2			; number to hex string start (8 chrs)
(1)  156/     5D6 :                     
(1)  157/     5D6 :                     BHsend		ds.w	1			; bin/decimal/hex string end
(1)  158/     5D8 :                     
(1)  159/     5D8 :                     
(1)  160/     5D8 :                     prstk		ds.b	1			; stacked function index
(1)  161/     5D9 :                     
(1)  162/     5D9 :                     tpower		ds.b	1			; remember CORDIC power
(1)  163/     5DA :                     
(1)  164/     5DA :                     Asrch		ds.b	1			; scan-between-quotes flag, alt search character
(1)  165/     5DB :                     
(1)  166/     5DB :                     Dimcnt		ds.b	1			; # of dimensions
(1)  167/     5DC :                     
(1)  168/     5DC :                     Breakf		ds.b	1			; break flag, $00=END else=break
(1)  169/     5DD :                     Oquote		ds.b	1			; open quote flag (Flag: DATA; LIST; memory)
(1)  170/     5DE :                     Gclctd		ds.b	1			; garbage collected flag
(1)  171/     5DF :                     Sufnxf		ds.b	1			; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
(1)  172/     5E0 :                     Imode		ds.b	1			; input mode flag, $00=INPUT, $98=READ
(1)  173/     5E1 :                     
(1)  174/     5E1 :                     Cflag		ds.b	1			; comparison evaluation flag
(1)  175/     5E2 :                     
(1)  176/     5E2 :                     TabSiz		ds.b	1			; TAB step size
(1)  177/     5E3 :                     
(1)  178/     5E3 :                     comp_f		ds.b	1			; compare function flag, bits 0,1 and 2 used
(1)  179/     5E4 :                     								; bit 2 set if >
(1)  180/     5E4 :                     								; bit 1 set if =
(1)  181/     5E4 :                     								; bit 0 set if <
(1)  182/     5E4 :                     
(1)  183/     5E4 :                     Nullct		ds.b	1			; nulls output after each line
(1)  184/     5E5 :                     TPos		ds.b	1			; BASIC terminal position byte
(1)  185/     5E6 :                     TWidth		ds.b	1			; BASIC terminal width byte
(1)  186/     5E7 :                     Iclim		ds.b	1			; input column limit
(1)  187/     5E8 :                     ccflag		ds.b	1			; CTRL-C check flag
(1)  188/     5E9 :                     ccbyte		ds.b	1			; CTRL-C last received byte
(1)  189/     5EA :                     ccnull		ds.b	1			; CTRL-C last received byte 'life' timer
(1)  190/     5EB :                     
(1)  191/     5EB :                     	ALIGN	2
(1)  192/     5EC :                     
(1)  193/     5EC :                     ; these variables for load/save routines
(1)  194/     5EC :                     
(1)  195/     5EC :                     ; ifne   FLASH_SUPPORT
(1)  196/     5EC :                     ;
(1)  197/     5EC :                     ;load_first      ds.b    1               ; Boolean indicating if first byte read
(1)  198/     5EC :                     ;load_filename   ds.b    13              ; Hold LOAD/SAVE filename (DOS 8.3 format plus terminating null)
(1)  199/     5EC :                     ;
(1)  200/     5EC :                     ; endc
(1)  201/     5EC :                     ;
(1)  202/     5EC :                     ;		even			; dummy even value and zero pad byte
(1)  203/     5EC :                     
(1)  204/     5EC :                     prg_strt
(1)  205/     5EC :                     
(1)  206/     5EC :                     ; Use these two lines when running from ROM
(1)  207/     5EC : =$8000              ram_addr	EQU	$08000		; RAM start address
(1)  208/     5EC : =$2000              ram_size	EQU	$02000		; RAM size
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm(basic68k.inc) - Page 6 - 12/13/2023 15:59:9


(1)  209/     5EC :                     
(1)  210/     5EC :                     ; Use these two lines when running from RAM
(1)  211/     5EC :                     ;ram_addr	EQU	$04000		; RAM start address
(1)  212/     5EC :                     ;ram_size	EQU	$04000		; RAM size
(1)  213/     5EC :                     
   93/     5EC :                        								; RAM offset definitions
   94/     5EC :                        
   95/     5EC :                        ; Use this value to run out of ROM
   96/     5EC :                        ;	ORG		$00C000				; past the vectors in a real system
   97/     5EC :                        ; Use this value to run out of RAM
   98/    3000 :                        	ORG		EBSC_CS				; past the vectors in a real system
   99/    3000 :                        
  100/    3000 : 2E7C 0000 8400         	MOVE.L	#(ram_addr+ram_base),A7	; Reset: Initial SSP
  101/    3006 : 207C 0000 3054         	MOVE.L	#code_start,A0		; Reset: Initial PC
  102/    300C : 4ED0                   	JMP	(A0)
  103/    300E :                        
  104/    300E : =$E001                 ACIAC:	EQU	$0000E001
  105/    300E : =$E000                 ACIAD:	EQU	$0000E000
  106/    300E :                        
  107/    300E :                        ;************************************************************************************
  108/    300E :                        ;
  109/    300E :                        ; the following code is simulator specific, change to suit your system
  110/    300E :                        ; Output character to the console from register d0.b
  111/    300E :                        
  112/    300E :                        VEC_OUT
  113/    300E : 4840                   	SWAP	D0
  114/    3010 :                        CO0:
  115/    3010 : 1039 0000 E001         	MOVE.B	ACIAC,D0
  116/    3016 : C03C 0002              	AND.B	#$02,D0
  117/    301A : 67F4                   	BEQ	CO0
  118/    301C : 4840                   	SWAP	D0
  119/    301E : 13C0 0000 E000         	MOVE.B	D0,ACIAD
  120/    3024 : 4E75                   	RTS
  121/    3026 :                        
  122/    3026 :                        ;************************************************************************************
  123/    3026 :                        ;
  124/    3026 :                        ; input a character from the console into register d0
  125/    3026 :                        ; else return Cb=0 if there's no character available
  126/    3026 :                        
  127/    3026 :                        VEC_IN
  128/    3026 : 1039 0000 E001         	MOVE.B	ACIAC,D0
  129/    302C : C03C 0001              	AND.B	#$01,D0
  130/    3030 : 6710                   	BEQ     NOCHR
  131/    3032 : 1039 0000 E000         	MOVE.B	ACIAD,D0
  132/    3038 : 0000 0000              	ORI.b	#$00,d0		; set z flag on received byte
  133/    303C : 003C 0001              	ORI.b	#1,CCR		; set carry, flag we got a byte
  134/    3040 : 4E75                   	RTS
  135/    3042 :                        NOCHR
  136/    3042 : 0000 0000              	ORI.b   #$00,d0
  137/    3046 : 4E75                   	RTS
  138/    3048 :                        
  139/    3048 :                        ;************************************************************************************
  140/    3048 :                        ;
  141/    3048 :                        ; LOAD routine for the TS2 computer (not implemented)
  142/    3048 :                        
  143/    3048 :                        VEC_LD
  144/    3048 : 7E2E                          MOVEQ           #$2E,d7                        ; error code $2E "Not implemented" error
  145/    304A : 6000 0122                     BRA             LAB_XERR                       ; do error #d7, then warm start
  146/    304E :                        
  147/    304E :                        ;************************************************************************************
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 7 - 12/13/2023 15:59:9


  148/    304E :                        ;
  149/    304E :                        ; SAVE routine for the TS2 computer (not implemented)
  150/    304E :                        
  151/    304E :                        VEC_SV
  152/    304E : 7E2E                          MOVEQ           #$2E,d7                        ; error code $2E "Not implemented" error
  153/    3050 : 6000 011C                     BRA             LAB_XERR                       ; do error #d7, then warm start
  154/    3054 :                        
  155/    3054 :                        
  156/    3054 :                        ;************************************************************************************
  157/    3054 :                        
  158/    3054 :                        code_start
  159/    3054 :                        ;                               ; Set up ACIA parameters
  160/    3054 :                        ;        LEA.L   ACIA_1,A0      ; A0 points to console ACIA
  161/    3054 :                        ;        MOVE.B  #$15,(A0)      ; Set up ACIA1 constants (no IRQ,
  162/    3054 :                        ;                               ; RTS* low, 8 bit, no parity, 1 stop)
  163/    3054 :                        ;        LEA.L   ACIA_2,A0      ; A0 points to aux. ACIA
  164/    3054 :                        ;        MOVE.B  #$15,(A0)      ; Set up ACIA2 constants (no IRQ,
  165/    3054 :                        ;                               ; RTS* low, 8 bit, no parity, 1 stop)
  166/    3054 :                        
  167/    3054 :                        ; to tell EhBASIC where and how much RAM it has pass the address in a0 and the size
  168/    3054 :                        ; in d0. these values are at the end of the .inc file
  169/    3054 :                        
  170/    3054 : 207C 0000 8000         	MOVEA.l	#ram_addr,a0			; tell BASIC where RAM starts
  171/    305A : 203C 0000 2000         	MOVE.l	#ram_size,d0			; tell BASIC how big RAM is
  172/    3060 :                        
  173/    3060 :                        ; end of simulator specific code
  174/    3060 :                        
  175/    3060 :                        
  176/    3060 :                        ;************************************************************************************
  177/    3060 :                        ;************************************************************************************
  178/    3060 :                        ;************************************************************************************
  179/    3060 :                        ;************************************************************************************
  180/    3060 :                        ;
  181/    3060 :                        ; Register use :- (must improve this !!)
  182/    3060 :                        ;
  183/    3060 :                        ;	a6 -	temp Bpntr					; temporary BASIC execute pointer
  184/    3060 :                        ;	a5 -	Bpntr						; BASIC execute (get byte) pointer
  185/    3060 :                        ;	a4 -	des_sk				       ; descriptor stack pointer
  186/    3060 :                        ;	a3 -	ram_strt					; start of RAM. all RAM references are offsets
  187/    3060 :                        ;								; from this value
  188/    3060 :                        ;
  189/    3060 :                        
  190/    3060 :                        ;************************************************************************************
  191/    3060 :                        ;
  192/    3060 :                        ; BASIC cold start entry point. assume entry with RAM address in a0 and RAM length
  193/    3060 :                        ; in d0
  194/    3060 :                        
  195/    3060 :                        LAB_COLD
  196/    3060 :                        ;	CMP.l		#$4000,d0			; compare size with 16k
  197/    3060 :                        ;	BGE.s		LAB_sizok			; branch if >= 16k
  198/    3060 :                        ;
  199/    3060 :                        ;	MOVEQ	#5,d0					; error 5 - not enough RAM
  200/    3060 :                        ;	move.b	#228,D7					; Go to TUTOR function
  201/    3060 :                        ;	trap	#14						; Call TRAP14 handler
  202/    3060 :                        ;
  203/    3060 :                        ;LAB_sizok
  204/    3060 : 2648                   	MOVEA.l	a0,a3					; copy RAM base to a3
  205/    3062 : D1C0                   	ADDA.l	d0,a0					; a0 is top of RAM
  206/    3064 : 2748 044A              	MOVE.l	a0,Ememl(a3)			; set end of mem
  207/    3068 : 2E7C 0000 8400         	MOVE.l	#ram_addr+ram_base,sp	; set stack to RAM start + 1k
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 8 - 12/13/2023 15:59:9


  208/    306E :                        
  209/    306E : 303C 4EF9              	MOVE.w	#$4EF9,d0				; JMP opcode
  210/    3072 : 204F                   	MOVEA.l	sp,a0					; point to start of vector table
  211/    3074 :                        
  212/    3074 : 30C0                   	MOVE.w	d0,(a0)+				; LAB_WARM
  213/    3076 : 43FA FFE8              	LEA		LAB_COLD(pc),a1			; initial warm start vector
  214/    307A : 20C9                   	MOVE.l	a1,(a0)+				; set vector
  215/    307C :                        
  216/    307C : 30C0                   	MOVE.w	d0,(a0)+				; Usrjmp
  217/    307E : 43FA 00DC              	LEA		LAB_FCER(pc),a1			; initial user function vector
  218/    3082 :                        									; "Function call" error
  219/    3082 : 20C9                   	MOVE.l	a1,(a0)+				; set vector
  220/    3084 :                        
  221/    3084 : 30C0                   	MOVE.w	d0,(a0)+				; V_INPT JMP opcode
  222/    3086 : 43FA FF9E              	LEA		VEC_IN(pc),a1			; get byte from input device vector
  223/    308A : 20C9                   	MOVE.l	a1,(a0)+				; set vector
  224/    308C :                        
  225/    308C : 30C0                   	MOVE.w	d0,(a0)+				; V_OUTP JMP opcode
  226/    308E : 43FA FF7E              	LEA		VEC_OUT(pc),a1			; send byte to output device vector
  227/    3092 : 20C9                   	MOVE.l	a1,(a0)+				; set vector
  228/    3094 :                        
  229/    3094 : 30C0                   	MOVE.w	d0,(a0)+				; V_LOAD JMP opcode
  230/    3096 : 43FA FFB0              	LEA		VEC_LD(pc),a1			; load BASIC program vector
  231/    309A : 20C9                   	MOVE.l	a1,(a0)+				; set vector
  232/    309C :                        
  233/    309C : 30C0                   	MOVE.w	d0,(a0)+				; V_SAVE JMP opcode
  234/    309E : 43FA FFAE              	LEA		VEC_SV(pc),a1			; save BASIC program vector
  235/    30A2 : 20C9                   	MOVE.l	a1,(a0)+				; set vector
  236/    30A4 :                        
  237/    30A4 : 30C0                   	MOVE.w	d0,(a0)+				; V_CTLC JMP opcode
  238/    30A6 : 43FA 2634              	LEA		VEC_CC(pc),a1			; save CTRL-C check vector
  239/    30AA : 20C9                   	MOVE.l	a1,(a0)+				; set vector
  240/    30AC :                        
  241/    30AC :                        ; set-up start values
  242/    30AC :                        
  243/    30AC :                        ;##LAB_GMEM
  244/    30AC : 7000                   	MOVEQ	#$00,d0					; clear d0
  245/    30AE : 1740 05E4              	MOVE.b	d0,Nullct(a3)			; default NULL count
  246/    30B2 : 1740 05E5              	MOVE.b	d0,TPos(a3)				; clear terminal position
  247/    30B6 : 1740 05E8              	MOVE.b	d0,ccflag(a3)			; allow CTRL-C check
  248/    30BA : 3740 05EA              	MOVE.w	d0,prg_strt-2(a3)			; clear start word
  249/    30BE : 3740 05D6              	MOVE.w	d0,BHsend(a3)			; clear value to string end word
  250/    30C2 :                        
  251/    30C2 : 177C 0050 05E6         	MOVE.b	#$50,TWidth(a3)			; default terminal width byte for simulator
  252/    30C8 : 177C 000E 05E2         	MOVE.b	#$0E,TabSiz(a3)			; save default tab size = 14
  253/    30CE :                        
  254/    30CE : 177C 0038 05E7         	MOVE.b	#$38,Iclim(a3)			; default limit for TAB = 14 for simulator
  255/    30D4 :                        
  256/    30D4 : 49EB 048E              	LEA		des_sk(a3),a4			; set descriptor stack start
  257/    30D8 :                        
  258/    30D8 : 41EB 05EC              	LEA		prg_strt(a3),a0			; get start of mem
  259/    30DC : 2748 042E              	MOVE.l	a0,Smeml(a3)			; save start of mem
  260/    30E0 :                        
  261/    30E0 : 6100 0322              	BSR		LAB_1463				; do "NEW" and "CLEAR"
  262/    30E4 : 6100 08A0              	BSR		LAB_CRLF				; print CR/LF
  263/    30E8 : 202B 044A              	MOVE.l	Ememl(a3),d0			; get end of mem
  264/    30EC : 90AB 042E              	SUB.l		Smeml(a3),d0			; subtract start of mem
  265/    30F0 :                        
  266/    30F0 : 6100 1BDC              	BSR		LAB_295E				; print d0 as unsigned integer (bytes free)
  267/    30F4 : 41FA 3404              	LEA		LAB_SMSG(pc),a0			; point to start message
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 9 - 12/13/2023 15:59:9


  268/    30F8 : 6100 08EA              	BSR		LAB_18C3				; print null terminated string from memory
  269/    30FC :                        
  270/    30FC : 41FA 29E8              	LEA		LAB_RSED(pc),a0			; get pointer to value
  271/    3100 : 6100 1A74              	BSR		LAB_UFAC				; unpack memory (a0) into FAC1
  272/    3104 :                        
  273/    3104 : 41FA 0092              	LEA		LAB_1274(pc),a0			; get warm start vector
  274/    3108 : 2748 0402              	MOVE.l	a0,Wrmjpv(a3)			; set warm start vector
  275/    310C : 6100 1FE6              	BSR		LAB_RND					; initialise
  276/    3110 : 4EEB 0400              	JMP		LAB_WARM(a3)			; go do warm start
  277/    3114 :                        
  278/    3114 :                        
  279/    3114 :                        ;************************************************************************************
  280/    3114 :                        ;
  281/    3114 :                        ; do format error
  282/    3114 :                        
  283/    3114 :                        LAB_FOER
  284/    3114 : 7E2C                   	MOVEQ		#$2C,d7				; error code $2C "Format" error
  285/    3116 : 6056                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  286/    3118 :                        
  287/    3118 :                        
  288/    3118 :                        ;************************************************************************************
  289/    3118 :                        ;
  290/    3118 :                        ; do address error
  291/    3118 :                        
  292/    3118 :                        LAB_ADER
  293/    3118 : 7E2A                   	MOVEQ		#$2A,d7				; error code $2A "Address" error
  294/    311A : 6052                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  295/    311C :                        
  296/    311C :                        
  297/    311C :                        ;************************************************************************************
  298/    311C :                        ;
  299/    311C :                        ; do wrong dimensions error
  300/    311C :                        
  301/    311C :                        LAB_WDER
  302/    311C : 7E28                   	MOVEQ		#$28,d7				; error code $28 "Wrong dimensions" error
  303/    311E : 604E                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  304/    3120 :                        
  305/    3120 :                        
  306/    3120 :                        ;************************************************************************************
  307/    3120 :                        ;
  308/    3120 :                        ; do undimensioned array error
  309/    3120 :                        
  310/    3120 :                        LAB_UDER
  311/    3120 : 7E26                   	MOVEQ		#$26,d7				; error code $26 "undimensioned array" error
  312/    3122 : 604A                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  313/    3124 :                        
  314/    3124 :                        
  315/    3124 :                        ;************************************************************************************
  316/    3124 :                        ;
  317/    3124 :                        ; do undefined variable error
  318/    3124 :                        
  319/    3124 :                        LAB_UVER
  320/    3124 :                        
  321/    3124 : 7E24                   	MOVEQ		#$24,d7				; error code $24 "undefined variable" error
  322/    3126 : 6046                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  323/    3128 :                        
  324/    3128 :                        
  325/    3128 :                        ;************************************************************************************
  326/    3128 :                        ;
  327/    3128 :                        ; do loop without do error
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 10 - 12/13/2023 15:59:9


  328/    3128 :                        
  329/    3128 :                        LAB_LDER
  330/    3128 : 7E22                   	MOVEQ		#$22,d7				; error code $22 "LOOP without DO" error
  331/    312A : 6042                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  332/    312C :                        
  333/    312C :                        
  334/    312C :                        ;************************************************************************************
  335/    312C :                        ;
  336/    312C :                        ; do undefined function error
  337/    312C :                        
  338/    312C :                        LAB_UFER
  339/    312C : 7E20                   	MOVEQ		#$20,d7				; error code $20 "Undefined function" error
  340/    312E : 603E                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  341/    3130 :                        
  342/    3130 :                        
  343/    3130 :                        ;************************************************************************************
  344/    3130 :                        ;
  345/    3130 :                        ; do can't continue error
  346/    3130 :                        
  347/    3130 :                        LAB_CCER
  348/    3130 : 7E1E                   	MOVEQ		#$1E,d7				; error code $1E "Can't continue" error
  349/    3132 : 603A                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  350/    3134 :                        
  351/    3134 :                        
  352/    3134 :                        ;************************************************************************************
  353/    3134 :                        ;
  354/    3134 :                        ; do string too complex error
  355/    3134 :                        
  356/    3134 :                        LAB_SCER
  357/    3134 : 7E1C                   	MOVEQ		#$1C,d7				; error code $1C "String too complex" error
  358/    3136 : 6036                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  359/    3138 :                        
  360/    3138 :                        
  361/    3138 :                        ;************************************************************************************
  362/    3138 :                        ;
  363/    3138 :                        ; do string too long error
  364/    3138 :                        
  365/    3138 :                        LAB_SLER
  366/    3138 : 7E1A                   	MOVEQ		#$1A,d7				; error code $1A "String too long" error
  367/    313A : 6032                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  368/    313C :                        
  369/    313C :                        
  370/    313C :                        ;************************************************************************************
  371/    313C :                        ;
  372/    313C :                        ; do type missmatch error
  373/    313C :                        
  374/    313C :                        LAB_TMER
  375/    313C : 7E18                   	MOVEQ		#$18,d7				; error code $18 "Type mismatch" error
  376/    313E : 602E                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  377/    3140 :                        
  378/    3140 :                        
  379/    3140 :                        ;************************************************************************************
  380/    3140 :                        ;
  381/    3140 :                        ; do illegal direct error
  382/    3140 :                        
  383/    3140 :                        LAB_IDER
  384/    3140 : 7E16                   	MOVEQ		#$16,d7				; error code $16 "Illegal direct" error
  385/    3142 : 602A                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  386/    3144 :                        
  387/    3144 :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 11 - 12/13/2023 15:59:9


  388/    3144 :                        ;************************************************************************************
  389/    3144 :                        ;
  390/    3144 :                        ; do divide by zero error
  391/    3144 :                        
  392/    3144 :                        LAB_DZER
  393/    3144 : 7E14                   	MOVEQ		#$14,d7				; error code $14 "Divide by zero" error
  394/    3146 : 6026                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  395/    3148 :                        
  396/    3148 :                        
  397/    3148 :                        ;************************************************************************************
  398/    3148 :                        ;
  399/    3148 :                        ; do double dimension error
  400/    3148 :                        
  401/    3148 :                        LAB_DDER
  402/    3148 : 7E12                   	MOVEQ		#$12,d7				; error code $12 "Double dimension" error
  403/    314A : 6022                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  404/    314C :                        
  405/    314C :                        
  406/    314C :                        ;************************************************************************************
  407/    314C :                        ;
  408/    314C :                        ; do array bounds error
  409/    314C :                        
  410/    314C :                        LAB_ABER
  411/    314C : 7E10                   	MOVEQ		#$10,d7				; error code $10 "Array bounds" error
  412/    314E : 601E                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  413/    3150 :                        
  414/    3150 :                        
  415/    3150 :                        ;************************************************************************************
  416/    3150 :                        ;
  417/    3150 :                        ; do undefined satement error
  418/    3150 :                        
  419/    3150 :                        LAB_USER
  420/    3150 : 7E0E                   	MOVEQ		#$0E,d7				; error code $0E "Undefined statement" error
  421/    3152 : 601A                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  422/    3154 :                        
  423/    3154 :                        
  424/    3154 :                        ;************************************************************************************
  425/    3154 :                        ;
  426/    3154 :                        ; do out of memory error
  427/    3154 :                        
  428/    3154 :                        LAB_OMER
  429/    3154 : 7E0C                   	MOVEQ		#$0C,d7				; error code $0C "Out of memory" error
  430/    3156 : 6016                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  431/    3158 :                        
  432/    3158 :                        
  433/    3158 :                        ;************************************************************************************
  434/    3158 :                        ;
  435/    3158 :                        ; do overflow error
  436/    3158 :                        
  437/    3158 :                        LAB_OFER
  438/    3158 : 7E0A                   	MOVEQ		#$0A,d7				; error code $0A "Overflow" error
  439/    315A : 6012                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  440/    315C :                        
  441/    315C :                        
  442/    315C :                        ;************************************************************************************
  443/    315C :                        ;
  444/    315C :                        ; do function call error
  445/    315C :                        
  446/    315C :                        LAB_FCER
  447/    315C : 7E08                   	MOVEQ		#$08,d7				; error code $08 "Function call" error
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 12 - 12/13/2023 15:59:9


  448/    315E : 600E                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  449/    3160 :                        
  450/    3160 :                        
  451/    3160 :                        ;************************************************************************************
  452/    3160 :                        ;
  453/    3160 :                        ; do out of data error
  454/    3160 :                        
  455/    3160 :                        LAB_ODER
  456/    3160 : 7E06                   	MOVEQ		#$06,d7				; error code $06 "Out of DATA" error
  457/    3162 : 600A                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  458/    3164 :                        
  459/    3164 :                        
  460/    3164 :                        ;************************************************************************************
  461/    3164 :                        ;
  462/    3164 :                        ; do return without gosub error
  463/    3164 :                        
  464/    3164 :                        LAB_RGER
  465/    3164 : 7E04                   	MOVEQ		#$04,d7				; error code $04 "RETURN without GOSUB" error
  466/    3166 : 6006                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  467/    3168 :                        
  468/    3168 :                        
  469/    3168 :                        ;************************************************************************************
  470/    3168 :                        ;
  471/    3168 :                        ; do syntax error
  472/    3168 :                        
  473/    3168 :                        LAB_SNER
  474/    3168 : 7E02                   	MOVEQ		#$02,d7				; error code $02 "Syntax" error
  475/    316A : 6002                   	BRA.s		LAB_XERR				; do error #d7, then warm start
  476/    316C :                        
  477/    316C :                        
  478/    316C :                        ;************************************************************************************
  479/    316C :                        ;
  480/    316C :                        ; do next without for error
  481/    316C :                        
  482/    316C :                        LAB_NFER
  483/    316C : 7E00                   	MOVEQ		#$00,d7				; error code $00 "NEXT without FOR" error
  484/    316E :                        
  485/    316E :                        
  486/    316E :                        ;************************************************************************************
  487/    316E :                        ;
  488/    316E :                        ; do error #d7, then warm start
  489/    316E :                        
  490/    316E :                        LAB_XERR
  491/    316E : 6100 02CA              	BSR		LAB_1491				; flush stack & clear continue flag
  492/    3172 : 6100 0812              	BSR		LAB_CRLF				; print CR/LF
  493/    3176 : 43FA 2FFA              	LEA		LAB_BAER(pc),a1			; start of error message pointer table
  494/    317A : 3E31 7000              	MOVE.w	(a1,d7.w),d7			; get error message offset
  495/    317E : 41F1 7000              	LEA		(a1,d7.w),a0			; get error message address
  496/    3182 : 6100 0860              	BSR		LAB_18C3				; print null terminated string from memory
  497/    3186 : 41FA 3335              	LEA		LAB_EMSG(pc),a0			; point to " Error" message
  498/    318A :                        LAB_1269
  499/    318A : 6100 0858              	BSR		LAB_18C3				; print null terminated string from memory
  500/    318E : 202B 0452              	MOVE.l	Clinel(a3),d0			; get current line
  501/    3192 : 6B04                   	BMI.s	LAB_1274				; go do warm start if -ve # (was immediate mode)
  502/    3194 :                        
  503/    3194 :                        									; else print line number
  504/    3194 : 6100 1B2C              	BSR		LAB_2953				; print " in line [LINE #]"
  505/    3198 :                        
  506/    3198 :                        ; BASIC warm start entry point, wait for Basic command
  507/    3198 :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 13 - 12/13/2023 15:59:9


  508/    3198 :                        LAB_1274
  509/    3198 : 41FA 3356              	LEA		LAB_RMSG(pc),a0			; point to "Ready" message
  510/    319C : 6100 0846              	BSR		LAB_18C3				; go do print string
  511/    31A0 :                        
  512/    31A0 :                        ; wait for Basic command - no "Ready"
  513/    31A0 :                        
  514/    31A0 :                        LAB_127D
  515/    31A0 : 72FF                   	MOVEQ	#-1,d1					; set to -1
  516/    31A2 : 2741 0452              	MOVE.l	d1,Clinel(a3)			; set current line #
  517/    31A6 : 1741 05DC              	MOVE.b	d1,Breakf(a3)			; set break flag
  518/    31AA : 4BEB 0490              	LEA		Ibuffs(a3),a5			; set basic execute pointer ready for new line
  519/    31AE :                        LAB_127E
  520/    31AE : 6100 00EC              	BSR		LAB_1357				; call for BASIC input
  521/    31B2 : 6100 0BFC              	BSR		LAB_GBYT				; scan memory
  522/    31B6 : 67F6                   	BEQ.s	LAB_127E				; loop while null
  523/    31B8 :                        
  524/    31B8 :                        ; got to interpret input line now ....
  525/    31B8 :                        
  526/    31B8 : 6508                   	BCS.s	LAB_1295				; branch if numeric character, handle new
  527/    31BA :                        								; BASIC line
  528/    31BA :                        
  529/    31BA :                        								; no line number so do immediate mode, a5
  530/    31BA :                        								; points to the buffer start
  531/    31BA : 6100 0156              	BSR		LAB_13A6				; crunch keywords into Basic tokens
  532/    31BE :                        								; crunch from (a5), output to (a0)
  533/    31BE :                        								; returns ..
  534/    31BE :                        								; d2 is length, d1 trashed, d0 trashed,
  535/    31BE :                        								; a1 trashed
  536/    31BE : 6000 03C6              	BRA		LAB_15F6				; go scan & interpret code
  537/    31C2 :                        
  538/    31C2 :                        
  539/    31C2 :                        ;************************************************************************************
  540/    31C2 :                        ;
  541/    31C2 :                        ; handle a new BASIC line
  542/    31C2 :                        
  543/    31C2 :                        LAB_1295
  544/    31C2 : 6100 0640              	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
  545/    31C6 : 6100 014A              	BSR		LAB_13A6				; crunch keywords into Basic tokens
  546/    31CA :                        								; crunch from (a5), output to (a0)
  547/    31CA :                        								; returns .. d2 is length,
  548/    31CA :                        								; d1 trashed, d0 trashed, a1 trashed
  549/    31CA : 222B 042A              	MOVE.l	Itemp(a3),d1			; get required line #
  550/    31CE : 6100 0218              	BSR		LAB_SSLN				; search BASIC for d1 line number
  551/    31D2 :                        								; returns pointer in a0
  552/    31D2 : 6532                   	BCS.s		LAB_12E6				; branch if not found
  553/    31D4 :                        
  554/    31D4 :                        								; aroooogah! line # already exists! delete it
  555/    31D4 : 2250                   	MOVEA.l	(a0),a1				; get start of block (next line pointer)
  556/    31D6 : 202B 0432              	MOVE.l	Sfncl(a3),d0			; get end of block (start of functions)
  557/    31DA : 9089                   	SUB.l		a1,d0					; subtract start of block ( = bytes to move)
  558/    31DC : E288                   	LSR.l		#1,d0					; /2 (word move)
  559/    31DE : 5380                   	SUBQ.l	#1,d0					; adjust for DBF loop
  560/    31E0 : 4840                   	SWAP		d0					; swap high word to low word
  561/    31E2 : 2448                   	MOVEA.l	a0,a2					; copy destination
  562/    31E4 :                        LAB_12AE
  563/    31E4 : 4840                   	SWAP		d0					; swap high word to low word
  564/    31E6 :                        LAB_12B0
  565/    31E6 : 34D9                   	MOVE.w	(a1)+,(a2)+				; copy word
  566/    31E8 : 51C8 FFFC              	DBF		d0,LAB_12B0				; decrement low count and loop until done
  567/    31EC :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 14 - 12/13/2023 15:59:9


  568/    31EC : 4840                   	SWAP		d0					; swap high word to low word
  569/    31EE : 51C8 FFF4              	DBF		d0,LAB_12AE				; decrement high count and loop until done
  570/    31F2 :                        
  571/    31F2 : 274A 0432              	MOVE.l	a2,Sfncl(a3)			; start of functions
  572/    31F6 : 274A 0436              	MOVE.l	a2,Svarl(a3)			; save start of variables
  573/    31FA : 274A 043A              	MOVE.l	a2,Sstrl(a3)			; start of strings
  574/    31FE : 274A 043E              	MOVE.l	a2,Sarryl(a3)			; save start of arrays
  575/    3202 : 274A 0442              	MOVE.l	a2,Earryl(a3)			; save end of arrays
  576/    3206 :                        
  577/    3206 :                        								; got new line in buffer and no existing same #
  578/    3206 :                        LAB_12E6
  579/    3206 : 102B 0490              	MOVE.b	Ibuffs(a3),d0			; get byte from start of input buffer
  580/    320A : 6764                   	BEQ.s		LAB_1325				; if null line go do line chaining
  581/    320C :                        
  582/    320C :                        								; got new line and it isn't empty line
  583/    320C : 226B 0432              	MOVEA.l	Sfncl(a3),a1			; get start of functions (end of block to move)
  584/    3210 : 45F1 2008              	LEA		8(a1,d2),a2				; copy it, add line length and add room for
  585/    3214 :                        								; pointer and line number
  586/    3214 :                        
  587/    3214 : 274A 0432              	MOVE.l	a2,Sfncl(a3)			; start of functions
  588/    3218 : 274A 0436              	MOVE.l	a2,Svarl(a3)			; save start of variables
  589/    321C : 274A 043A              	MOVE.l	a2,Sstrl(a3)			; start of strings
  590/    3220 : 274A 043E              	MOVE.l	a2,Sarryl(a3)			; save start of arrays
  591/    3224 : 274A 0442              	MOVE.l	a2,Earryl(a3)			; save end of arrays
  592/    3228 : 276B 044A 0446         	MOVE.l	Ememl(a3),Sstorl(a3)		; copy end of mem to start of strings, clear
  593/    322E :                        								; strings
  594/    322E :                        
  595/    322E : 2209                   	MOVE.l	a1,d1					; copy end of block to move
  596/    3230 : 9288                   	SUB.l		a0,d1					; subtract start of block to move
  597/    3232 : E289                   	LSR.l		#1,d1					; /2 (word copy)
  598/    3234 : 5381                   	SUBQ.l	#1,d1					; correct for loop end on -1
  599/    3236 : 4841                   	SWAP		d1					; swap high word to low word
  600/    3238 :                        LAB_12FF
  601/    3238 : 4841                   	SWAP		d1					; swap high word to low word
  602/    323A :                        LAB_1301
  603/    323A : 3521                   	MOVE.w	-(a1),-(a2)				; decrement pointers and copy word
  604/    323C : 51C9 FFFC              	DBF		d1,LAB_1301				; decrement & loop
  605/    3240 :                        
  606/    3240 : 4841                   	SWAP		d1					; swap high word to low word
  607/    3242 : 51C9 FFF4              	DBF		d1,LAB_12FF				; decrement high count and loop until done
  608/    3246 :                        
  609/    3246 :                        ; space is opened up, now copy the crunched line from the input buffer into the space
  610/    3246 :                        
  611/    3246 : 43EB 0490              	LEA		Ibuffs(a3),a1			; source is input buffer
  612/    324A : 2448                   	MOVEA.l	a0,a2					; copy destination
  613/    324C : 72FF                   	MOVEQ		#-1,d1				; set to allow re-chaining
  614/    324E : 24C1                   	MOVE.l	d1,(a2)+				; set next line pointer (allow re-chaining)
  615/    3250 : 24EB 042A              	MOVE.l	Itemp(a3),(a2)+			; save line number
  616/    3254 : E24A                   	LSR.w		#1,d2					; /2 (word copy)
  617/    3256 : 5342                   	SUBQ.w	#1,d2					; correct for loop end on -1
  618/    3258 :                        LAB_1303
  619/    3258 : 34D9                   	MOVE.w	(a1)+,(a2)+				; copy word
  620/    325A : 51CA FFFC              	DBF		d2,LAB_1303				; decrement & loop
  621/    325E :                        
  622/    325E : 6010                   	BRA.s		LAB_1325				; go test for end of prog
  623/    3260 :                        
  624/    3260 :                        ; rebuild chaining of BASIC lines
  625/    3260 :                        
  626/    3260 :                        LAB_132E
  627/    3260 : 5048                   	ADDQ.w	#8,a0					; point to first code byte of line, there is
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 15 - 12/13/2023 15:59:9


  628/    3262 :                        								; always 1 byte + [EOL] as null entries are
  629/    3262 :                        								; deleted
  630/    3262 :                        LAB_1330
  631/    3262 : 4A18                   	TST.b		(a0)+					; test byte	
  632/    3264 : 66FC                   	BNE.s		LAB_1330				; loop if not [EOL]
  633/    3266 :                        
  634/    3266 :                        								; was [EOL] so get next line start
  635/    3266 : 3208                   	MOVE.w	a0,d1					; past pad byte(s)
  636/    3268 : 0241 0001              	ANDI.w	#1,d1					; mask odd bit
  637/    326C : D0C1                   	ADD.w		d1,a0					; add back to ensure even
  638/    326E : 2288                   	MOVE.l	a0,(a1)				; save next line pointer to current line
  639/    3270 :                        LAB_1325
  640/    3270 : 2248                   	MOVEA.l	a0,a1					; copy pointer for this line
  641/    3272 : 4A90                   	TST.l		(a0)					; test pointer to next line
  642/    3274 : 66EA                   	BNE.s		LAB_132E				; not end of program yet so we must
  643/    3276 :                        								; go and fix the pointers
  644/    3276 :                        
  645/    3276 : 6100 0198              	BSR		LAB_1477				; reset execution to start, clear variables
  646/    327A :                        								; and flush stack
  647/    327A : 6000 FF24              	BRA		LAB_127D				; now we just wait for Basic command, no "Ready"
  648/    327E :                        
  649/    327E :                        
  650/    327E :                        ;************************************************************************************
  651/    327E :                        ;
  652/    327E :                        ; receive a line from the keyboard
  653/    327E :                        								; character $08 as delete key, BACKSPACE on
  654/    327E :                        								; standard keyboard
  655/    327E :                        LAB_134B
  656/    327E : 6100 077E              	BSR		LAB_PRNA				; go print the character
  657/    3282 : 7020                   	MOVEQ		#' ',d0				; load [SPACE]
  658/    3284 : 6100 0778              	BSR		LAB_PRNA				; go print
  659/    3288 : 7008                   	MOVEQ		#$08,d0				; load [BACKSPACE]
  660/    328A : 6100 0772              	BSR		LAB_PRNA				; go print
  661/    328E : 5341                   	SUBQ.w	#$01,d1				; decrement the buffer index (delete)
  662/    3290 : 6010                   	BRA.s		LAB_1359				; re-enter loop
  663/    3292 :                        
  664/    3292 :                        ; print "? " and get BASIC input
  665/    3292 :                        ; return a0 pointing to the buffer start
  666/    3292 :                        
  667/    3292 :                        LAB_INLN
  668/    3292 : 6100 0768              	BSR		LAB_18E3				; print "?" character
  669/    3296 : 7020                   	MOVEQ		#' ',d0				; load " "
  670/    3298 : 6100 0764              	BSR		LAB_PRNA				; go print
  671/    329C :                        
  672/    329C :                        ; call for BASIC input (main entry point)
  673/    329C :                        ; return a0 pointing to the buffer start
  674/    329C :                        
  675/    329C :                        LAB_1357
  676/    329C : 7200                   	MOVEQ		#$00,d1				; clear buffer index
  677/    329E : 41EB 0490              	LEA		Ibuffs(a3),a0			; set buffer base pointer
  678/    32A2 :                        LAB_1359
  679/    32A2 : 4EAB 040C              	JSR		V_INPT(a3)				; call scan input device
  680/    32A6 : 64FA                   	BCC.s		LAB_1359				; loop if no byte
  681/    32A8 :                        
  682/    32A8 : 67F8                   	BEQ.s		LAB_1359				; loop if null byte
  683/    32AA :                        
  684/    32AA : B03C 0007              	CMP.b		#$07,d0				; compare with [BELL]
  685/    32AE : 6718                   	BEQ.s		LAB_1378				; branch if [BELL]
  686/    32B0 :                        
  687/    32B0 : B03C 000D              	CMP.b		#$0D,d0				; compare with [CR]
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 16 - 12/13/2023 15:59:9


  688/    32B4 : 6700 06CA              	BEQ		LAB_1866				; do CR/LF exit if [CR]
  689/    32B8 :                        
  690/    32B8 : 4A41                   	TST.w		d1					; set flags on buffer index
  691/    32BA : 6606                   	BNE.s		LAB_1374				; branch if not empty
  692/    32BC :                        
  693/    32BC :                        ; the next two lines ignore any non printing character and [SPACE] if the input buffer
  694/    32BC :                        ; is empty
  695/    32BC :                        
  696/    32BC : B03C 0020              	CMP.b		#' ',d0				; compare with [SP]+1
  697/    32C0 : 63E0                   	BLS.s		LAB_1359				; if < ignore character
  698/    32C2 :                        
  699/    32C2 :                        ;##	CMP.b		#' '+1,d0				; compare with [SP]+1
  700/    32C2 :                        ;##	BCS.s		LAB_1359				; if < ignore character
  701/    32C2 :                        
  702/    32C2 :                        LAB_1374
  703/    32C2 : B03C 0008              	CMP.b		#$08,d0				; compare with [BACKSPACE]
  704/    32C6 : 67B6                   	BEQ.s		LAB_134B				; go delete last character
  705/    32C8 :                        
  706/    32C8 :                        LAB_1378
  707/    32C8 : B27C 00FF              	CMP.w		#(Ibuffe-Ibuffs-1),d1		; compare character count with max-1
  708/    32CC : 640C                   	BCC.s		LAB_138E				; skip store & do [BELL] if buffer full
  709/    32CE :                        
  710/    32CE : 1180 1000              	MOVE.b	d0,(a0,d1.w)			; else store in buffer
  711/    32D2 : 5241                   	ADDQ.w	#$01,d1				; increment index
  712/    32D4 :                        LAB_137F
  713/    32D4 : 6100 0728              	BSR		LAB_PRNA				; go print the character
  714/    32D8 : 60C8                   	BRA.s		LAB_1359				; always loop for next character
  715/    32DA :                        
  716/    32DA :                        ; announce buffer full
  717/    32DA :                        
  718/    32DA :                        LAB_138E
  719/    32DA : 7007                   	MOVEQ		#$07,d0				; [BELL] character into d0
  720/    32DC : 60F6                   	BRA.s		LAB_137F				; go print the [BELL] but ignore input character
  721/    32DE :                        
  722/    32DE :                        
  723/    32DE :                        ;************************************************************************************
  724/    32DE :                        ;
  725/    32DE :                        ; copy a hex value without crunching
  726/    32DE :                        
  727/    32DE :                        LAB_1392
  728/    32DE : 1180 2000              	MOVE.b	d0,(a0,d2.w)			; save the byte to the output
  729/    32E2 : 5242                   	ADDQ.w	#1,d2					; increment the buffer save index
  730/    32E4 :                        
  731/    32E4 : 5241                   	ADDQ.w	#1,d1					; increment the buffer read index
  732/    32E6 : 1035 1000              	MOVE.b	(a5,d1.w),d0			; get a byte from the input buffer
  733/    32EA : 6700 0094              	BEQ		LAB_13EC				; if [EOL] go save it without crunching
  734/    32EE :                        
  735/    32EE : B03C 0020              	CMP.b		#' ',d0				; compare the character with " "
  736/    32F2 : 67EA                   	BEQ.s		LAB_1392				; if [SPACE] just go save it and get another
  737/    32F4 :                        
  738/    32F4 : B03C 0030              	CMP.b		#'0',d0				; compare the character with "0"
  739/    32F8 : 654A                   	BCS.s		LAB_13C6				; if < "0" quit the hex save loop
  740/    32FA :                        
  741/    32FA : B03C 0039              	CMP.b		#'9',d0				; compare with "9"
  742/    32FE : 63DE                   	BLS.s		LAB_1392				; if it is "0" to "9" save it and get another
  743/    3300 :                        
  744/    3300 : 7ADF                   	MOVEQ		#-33,d5				; mask xx0x xxxx, ASCII upper case
  745/    3302 : CA00                   	AND.b		d0,d5					; mask the character
  746/    3304 :                        
  747/    3304 : BA3C 0041              	CMP.b		#'A',d5				; compare with "A"
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 17 - 12/13/2023 15:59:9


  748/    3308 : 6540                   	BCS.s		LAB_13CC				; if < "A" quit the hex save loop
  749/    330A :                        
  750/    330A : BA3C 0046              	CMP.b		#'F',d5				; compare with "F"
  751/    330E : 63CE                   	BLS.s		LAB_1392				; if it is "A" to "F" save it and get another
  752/    3310 :                        
  753/    3310 : 6038                   	BRA.s		LAB_13CC				; else continue crunching
  754/    3312 :                        
  755/    3312 :                        ; crunch keywords into Basic tokens
  756/    3312 :                        ; crunch from (a5), output to (a0)
  757/    3312 :                        ; returns ..
  758/    3312 :                        ; d4 trashed
  759/    3312 :                        ; d3 trashed
  760/    3312 :                        ; d2 is length
  761/    3312 :                        ; d1 trashed
  762/    3312 :                        ; d0 trashed
  763/    3312 :                        ; a1 trashed
  764/    3312 :                        
  765/    3312 :                        ; this is the improved BASIC crunch routine and is 10 to 100 times faster than the
  766/    3312 :                        ; old list search
  767/    3312 :                        
  768/    3312 :                        LAB_13A6
  769/    3312 : 7200                   	MOVEQ		#0,d1					; clear the read index
  770/    3314 : 2401                   	MOVE.l	d1,d2					; clear the save index
  771/    3316 : 1741 05DD              	MOVE.b	d1,Oquote(a3)			; clear the open quote/DATA flag
  772/    331A :                        LAB_13AC
  773/    331A : 7000                   	MOVEQ		#0,d0					; clear word
  774/    331C : 1035 1000              	MOVE.b	(a5,d1.w),d0			; get byte from input buffer
  775/    3320 : 675E                   	BEQ.s		LAB_13EC				; if null save byte then continue crunching
  776/    3322 :                        
  777/    3322 : B03C 005F              	CMP.b		#'_',d0				; compare with "_"
  778/    3326 : 6458                   	BCC.s		LAB_13EC				; if >= "_" save byte then continue crunching
  779/    3328 :                        
  780/    3328 : B03C 003C              	CMP.b		#'<',d0				; compare with "<"
  781/    332C : 641C                   	BCC.s		LAB_13CC				; if >= "<" go crunch
  782/    332E :                        
  783/    332E : B03C 0030              	CMP.b		#'0',d0				; compare with "0"
  784/    3332 : 644C                   	BCC.s		LAB_13EC				; if >= "0" save byte then continue crunching
  785/    3334 :                        
  786/    3334 : 1740 05DA              	MOVE.b	d0,Asrch(a3)			; save buffer byte as search character
  787/    3338 : B03C 0022              	CMP.b		#$22,d0				; is it quote character?
  788/    333C : 6776                   	BEQ.s		LAB_1410				; branch if so (copy quoted string)
  789/    333E :                        
  790/    333E : B03C 0024              	CMP.b		#'$',d0				; is it the hex value character?
  791/    3342 : 679A                   	BEQ.s		LAB_1392				; if so go copy a hex value
  792/    3344 :                        
  793/    3344 :                        LAB_13C6
  794/    3344 : B03C 002A              	CMP.b		#'*',d0				; compare with "*"
  795/    3348 : 6536                   	BCS.s		LAB_13EC				; if <= "*" save byte then continue crunching
  796/    334A :                        
  797/    334A :                        								; crunch rest
  798/    334A :                        LAB_13CC
  799/    334A : 082B 0006 05DD         	BTST.b	#6,Oquote(a3)			; test open quote/DATA token flag
  800/    3350 : 662E                   	BNE.s		LAB_13EC				; branch if b6 of Oquote set (was DATA)
  801/    3352 :                        								; go save byte then continue crunching
  802/    3352 :                        
  803/    3352 : 903C 002A              	SUB.b		#$2A,d0				; normalise byte
  804/    3356 : D040                   	ADD.w		d0,d0					; *2 makes word offset (high byte=$00)
  805/    3358 : 43FA 2C1A              	LEA		TAB_CHRT(pc),a1			; get keyword offset table address
  806/    335C : 3031 0000              	MOVE.w	(a1,d0.w),d0			; get offset into keyword table
  807/    3360 : 6B6E                   	BMI.s		LAB_141F				; branch if no keywords for character
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 18 - 12/13/2023 15:59:9


  808/    3362 :                        
  809/    3362 : 43FA 2FA6              	LEA		TAB_STAR(pc),a1			; get keyword table address
  810/    3366 : D2C0                   	ADDA.w	d0,a1					; add keyword offset
  811/    3368 : 76FF                   	MOVEQ		#-1,d3				; clear index
  812/    336A : 3801                   	MOVE.w	d1,d4					; copy read index
  813/    336C :                        LAB_13D6
  814/    336C : 5243                   	ADDQ.w	#1,d3					; increment table index
  815/    336E : 1031 3000              	MOVE.b	(a1,d3.w),d0			; get byte from table
  816/    3372 :                        LAB_13D8
  817/    3372 : 6B0A                   	BMI.s		LAB_13EA				; branch if token, save token and continue
  818/    3374 :                        								; crunching
  819/    3374 :                        
  820/    3374 : 5244                   	ADDQ.w	#1,d4					; increment read index
  821/    3376 : B035 4000              	CMP.b		(a5,d4.w),d0			; compare byte from input buffer
  822/    337A : 67F0                   	BEQ.s		LAB_13D6				; loop if character match
  823/    337C :                        
  824/    337C : 6040                   	BRA.s		LAB_1417				; branch if no match
  825/    337E :                        
  826/    337E :                        LAB_13EA
  827/    337E : 3204                   	MOVE.w	d4,d1					; update read index
  828/    3380 :                        LAB_13EC
  829/    3380 : 1180 2000              	MOVE.b	d0,(a0,d2.w)			; save byte to output
  830/    3384 : 5242                   	ADDQ.w	#1,d2					; increment buffer save index
  831/    3386 : 5241                   	ADDQ.w	#1,d1					; increment buffer read index
  832/    3388 : 4A00                   	TST.b		d0					; set flags
  833/    338A : 674A                   	BEQ.s		LAB_142A				; branch if was null [EOL]
  834/    338C :                        
  835/    338C :                        								; d0 holds token or byte here
  836/    338C : 903C 003A              	SUB.b		#$3A,d0				; subtract ":"
  837/    3390 : 6706                   	BEQ.s		LAB_13FF				; branch if it was ":" (is now $00)
  838/    3392 :                        
  839/    3392 :                        								; d0 now holds token-$3A
  840/    3392 : B03C 0049              	CMP.b		#(TK_DATA-$3A),d0			; compare with DATA token - $3A
  841/    3396 : 6604                   	BNE.s		LAB_1401				; branch if not DATA
  842/    3398 :                        
  843/    3398 :                        								; token was : or DATA
  844/    3398 :                        LAB_13FF
  845/    3398 : 1740 05DD              	MOVE.b	d0,Oquote(a3)			; save token-$3A ($00 for ":", TK_DATA-$3A for
  846/    339C :                        								; DATA)
  847/    339C :                        LAB_1401
  848/    339C : 903C 0055              	SUB.b		#(TK_REM-$3A),d0			; subtract REM token offset
  849/    33A0 : 6600 FF78              	BNE		LAB_13AC				; If wasn't REM then go crunch rest of line
  850/    33A4 :                        
  851/    33A4 : 1740 05DA              	MOVE.b	d0,Asrch(a3)			; else was REM so set search for [EOL]
  852/    33A8 :                        
  853/    33A8 :                        								; loop for REM, "..." etc.
  854/    33A8 :                        LAB_1408
  855/    33A8 : 1035 1000              	MOVE.b	(a5,d1.w),d0			; get byte from input buffer
  856/    33AC : 67D2                   	BEQ.s		LAB_13EC				; branch if null [EOL]
  857/    33AE :                        
  858/    33AE : B02B 05DA              	CMP.b		Asrch(a3),d0			; compare with stored character
  859/    33B2 : 67CC                   	BEQ.s		LAB_13EC				; branch if match (end quote, REM, :, or DATA)
  860/    33B4 :                        
  861/    33B4 :                        								; entry for copy string in quotes, don't crunch
  862/    33B4 :                        LAB_1410
  863/    33B4 : 1180 2000              	MOVE.b	d0,(a0,d2.w)			; save byte to output
  864/    33B8 : 5242                   	ADDQ.w	#1,d2					; increment buffer save index
  865/    33BA : 5241                   	ADDQ.w	#1,d1					; increment buffer read index
  866/    33BC : 60EA                   	BRA.s		LAB_1408				; loop
  867/    33BE :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 19 - 12/13/2023 15:59:9


  868/    33BE :                        ; not found keyword this go so find the end of this word in the table
  869/    33BE :                        
  870/    33BE :                        LAB_1417
  871/    33BE : 3801                   	MOVE.w	d1,d4					; reset read pointer
  872/    33C0 :                        LAB_141B
  873/    33C0 : 5243                   	ADDQ.w	#1,d3					; increment keyword table pointer, flag
  874/    33C2 :                        								; unchanged
  875/    33C2 : 1031 3000              	MOVE.b	(a1,d3.w),d0			; get keyword table byte
  876/    33C6 : 6AF8                   	BPL.s		LAB_141B				; if not end of keyword go do next byte
  877/    33C8 :                        
  878/    33C8 : 5243                   	ADDQ.w	#1,d3					; increment keyword table pointer flag
  879/    33CA :                        								; unchanged
  880/    33CA : 1031 3000              	MOVE.b	(a1,d3.w),d0			; get keyword table byte
  881/    33CE : 66A2                   	BNE.s		LAB_13D8				; go test next word if not zero byte (table end)
  882/    33D0 :                        
  883/    33D0 :                        								; reached end of table with no match
  884/    33D0 :                        LAB_141F
  885/    33D0 : 1035 1000              	MOVE.b	(a5,d1.w),d0			; restore byte from input buffer
  886/    33D4 : 60AA                   	BRA.s		LAB_13EC				; go save byte in output and continue crunching
  887/    33D6 :                        
  888/    33D6 :                        								; reached [EOL]
  889/    33D6 :                        LAB_142A
  890/    33D6 : 7000                   	MOVEQ		#0,d0					; ensure longword clear
  891/    33D8 : 0102                   	BTST		d0,d2					; test odd bit (fastest)
  892/    33DA : 6706                   	BEQ.s		LAB_142C				; branch if no bytes to fill
  893/    33DC :                        
  894/    33DC : 1180 2000              	MOVE.b	d0,(a0,d2.w)			; clear next byte
  895/    33E0 : 5242                   	ADDQ.w	#1,d2					; increment buffer save index
  896/    33E2 :                        LAB_142C
  897/    33E2 : 2180 2000              	MOVE.l	d0,(a0,d2.w)			; clear next line pointer, EOT in immediate mode
  898/    33E6 : 4E75                   	RTS
  899/    33E8 :                        
  900/    33E8 :                        
  901/    33E8 :                        ;************************************************************************************
  902/    33E8 :                        ;
  903/    33E8 :                        ; search Basic for d1 line number from start of mem
  904/    33E8 :                        
  905/    33E8 :                        LAB_SSLN
  906/    33E8 : 206B 042E              	MOVEA.l	Smeml(a3),a0			; get start of program mem
  907/    33EC : 6002                   	BRA.s		LAB_SCLN				; go search for required line from a0
  908/    33EE :                        
  909/    33EE :                        LAB_145F
  910/    33EE : 2040                   	MOVEA.l	d0,a0					; copy next line pointer
  911/    33F0 :                        
  912/    33F0 :                        ; search Basic for d1 line number from a0
  913/    33F0 :                        ; returns Cb=0 if found
  914/    33F0 :                        ; returns a0 pointer to found or next higher (not found) line
  915/    33F0 :                        
  916/    33F0 :                        LAB_SCLN
  917/    33F0 : 2018                   	MOVE.l	(a0)+,d0				; get next line pointer and point to line #
  918/    33F2 : 6708                   	BEQ.s		LAB_145E				; is end marker so we're done, do 'no line' exit
  919/    33F4 :                        
  920/    33F4 : B290                   	CMP.l		(a0),d1				; compare this line # with required line #
  921/    33F6 : 6EF6                   	BGT.s		LAB_145F				; loop if required # > this #
  922/    33F8 :                        
  923/    33F8 : 5948                   	SUBQ.w	#4,a0					; adjust pointer, flags not changed
  924/    33FA : 4E75                   	RTS
  925/    33FC :                        
  926/    33FC :                        LAB_145E
  927/    33FC : 5948                   	SUBQ.w	#4,a0					; adjust pointer, flags not changed
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 20 - 12/13/2023 15:59:9


  928/    33FE : 5380                   	SUBQ.l	#1,d0					; make end program found = -1, set carry
  929/    3400 : 4E75                   	RTS
  930/    3402 :                        
  931/    3402 :                        
  932/    3402 :                        ;************************************************************************************
  933/    3402 :                        ;
  934/    3402 :                        ; perform NEW
  935/    3402 :                        
  936/    3402 :                        LAB_NEW
  937/    3402 : 664E                   	BNE.s		RTS_005				; exit if not end of statement (do syntax error)
  938/    3404 :                        
  939/    3404 :                        LAB_1463
  940/    3404 : 206B 042E              	MOVEA.l	Smeml(a3),a0			; point to start of program memory
  941/    3408 : 7000                   	MOVEQ		#0,d0					; clear longword
  942/    340A : 20C0                   	MOVE.l	d0,(a0)+				; clear first line, next line pointer
  943/    340C : 2748 0432              	MOVE.l	a0,Sfncl(a3)			; set start of functions
  944/    3410 :                        
  945/    3410 :                        ; reset execution to start, clear variables and flush stack
  946/    3410 :                        
  947/    3410 :                        LAB_1477
  948/    3410 : 2A6B 042E              	MOVEA.l	Smeml(a3),a5			; reset BASIC execute pointer
  949/    3414 : 534D                   	SUBQ.w	#1,a5					; -1 (as end of previous line)
  950/    3416 :                        
  951/    3416 :                        ; "CLEAR" command gets here
  952/    3416 :                        
  953/    3416 :                        LAB_147A
  954/    3416 : 276B 044A 0446         	MOVE.l	Ememl(a3),Sstorl(a3)		; save end of mem as bottom of string space
  955/    341C : 202B 0432              	MOVE.l	Sfncl(a3),d0			; get start of functions
  956/    3420 : 2740 0436              	MOVE.l	d0,Svarl(a3)			; start of variables
  957/    3424 : 2740 043A              	MOVE.l	d0,Sstrl(a3)			; start of strings
  958/    3428 : 2740 043E              	MOVE.l	d0,Sarryl(a3)			; set start of arrays
  959/    342C : 2740 0442              	MOVE.l	d0,Earryl(a3)			; set end of arrays
  960/    3430 :                        LAB_1480
  961/    3430 : 7000                   	MOVEQ		#0,d0					; set Zb
  962/    3432 : 1740 05EA              	MOVE.b	d0,ccnull(a3)			; clear get byte countdown
  963/    3436 : 6100 01D0              	BSR		LAB_RESTORE				; perform RESTORE command
  964/    343A :                        
  965/    343A :                        ; flush stack & clear continue flag
  966/    343A :                        
  967/    343A :                        LAB_1491
  968/    343A : 49EB 048E              	LEA		des_sk(a3),a4			; reset descriptor stack pointer
  969/    343E :                        
  970/    343E : 201F                   	MOVE.l	(sp)+,d0				; pull return address
  971/    3440 : 2E7C 0000 8400         	MOVE.l	#ram_addr+ram_base,sp	; set stack to RAM start + 1k, flush stack
  972/    3446 : 2F00                   	MOVE.l	d0,-(sp)				; restore return address
  973/    3448 :                        
  974/    3448 : 7000                   	MOVEQ		#0,d0					; clear longword
  975/    344A : 2740 045A              	MOVE.l	d0,Cpntrl(a3)			; clear continue pointer
  976/    344E : 1740 05DF              	MOVE.b	d0,Sufnxf(a3)			; clear subscript/FNX flag
  977/    3452 :                        RTS_005
  978/    3452 : 4E75                   	RTS
  979/    3454 :                        
  980/    3454 :                        
  981/    3454 :                        ;************************************************************************************
  982/    3454 :                        ;
  983/    3454 :                        ; perform CLEAR
  984/    3454 :                        
  985/    3454 :                        LAB_CLEAR
  986/    3454 : 67C0                   	BEQ.s		LAB_147A				; if no following byte go do "CLEAR"
  987/    3456 :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 21 - 12/13/2023 15:59:9


  988/    3456 : 4E75                   	RTS							; was following byte (go do syntax error)
  989/    3458 :                        
  990/    3458 :                        
  991/    3458 :                        ;************************************************************************************
  992/    3458 :                        ;
  993/    3458 :                        ; perform LIST [n][-m]
  994/    3458 :                        
  995/    3458 :                        LAB_LIST
  996/    3458 : 6512                   	BCS.s		LAB_14BD				; branch if next character numeric (LIST n...)
  997/    345A :                        
  998/    345A : 72FF                   	MOVEQ		#-1,d1				; set end to $FFFFFFFF
  999/    345C : 2741 042A              	MOVE.l	d1,Itemp(a3)			; save to Itemp
 1000/    3460 :                        
 1001/    3460 : 7200                   	MOVEQ		#0,d1					; set start to $00000000
 1002/    3462 : 4A00                   	TST.b		d0					; test next byte
 1003/    3464 : 670A                   	BEQ.s		LAB_14C0				; branch if next character [NULL] (LIST)
 1004/    3466 :                        
 1005/    3466 : B03C 00B3              	CMP.b		#TK_MINUS,d0			; compare with token for -
 1006/    346A : 66E6                   	BNE.s		RTS_005				; exit if not - (LIST -m)
 1007/    346C :                        
 1008/    346C :                        								; LIST [[n]-[m]] this sets the n, if present,
 1009/    346C :                        								; as the start and end
 1010/    346C :                        LAB_14BD
 1011/    346C : 6100 0396              	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
 1012/    3470 :                        LAB_14C0
 1013/    3470 : 6100 FF76              	BSR		LAB_SSLN				; search BASIC for d1 line number
 1014/    3474 :                        								; (pointer in a0)
 1015/    3474 : 6100 093A              	BSR		LAB_GBYT				; scan memory
 1016/    3478 : 6716                   	BEQ.s		LAB_14D4				; branch if no more characters
 1017/    347A :                        
 1018/    347A :                        								; this bit checks the - is present
 1019/    347A : B03C 00B3              	CMP.b		#TK_MINUS,d0			; compare with token for -
 1020/    347E : 66D2                   	BNE.s		RTS_005				; return if not "-" (will be Syntax error)
 1021/    3480 :                        
 1022/    3480 : 72FF                   	MOVEQ		#-1,d1				; set end to $FFFFFFFF
 1023/    3482 : 2741 042A              	MOVE.l	d1,Itemp(a3)			; save Itemp
 1024/    3486 :                        
 1025/    3486 :                        								; LIST [n]-[m] the - was there so see if
 1026/    3486 :                        								; there is an m to set as the end value
 1027/    3486 : 6100 0926              	BSR		LAB_IGBY				; increment & scan memory
 1028/    348A : 6704                   	BEQ.s		LAB_14D4				; branch if was [NULL] (LIST n-)
 1029/    348C :                        
 1030/    348C : 6100 0376              	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
 1031/    3490 :                        LAB_14D4
 1032/    3490 : 177C 0000 05DD         	MOVE.b	#$00,Oquote(a3)			; clear open quote flag
 1033/    3496 : 6100 04EE              	BSR		LAB_CRLF				; print CR/LF
 1034/    349A : 2018                   	MOVE.l	(a0)+,d0				; get next line pointer
 1035/    349C : 67B4                   	BEQ.s		RTS_005				; if null all done so exit
 1036/    349E :                        
 1037/    349E : 2240                   	MOVEA.l	d0,a1					; copy next line pointer
 1038/    34A0 : 6100 012C              	BSR		LAB_1629				; do CRTL-C check vector
 1039/    34A4 :                        
 1040/    34A4 : 2018                   	MOVE.l	(a0)+,d0				; get this line #
 1041/    34A6 : B0AB 042A              	CMP.l		Itemp(a3),d0			; compare end line # with this line #
 1042/    34AA : 62A6                   	BHI.s		RTS_005				; if this line greater all done so exit
 1043/    34AC :                        
 1044/    34AC :                        LAB_14E2
 1045/    34AC : 48E7 00C0              	MOVEM.l	a0-a1,-(sp)				; save registers
 1046/    34B0 : 6100 181C              	BSR		LAB_295E				; print d0 as unsigned integer
 1047/    34B4 : 4CDF 0300              	MOVEM.l	(sp)+,a0-a1				; restore registers
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 22 - 12/13/2023 15:59:9


 1048/    34B8 : 7020                   	MOVEQ		#$20,d0				; space is the next character
 1049/    34BA :                        LAB_150C
 1050/    34BA : 6100 0542              	BSR		LAB_PRNA				; go print the character
 1051/    34BE : B03C 0022              	CMP.b		#$22,d0				; was it " character
 1052/    34C2 : 6606                   	BNE.s		LAB_1519				; branch if not
 1053/    34C4 :                        
 1054/    34C4 :                        								; we're either entering or leaving quotes
 1055/    34C4 : 0A2B 00FF 05DD         	EOR.b		#$FF,Oquote(a3)			; toggle open quote flag
 1056/    34CA :                        LAB_1519
 1057/    34CA : 1018                   	MOVE.b	(a0)+,d0				; get byte and increment pointer
 1058/    34CC : 6608                   	BNE.s		LAB_152E				; branch if not [EOL] (go print)
 1059/    34CE :                        
 1060/    34CE :                        								; was [EOL]
 1061/    34CE : 2049                   	MOVEA.l	a1,a0					; copy next line pointer
 1062/    34D0 : 2008                   	MOVE.l	a0,d0					; copy to set flags
 1063/    34D2 : 66BC                   	BNE.s		LAB_14D4				; go do next line if not [EOT]
 1064/    34D4 :                        
 1065/    34D4 : 4E75                   	RTS
 1066/    34D6 :                        
 1067/    34D6 :                        LAB_152E
 1068/    34D6 : 6AE2                   	BPL.s		LAB_150C				; just go print it if not token byte
 1069/    34D8 :                        
 1070/    34D8 :                        								; else it was a token byte so maybe uncrunch it
 1071/    34D8 : 4A2B 05DD              	TST.b		Oquote(a3)				; test the open quote flag
 1072/    34DC : 6BDC                   	BMI.s		LAB_150C				; just go print character if open quote set
 1073/    34DE :                        
 1074/    34DE :                        								; else uncrunch BASIC token
 1075/    34DE : 45FA 2AFE              	LEA		LAB_KEYT(pc),a2			; get keyword table address
 1076/    34E2 : 727F                   	MOVEQ		#$7F,d1				; mask into d1
 1077/    34E4 : C200                   	AND.b		d0,d1					; copy and mask token
 1078/    34E6 : E549                   	LSL.w		#2,d1					; *4
 1079/    34E8 : 45F2 1000              	LEA		(a2,d1.w),a2			; get keyword entry address
 1080/    34EC : 101A                   	MOVE.b	(a2)+,d0				; get byte from keyword table
 1081/    34EE : 6100 050E              	BSR		LAB_PRNA				; go print the first character
 1082/    34F2 : 7200                   	MOVEQ		#0,d1					; clear d1
 1083/    34F4 : 121A                   	MOVE.b	(a2)+,d1				; get remaining length byte from keyword table
 1084/    34F6 : 6BD2                   	BMI.s		LAB_1519				; if -ve done so go get next byte
 1085/    34F8 :                        
 1086/    34F8 : 3012                   	MOVE.w	(a2),d0				; get offset to rest
 1087/    34FA : 45FA 2E0E              	LEA		TAB_STAR(pc),a2			; get keyword table address
 1088/    34FE : 45F2 0000              	LEA		(a2,d0.w),a2			; get address of rest
 1089/    3502 :                        LAB_1540
 1090/    3502 : 101A                   	MOVE.b	(a2)+,d0				; get byte from keyword table
 1091/    3504 : 6100 04F8              	BSR		LAB_PRNA				; go print the character
 1092/    3508 : 51C9 FFF8              	DBF		d1,LAB_1540				; decrement and loop if more to do
 1093/    350C :                        
 1094/    350C : 60BC                   	BRA.s		LAB_1519				; go get next byte
 1095/    350E :                        
 1096/    350E :                        
 1097/    350E :                        ;************************************************************************************
 1098/    350E :                        ;
 1099/    350E :                        ; perform FOR
 1100/    350E :                        
 1101/    350E :                        LAB_FOR
 1102/    350E : 6100 0396              	BSR		LAB_LET				; go do LET
 1103/    3512 :                        
 1104/    3512 : 202B 0472              	MOVE.l	Lvarpl(a3),d0			; get the loop variable pointer
 1105/    3516 : B0AB 043A              	CMP.l		Sstrl(a3),d0			; compare it with the end of vars memory
 1106/    351A : 6C00 FC20              	BGE		LAB_TMER				; if greater go do type mismatch error
 1107/    351E :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 23 - 12/13/2023 15:59:9


 1108/    351E :                        ; test for not less than the start of variables memory if needed
 1109/    351E :                        ;
 1110/    351E :                        ;	CMP.l		Svarl(a3),d0			; compare it with the start of variables memory
 1111/    351E :                        ;	BLT		LAB_TMER				; if not variables memory do type mismatch error
 1112/    351E :                        
 1113/    351E :                        ;	MOVEQ		#28,d0				; we need 28 bytes !
 1114/    351E :                        ;	BSR.s		LAB_1212				; check room on stack for d0 bytes
 1115/    351E :                        
 1116/    351E : 6100 0214              	BSR		LAB_SNBS				; scan for next BASIC statement ([:] or [EOL])
 1117/    3522 :                        								; returns a0 as pointer to [:] or [EOL]
 1118/    3522 : 2E88                   	MOVE.l	a0,(sp)				; push onto stack (and dump the return address)
 1119/    3524 : 2F2B 0452              	MOVE.l	Clinel(a3),-(sp)			; push current line onto stack
 1120/    3528 :                        
 1121/    3528 : 70AA                   	MOVEQ		#TK_TO-$100,d0			; set "TO" token
 1122/    352A : 6100 087A              	BSR		LAB_SCCA				; scan for CHR$(d0) else syntax error/warm start
 1123/    352E : 6100 0708              	BSR		LAB_CTNM				; check if source is numeric, else type mismatch
 1124/    3532 : 1F2B 05B5              	MOVE.b	Dtypef(a3),-(sp)			; push the FOR variable data type onto stack
 1125/    3536 : 6100 06FE              	BSR		LAB_EVNM				; evaluate expression and check is numeric else
 1126/    353A :                        								; do type mismatch
 1127/    353A :                        
 1128/    353A : 2F2B 0590              	MOVE.l	FAC1_m(a3),-(sp)			; push TO value mantissa
 1129/    353E : 3F2B 0594              	MOVE.w	FAC1_e(a3),-(sp)			; push TO value exponent and sign
 1130/    3542 :                        
 1131/    3542 : 277C 8000 0000 0590    	MOVE.l	#$80000000,FAC1_m(a3)		; set default STEP size mantissa
 1132/    354A : 377C 8100 0594         	MOVE.w	#$8100,FAC1_e(a3)			; set default STEP size exponent and sign
 1133/    3550 :                        
 1134/    3550 : 6100 085E              	BSR		LAB_GBYT				; scan memory
 1135/    3554 : B03C 00AF              	CMP.b		#TK_STEP,d0				; compare with STEP token
 1136/    3558 : 6608                   	BNE.s		LAB_15B3				; jump if not "STEP"
 1137/    355A :                        
 1138/    355A :                        								; was STEP token so ....
 1139/    355A : 6100 0852              	BSR		LAB_IGBY				; increment & scan memory
 1140/    355E : 6100 06D6              	BSR		LAB_EVNM				; evaluate expression & check is numeric
 1141/    3562 :                        								; else do type mismatch
 1142/    3562 :                        LAB_15B3
 1143/    3562 : 2F2B 0590              	MOVE.l	FAC1_m(a3),-(sp)			; push STEP value mantissa
 1144/    3566 : 3F2B 0594              	MOVE.w	FAC1_e(a3),-(sp)			; push STEP value exponent and sign
 1145/    356A :                        
 1146/    356A : 2F2B 0472              	MOVE.l	Lvarpl(a3),-(sp)			; push variable pointer for FOR/NEXT
 1147/    356E : 3F3C 0081              	MOVE.w	#TK_FOR,-(sp)			; push FOR token on stack
 1148/    3572 :                        
 1149/    3572 : 6018                   	BRA.s		LAB_15C2				; go do interpreter inner loop
 1150/    3574 :                        
 1151/    3574 :                        LAB_15DC							; have reached [EOL]+1
 1152/    3574 : 300D                   	MOVE.w	a5,d0					; copy BASIC execute pointer
 1153/    3576 : C07C 0001              	AND.w		#1,d0					; and make line start address even
 1154/    357A : DAC0                   	ADD.w		d0,a5					; add to BASIC execute pointer
 1155/    357C : 201D                   	MOVE.l	(a5)+,d0				; get next line pointer
 1156/    357E : 6700 FC18              	BEQ		LAB_1274				; if null go to immediate mode, no "BREAK"
 1157/    3582 :                        								; message (was immediate or [EOT] marker)
 1158/    3582 :                        
 1159/    3582 : 275D 0452              	MOVE.l	(a5)+,Clinel(a3)			; save (new) current line #
 1160/    3586 :                        LAB_15F6
 1161/    3586 : 6100 0828              	BSR		LAB_GBYT				; get BASIC byte
 1162/    358A : 611A                   	BSR.s		LAB_15FF				; go interpret BASIC code from (a5)
 1163/    358C :                        
 1164/    358C :                        ; interpreter inner loop (re)entry point
 1165/    358C :                        
 1166/    358C :                        LAB_15C2
 1167/    358C : 6140                   	BSR.s		LAB_1629				; do CRTL-C check vector
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 24 - 12/13/2023 15:59:9


 1168/    358E : 4A2B 0452              	TST.b		Clinel(a3)				; test current line #, is -ve for immediate mode
 1169/    3592 : 6B04                   	BMI.s		LAB_15D1				; branch if immediate mode
 1170/    3594 :                        
 1171/    3594 : 274D 045A              	MOVE.l	a5,Cpntrl(a3)			; save BASIC execute pointer as continue pointer
 1172/    3598 :                        LAB_15D1
 1173/    3598 : 101D                   	MOVE.b	(a5)+,d0				; get this byte & increment pointer
 1174/    359A : 67D8                   	BEQ.s		LAB_15DC				; loop if [EOL]
 1175/    359C :                        
 1176/    359C : B03C 003A              	CMP.b		#$3A,d0				; compare with ":"
 1177/    35A0 : 67E4                   	BEQ.s		LAB_15F6				; loop if was statement separator
 1178/    35A2 :                        
 1179/    35A2 : 6000 FBC4              	BRA		LAB_SNER				; else syntax error, then warm start
 1180/    35A6 :                        
 1181/    35A6 :                        
 1182/    35A6 :                        ;************************************************************************************
 1183/    35A6 :                        ;
 1184/    35A6 :                        ; interpret BASIC code from (a5)
 1185/    35A6 :                        
 1186/    35A6 :                        LAB_15FF
 1187/    35A6 : 6700 008C              	BEQ		RTS_006				; exit if zero [EOL]
 1188/    35AA :                        
 1189/    35AA :                        LAB_1602
 1190/    35AA : 0A00 0080              	EORI.b	#$80,d0				; normalise token
 1191/    35AE : 6B00 02F6              	BMI		LAB_LET				; if not token, go do implied LET
 1192/    35B2 :                        
 1193/    35B2 : B03C 0028              	CMP.b		#(TK_TAB-$80),d0			; compare normalised token with TAB
 1194/    35B6 : 6400 FBB0              	BCC		LAB_SNER				; branch if d0>=TAB, syntax error/warm start
 1195/    35BA :                        								; only tokens before TAB can start a statement
 1196/    35BA :                        
 1197/    35BA : 4880                   	EXT.w		d0					; byte to word (clear high byte)
 1198/    35BC : D040                   	ADD.w		d0,d0					; *2
 1199/    35BE : 41FA 287C              	LEA		LAB_CTBL(pc),a0			; get vector table base address
 1200/    35C2 : 3030 0000              	MOVE.w	(a0,d0.w),d0			; get offset to vector
 1201/    35C6 : 4870 0000              	PEA		(a0,d0.w)				; push vector
 1202/    35CA : 6000 07E2              	BRA		LAB_IGBY				; get following byte & execute vector
 1203/    35CE :                        
 1204/    35CE :                        
 1205/    35CE :                        ;************************************************************************************
 1206/    35CE :                        ;
 1207/    35CE :                        ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
 1208/    35CE :                        ; key press is detected.
 1209/    35CE :                        
 1210/    35CE :                        LAB_1629
 1211/    35CE : 4EEB 0424              	JMP		V_CTLC(a3)				; ctrl c check vector
 1212/    35D2 :                        
 1213/    35D2 :                        ; if there was a key press it gets back here .....
 1214/    35D2 :                        
 1215/    35D2 :                        LAB_1636
 1216/    35D2 : B03C 0003              	CMP.b		#$03,d0				; compare with CTRL-C
 1217/    35D6 : 670C                   	BEQ.s		LAB_163B				; STOP if was CTRL-C
 1218/    35D8 :                        
 1219/    35D8 :                        LAB_1639
 1220/    35D8 : 4E75                   	RTS
 1221/    35DA :                        
 1222/    35DA :                        
 1223/    35DA :                        ;************************************************************************************
 1224/    35DA :                        ;
 1225/    35DA :                        ; perform END
 1226/    35DA :                        
 1227/    35DA :                        LAB_END
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 25 - 12/13/2023 15:59:9


 1228/    35DA : 66FC                   	BNE.s		LAB_1639				; exit if something follows STOP
 1229/    35DC : 177C 0000 05DC         	MOVE.b	#0,Breakf(a3)			; clear break flag, indicate program end
 1230/    35E2 :                        
 1231/    35E2 :                        
 1232/    35E2 :                        ;************************************************************************************
 1233/    35E2 :                        ;
 1234/    35E2 :                        ; perform STOP
 1235/    35E2 :                        
 1236/    35E2 :                        LAB_STOP
 1237/    35E2 : 66F4                   	BNE.s		LAB_1639				; exit if something follows STOP
 1238/    35E4 :                        
 1239/    35E4 :                        LAB_163B
 1240/    35E4 : 43EB 0590              	LEA		Ibuffe(a3),a1			; get buffer end
 1241/    35E8 : BBC9                   	CMPA.l	a1,a5					; compare execute address with buffer end
 1242/    35EA : 650A                   	BCS.s		LAB_164F				; branch if BASIC pointer is in buffer
 1243/    35EC :                        								; can't continue in immediate mode
 1244/    35EC :                        
 1245/    35EC :                        								; else...
 1246/    35EC : 274D 045A              	MOVE.l	a5,Cpntrl(a3)			; save BASIC execute pointer as continue pointer
 1247/    35F0 :                        LAB_1647
 1248/    35F0 : 276B 0452 0456         	MOVE.l	Clinel(a3),Blinel(a3)		; save break line
 1249/    35F6 :                        LAB_164F
 1250/    35F6 : 584F                   	ADDQ.w	#4,sp					; dump return address, don't return to execute
 1251/    35F8 :                        								; loop
 1252/    35F8 : 102B 05DC              	MOVE.b	Breakf(a3),d0			; get break flag
 1253/    35FC : 6700 FB9A              	BEQ		LAB_1274				; go do warm start if was program end
 1254/    3600 :                        
 1255/    3600 : 41FA 2EB3              	LEA		LAB_BMSG(pc),a0			; point to "Break"
 1256/    3604 : 6000 FB84              	BRA		LAB_1269				; print "Break" and do warm start
 1257/    3608 :                        
 1258/    3608 :                        
 1259/    3608 :                        ;************************************************************************************
 1260/    3608 :                        ;
 1261/    3608 :                        ; perform RESTORE
 1262/    3608 :                        
 1263/    3608 :                        LAB_RESTORE
 1264/    3608 : 206B 042E              	MOVEA.l	Smeml(a3),a0			; copy start of memory
 1265/    360C : 6720                   	BEQ.s		LAB_1624				; branch if next character null (RESTORE)
 1266/    360E :                        
 1267/    360E : 6100 01F4              	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
 1268/    3612 : B2AB 0452              	CMP.l		Clinel(a3),d1			; compare current line # with required line #
 1269/    3616 : 630E                   	BLS.s		LAB_GSCH				; branch if >= (start search from beginning)
 1270/    3618 :                        
 1271/    3618 : 204D                   	MOVEA.l	a5,a0					; copy BASIC execute pointer
 1272/    361A :                        LAB_RESs
 1273/    361A : 4A18                   	TST.b		(a0)+					; test next byte & increment pointer
 1274/    361C : 66FC                   	BNE.s		LAB_RESs				; loop if not EOL
 1275/    361E :                        
 1276/    361E : 3008                   	MOVE.w	a0,d0					; copy pointer
 1277/    3620 : C07C 0001              	AND.w		#1,d0					; mask odd bit
 1278/    3624 : D0C0                   	ADD.w		d0,a0					; add pointer
 1279/    3626 :                        								; search for line in Itemp from (a0)
 1280/    3626 :                        LAB_GSCH
 1281/    3626 : 6100 FDC8              	BSR		LAB_SCLN				; search for d1 line number from a0
 1282/    362A :                        								; returns Cb=0 if found
 1283/    362A : 6500 FB24              	BCS		LAB_USER				; go do "Undefined statement" error if not found
 1284/    362E :                        
 1285/    362E :                        LAB_1624
 1286/    362E : 4A20                   	TST.b		-(a0)					; decrement pointer (faster)
 1287/    3630 : 2748 0462              	MOVE.l	a0,Dptrl(a3)			; save DATA pointer
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 26 - 12/13/2023 15:59:9


 1288/    3634 :                        RTS_006
 1289/    3634 : 4E75                   	RTS
 1290/    3636 :                        
 1291/    3636 :                        
 1292/    3636 :                        ;************************************************************************************
 1293/    3636 :                        ;
 1294/    3636 :                        ; perform NULL
 1295/    3636 :                        
 1296/    3636 :                        LAB_NULL
 1297/    3636 : 6100 10E2              	BSR		LAB_GTBY				; get byte parameter, result in d0 and Itemp
 1298/    363A : 1740 05E4              	MOVE.b	d0,Nullct(a3)			; save new NULL count
 1299/    363E : 4E75                   	RTS
 1300/    3640 :                        
 1301/    3640 :                        
 1302/    3640 :                        ;************************************************************************************
 1303/    3640 :                        ;
 1304/    3640 :                        ; perform CONT
 1305/    3640 :                        
 1306/    3640 :                        LAB_CONT
 1307/    3640 : 6600 FB26              	BNE		LAB_SNER				; if following byte exit to do syntax error
 1308/    3644 :                        
 1309/    3644 : 4A2B 0452              	TST.b		Clinel(a3)				; test current line #, is -ve for immediate mode
 1310/    3648 : 6A00 FAE6              	BPL		LAB_CCER				; if running go do can't continue error
 1311/    364C :                        
 1312/    364C : 202B 045A              	MOVE.l	Cpntrl(a3),d0			; get continue pointer
 1313/    3650 : 6700 FADE              	BEQ		LAB_CCER				; go do can't continue error if we can't
 1314/    3654 :                        
 1315/    3654 :                        								; we can continue so ...
 1316/    3654 : 2A40                   	MOVEA.l	d0,a5					; save continue pointer as BASIC execute pointer
 1317/    3656 : 276B 0456 0452         	MOVE.l	Blinel(a3),Clinel(a3)		; set break line as current line
 1318/    365C : 4E75                   	RTS
 1319/    365E :                        
 1320/    365E :                        
 1321/    365E :                        ;************************************************************************************
 1322/    365E :                        ;
 1323/    365E :                        ; perform RUN
 1324/    365E :                        
 1325/    365E :                        LAB_RUN
 1326/    365E : 660C                   	BNE.s		LAB_RUNn				; if following byte do RUN n
 1327/    3660 :                        
 1328/    3660 : 6100 FDAE              	BSR		LAB_1477				; execution to start, clear vars & flush stack
 1329/    3664 : 274D 045A              	MOVE.l	a5,Cpntrl(a3)			; save as continue pointer
 1330/    3668 : 6000 FF22              	BRA		LAB_15C2				; go do interpreter inner loop
 1331/    366C :                        								; (can't RTS, we flushed the stack!)
 1332/    366C :                        
 1333/    366C :                        LAB_RUNn
 1334/    366C : 6100 FDA8              	BSR		LAB_147A				; go do "CLEAR"
 1335/    3670 : 601C                   	BRA.s		LAB_16B0				; get n and do GOTO n
 1336/    3672 :                        
 1337/    3672 :                        
 1338/    3672 :                        ;************************************************************************************
 1339/    3672 :                        ;
 1340/    3672 :                        ; perform DO
 1341/    3672 :                        
 1342/    3672 :                        LAB_DO
 1343/    3672 :                        ;	MOVE.l	#$05,d0				; need 5 bytes for DO
 1344/    3672 :                        ;	BSR.s		LAB_1212				; check room on stack for A bytes
 1345/    3672 : 2F0D                   	MOVE.l	a5,-(sp)				; push BASIC execute pointer on stack
 1346/    3674 : 2F2B 0452              	MOVE.l	Clinel(a3),-(sp)			; push current line on stack
 1347/    3678 : 3F3C 009C              	MOVE.w	#TK_DO,-(sp)			; push token for DO on stack
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 27 - 12/13/2023 15:59:9


 1348/    367C : 487A FF0E              	PEA		LAB_15C2(pc)			; set return address
 1349/    3680 : 6000 072E              	BRA		LAB_GBYT				; scan memory & return to interpreter inner loop
 1350/    3684 :                        
 1351/    3684 :                        
 1352/    3684 :                        ;************************************************************************************
 1353/    3684 :                        ;
 1354/    3684 :                        ; perform GOSUB
 1355/    3684 :                        
 1356/    3684 :                        LAB_GOSUB
 1357/    3684 :                        ;	MOVE.l	#10,d0				; need 10 bytes for GOSUB
 1358/    3684 :                        ;	BSR.s		LAB_1212				; check room on stack for d0 bytes
 1359/    3684 : 2F0D                   	MOVE.l	a5,-(sp)				; push BASIC execute pointer
 1360/    3686 : 2F2B 0452              	MOVE.l	Clinel(a3),-(sp)			; push current line
 1361/    368A : 3F3C 008D              	MOVE.w	#TK_GOSUB,-(sp)			; push token for GOSUB
 1362/    368E :                        LAB_16B0
 1363/    368E : 6100 0720              	BSR		LAB_GBYT				; scan memory
 1364/    3692 : 487A FEF8              	PEA		LAB_15C2(pc)			; return to interpreter inner loop after GOTO n
 1365/    3696 :                        
 1366/    3696 :                        ; this PEA is needed because either we just cleared the stack and have nowhere to return
 1367/    3696 :                        ; to or, in the case of GOSUB, we have just dropped a load on the stack and the address
 1368/    3696 :                        ; we whould have returned to is buried. This burried return address will be unstacked by
 1369/    3696 :                        ; the corresponding RETURN command
 1370/    3696 :                        
 1371/    3696 :                        
 1372/    3696 :                        ;************************************************************************************
 1373/    3696 :                        ;
 1374/    3696 :                        ; perform GOTO
 1375/    3696 :                        
 1376/    3696 :                        LAB_GOTO
 1377/    3696 : 6100 016C              	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
 1378/    369A : 206B 042E              	MOVEA.l	Smeml(a3),a0			; get start of memory
 1379/    369E : B2AB 0452              	CMP.l		Clinel(a3),d1			; compare current line with wanted #
 1380/    36A2 : 630E                   	BLS.s		LAB_16D0				; branch if current # => wanted #
 1381/    36A4 :                        
 1382/    36A4 : 204D                   	MOVEA.l	a5,a0					; copy BASIC execute pointer
 1383/    36A6 :                        LAB_GOTs
 1384/    36A6 : 4A18                   	TST.b		(a0)+					; test next byte & increment pointer
 1385/    36A8 : 66FC                   	BNE.s		LAB_GOTs				; loop if not EOL
 1386/    36AA :                        
 1387/    36AA : 3008                   	MOVE.w	a0,d0					; past pad byte(s)
 1388/    36AC : C07C 0001              	AND.w		#1,d0					; mask odd bit
 1389/    36B0 : D0C0                   	ADD.w		d0,a0					; add to pointer
 1390/    36B2 :                        
 1391/    36B2 :                        LAB_16D0
 1392/    36B2 : 6100 FD3C              	BSR		LAB_SCLN				; search for d1 line number from a0
 1393/    36B6 :                        								; returns Cb=0 if found
 1394/    36B6 : 6500 FA98              	BCS		LAB_USER				; if carry set go do "Undefined statement" error
 1395/    36BA :                        
 1396/    36BA : 2A48                   	MOVEA.l	a0,a5					; copy to basic execute pointer
 1397/    36BC : 534D                   	SUBQ.w	#1,a5					; decrement pointer
 1398/    36BE : 274D 045A              	MOVE.l	a5,Cpntrl(a3)			; save as continue pointer
 1399/    36C2 : 4E75                   	RTS
 1400/    36C4 :                        
 1401/    36C4 :                        
 1402/    36C4 :                        ;************************************************************************************
 1403/    36C4 :                        ;
 1404/    36C4 :                        ; perform LOOP
 1405/    36C4 :                        
 1406/    36C4 :                        LAB_LOOP
 1407/    36C4 : 0C6F 009C 0004         	CMP.w		#TK_DO,4(sp)			; compare token on stack with DO token
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 28 - 12/13/2023 15:59:9


 1408/    36CA : 6600 FA5C              	BNE		LAB_LDER				; branch if no matching DO
 1409/    36CE :                        
 1410/    36CE : 1E00                   	MOVE.b	d0,d7					; copy following token (byte)
 1411/    36D0 : 672E                   	BEQ.s		LoopAlways				; if no following token loop forever
 1412/    36D2 :                        
 1413/    36D2 : BE3C 003A              	CMP.b		#':',d7				; compare with ":"
 1414/    36D6 : 6728                   	BEQ.s		LoopAlways				; if no following token loop forever
 1415/    36D8 :                        
 1416/    36D8 : 9E3C 00B0              	SUB.b		#TK_UNTIL,d7			; subtract token for UNTIL
 1417/    36DC : 6708                   	BEQ.s		DoRest				; branch if was UNTIL
 1418/    36DE :                        
 1419/    36DE : 5307                   	SUBQ.b	#1,d7					; decrement result
 1420/    36E0 : 6600 FA86              	BNE		LAB_SNER				; if not WHILE go do syntax error & warm start
 1421/    36E4 :                        								; only if the token was WHILE will this fail
 1422/    36E4 :                        
 1423/    36E4 : 7EFF                   	MOVEQ		#-1,d7				; set invert result longword
 1424/    36E6 :                        DoRest
 1425/    36E6 : 6100 06C6              	BSR		LAB_IGBY				; increment & scan memory
 1426/    36EA : 6100 0562              	BSR		LAB_EVEX				; evaluate expression
 1427/    36EE : 4A2B 0594              	TST.b		FAC1_e(a3)				; test FAC1 exponent
 1428/    36F2 : 6706                   	BEQ.s		DoCmp					; if = 0 go do straight compare
 1429/    36F4 :                        
 1430/    36F4 : 177C 00FF 0594         	MOVE.b	#$FF,FAC1_e(a3)			; else set all bits
 1431/    36FA :                        DoCmp
 1432/    36FA : BF2B 0594              	EOR.b		d7,FAC1_e(a3)			; EOR with invert byte
 1433/    36FE : 6614                   	BNE.s		LoopDone				; if <> 0 clear stack & back to interpreter loop
 1434/    3700 :                        
 1435/    3700 :                        								; loop condition wasn't met so do it again
 1436/    3700 :                        LoopAlways
 1437/    3700 : 276F 0006 0452         	MOVE.l	6(sp),Clinel(a3)			; copy DO current line
 1438/    3706 : 2A6F 000A              	MOVE.l	10(sp),a5				; save BASIC execute pointer
 1439/    370A :                        
 1440/    370A : 41FA FE80              	LEA		LAB_15C2(pc),a0			; get return address
 1441/    370E : 2E88                   	MOVE.l	a0,(sp)				; dump the call to this routine and set the
 1442/    3710 :                        								; return address
 1443/    3710 : 6000 069E              	BRA		LAB_GBYT				; scan memory and return to interpreter inner
 1444/    3714 :                        								; loop
 1445/    3714 :                        
 1446/    3714 :                        								; clear stack & back to interpreter loop
 1447/    3714 :                        LoopDone
 1448/    3714 : 4FEF 000E              	LEA		14(sp),sp				; dump structure and call from stack
 1449/    3718 : 6014                   	BRA.s		LAB_DATA				; go perform DATA (find : or [EOL])
 1450/    371A :                        
 1451/    371A :                        
 1452/    371A :                        ;************************************************************************************
 1453/    371A :                        ;
 1454/    371A :                        ; perform RETURN
 1455/    371A :                        
 1456/    371A :                        LAB_RETURN
 1457/    371A : 6616                   	BNE.s		RTS_007				; exit if following token to allow syntax error
 1458/    371C :                        
 1459/    371C : 0C6F 008D 0004         	CMP.w		#TK_GOSUB,4(sp)			; compare token from stack with GOSUB
 1460/    3722 : 6600 FA40              	BNE		LAB_RGER				; do RETURN without GOSUB error if no matching
 1461/    3726 :                        								; GOSUB
 1462/    3726 :                        
 1463/    3726 : 5C4F                   	ADDQ.w	#6,sp					; dump calling address & token
 1464/    3728 : 275F 0452              	MOVE.l	(sp)+,Clinel(a3)			; pull current line
 1465/    372C : 2A5F                   	MOVE.l	(sp)+,a5				; pull BASIC execute pointer
 1466/    372E :                        								; now do perform "DATA" statement as we could be
 1467/    372E :                        								; returning into the middle of an ON <var> GOSUB
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 29 - 12/13/2023 15:59:9


 1468/    372E :                        								; n,m,p,q line (the return address used by the
 1469/    372E :                        								; DATA statement is the one pushed before the
 1470/    372E :                        								; GOSUB was executed!)
 1471/    372E :                        
 1472/    372E :                        
 1473/    372E :                        ;************************************************************************************
 1474/    372E :                        ;
 1475/    372E :                        ; perform DATA
 1476/    372E :                        
 1477/    372E :                        LAB_DATA
 1478/    372E : 6104                   	BSR.s		LAB_SNBS				; scan for next BASIC statement ([:] or [EOL])
 1479/    3730 :                        								; returns a0 as pointer to [:] or [EOL]
 1480/    3730 : 2A48                   	MOVEA.l	a0,a5					; skip rest of statement
 1481/    3732 :                        RTS_007
 1482/    3732 : 4E75                   	RTS
 1483/    3734 :                        
 1484/    3734 :                        
 1485/    3734 :                        ;************************************************************************************
 1486/    3734 :                        ;
 1487/    3734 :                        ; scan for next BASIC statement ([:] or [EOL])
 1488/    3734 :                        ; returns a0 as pointer to [:] or [EOL]
 1489/    3734 :                        
 1490/    3734 :                        LAB_SNBS
 1491/    3734 : 204D                   	MOVEA.l	a5,a0					; copy BASIC execute pointer
 1492/    3736 : 7222                   	MOVEQ		#$22,d1				; set string quote character
 1493/    3738 : 743A                   	MOVEQ		#$3A,d2				; set look for character = ":"
 1494/    373A : 6008                   	BRA.s		LAB_172D				; go do search
 1495/    373C :                        
 1496/    373C :                        LAB_172C
 1497/    373C : B400                   	CMP.b		d0,d2					; compare with ":"
 1498/    373E : 6708                   	BEQ.s		RTS_007a				; exit if found
 1499/    3740 :                        
 1500/    3740 : B200                   	CMP.b		d0,d1					; compare with '"'
 1501/    3742 : 670C                   	BEQ.s		LAB_1725				; if found go search for [EOL]
 1502/    3744 :                        
 1503/    3744 :                        LAB_172D
 1504/    3744 : 1018                   	MOVE.b	(a0)+,d0				; get next byte
 1505/    3746 : 66F4                   	BNE.s		LAB_172C				; loop if not null [EOL]
 1506/    3748 :                        
 1507/    3748 :                        RTS_007a
 1508/    3748 : 5348                   	SUBQ.w	#1,a0					; correct pointer
 1509/    374A : 4E75                   	RTS
 1510/    374C :                        
 1511/    374C :                        LAB_1723
 1512/    374C : B200                   	CMP.b		d0,d1					; compare with '"'
 1513/    374E : 67F4                   	BEQ.s		LAB_172D				; if found go search for ":" or [EOL]
 1514/    3750 :                        
 1515/    3750 :                        LAB_1725
 1516/    3750 : 1018                   	MOVE.b	(a0)+,d0				; get next byte
 1517/    3752 : 66F8                   	BNE.s		LAB_1723				; loop if not null [EOL]
 1518/    3754 :                        
 1519/    3754 : 60F2                   	BRA.s		RTS_007a				; correct pointer & return
 1520/    3756 :                        
 1521/    3756 :                        
 1522/    3756 :                        ;************************************************************************************
 1523/    3756 :                        ;
 1524/    3756 :                        ; perform IF
 1525/    3756 :                        
 1526/    3756 :                        LAB_IF
 1527/    3756 : 6100 04F6              	BSR		LAB_EVEX				; evaluate expression
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 30 - 12/13/2023 15:59:9


 1528/    375A : 6100 0654              	BSR		LAB_GBYT				; scan memory
 1529/    375E : B03C 00AD              	CMP.b		#TK_THEN,d0				; compare with THEN token
 1530/    3762 : 6714                   	BEQ.s		LAB_174B				; if it was THEN then continue
 1531/    3764 :                        
 1532/    3764 :                        								; wasn't IF .. THEN so must be IF .. GOTO
 1533/    3764 : B03C 0089              	CMP.b		#TK_GOTO,d0				; compare with GOTO token
 1534/    3768 : 6600 F9FE              	BNE		LAB_SNER				; if not GOTO token do syntax error/warm start
 1535/    376C :                        
 1536/    376C :                        								; was GOTO so check for GOTO <n>
 1537/    376C : 204D                   	MOVE.l	a5,a0					; save the execute pointer
 1538/    376E : 6100 063E              	BSR		LAB_IGBY				; scan memory, test for a numeric character
 1539/    3772 : 2A48                   	MOVE.l	a0,a5					; restore the execute pointer
 1540/    3774 : 6400 F9F2              	BCC		LAB_SNER				; if not numeric do syntax error/warm start
 1541/    3778 :                        
 1542/    3778 :                        LAB_174B
 1543/    3778 : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
 1544/    377C : 671E                   	BEQ.s		LAB_174E				; if result was zero go look for an ELSE
 1545/    377E :                        
 1546/    377E : 6100 062E              	BSR		LAB_IGBY				; increment & scan memory
 1547/    3782 : 6500 FF12              	BCS		LAB_GOTO				; if numeric do GOTO n
 1548/    3786 :                        								; a GOTO <n> will never return to the IF
 1549/    3786 :                        								; statement so there is no need to return
 1550/    3786 :                        								; to this code
 1551/    3786 :                        
 1552/    3786 : B03C 008E              	CMP.b		#TK_RETURN,d0			; compare with RETURN token
 1553/    378A : 6700 FE1E              	BEQ		LAB_1602				; if RETURN then interpret BASIC code from (a5)
 1554/    378E :                        								; and don't return here
 1555/    378E :                        
 1556/    378E : 6100 FE16              	BSR		LAB_15FF				; else interpret BASIC code from (a5)
 1557/    3792 :                        
 1558/    3792 :                        ; the IF was executed and there may be a following ELSE so the code needs to return
 1559/    3792 :                        ; here to check and ignore the ELSE if present
 1560/    3792 :                        
 1561/    3792 : 1015                   	MOVE.b	(a5),d0				; get the next basic byte
 1562/    3794 : B03C 00A9              	CMP.b		#TK_ELSE,d0				; compare it with the token for ELSE
 1563/    3798 : 6794                   	BEQ		LAB_DATA				; if ELSE ignore the following statement
 1564/    379A :                        
 1565/    379A :                        ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
 1566/    379A :                        ; following ELSE will, correctly, cause a syntax error
 1567/    379A :                        
 1568/    379A : 4E75                   	RTS							; else return to interpreter inner loop
 1569/    379C :                        
 1570/    379C :                        ; perform ELSE after IF
 1571/    379C :                        
 1572/    379C :                        LAB_174E
 1573/    379C : 101D                   	MOVE.b	(a5)+,d0				; faster increment past THEN
 1574/    379E : 163C 00A9              	MOVE.b		#TK_ELSE,d3				; set search for ELSE token
 1575/    37A2 : 183C 008B              	MOVE.b		#TK_IF,d4				; set search for IF token
 1576/    37A6 : 7A00                   	MOVEQ		#0,d5					; clear the nesting depth
 1577/    37A8 :                        LAB_1750
 1578/    37A8 : 101D                   	MOVE.b	(a5)+,d0				; get next BASIC byte & increment ptr
 1579/    37AA : 6720                   	BEQ.s		LAB_1754				; if EOL correct the pointer and return
 1580/    37AC :                        
 1581/    37AC : B004                   	CMP.b		d4,d0					; compare with "IF" token
 1582/    37AE : 6604                   	BNE.s		LAB_1752				; skip if not nested IF
 1583/    37B0 :                        
 1584/    37B0 : 5245                   	ADDQ.w	#1,d5					; else increment the nesting depth ..
 1585/    37B2 : 60F4                   	BRA.s		LAB_1750				; .. and continue looking
 1586/    37B4 :                        
 1587/    37B4 :                        LAB_1752
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 31 - 12/13/2023 15:59:9


 1588/    37B4 : B003                   	CMP.b		d3,d0					; compare with ELSE token
 1589/    37B6 : 66F0                   	BNE.s		LAB_1750				; if not ELSE continue looking
 1590/    37B8 :                        
 1591/    37B8 :                        LAB_1756
 1592/    37B8 : 51CD FFEE              	DBF		d5,LAB_1750				; loop if still nested
 1593/    37BC :                        
 1594/    37BC :                        ; found the matching ELSE, now do <{n|statement}>
 1595/    37BC :                        
 1596/    37BC : 6100 05F2              	BSR		LAB_GBYT				; scan memory
 1597/    37C0 : 6500 FED4              	BCS		LAB_GOTO				; if numeric do GOTO n
 1598/    37C4 :                        								; code will return to the interpreter loop
 1599/    37C4 :                        								; at the tail end of the GOTO <n>
 1600/    37C4 :                        
 1601/    37C4 : 6000 FDE0              	BRA		LAB_15FF				; else interpret BASIC code from (a5)
 1602/    37C8 :                        								; code will return to the interpreter loop
 1603/    37C8 :                        								; at the tail end of the <statement>
 1604/    37C8 :                        
 1605/    37C8 :                        
 1606/    37C8 :                        ;************************************************************************************
 1607/    37C8 :                        ;
 1608/    37C8 :                        ; perform REM, skip (rest of) line
 1609/    37C8 :                        
 1610/    37C8 :                        LAB_REM
 1611/    37C8 : 4A1D                   	TST.b		(a5)+					; test byte & increment pointer
 1612/    37CA : 66FC                   	BNE.s		LAB_REM				; loop if not EOL
 1613/    37CC :                        
 1614/    37CC :                        LAB_1754
 1615/    37CC : 534D                   	SUBQ.w	#1,a5					; correct the execute pointer
 1616/    37CE : 4E75                   	RTS
 1617/    37D0 :                        
 1618/    37D0 :                        
 1619/    37D0 :                        ;************************************************************************************
 1620/    37D0 :                        ;
 1621/    37D0 :                        ; perform ON
 1622/    37D0 :                        
 1623/    37D0 :                        LAB_ON
 1624/    37D0 : 6100 0F48              	BSR		LAB_GTBY				; get byte parameter, result in d0 and Itemp
 1625/    37D4 : 1400                   	MOVE.b	d0,d2					; copy byte
 1626/    37D6 : 6100 05D8              	BSR		LAB_GBYT				; restore BASIC byte
 1627/    37DA : 3F00                   	MOVE.w	d0,-(sp)				; push GOTO/GOSUB token
 1628/    37DC : B03C 008D              	CMP.b		#TK_GOSUB,d0			; compare with GOSUB token
 1629/    37E0 : 6708                   	BEQ.s		LAB_176C				; branch if GOSUB
 1630/    37E2 :                        
 1631/    37E2 : B03C 0089              	CMP.b		#TK_GOTO,d0				; compare with GOTO token
 1632/    37E6 : 6600 F980              	BNE		LAB_SNER				; if not GOTO do syntax error, then warm start
 1633/    37EA :                        
 1634/    37EA :                        ; next character was GOTO or GOSUB
 1635/    37EA :                        
 1636/    37EA :                        LAB_176C
 1637/    37EA : 5302                   	SUBQ.b	#1,d2					; decrement index (byte value)
 1638/    37EC : 6606                   	BNE.s		LAB_1773				; branch if not zero
 1639/    37EE :                        
 1640/    37EE : 301F                   	MOVE.w	(sp)+,d0				; pull GOTO/GOSUB token
 1641/    37F0 : 6000 FDB8              	BRA		LAB_1602				; go execute it
 1642/    37F4 :                        
 1643/    37F4 :                        LAB_1773
 1644/    37F4 : 6100 05B8              	BSR		LAB_IGBY				; increment & scan memory
 1645/    37F8 : 610A                   	BSR.s		LAB_GFPN				; get fixed-point number into temp integer & d1
 1646/    37FA :                        								; (skip this n)
 1647/    37FA : B03C 002C              	CMP.b		#$2C,d0				; compare next character with ","
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 32 - 12/13/2023 15:59:9


 1648/    37FE : 67EA                   	BEQ.s		LAB_176C				; loop if ","
 1649/    3800 :                        
 1650/    3800 : 301F                   	MOVE.w	(sp)+,d0				; pull GOTO/GOSUB token (run out of options)
 1651/    3802 : 4E75                   	RTS							; and exit
 1652/    3804 :                        
 1653/    3804 :                        
 1654/    3804 :                        ;************************************************************************************
 1655/    3804 :                        ;
 1656/    3804 :                        ; get fixed-point number into temp integer & d1
 1657/    3804 :                        ; interpret number from (a5), leave (a5) pointing to byte after #
 1658/    3804 :                        
 1659/    3804 :                        LAB_GFPN
 1660/    3804 : 7200                   	MOVEQ		#$00,d1				; clear integer register
 1661/    3806 : 2001                   	MOVE.l	d1,d0					; clear d0
 1662/    3808 : 6100 05A6              	BSR		LAB_GBYT				; scan memory, Cb=1 if "0"-"9", & get byte
 1663/    380C : 642E                   	BCC.s		LAB_1786				; return if carry clear, chr was not "0"-"9"
 1664/    380E :                        
 1665/    380E : 2F02                   	MOVE.l	d2,-(sp)				; save d2
 1666/    3810 :                        LAB_1785
 1667/    3810 : 2401                   	MOVE.l	d1,d2					; copy integer register
 1668/    3812 : D281                   	ADD.l		d1,d1					; *2
 1669/    3814 : 6500 F952              	BCS		LAB_SNER				; if overflow do syntax error, then warm start
 1670/    3818 :                        
 1671/    3818 : D281                   	ADD.l		d1,d1					; *4
 1672/    381A : 6500 F94C              	BCS		LAB_SNER				; if overflow do syntax error, then warm start
 1673/    381E :                        
 1674/    381E : D282                   	ADD.l		d2,d1					; *1 + *4
 1675/    3820 : 6500 F946              	BCS		LAB_SNER				; if overflow do syntax error, then warm start
 1676/    3824 :                        
 1677/    3824 : D281                   	ADD.l		d1,d1					; *10
 1678/    3826 : 6500 F940              	BCS		LAB_SNER				; if overflow do syntax error, then warm start
 1679/    382A :                        
 1680/    382A : 903C 0030              	SUB.b		#$30,d0				; subtract $30 from byte
 1681/    382E : D280                   	ADD.l		d0,d1					; add to integer register, the top 24 bits are
 1682/    3830 :                        								; always clear
 1683/    3830 : 6900 F936              	BVS		LAB_SNER				; if overflow do syntax error, then warm start
 1684/    3834 :                        								; this makes the maximum line number 2147483647
 1685/    3834 : 6100 0578              	BSR		LAB_IGBY				; increment & scan memory
 1686/    3838 : 65D6                   	BCS.s		LAB_1785				; loop for next character if "0"-"9"
 1687/    383A :                        
 1688/    383A : 241F                   	MOVE.l	(sp)+,d2				; restore d2
 1689/    383C :                        LAB_1786
 1690/    383C : 2741 042A              	MOVE.l	d1,Itemp(a3)			; save Itemp
 1691/    3840 : 4E75                   	RTS
 1692/    3842 :                        
 1693/    3842 :                        
 1694/    3842 :                        ;************************************************************************************
 1695/    3842 :                        ;
 1696/    3842 :                        ; perform DEC
 1697/    3842 :                        
 1698/    3842 :                        LAB_DEC
 1699/    3842 : 3F3C 8180              	MOVE.w	#$8180,-(sp)			; set -1 sign/exponent
 1700/    3846 : 600A                   	BRA.s		LAB_17B7				; go do DEC
 1701/    3848 :                        
 1702/    3848 :                        
 1703/    3848 :                        ;************************************************************************************
 1704/    3848 :                        ;
 1705/    3848 :                        ; perform INC
 1706/    3848 :                        
 1707/    3848 :                        LAB_INC
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 33 - 12/13/2023 15:59:9


 1708/    3848 : 3F3C 8100              	MOVE.w	#$8100,-(sp)			; set 1 sign/exponent
 1709/    384C : 6004                   	BRA.s		LAB_17B7				; go do INC
 1710/    384E :                        
 1711/    384E :                        								; was "," so another INCR variable to do
 1712/    384E :                        LAB_17B8
 1713/    384E : 6100 055E              	BSR		LAB_IGBY				; increment and scan memory
 1714/    3852 :                        LAB_17B7
 1715/    3852 : 6100 076C              	BSR		LAB_GVAR				; get variable address in a0
 1716/    3856 :                        
 1717/    3856 : 6732                   	BEQ.s		LAB_INCT				; if variable not found skip the inc/dec
 1718/    3858 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
 1719/    385C :                        								; $00=float
 1720/    385C : 6B00 F8DE              	BMI		LAB_TMER				; if string do "Type mismatch" error/warm start
 1721/    3860 :                        
 1722/    3860 : 6636                   	BNE.s		LAB_INCI				; go do integer INC/DEC
 1723/    3862 :                        
 1724/    3862 : 2748 0472              	MOVE.l	a0,Lvarpl(a3)			; save var address
 1725/    3866 : 6100 130E              	BSR		LAB_UFAC				; unpack memory (a0) into FAC1
 1726/    386A : 277C 8000 0000 0598    	MOVE.l	#$80000000,FAC2_m(a3)		; set FAC2 mantissa for 1
 1727/    3872 : 3017                   	MOVE.w	(sp),d0				; move exponent & sign to d0
 1728/    3874 : 3740 059C              	MOVE.w	d0,FAC2_e(a3)			; move exponent & sign to FAC2
 1729/    3878 : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; make sign compare = FAC1 sign
 1730/    387E : B12B 059E              	EOR.b		d0,FAC_sc(a3)			; make sign compare (FAC1_s EOR FAC2_s)
 1731/    3882 : 6100 100E              	BSR		LAB_ADD				; add FAC2 to FAC1
 1732/    3886 : 6100 130A              	BSR		LAB_PFAC				; pack FAC1 into variable (Lvarpl)
 1733/    388A :                        LAB_INCT
 1734/    388A : 6100 0524              	BSR		LAB_GBYT				; scan memory
 1735/    388E : 0C00 002C              	CMPI.b	#$2C,d0				; compare with ","
 1736/    3892 : 67BA                   	BEQ.s		LAB_17B8				; continue if "," (another variable to do)
 1737/    3894 :                        
 1738/    3894 : 544F                   	ADDQ.w	#2,sp					; else dump sign & exponent
 1739/    3896 : 4E75                   	RTS
 1740/    3898 :                        
 1741/    3898 :                        LAB_INCI
 1742/    3898 : 4A2F 0001              	TST.b		1(sp)					; test sign
 1743/    389C : 6604                   	BNE.s		LAB_DECI				; branch if DEC
 1744/    389E :                        
 1745/    389E : 5290                   	ADDQ.l	#1,(a0)				; increment variable
 1746/    38A0 : 60E8                   	BRA.s		LAB_INCT				; go scan for more
 1747/    38A2 :                        
 1748/    38A2 :                        LAB_DECI
 1749/    38A2 : 5390                   	SUBQ.l	#1,(a0)				; decrement variable
 1750/    38A4 : 60E4                   	BRA.s		LAB_INCT				; go scan for more
 1751/    38A6 :                        
 1752/    38A6 :                        
 1753/    38A6 :                        ;************************************************************************************
 1754/    38A6 :                        ;
 1755/    38A6 :                        ; perform LET
 1756/    38A6 :                        
 1757/    38A6 :                        LAB_LET
 1758/    38A6 : 6100 0714              	BSR		LAB_SVAR				; search for or create a variable
 1759/    38AA :                        								; return the variable address in a0
 1760/    38AA : 2748 0472              	MOVE.l	a0,Lvarpl(a3)			; save variable address
 1761/    38AE : 1F2B 05B5              	MOVE.b	Dtypef(a3),-(sp)			; push var data type, $80=string, $40=integer,
 1762/    38B2 :                        								; $00=float
 1763/    38B2 : 70BD                   	MOVEQ		#TK_EQUAL-$100,d0			; get = token
 1764/    38B4 : 6100 04F0              	BSR		LAB_SCCA				; scan for CHR$(d0), else do syntax error/warm
 1765/    38B8 :                        								; start
 1766/    38B8 : 6100 0394              	BSR		LAB_EVEX				; evaluate expression
 1767/    38BC : 102B 05B5              	MOVE.b	Dtypef(a3),d0			; copy expression data type
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 34 - 12/13/2023 15:59:9


 1768/    38C0 : 175F 05B5              	MOVE.b	(sp)+,Dtypef(a3)			; pop variable data type
 1769/    38C4 : E318                   	ROL.b		#1,d0					; set carry if expression type = string
 1770/    38C6 : 6100 0372              	BSR		LAB_CKTM				; type match check, set C for string
 1771/    38CA : 6700 12C6              	BEQ		LAB_PFAC				; if number pack FAC1 into variable Lvarpl & RET
 1772/    38CE :                        
 1773/    38CE :                        ; string LET
 1774/    38CE :                        
 1775/    38CE :                        LAB_17D5
 1776/    38CE : 246B 0472              	MOVEA.l	Lvarpl(a3),a2			; get pointer to variable
 1777/    38D2 :                        LAB_17D6
 1778/    38D2 : 206B 0590              	MOVEA.l	FAC1_m(a3),a0			; get descriptor pointer
 1779/    38D6 : 2250                   	MOVEA.l	(a0),a1				; get string pointer
 1780/    38D8 : B3EB 0446              	CMP.l		Sstorl(a3),a1			; compare string memory start with string
 1781/    38DC :                        								; pointer
 1782/    38DC : 6516                   	BCS.s		LAB_1811				; if it was in program memory assign the value
 1783/    38DE :                        								; and exit
 1784/    38DE :                        
 1785/    38DE : B1EB 0432              	CMPA.l	Sfncl(a3),a0			; compare functions start with descriptor
 1786/    38E2 :                        								; pointer
 1787/    38E2 : 6510                   	BCS.s		LAB_1811				; branch if >= (string is on stack)
 1788/    38E4 :                        
 1789/    38E4 :                        								; string is variable$ make space and copy string
 1790/    38E4 :                        LAB_1810
 1791/    38E4 : 7200                   	MOVEQ		#0,d1					; clear length
 1792/    38E6 : 3228 0004              	MOVE.w	4(a0),d1				; get string length
 1793/    38EA : 2050                   	MOVEA.l	(a0),a0				; get string pointer
 1794/    38EC : 6100 0B06              	BSR		LAB_20C9				; copy string
 1795/    38F0 : 206B 0590              	MOVEA.l	FAC1_m(a3),a0			; get descriptor pointer back
 1796/    38F4 :                        								; clean stack & assign value to string variable
 1797/    38F4 :                        LAB_1811
 1798/    38F4 : B9C8                   	CMPA.l	a0,a4					; is string on the descriptor stack
 1799/    38F6 : 6602                   	BNE.s		LAB_1813				; skip pop if not
 1800/    38F8 :                        
 1801/    38F8 : 5C4C                   	ADDQ.w	#$06,a4				; else update stack pointer
 1802/    38FA :                        LAB_1813
 1803/    38FA : 24D8                   	MOVE.l	(a0)+,(a2)+				; save pointer to variable
 1804/    38FC : 3490                   	MOVE.w	(a0),(a2)				; save length to variable
 1805/    38FE :                        RTS_008
 1806/    38FE : 4E75                   	RTS
 1807/    3900 :                        
 1808/    3900 :                        
 1809/    3900 :                        ;************************************************************************************
 1810/    3900 :                        ;
 1811/    3900 :                        ; perform GET
 1812/    3900 :                        
 1813/    3900 :                        LAB_GET
 1814/    3900 : 6100 06BA              	BSR		LAB_SVAR				; search for or create a variable
 1815/    3904 :                        								; return the variable address in a0
 1816/    3904 : 2748 0472              	MOVE.l	a0,Lvarpl(a3)			; save variable address as GET variable
 1817/    3908 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
 1818/    390C :                        								; $00=float
 1819/    390C : 6B0C                   	BMI.s		LAB_GETS				; go get string character
 1820/    390E :                        
 1821/    390E :                        								; was numeric get
 1822/    390E : 6100 1DF2              	BSR		INGET					; get input byte
 1823/    3912 : 6100 09BC              	BSR		LAB_1FD0				; convert d0 to unsigned byte in FAC1
 1824/    3916 : 6000 127A              	BRA		LAB_PFAC				; pack FAC1 into variable (Lvarpl) & return
 1825/    391A :                        
 1826/    391A :                        LAB_GETS
 1827/    391A : 7200                   	MOVEQ		#$00,d1				; assume no byte
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 35 - 12/13/2023 15:59:9


 1828/    391C : 2041                   	MOVE.l	d1,a0					; assume null string
 1829/    391E : 6100 1DE2              	BSR		INGET					; get input byte
 1830/    3922 : 6408                   	BCC.s		LAB_NoSt				; branch if no byte received
 1831/    3924 :                        
 1832/    3924 : 7201                   	MOVEQ		#$01,d1				; string is single byte
 1833/    3926 : 6100 0AFE              	BSR		LAB_2115				; make string space d1 bytes long
 1834/    392A :                        								; return a0 = pointer, other registers unchanged
 1835/    392A :                        
 1836/    392A : 1080                   	MOVE.b	d0,(a0)				; save byte in string (byte IS string!)
 1837/    392C :                        LAB_NoSt
 1838/    392C : 6100 0ADE              	BSR		LAB_RTST				; push string on descriptor stack
 1839/    3930 :                        								; a0 = pointer, d1 = length
 1840/    3930 :                        
 1841/    3930 : 609C                   	BRA.s		LAB_17D5				; do string LET & return
 1842/    3932 :                        
 1843/    3932 :                        
 1844/    3932 :                        ;************************************************************************************
 1845/    3932 :                        ;
 1846/    3932 :                        ; PRINT
 1847/    3932 :                        
 1848/    3932 :                        LAB_1829
 1849/    3932 : 6100 00B4              	BSR		LAB_18C6				; print string from stack
 1850/    3936 :                        LAB_182C
 1851/    3936 : 6100 0478              	BSR		LAB_GBYT				; scan memory
 1852/    393A :                        
 1853/    393A :                        ; perform PRINT
 1854/    393A :                        
 1855/    393A :                        LAB_PRINT
 1856/    393A : 674A                   	BEQ.s		LAB_CRLF				; if nothing following just print CR/LF
 1857/    393C :                        
 1858/    393C :                        LAB_1831
 1859/    393C : B03C 00A8              	CMP.b		#TK_TAB,d0				; compare with TAB( token
 1860/    3940 : 6764                   	BEQ.s		LAB_18A2				; go do TAB/SPC
 1861/    3942 :                        
 1862/    3942 : B03C 00AC              	CMP.b		#TK_SPC,d0				; compare with SPC( token
 1863/    3946 : 675E                   	BEQ.s		LAB_18A2				; go do TAB/SPC
 1864/    3948 :                        
 1865/    3948 : B03C 002C              	CMP.b		#',',d0				; compare with ","
 1866/    394C : 6740                   	BEQ.s		LAB_188B				; go do move to next TAB mark
 1867/    394E :                        
 1868/    394E : B03C 003B              	CMP.b		#';',d0				; compare with ";"
 1869/    3952 : 6700 0086              	BEQ		LAB_18BD				; if ";" continue with PRINT processing
 1870/    3956 :                        
 1871/    3956 : 6100 02F6              	BSR		LAB_EVEX				; evaluate expression
 1872/    395A : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
 1873/    395E :                        								; $00=float
 1874/    395E : 6BD2                   	BMI.s		LAB_1829				; branch if string
 1875/    3960 :                        
 1876/    3960 :                        ; replace the two lines above with this code
 1877/    3960 :                        
 1878/    3960 :                        ;	MOVE.b	Dtypef(a3),d0			; get data type flag, $80=string, $00=numeric
 1879/    3960 :                        ;	BMI.s		LAB_1829				; branch if string
 1880/    3960 :                        
 1881/    3960 : 6100 13B2              	BSR		LAB_2970				; convert FAC1 to string
 1882/    3964 : 6100 0A60              	BSR		LAB_20AE				; print " terminated string to FAC1 stack
 1883/    3968 :                        
 1884/    3968 :                        ; don't check fit if terminal width byte is zero
 1885/    3968 :                        
 1886/    3968 : 7000                   	MOVEQ		#0,d0					; clear d0
 1887/    396A : 102B 05E6              	MOVE.b	TWidth(a3),d0			; get terminal width byte
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 36 - 12/13/2023 15:59:9


 1888/    396E : 670C                   	BEQ.s		LAB_185E				; skip check if zero
 1889/    3970 :                        
 1890/    3970 : 902C 0007              	SUB.b		7(a4),d0				; subtract string length
 1891/    3974 : 902B 05E5              	SUB.b		TPos(a3),d0				; subtract terminal position
 1892/    3978 : 6402                   	BCC		LAB_185E				; branch if less than terminal width
 1893/    397A :                        
 1894/    397A : 610A                   	BSR.s		LAB_CRLF				; else print CR/LF
 1895/    397C :                        LAB_185E
 1896/    397C : 616A                   	BSR.s		LAB_18C6				; print string from stack
 1897/    397E : 60B6                   	BRA.s		LAB_182C				; always go continue processing line
 1898/    3980 :                        
 1899/    3980 :                        
 1900/    3980 :                        ;************************************************************************************
 1901/    3980 :                        ;
 1902/    3980 :                        ; CR/LF return to BASIC from BASIC input handler
 1903/    3980 :                        ; leaves a0 pointing to the buffer start
 1904/    3980 :                        
 1905/    3980 :                        LAB_1866
 1906/    3980 : 11BC 0000 1000         	MOVE.b	#$00,(a0,d1.w)			; null terminate input
 1907/    3986 :                        
 1908/    3986 :                        ; print CR/LF
 1909/    3986 :                        
 1910/    3986 :                        LAB_CRLF
 1911/    3986 : 700D                   	MOVEQ		#$0D,d0				; load [CR]
 1912/    3988 : 6174                   	BSR.s		LAB_PRNA				; go print the character
 1913/    398A : 700A                   	MOVEQ		#$0A,d0				; load [LF]
 1914/    398C : 6070                   	BRA.s		LAB_PRNA				; go print the character & return
 1915/    398E :                        
 1916/    398E :                        LAB_188B
 1917/    398E : 142B 05E5              	MOVE.b	TPos(a3),d2				; get terminal position
 1918/    3992 : B42B 05E7              	CMP.b		Iclim(a3),d2			; compare with input column limit
 1919/    3996 : 6504                   	BCS.s		LAB_1898				; branch if less than Iclim
 1920/    3998 :                        
 1921/    3998 : 61EC                   	BSR.s		LAB_CRLF				; else print CR/LF (next line)
 1922/    399A : 603E                   	BRA.s		LAB_18BD				; continue with PRINT processing
 1923/    399C :                        
 1924/    399C :                        LAB_1898
 1925/    399C : 942B 05E2              	SUB.b		TabSiz(a3),d2			; subtract TAB size
 1926/    39A0 : 64FA                   	BCC.s		LAB_1898				; loop if result was >= 0
 1927/    39A2 :                        
 1928/    39A2 : 4402                   	NEG.b		d2					; twos complement it
 1929/    39A4 : 6022                   	BRA.s		LAB_18B7				; print d2 spaces
 1930/    39A6 :                        
 1931/    39A6 :                        								; do TAB/SPC
 1932/    39A6 :                        LAB_18A2
 1933/    39A6 : 3F00                   	MOVE.w	d0,-(sp)				; save token
 1934/    39A8 : 6100 0D6C              	BSR		LAB_SGBY				; increment and get byte, result in d0 and Itemp
 1935/    39AC : 3400                   	MOVE.w	d0,d2					; copy byte
 1936/    39AE : 6100 0400              	BSR		LAB_GBYT				; get basic byte back
 1937/    39B2 : B03C 0029              	CMP.b		#$29,d0				; is next character ")"
 1938/    39B6 : 6600 F7B0              	BNE		LAB_SNER				; if not do syntax error, then warm start
 1939/    39BA :                        
 1940/    39BA : 301F                   	MOVE.w	(sp)+,d0				; get token back
 1941/    39BC : B03C 00A8              	CMP.b		#TK_TAB,d0				; was it TAB ?
 1942/    39C0 : 6606                   	BNE.s		LAB_18B7				; branch if not (was SPC)
 1943/    39C2 :                        
 1944/    39C2 :                        								; calculate TAB offset
 1945/    39C2 : 942B 05E5              	SUB.b		TPos(a3),d2				; subtract terminal position
 1946/    39C6 : 6312                   	BLS.s		LAB_18BD				; branch if result was <= 0
 1947/    39C8 :                        								; can't TAB backwards or already there
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 37 - 12/13/2023 15:59:9


 1948/    39C8 :                        
 1949/    39C8 :                        								; print d2.b spaces
 1950/    39C8 :                        LAB_18B7
 1951/    39C8 : 7000                   	MOVEQ		#0,d0					; clear longword
 1952/    39CA : 5300                   	SUBQ.b	#1,d0					; make d0 = $FF
 1953/    39CC : C480                   	AND.l		d0,d2					; mask for byte only
 1954/    39CE : 670A                   	BEQ.s		LAB_18BD				; branch if zero
 1955/    39D0 :                        
 1956/    39D0 : 7020                   	MOVEQ		#$20,d0				; load " "
 1957/    39D2 : 5302                   	SUBQ.b	#1,d2					; adjust for DBF loop
 1958/    39D4 :                        LAB_18B8
 1959/    39D4 : 6128                   	BSR.s		LAB_PRNA				; go print
 1960/    39D6 : 51CA FFFC              	DBF		d2,LAB_18B8				; decrement count and loop if not all done
 1961/    39DA :                        
 1962/    39DA :                        								; continue with PRINT processing
 1963/    39DA :                        LAB_18BD
 1964/    39DA : 6100 03D2              	BSR		LAB_IGBY				; increment & scan memory
 1965/    39DE : 6600 FF5C              	BNE		LAB_1831				; if byte continue executing PRINT
 1966/    39E2 :                        
 1967/    39E2 : 4E75                   	RTS							; exit if nothing more to print
 1968/    39E4 :                        
 1969/    39E4 :                        
 1970/    39E4 :                        ;************************************************************************************
 1971/    39E4 :                        ;
 1972/    39E4 :                        ; print null terminated string from a0
 1973/    39E4 :                        
 1974/    39E4 :                        LAB_18C3
 1975/    39E4 : 6100 09E0              	BSR		LAB_20AE				; print terminated string to FAC1/stack
 1976/    39E8 :                        
 1977/    39E8 :                        ; print string from stack
 1978/    39E8 :                        
 1979/    39E8 :                        LAB_18C6
 1980/    39E8 : 6100 0BD0              	BSR		LAB_22B6				; pop string off descriptor stack or from memory
 1981/    39EC :                        								; returns with d0 = length, a0 = pointer
 1982/    39EC : 670C                   	BEQ.s		RTS_009				; exit (RTS) if null string
 1983/    39EE :                        
 1984/    39EE : 3200                   	MOVE.w	d0,d1					; copy length & set Z flag
 1985/    39F0 : 5341                   	SUBQ.w	#1,d1					; -1 for BF loop
 1986/    39F2 :                        LAB_18CD
 1987/    39F2 : 1018                   	MOVE.b	(a0)+,d0				; get byte from string
 1988/    39F4 : 6108                   	BSR.s		LAB_PRNA				; go print the character
 1989/    39F6 : 51C9 FFFA              	DBF		d1,LAB_18CD				; decrement count and loop if not done yet
 1990/    39FA :                        
 1991/    39FA :                        RTS_009
 1992/    39FA : 4E75                   	RTS
 1993/    39FC :                        
 1994/    39FC :                        
 1995/    39FC :                        ;************************************************************************************
 1996/    39FC :                        ;
 1997/    39FC :                        ; print "?" character
 1998/    39FC :                        
 1999/    39FC :                        LAB_18E3
 2000/    39FC : 703F                   	MOVEQ		#$3F,d0				; load "?" character
 2001/    39FE :                        
 2002/    39FE :                        
 2003/    39FE :                        ;************************************************************************************
 2004/    39FE :                        ;
 2005/    39FE :                        ; print character in d0, includes the null handler and infinite line length code
 2006/    39FE :                        ; changes no registers
 2007/    39FE :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 38 - 12/13/2023 15:59:9


 2008/    39FE :                        LAB_PRNA
 2009/    39FE : 2F01                   	MOVE.l	d1,-(sp)				; save d1
 2010/    3A00 : B03C 0020              	CMP.b		#$20,d0				; compare with " "
 2011/    3A04 : 6528                   	BCS.s		LAB_18F9				; branch if less, non printing character
 2012/    3A06 :                        
 2013/    3A06 :                        								; don't check fit if terminal width byte is zero
 2014/    3A06 : 122B 05E6              	MOVE.b	TWidth(a3),d1			; get terminal width
 2015/    3A0A : 6610                   	BNE.s		LAB_18F0				; branch if not zero (not infinite length)
 2016/    3A0C :                        
 2017/    3A0C :                        								; is "infinite line" so check TAB position
 2018/    3A0C : 122B 05E5              	MOVE.b	TPos(a3),d1				; get position
 2019/    3A10 : 922B 05E2              	SUB.b		TabSiz(a3),d1			; subtract TAB size
 2020/    3A14 : 6614                   	BNE.s		LAB_18F7				; skip reset if different
 2021/    3A16 :                        
 2022/    3A16 : 1741 05E5              	MOVE.b	d1,TPos(a3)				; else reset position
 2023/    3A1A : 600E                   	BRA.s		LAB_18F7				; go print character
 2024/    3A1C :                        
 2025/    3A1C :                        LAB_18F0
 2026/    3A1C : B22B 05E5              	CMP.b		TPos(a3),d1				; compare with terminal character position
 2027/    3A20 : 6608                   	BNE.s		LAB_18F7				; branch if not at end of line
 2028/    3A22 :                        
 2029/    3A22 : 2F00                   	MOVE.l	d0,-(sp)				; save d0
 2030/    3A24 : 6100 FF60              	BSR		LAB_CRLF				; else print CR/LF
 2031/    3A28 : 201F                   	MOVE.l	(sp)+,d0				; restore d0
 2032/    3A2A :                        LAB_18F7
 2033/    3A2A : 522B 05E5              	ADDQ.b	#$01,TPos(a3)			; increment terminal position
 2034/    3A2E :                        LAB_18F9
 2035/    3A2E : 4EAB 0412              	JSR		V_OUTP(a3)				; output byte via output vector
 2036/    3A32 : B03C 000D              	CMP.b		#$0D,d0				; compare with [CR]
 2037/    3A36 : 6618                   	BNE.s		LAB_188A				; branch if not [CR]
 2038/    3A38 :                        
 2039/    3A38 :                        								; else print nullct nulls after the [CR]
 2040/    3A38 : 7200                   	MOVEQ		#$00,d1				; clear d1
 2041/    3A3A : 122B 05E4              	MOVE.b	Nullct(a3),d1			; get null count
 2042/    3A3E : 670C                   	BEQ.s		LAB_1886				; branch if no nulls
 2043/    3A40 :                        
 2044/    3A40 : 7000                   	MOVEQ		#$00,d0				; load [NULL]
 2045/    3A42 :                        LAB_1880
 2046/    3A42 : 4EAB 0412              	JSR		V_OUTP(a3)				; go print the character
 2047/    3A46 : 51C9 FFFA              	DBF		d1,LAB_1880				; decrement count and loop if not all done
 2048/    3A4A :                        
 2049/    3A4A : 700D                   	MOVEQ		#$0D,d0				; restore the character
 2050/    3A4C :                        LAB_1886
 2051/    3A4C : 1741 05E5              	MOVE.b	d1,TPos(a3)				; clear terminal position
 2052/    3A50 :                        LAB_188A
 2053/    3A50 : 221F                   	MOVE.l	(sp)+,d1				; restore d1
 2054/    3A52 : 4E75                   	RTS
 2055/    3A54 :                        
 2056/    3A54 :                        
 2057/    3A54 :                        ;************************************************************************************
 2058/    3A54 :                        ;
 2059/    3A54 :                        ; handle bad input data
 2060/    3A54 :                        
 2061/    3A54 :                        LAB_1904
 2062/    3A54 : 2A5F                   	MOVEA.l	(sp)+,a5				; restore execute pointer
 2063/    3A56 : 4A2B 05E0              	TST.b		Imode(a3)				; test input mode flag, $00=INPUT, $98=READ
 2064/    3A5A : 6A0A                   	BPL.s		LAB_1913				; branch if INPUT (go do redo)
 2065/    3A5C :                        
 2066/    3A5C : 276B 045E 0452         	MOVE.l	Dlinel(a3),Clinel(a3)		; save DATA line as current line
 2067/    3A62 : 6000 F6D8              	BRA		LAB_TMER				; do type mismatch error, then warm start
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 39 - 12/13/2023 15:59:9


 2068/    3A66 :                        
 2069/    3A66 :                        								; mode was INPUT
 2070/    3A66 :                        LAB_1913
 2071/    3A66 : 41FA 2A76              	LEA		LAB_REDO(pc),a0			; point to redo message
 2072/    3A6A : 6100 FF78              	BSR		LAB_18C3				; print null terminated string from memory
 2073/    3A6E : 2A6B 045A              	MOVEA.l	Cpntrl(a3),a5			; save continue pointer as BASIC execute pointer
 2074/    3A72 : 4E75                   	RTS
 2075/    3A74 :                        
 2076/    3A74 :                        
 2077/    3A74 :                        ;************************************************************************************
 2078/    3A74 :                        ;
 2079/    3A74 :                        ; perform INPUT
 2080/    3A74 :                        
 2081/    3A74 :                        LAB_INPUT
 2082/    3A74 : 6100 0862              	BSR		LAB_CKRN				; check not direct (back here if ok)
 2083/    3A78 : B03C 0022              	CMP.b		#'"',d0				; compare the next byte with open quote
 2084/    3A7C : 660E                   	BNE.s		LAB_1934				; if no prompt string just go get the input
 2085/    3A7E :                        
 2086/    3A7E : 6100 0306              	BSR		LAB_1BC1				; print "..." string
 2087/    3A82 : 703B                   	MOVEQ		#';',d0				; set the search character to ";"
 2088/    3A84 : 6100 0320              	BSR		LAB_SCCA				; scan for CHR$(d0), else do syntax error/warm
 2089/    3A88 :                        								; start
 2090/    3A88 : 6100 FF5E              	BSR		LAB_18C6				; print string from Sutill/Sutilh
 2091/    3A8C :                        								; finished the prompt, now read the data
 2092/    3A8C :                        LAB_1934
 2093/    3A8C : 6100 F804              	BSR		LAB_INLN				; print "? " and get BASIC input
 2094/    3A90 :                        								; return a0 pointing to the buffer start
 2095/    3A90 : 7000                   	MOVEQ		#0,d0					; flag INPUT
 2096/    3A92 : 4A10                   	TST.b		(a0)					; test first byte from buffer
 2097/    3A94 : 660A                   	BNE.s		LAB_1953				; branch if not null input
 2098/    3A96 :                        
 2099/    3A96 : 6000 FB58              	BRA		LAB_1647				; go do BREAK exit
 2100/    3A9A :                        
 2101/    3A9A :                        
 2102/    3A9A :                        ;************************************************************************************
 2103/    3A9A :                        ;
 2104/    3A9A :                        ; perform READ
 2105/    3A9A :                        
 2106/    3A9A :                        LAB_READ
 2107/    3A9A : 206B 0462              	MOVEA.l	Dptrl(a3),a0			; get the DATA pointer
 2108/    3A9E : 7098                   	MOVEQ		#$98-$100,d0			; flag READ
 2109/    3AA0 :                        LAB_1953
 2110/    3AA0 : 1740 05E0              	MOVE.b	d0,Imode(a3)			; set input mode flag, $00=INPUT, $98=READ
 2111/    3AA4 : 2748 0466              	MOVE.l	a0,Rdptrl(a3)			; save READ pointer
 2112/    3AA8 :                        
 2113/    3AA8 :                        								; READ or INPUT the next variable from list
 2114/    3AA8 :                        LAB_195B
 2115/    3AA8 : 6100 0512              	BSR		LAB_SVAR				; search for or create a variable
 2116/    3AAC :                        								; return the variable address in a0
 2117/    3AAC : 2748 0472              	MOVE.l	a0,Lvarpl(a3)			; save variable address as LET variable
 2118/    3AB0 : 2F0D                   	MOVE.l	a5,-(sp)				; save BASIC execute pointer
 2119/    3AB2 :                        LAB_1961
 2120/    3AB2 : 2A6B 0466              	MOVEA.l	Rdptrl(a3),a5			; set READ pointer as BASIC execute pointer
 2121/    3AB6 : 6100 02F8              	BSR		LAB_GBYT				; scan memory
 2122/    3ABA : 661E                   	BNE.s		LAB_1986				; if not null go get the value
 2123/    3ABC :                        
 2124/    3ABC :                        								; the pointer was to a null entry
 2125/    3ABC : 4A2B 05E0              	TST.b		Imode(a3)				; test input mode flag, $00=INPUT, $98=READ
 2126/    3AC0 : 6B72                   	BMI.s		LAB_19DD				; branch if READ (go find the next statement)
 2127/    3AC2 :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 40 - 12/13/2023 15:59:9


 2128/    3AC2 :                        								; else the mode was INPUT so get more
 2129/    3AC2 : 6100 FF38              	BSR		LAB_18E3				; print a "?" character
 2130/    3AC6 : 6100 F7CA              	BSR		LAB_INLN				; print "? " and get BASIC input
 2131/    3ACA :                        								; return a0 pointing to the buffer start
 2132/    3ACA : 4A10                   	TST.b		(a0)					; test the first byte from the buffer
 2133/    3ACC : 6604                   	BNE.s		LAB_1984				; if not null input go handle it
 2134/    3ACE :                        
 2135/    3ACE : 6000 FB20              	BRA		LAB_1647				; else go do the BREAK exit
 2136/    3AD2 :                        
 2137/    3AD2 :                        LAB_1984
 2138/    3AD2 : 2A48                   	MOVEA.l	a0,a5					; set the execute pointer to the buffer
 2139/    3AD4 : 534D                   	SUBQ.w	#1,a5					; decrement the execute pointer
 2140/    3AD6 :                        
 2141/    3AD6 :                        LAB_1985
 2142/    3AD6 : 6100 02D6              	BSR		LAB_IGBY				; increment & scan memory
 2143/    3ADA :                        LAB_1986
 2144/    3ADA : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
 2145/    3ADE :                        								; $00=float
 2146/    3ADE : 6A20                   	BPL.s		LAB_19B0				; branch if numeric
 2147/    3AE0 :                        
 2148/    3AE0 :                        								; else get string
 2149/    3AE0 : 1400                   	MOVE.b	d0,d2					; save search character
 2150/    3AE2 : B03C 0022              	CMP.b		#$22,d0				; was it " ?
 2151/    3AE6 : 6706                   	BEQ.s		LAB_1999				; branch if so
 2152/    3AE8 :                        
 2153/    3AE8 : 743A                   	MOVEQ		#':',d2				; set new search character
 2154/    3AEA : 702C                   	MOVEQ		#',',d0				; other search character is ","
 2155/    3AEC : 534D                   	SUBQ.w	#1,a5					; decrement BASIC execute pointer
 2156/    3AEE :                        LAB_1999
 2157/    3AEE : 524D                   	ADDQ.w	#1,a5					; increment BASIC execute pointer
 2158/    3AF0 : 1600                   	MOVE.b	d0,d3					; set second search character
 2159/    3AF2 : 204D                   	MOVEA.l	a5,a0					; BASIC execute pointer is source
 2160/    3AF4 :                        
 2161/    3AF4 : 6100 08D4              	BSR		LAB_20B4				; print d2/d3 terminated string to FAC1 stack
 2162/    3AF8 :                        								; d2 = Srchc, d3 = Asrch, a0 is source
 2163/    3AF8 : 2A4A                   	MOVEA.l	a2,a5					; copy end of string to BASIC execute pointer
 2164/    3AFA : 6100 FDD2              	BSR		LAB_17D5				; go do string LET
 2165/    3AFE : 6010                   	BRA.s		LAB_19B6				; go check string terminator
 2166/    3B00 :                        
 2167/    3B00 :                        								; get numeric INPUT
 2168/    3B00 :                        LAB_19B0
 2169/    3B00 : 1F2B 05B5              	MOVE.b	Dtypef(a3),-(sp)			; save variable data type
 2170/    3B04 : 6100 1DA6              	BSR		LAB_2887				; get FAC1 from string
 2171/    3B08 : 175F 05B5              	MOVE.b	(sp)+,Dtypef(a3)			; restore variable data type
 2172/    3B0C : 6100 1084              	BSR		LAB_PFAC				; pack FAC1 into (Lvarpl)
 2173/    3B10 :                        LAB_19B6
 2174/    3B10 : 6100 029E              	BSR		LAB_GBYT				; scan memory
 2175/    3B14 : 670A                   	BEQ.s		LAB_19C2				; branch if null (last entry)
 2176/    3B16 :                        
 2177/    3B16 : B03C 002C              	CMP.b		#',',d0				; else compare with ","
 2178/    3B1A : 6600 FF38              	BNE		LAB_1904				; if not "," go handle bad input data
 2179/    3B1E :                        
 2180/    3B1E : 524D                   	ADDQ.w	#1,a5					; else was "," so point to next chr
 2181/    3B20 :                        								; got good input data
 2182/    3B20 :                        LAB_19C2
 2183/    3B20 : 274D 0466              	MOVE.l	a5,Rdptrl(a3)			; save the read pointer for now
 2184/    3B24 : 2A5F                   	MOVEA.l	(sp)+,a5				; restore the execute pointer
 2185/    3B26 : 6100 0288              	BSR		LAB_GBYT				; scan the memory
 2186/    3B2A : 6736                   	BEQ.s		LAB_1A03				; if null go do extra ignored message
 2187/    3B2C :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 41 - 12/13/2023 15:59:9


 2188/    3B2C : 487A FF7A              	PEA		LAB_195B(pc)			; set return address
 2189/    3B30 : 6000 0272              	BRA		LAB_1C01				; scan for "," else do syntax error/warm start
 2190/    3B34 :                        								; then go INPUT next variable from list
 2191/    3B34 :                        
 2192/    3B34 :                        								; find next DATA statement or do "Out of Data"
 2193/    3B34 :                        								; error
 2194/    3B34 :                        LAB_19DD
 2195/    3B34 : 6100 FBFE              	BSR		LAB_SNBS				; scan for next BASIC statement ([:] or [EOL])
 2196/    3B38 :                        								; returns a0 as pointer to [:] or [EOL]
 2197/    3B38 : 2A48                   	MOVEA.l	a0,a5					; add index, now = pointer to [EOL]/[EOS]
 2198/    3B3A : 524D                   	ADDQ.w	#1,a5					; pointer to next character
 2199/    3B3C : B03C 003A              	CMP.b		#':',d0				; was it statement end?
 2200/    3B40 : 6712                   	BEQ.s		LAB_19F6				; branch if [:]
 2201/    3B42 :                        
 2202/    3B42 :                        								; was [EOL] so find next line
 2203/    3B42 :                        
 2204/    3B42 : 320D                   	MOVE.w	a5,d1					; past pad byte(s)
 2205/    3B44 : C27C 0001              	AND.w		#1,d1					; mask odd bit
 2206/    3B48 : DAC1                   	ADD.w		d1,a5					; add pointer
 2207/    3B4A : 241D                   	MOVE.l	(a5)+,d2				; get next line pointer
 2208/    3B4C : 6700 F612              	BEQ		LAB_ODER				; branch if end of program
 2209/    3B50 :                        
 2210/    3B50 : 275D 045E              	MOVE.l	(a5)+,Dlinel(a3)			; save current DATA line
 2211/    3B54 :                        LAB_19F6
 2212/    3B54 : 6100 025A              	BSR		LAB_GBYT				; scan memory
 2213/    3B58 : B03C 0083              	CMP.b		#TK_DATA,d0				; compare with "DATA" token
 2214/    3B5C : 6700 FF78              	BEQ		LAB_1985				; was "DATA" so go do next READ
 2215/    3B60 :                        
 2216/    3B60 : 60D2                   	BRA.s		LAB_19DD				; go find next statement if not "DATA"
 2217/    3B62 :                        
 2218/    3B62 :                        ; end of INPUT/READ routine
 2219/    3B62 :                        
 2220/    3B62 :                        LAB_1A03
 2221/    3B62 : 206B 0466              	MOVEA.l	Rdptrl(a3),a0			; get temp READ pointer
 2222/    3B66 : 4A2B 05E0              	TST.b		Imode(a3)				; get input mode flag, $00=INPUT, $98=READ
 2223/    3B6A : 6A06                   	BPL.s		LAB_1A0E				; branch if INPUT
 2224/    3B6C :                        
 2225/    3B6C : 2748 0462              	MOVE.l	a0,Dptrl(a3)			; else save temp READ pointer as DATA pointer
 2226/    3B70 : 4E75                   	RTS
 2227/    3B72 :                        
 2228/    3B72 :                        								; we were getting INPUT
 2229/    3B72 :                        LAB_1A0E
 2230/    3B72 : 4A10                   	TST.b		(a0)					; test next byte
 2231/    3B74 : 6602                   	BNE.s		LAB_1A1B				; error if not end of INPUT
 2232/    3B76 :                        
 2233/    3B76 : 4E75                   	RTS
 2234/    3B78 :                        								; user typed too much
 2235/    3B78 :                        LAB_1A1B
 2236/    3B78 : 41FA 2954              	LEA		LAB_IMSG(pc),a0			; point to extra ignored message
 2237/    3B7C : 6000 FE66              	BRA		LAB_18C3				; print null terminated string from memory & RTS
 2238/    3B80 :                        
 2239/    3B80 :                        
 2240/    3B80 :                        ;************************************************************************************
 2241/    3B80 :                        ;
 2242/    3B80 :                        ; perform NEXT
 2243/    3B80 :                        
 2244/    3B80 :                        LAB_NEXT
 2245/    3B80 : 6610                   	BNE.s		LAB_1A46				; branch if NEXT var
 2246/    3B82 :                        
 2247/    3B82 : 584F                   	ADDQ.w	#4,sp					; back past return address
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 42 - 12/13/2023 15:59:9


 2248/    3B84 : 0C57 0081              	CMP.w		#TK_FOR,(sp)			; is FOR token on stack?
 2249/    3B88 : 6600 F5E2              	BNE		LAB_NFER				; if not do NEXT without FOR err/warm start
 2250/    3B8C :                        
 2251/    3B8C : 206F 0002              	MOVEA.l	2(sp),a0				; get stacked FOR variable pointer
 2252/    3B90 : 601C                   	BRA.s		LAB_11BD				; branch always (no variable to search for)
 2253/    3B92 :                        
 2254/    3B92 :                        ; NEXT var
 2255/    3B92 :                        
 2256/    3B92 :                        LAB_1A46
 2257/    3B92 : 6100 042C              	BSR		LAB_GVAR				; get variable address in a0
 2258/    3B96 : 584F                   	ADDQ.w	#4,sp					; back past return address
 2259/    3B98 : 303C 0081              	MOVE.w	#TK_FOR,d0				; set for FOR token
 2260/    3B9C : 721C                   	MOVEQ		#$1C,d1				; set for FOR use size
 2261/    3B9E : 6002                   	BRA.s		LAB_11A6				; enter loop for next variable search
 2262/    3BA0 :                        
 2263/    3BA0 :                        LAB_11A5
 2264/    3BA0 : DFC1                   	ADDA.l	d1,sp					; add FOR stack use size
 2265/    3BA2 :                        LAB_11A6
 2266/    3BA2 : B057                   	CMP.w		(sp),d0				; is FOR token on stack?
 2267/    3BA4 : 6600 F5C6              	BNE		LAB_NFER				; if not found do NEXT without FOR error and
 2268/    3BA8 :                        								; warm start
 2269/    3BA8 :                        
 2270/    3BA8 :                        								; was FOR token
 2271/    3BA8 : B1EF 0002              	CMPA.l	2(sp),a0				; compare var pointer with stacked var pointer
 2272/    3BAC : 66F2                   	BNE.s		LAB_11A5				; loop if no match found
 2273/    3BAE :                        
 2274/    3BAE :                        LAB_11BD
 2275/    3BAE : 376F 0006 059C         	MOVE.w	6(sp),FAC2_e(a3)			; get STEP value exponent and sign
 2276/    3BB4 : 276F 0008 0598         	MOVE.l	8(sp),FAC2_m(a3)			; get STEP value mantissa
 2277/    3BBA :                        
 2278/    3BBA : 176F 0012 05B5         	MOVE.b	18(sp),Dtypef(a3)			; restore FOR variable data type
 2279/    3BC0 : 6100 021E              	BSR		LAB_1C19				; check type and unpack (a0)
 2280/    3BC4 :                        
 2281/    3BC4 : 176B 059D 059E         	MOVE.b	FAC2_s(a3),FAC_sc(a3)		; save FAC2 sign as sign compare
 2282/    3BCA : 102B 0595              	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
 2283/    3BCE : B12B 059E              	EOR.b		d0,FAC_sc(a3)			; EOR to create sign compare
 2284/    3BD2 :                        
 2285/    3BD2 : 2748 0472              	MOVE.l	a0,Lvarpl(a3)			; save variable pointer
 2286/    3BD6 : 6100 0CBA              	BSR		LAB_ADD				; add STEP value to FOR variable
 2287/    3BDA : 176F 0012 05B5         	MOVE.b	18(sp),Dtypef(a3)			; restore FOR variable data type (again)
 2288/    3BE0 : 6100 0FB0              	BSR		LAB_PFAC				; pack FAC1 into FOR variable (Lvarpl)
 2289/    3BE4 :                        
 2290/    3BE4 : 376F 000C 059C         	MOVE.w	12(sp),FAC2_e(a3)			; get TO value exponent and sign
 2291/    3BEA : 276F 000E 0598         	MOVE.l	14(sp),FAC2_m(a3)			; get TO value mantissa
 2292/    3BF0 :                        
 2293/    3BF0 : 176B 059D 059E         	MOVE.b	FAC2_s(a3),FAC_sc(a3)		; save FAC2 sign as sign compare
 2294/    3BF6 : 102B 0595              	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
 2295/    3BFA : B12B 059E              	EOR.b		d0,FAC_sc(a3)			; EOR to create sign compare
 2296/    3BFE :                        
 2297/    3BFE : 6100 103C              	BSR		LAB_27FA				; compare FAC1 with FAC2 (TO value)
 2298/    3C02 :                        								; returns d0=+1 if FAC1 > FAC2
 2299/    3C02 :                        								; returns d0= 0 if FAC1 = FAC2
 2300/    3C02 :                        								; returns d0=-1 if FAC1 < FAC2
 2301/    3C02 :                        
 2302/    3C02 : 322F 0006              	MOVE.w	6(sp),d1				; get STEP value exponent and sign
 2303/    3C06 : B141                   	EOR.w		d0,d1					; EOR compare result with STEP exponent and sign
 2304/    3C08 :                        
 2305/    3C08 : 4A00                   	TST.b		d0					; test for =
 2306/    3C0A : 6704                   	BEQ.s		LAB_1A90				; branch if = (loop INcomplete)
 2307/    3C0C :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 43 - 12/13/2023 15:59:9


 2308/    3C0C : 4A01                   	TST.b		d1					; test result
 2309/    3C0E : 6A0E                   	BPL.s		LAB_1A9B				; branch if > (loop complete)
 2310/    3C10 :                        
 2311/    3C10 :                        								; loop back and do it all again
 2312/    3C10 :                        LAB_1A90
 2313/    3C10 : 276F 0014 0452         	MOVE.l	20(sp),Clinel(a3)			; reset current line
 2314/    3C16 : 2A6F 0018              	MOVE.l	24(sp),a5				; reset BASIC execute pointer
 2315/    3C1A : 6000 F970              	BRA		LAB_15C2				; go do interpreter inner loop
 2316/    3C1E :                        
 2317/    3C1E :                        								; loop complete so carry on
 2318/    3C1E :                        LAB_1A9B
 2319/    3C1E : DEFC 001C              	ADDA.w	#28,sp				; add 28 to dump FOR structure
 2320/    3C22 : 6100 018C              	BSR		LAB_GBYT				; scan memory
 2321/    3C26 : B03C 002C              	CMP.b		#$2C,d0				; compare with ","
 2322/    3C2A : 6600 F960              	BNE		LAB_15C2				; if not "," go do interpreter inner loop
 2323/    3C2E :                        
 2324/    3C2E :                        								; was "," so another NEXT variable to do
 2325/    3C2E : 6100 017E              	BSR		LAB_IGBY				; else increment & scan memory
 2326/    3C32 : 6100 FF5E              	BSR		LAB_1A46				; do NEXT (var)
 2327/    3C36 :                        
 2328/    3C36 :                        
 2329/    3C36 :                        ;************************************************************************************
 2330/    3C36 :                        ;
 2331/    3C36 :                        ; evaluate expression & check is numeric, else do type mismatch
 2332/    3C36 :                        
 2333/    3C36 :                        LAB_EVNM
 2334/    3C36 : 6116                   	BSR.s		LAB_EVEX				; evaluate expression
 2335/    3C38 :                        
 2336/    3C38 :                        
 2337/    3C38 :                        ;************************************************************************************
 2338/    3C38 :                        ;
 2339/    3C38 :                        ; check if source is numeric, else do type mismatch
 2340/    3C38 :                        
 2341/    3C38 :                        LAB_CTNM
 2342/    3C38 : B040                   	CMP.w		d0,d0					; required type is numeric so clear carry
 2343/    3C3A :                        
 2344/    3C3A :                        
 2345/    3C3A :                        ;************************************************************************************
 2346/    3C3A :                        ;
 2347/    3C3A :                        ; type match check, set C for string, clear C for numeric
 2348/    3C3A :                        
 2349/    3C3A :                        LAB_CKTM
 2350/    3C3A : 082B 0007 05B5         	BTST.b	#7,Dtypef(a3)			; test data type flag, don't change carry
 2351/    3C40 : 6606                   	BNE.s		LAB_1ABA				; branch if data type is string
 2352/    3C42 :                        
 2353/    3C42 :                        								; else data type was numeric
 2354/    3C42 : 6500 F4F8              	BCS		LAB_TMER				; if required type is string do type mismatch
 2355/    3C46 :                        								; error
 2356/    3C46 :                        
 2357/    3C46 : 4E75                   	RTS
 2358/    3C48 :                        								; data type was string, now check required type
 2359/    3C48 :                        LAB_1ABA
 2360/    3C48 : 6400 F4F2              	BCC		LAB_TMER				; if required type is numeric do type mismatch
 2361/    3C4C :                        								; error
 2362/    3C4C : 4E75                   	RTS
 2363/    3C4E :                        
 2364/    3C4E :                        
 2365/    3C4E :                        ;************************************************************************************
 2366/    3C4E :                        ;
 2367/    3C4E :                        ; this routine evaluates any type of expression. first it pushes an end marker so
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 44 - 12/13/2023 15:59:9


 2368/    3C4E :                        ; it knows when the expression has been evaluated, this is a precedence value of zero.
 2369/    3C4E :                        ; next the first value is evaluated, this can be an in line value, either numeric or
 2370/    3C4E :                        ; string, a variable or array element of any type, a function or even an expression
 2371/    3C4E :                        ; in parenthesis. this value is kept in FAC_1
 2372/    3C4E :                        ; after the value is evaluated a test is made on the next BASIC program byte, if it
 2373/    3C4E :                        ; is a comparrison operator i.e. "<", "=" or ">", then the corresponding bit is set
 2374/    3C4E :                        ; in the comparison evaluation flag. this test loops until no more comparrison operators
 2375/    3C4E :                        ; are found or more than one of any type is found. in the last case an error is generated
 2376/    3C4E :                        
 2377/    3C4E :                        ; evaluate expression
 2378/    3C4E :                        
 2379/    3C4E :                        LAB_EVEX
 2380/    3C4E : 534D                   	SUBQ.w	#1,a5					; decrement BASIC execute pointer
 2381/    3C50 :                        LAB_EVEZ
 2382/    3C50 : 7200                   	MOVEQ		#0,d1					; clear precedence word
 2383/    3C52 : 1741 05B5              	MOVE.b	d1,Dtypef(a3)			; clear the data type, $80=string, $40=integer,
 2384/    3C56 :                        								; $00=float
 2385/    3C56 : 601C                   	BRA.s		LAB_1ACD				; enter loop
 2386/    3C58 :                        
 2387/    3C58 :                        ; get vector, set up operator then continue evaluation
 2388/    3C58 :                        
 2389/    3C58 :                        LAB_1B43
 2390/    3C58 : 41FA 22CA              	LEA		LAB_OPPT(pc),a0			; point to operator vector table
 2391/    3C5C : 3030 1002              	MOVE.w	2(a0,d1.w),d0			; get vector offset
 2392/    3C60 : 4870 0000              	PEA		(a0,d0.w)				; push vector
 2393/    3C64 :                        
 2394/    3C64 : 2F2B 0590              	MOVE.l	FAC1_m(a3),-(sp)			; push FAC1 mantissa
 2395/    3C68 : 3F2B 0594              	MOVE.w	FAC1_e(a3),-(sp)			; push sign and exponent
 2396/    3C6C : 1F2B 05E3              	MOVE.b	comp_f(a3),-(sp)			; push comparison evaluation flag
 2397/    3C70 :                        
 2398/    3C70 : 3230 1000              	MOVE.w	(a0,d1.w),d1			; get precedence value
 2399/    3C74 :                        LAB_1ACD
 2400/    3C74 : 3F01                   	MOVE.w	d1,-(sp)				; push precedence value
 2401/    3C76 : 6100 00E4              	BSR		LAB_GVAL				; get value from line
 2402/    3C7A : 177C 0000 05E3         	MOVE.b	#$00,comp_f(a3)			; clear compare function flag
 2403/    3C80 :                        LAB_1ADB
 2404/    3C80 : 6100 012E              	BSR		LAB_GBYT				; scan memory
 2405/    3C84 :                        LAB_1ADE
 2406/    3C84 : 903C 00BC              	SUB.b		#TK_GT,d0				; subtract token for > (lowest compare function)
 2407/    3C88 : 652A                   	BCS.s		LAB_1AFA				; branch if < TK_GT
 2408/    3C8A :                        
 2409/    3C8A : B03C 0003              	CMP.b		#$03,d0				; compare with ">" to "<" tokens
 2410/    3C8E : 650A                   	BCS.s		LAB_1AE0				; branch if <= TK_SGN (is compare function)
 2411/    3C90 :                        
 2412/    3C90 : 4A2B 05E3              	TST.b		comp_f(a3)				; test compare function flag
 2413/    3C94 : 6660                   	BNE.s		LAB_1B2A				; branch if compare function
 2414/    3C96 :                        
 2415/    3C96 : 6000 0086              	BRA		LAB_1B78				; go do functions
 2416/    3C9A :                        
 2417/    3C9A :                        								; was token for > = or < (d0 = 0, 1 or 2)
 2418/    3C9A :                        LAB_1AE0
 2419/    3C9A : 7201                   	MOVEQ		#1,d1					; set to 0000 0001
 2420/    3C9C : E121                   	ASL.b		d0,d1					; 1 if >, 2 if =, 4 if <
 2421/    3C9E : 102B 05E3              	MOVE.b	comp_f(a3),d0			; copy old compare function flag
 2422/    3CA2 : B32B 05E3              	EOR.b		d1,comp_f(a3)			; EOR in this compare function bit
 2423/    3CA6 : B02B 05E3              	CMP.b		comp_f(a3),d0			; compare old with new compare function flag
 2424/    3CAA : 6400 F4BC              	BCC		LAB_SNER				; if new <= old comp_f do syntax error and warm
 2425/    3CAE :                        								; start, there was more than one <, = or >
 2426/    3CAE : 6100 00FE              	BSR		LAB_IGBY				; increment & scan memory
 2427/    3CB2 : 60D0                   	BRA.s		LAB_1ADE				; go do next character
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 45 - 12/13/2023 15:59:9


 2428/    3CB4 :                        
 2429/    3CB4 :                        								; token is < ">" or > "<" tokens
 2430/    3CB4 :                        LAB_1AFA
 2431/    3CB4 : 4A2B 05E3              	TST.b		comp_f(a3)				; test compare function flag
 2432/    3CB8 : 663C                   	BNE.s		LAB_1B2A				; branch if compare function
 2433/    3CBA :                        
 2434/    3CBA :                        								; was < TK_GT so is operator or lower
 2435/    3CBA : D03C 000A              	ADD.b	#(TK_GT-TK_PLUS),d0			; add # of operators (+ -	; / ^ AND OR EOR)
 2436/    3CBE : 645E                   	BCC.s		LAB_1B78				; branch if < + operator
 2437/    3CC0 :                        
 2438/    3CC0 : 6608                   	BNE.s		LAB_1B0B				; branch if not + token
 2439/    3CC2 :                        
 2440/    3CC2 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
 2441/    3CC6 :                        								; $00=float
 2442/    3CC6 : 6B00 087E              	BMI		LAB_224D				; type is string & token was +
 2443/    3CCA :                        
 2444/    3CCA :                        LAB_1B0B
 2445/    3CCA : 7200                   	MOVEQ		#0,d1					; clear longword
 2446/    3CCC : D000                   	ADD.b		d0,d0					; *2
 2447/    3CCE : D000                   	ADD.b		d0,d0					; *4
 2448/    3CD0 : 1200                   	MOVE.b	d0,d1					; copy to index
 2449/    3CD2 :                        LAB_1B13
 2450/    3CD2 : 301F                   	MOVE.w	(sp)+,d0				; pull previous precedence
 2451/    3CD4 : 41FA 224E              	LEA		LAB_OPPT(pc),a0			; set pointer to operator table
 2452/    3CD8 : B070 1000              	CMP.w		(a0,d1.w),d0			; compare with this opperator precedence
 2453/    3CDC : 6446                   	BCC.s		LAB_1B7D				; branch if previous precedence (d0) >=
 2454/    3CDE :                        
 2455/    3CDE : 6100 FF58              	BSR		LAB_CTNM				; check if source is numeric, else type mismatch
 2456/    3CE2 :                        LAB_1B1C
 2457/    3CE2 : 3F00                   	MOVE.w	d0,-(sp)				; save precedence
 2458/    3CE4 :                        LAB_1B1D
 2459/    3CE4 : 6100 FF72              	BSR		LAB_1B43				; get vector, set-up operator and continue
 2460/    3CE8 :                        								; evaluation
 2461/    3CE8 : 301F                   	MOVE.w	(sp)+,d0				; restore precedence
 2462/    3CEA : 222B 05D8              	MOVE.l	prstk(a3),d1			; get stacked function pointer
 2463/    3CEE : 6A22                   	BPL.s		LAB_1B3C				; branch if stacked values
 2464/    3CF0 :                        
 2465/    3CF0 : 3000                   	MOVE.w	d0,d0					; copy precedence (set flags)
 2466/    3CF2 : 672E                   	BEQ.s		LAB_1B7B				; exit if done
 2467/    3CF4 :                        
 2468/    3CF4 : 603C                   	BRA.s		LAB_1B86				; else pop FAC2 & return (do function)
 2469/    3CF6 :                        
 2470/    3CF6 :                        								; was compare function (< = >)
 2471/    3CF6 :                        LAB_1B2A
 2472/    3CF6 : 102B 05B5              	MOVE.b	Dtypef(a3),d0			; get data type flag
 2473/    3CFA : 122B 05E3              	MOVE.b	comp_f(a3),d1			; get compare function flag
 2474/    3CFE : D000                   	ADD.b		d0,d0					; string bit flag into X bit
 2475/    3D00 : D301                   	ADDX.b	d1,d1					; shift compare function flag
 2476/    3D02 :                        
 2477/    3D02 : 177C 0000 05B5         	MOVE.b	#0,Dtypef(a3)			; clear data type flag, $00=float
 2478/    3D08 : 1741 05E3              	MOVE.b	d1,comp_f(a3)			; save new compare function flag
 2479/    3D0C : 534D                   	SUBQ.w	#1,a5					; decrement BASIC execute pointer
 2480/    3D0E : 7230                   	MOVEQ		#(TK_LT-TK_PLUS)*4,d1		; set offset to last operator entry
 2481/    3D10 : 60C0                   	BRA.s		LAB_1B13				; branch always
 2482/    3D12 :                        
 2483/    3D12 :                        LAB_1B3C
 2484/    3D12 : 41FA 2210              	LEA		LAB_OPPT(pc),a0			; point to function vector table
 2485/    3D16 : B070 1000              	CMP.w		(a0,d1.w),d0			; compare with this opperator precedence
 2486/    3D1A : 6416                   	BCC.s		LAB_1B86				; branch if d0 >=, pop FAC2 & return
 2487/    3D1C :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 46 - 12/13/2023 15:59:9


 2488/    3D1C : 60C4                   	BRA.s		LAB_1B1C				; branch always
 2489/    3D1E :                        
 2490/    3D1E :                        ; do functions
 2491/    3D1E :                        
 2492/    3D1E :                        LAB_1B78
 2493/    3D1E : 72FF                   	MOVEQ		#-1,d1				; flag all done
 2494/    3D20 : 301F                   	MOVE.w	(sp)+,d0				; pull precedence word
 2495/    3D22 :                        LAB_1B7B
 2496/    3D22 : 6732                   	BEQ.s		LAB_1B9D				; exit if done
 2497/    3D24 :                        
 2498/    3D24 :                        LAB_1B7D
 2499/    3D24 : B07C 0064              	CMP.w		#$64,d0				; compare previous precedence with $64
 2500/    3D28 : 6704                   	BEQ.s		LAB_1B84				; branch if was $64 (< function can be string)
 2501/    3D2A :                        
 2502/    3D2A : 6100 FF0C              	BSR		LAB_CTNM				; check if source is numeric, else type mismatch
 2503/    3D2E :                        LAB_1B84
 2504/    3D2E : 2741 05D8              	MOVE.l	d1,prstk(a3)			; save current operator index
 2505/    3D32 :                        
 2506/    3D32 :                        								; pop FAC2 & return
 2507/    3D32 :                        LAB_1B86
 2508/    3D32 : 101F                   	MOVE.b	(sp)+,d0				; pop comparison evaluation flag
 2509/    3D34 : 1200                   	MOVE.b	d0,d1					; copy comparison evaluation flag
 2510/    3D36 : E208                   	LSR.b		#1,d0					; shift out comparison evaluation lowest bit
 2511/    3D38 : 1740 05E1              	MOVE.b	d0,Cflag(a3)			; save comparison evaluation flag
 2512/    3D3C : 375F 059C              	MOVE.w	(sp)+,FAC2_e(a3)			; pop exponent and sign
 2513/    3D40 : 275F 0598              	MOVE.l	(sp)+,FAC2_m(a3)			; pop mantissa
 2514/    3D44 : 176B 059D 059E         	MOVE.b	FAC2_s(a3),FAC_sc(a3)		; copy FAC2 sign
 2515/    3D4A : 102B 0595              	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
 2516/    3D4E : B12B 059E              	EOR.b		d0,FAC_sc(a3)			; EOR FAC1 sign and set sign compare
 2517/    3D52 :                        
 2518/    3D52 : E209                   	LSR.b		#1,d1					; type bit into X and C
 2519/    3D54 : 4E75                   	RTS
 2520/    3D56 :                        
 2521/    3D56 :                        LAB_1B9D
 2522/    3D56 : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
 2523/    3D5A : 4E75                   	RTS
 2524/    3D5C :                        
 2525/    3D5C :                        
 2526/    3D5C :                        ;************************************************************************************
 2527/    3D5C :                        ;
 2528/    3D5C :                        ; get a value from the BASIC line
 2529/    3D5C :                        
 2530/    3D5C :                        LAB_GVAL
 2531/    3D5C : 6150                   	BSR.s		LAB_IGBY				; increment & scan memory
 2532/    3D5E : 6500 1B4C              	BCS		LAB_2887				; if numeric get FAC1 from string & return
 2533/    3D62 :                        
 2534/    3D62 : 4A00                   	TST.b		d0					; test byte
 2535/    3D64 : 6B00 0090              	BMI		LAB_1BD0				; if -ve go test token values
 2536/    3D68 :                        
 2537/    3D68 :                        								; else it is either a string, number, variable
 2538/    3D68 :                        								; or (<expr>)
 2539/    3D68 : B03C 0024              	CMP.b		#'$',d0				; compare with "$"
 2540/    3D6C : 6700 1B3E              	BEQ		LAB_2887				; if "$" get hex number from string & return
 2541/    3D70 :                        
 2542/    3D70 : B03C 0025              	CMP.b		#'%',d0				; else compare with "%"
 2543/    3D74 : 6700 1B36              	BEQ		LAB_2887				; if "%" get binary number from string & return
 2544/    3D78 :                        
 2545/    3D78 : B03C 002E              	CMP.b		#$2E,d0				; compare with "."
 2546/    3D7C : 6700 1B2E              	BEQ		LAB_2887				; if so get FAC1 from string and return
 2547/    3D80 :                        								; (e.g. .123)
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 47 - 12/13/2023 15:59:9


 2548/    3D80 :                        
 2549/    3D80 :                        								; wasn't a number so ...
 2550/    3D80 : B03C 0022              	CMP.b		#$22,d0				; compare with "
 2551/    3D84 : 660C                   	BNE.s		LAB_1BF3				; if not open quote it must be a variable or
 2552/    3D86 :                        								; open bracket
 2553/    3D86 :                        
 2554/    3D86 :                        								; was open quote so get the enclosed string
 2555/    3D86 :                        
 2556/    3D86 :                        ; print "..." string to string stack
 2557/    3D86 :                        
 2558/    3D86 :                        LAB_1BC1
 2559/    3D86 : 101D                   	MOVE.b	(a5)+,d0				; increment BASIC execute pointer (past ")
 2560/    3D88 :                        								; fastest/shortest method
 2561/    3D88 : 204D                   	MOVEA.l	a5,a0					; copy basic execute pointer (string start)
 2562/    3D8A : 6100 063A              	BSR		LAB_20AE				; print " terminated string to stack
 2563/    3D8E : 2A4A                   	MOVEA.l	a2,a5					; restore BASIC execute pointer from temp
 2564/    3D90 : 4E75                   	RTS
 2565/    3D92 :                        
 2566/    3D92 :                        ; get value from line .. continued
 2567/    3D92 :                        								; wasn't any sort of number so ...
 2568/    3D92 :                        LAB_1BF3
 2569/    3D92 : B03C 0028              	CMP.b		#'(',d0				; compare with "("
 2570/    3D96 : 6644                   	BNE.s		LAB_1C18				; if not "(" get (var) and return value in FAC1
 2571/    3D98 :                        								; and $ flag
 2572/    3D98 :                        
 2573/    3D98 :                        
 2574/    3D98 :                        ;************************************************************************************
 2575/    3D98 :                        ;
 2576/    3D98 :                        ; evaluate expression within parentheses
 2577/    3D98 :                        
 2578/    3D98 :                        LAB_1BF7
 2579/    3D98 : 6100 FEB6              	BSR		LAB_EVEZ				; evaluate expression (no decrement)
 2580/    3D9C :                        
 2581/    3D9C :                        
 2582/    3D9C :                        ;************************************************************************************
 2583/    3D9C :                        ;
 2584/    3D9C :                        ; all the 'scan for' routines return the character after the sought character
 2585/    3D9C :                        
 2586/    3D9C :                        ; scan for ")", else do syntax error, then warm start
 2587/    3D9C :                        
 2588/    3D9C :                        LAB_1BFB
 2589/    3D9C : 7029                   	MOVEQ		#$29,d0				; load d0 with ")"
 2590/    3D9E : 6006                   	BRA.s		LAB_SCCA
 2591/    3DA0 :                        
 2592/    3DA0 :                        
 2593/    3DA0 :                        ;************************************************************************************
 2594/    3DA0 :                        ;
 2595/    3DA0 :                        ; scan for "," and get byte, else do Syntax error then warm start
 2596/    3DA0 :                        
 2597/    3DA0 :                        LAB_SCGB
 2598/    3DA0 : 487A 0978              	PEA		LAB_GTBY(pc)			; return address is to get byte parameter
 2599/    3DA4 :                        
 2600/    3DA4 :                        
 2601/    3DA4 :                        ;************************************************************************************
 2602/    3DA4 :                        ;
 2603/    3DA4 :                        ; scan for ",", else do syntax error, then warm start
 2604/    3DA4 :                        
 2605/    3DA4 :                        LAB_1C01
 2606/    3DA4 : 702C                   	MOVEQ		#$2C,d0				; load d0 with ","
 2607/    3DA6 :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 48 - 12/13/2023 15:59:9


 2608/    3DA6 :                        
 2609/    3DA6 :                        ;************************************************************************************
 2610/    3DA6 :                        ;
 2611/    3DA6 :                        ; scan for CHR$(d0) , else do syntax error, then warm start
 2612/    3DA6 :                        
 2613/    3DA6 :                        LAB_SCCA
 2614/    3DA6 : B01D                   	CMP.b		(a5)+,d0				; check next byte is = d0
 2615/    3DA8 : 6706                   	BEQ.s		LAB_GBYT				; if so go get next
 2616/    3DAA :                        
 2617/    3DAA : 6000 F3BC              	BRA		LAB_SNER				; else do syntax error/warm start
 2618/    3DAE :                        
 2619/    3DAE :                        
 2620/    3DAE :                        ;************************************************************************************
 2621/    3DAE :                        ;
 2622/    3DAE :                        ; BASIC increment and scan memory routine
 2623/    3DAE :                        
 2624/    3DAE :                        LAB_IGBY
 2625/    3DAE : 101D                   	MOVE.b	(a5)+,d0				; get byte & increment pointer
 2626/    3DB0 :                        
 2627/    3DB0 :                        ; scan memory routine, exit with Cb = 1 if numeric character
 2628/    3DB0 :                        ; also skips any spaces encountered
 2629/    3DB0 :                        
 2630/    3DB0 :                        LAB_GBYT
 2631/    3DB0 : 1015                   	MOVE.b	(a5),d0				; get byte
 2632/    3DB2 :                        
 2633/    3DB2 : B03C 0020              	CMP.b		#$20,d0				; compare with " "
 2634/    3DB6 : 67F6                   	BEQ.s		LAB_IGBY				; if " " go do next
 2635/    3DB8 :                        
 2636/    3DB8 :                        ; test current BASIC byte, exit with Cb = 1 if numeric character
 2637/    3DB8 :                        
 2638/    3DB8 : B03C 00A9              	CMP.b		#TK_ELSE,d0				; compare with the token for ELSE
 2639/    3DBC : 640E                   	BCC.s		RTS_001				; exit if >= (not numeric, carry clear)
 2640/    3DBE :                        
 2641/    3DBE : B03C 003A              	CMP.b		#$3A,d0				; compare with ":"
 2642/    3DC2 : 6408                   	BCC.s		RTS_001				; exit if >= (not numeric, carry clear)
 2643/    3DC4 :                        
 2644/    3DC4 : 1C3C 00D0              	MOVE.b		#$D0,d6				; set -"0"
 2645/    3DC8 : D006                   	ADD.b		d6,d0					; add -"0"
 2646/    3DCA : 9006                   	SUB.b		d6,d0					; subtract -"0"
 2647/    3DCC :                        RTS_001							; carry set if byte = "0"-"9"
 2648/    3DCC : 4E75                   	RTS
 2649/    3DCE :                        
 2650/    3DCE :                        
 2651/    3DCE :                        ;************************************************************************************
 2652/    3DCE :                        ;
 2653/    3DCE :                        ; set-up for - operator
 2654/    3DCE :                        
 2655/    3DCE :                        LAB_1C11
 2656/    3DCE : 6100 FE68              	BSR		LAB_CTNM				; check if source is numeric, else type mismatch
 2657/    3DD2 : 7228                   	MOVEQ	#(TK_GT-TK_PLUS)*4,d1			; set offset from base to - operator
 2658/    3DD4 :                        LAB_1C13
 2659/    3DD4 : 4FEF 0004              	LEA		4(sp),sp				; dump GVAL return address
 2660/    3DD8 : 6000 FF0A              	BRA		LAB_1B1D				; continue evaluating expression
 2661/    3DDC :                        
 2662/    3DDC :                        
 2663/    3DDC :                        ;************************************************************************************
 2664/    3DDC :                        ;
 2665/    3DDC :                        ; variable name set-up
 2666/    3DDC :                        ; get (var), return value in FAC_1 & data type flag
 2667/    3DDC :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 49 - 12/13/2023 15:59:9


 2668/    3DDC :                        LAB_1C18
 2669/    3DDC : 6100 01E2              	BSR		LAB_GVAR				; get variable address in a0
 2670/    3DE0 :                        
 2671/    3DE0 :                        ; return existing variable value
 2672/    3DE0 :                        
 2673/    3DE0 :                        LAB_1C19
 2674/    3DE0 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
 2675/    3DE4 :                        								; $00=float
 2676/    3DE4 : 6700 0D90              	BEQ		LAB_UFAC				; if float unpack memory (a0) into FAC1 and
 2677/    3DE8 :                        								; return
 2678/    3DE8 :                        
 2679/    3DE8 : 6A06                   	BPL.s		LAB_1C1A				; if integer unpack memory (a0) into FAC1
 2680/    3DEA :                        								; and return
 2681/    3DEA :                        
 2682/    3DEA : 2748 0590              	MOVE.l	a0,FAC1_m(a3)			; else save descriptor pointer in FAC1
 2683/    3DEE : 4E75                   	RTS
 2684/    3DF0 :                        
 2685/    3DF0 :                        LAB_1C1A
 2686/    3DF0 : 2010                   	MOVE.l	(a0),d0				; get integer value
 2687/    3DF2 : 6000 04BC              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
 2688/    3DF6 :                        
 2689/    3DF6 :                        
 2690/    3DF6 :                        ;************************************************************************************
 2691/    3DF6 :                        ;
 2692/    3DF6 :                        ; get value from line .. continued
 2693/    3DF6 :                        ; do tokens
 2694/    3DF6 :                        
 2695/    3DF6 :                        LAB_1BD0
 2696/    3DF6 : B03C 00B3              	CMP.b		#TK_MINUS,d0			; compare with token for -
 2697/    3DFA : 67D2                   	BEQ.s		LAB_1C11				; branch if - token (do set-up for - operator)
 2698/    3DFC :                        
 2699/    3DFC :                        								; wasn't -123 so ...
 2700/    3DFC : B03C 00B2              	CMP.b		#TK_PLUS,d0				; compare with token for +
 2701/    3E00 : 6700 FF5A              	BEQ		LAB_GVAL				; branch if + token (+n = n so ignore leading +)
 2702/    3E04 :                        
 2703/    3E04 : B03C 00AE              	CMP.b		#TK_NOT,d0				; compare with token for NOT
 2704/    3E08 : 6606                   	BNE.s		LAB_1BE7				; branch if not token for NOT
 2705/    3E0A :                        
 2706/    3E0A :                        								; was NOT token
 2707/    3E0A : 323C 002C              	MOVE.w	#(TK_EQUAL-TK_PLUS)*4,d1		; offset to NOT function
 2708/    3E0E : 60C4                   	BRA.s		LAB_1C13				; do set-up for function then execute
 2709/    3E10 :                        
 2710/    3E10 :                        								; wasn't +, - or NOT so ...
 2711/    3E10 :                        LAB_1BE7
 2712/    3E10 : B03C 00AB              	CMP.b		#TK_FN,d0				; compare with token for FN
 2713/    3E14 : 6700 0514              	BEQ		LAB_201E				; if FN go evaluate FNx
 2714/    3E18 :                        
 2715/    3E18 :                        								; wasn't +, -, NOT or FN so ...
 2716/    3E18 : 903C 00BF              	SUB.b		#TK_SGN,d0				; compare with token for SGN & normalise
 2717/    3E1C : 6500 F34A              	BCS		LAB_SNER				; if < SGN token then do syntax error
 2718/    3E20 :                        
 2719/    3E20 :                        ; get value from line .. continued
 2720/    3E20 :                        ; only functions left so set up function references
 2721/    3E20 :                        
 2722/    3E20 :                        ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
 2723/    3E20 :                        ; to process function calls. now the function vector is computed and pushed on the stack
 2724/    3E20 :                        ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
 2725/    3E20 :                        ; is calculated and the routine called, if not this routine just does RTS. whichever
 2726/    3E20 :                        ; happens the RTS at the end of this routine, or the preprocess routine calls, the
 2727/    3E20 :                        ; function code
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 50 - 12/13/2023 15:59:9


 2728/    3E20 :                        
 2729/    3E20 :                        ; this also removes some less than elegant code that was used to bypass type checking
 2730/    3E20 :                        ; for functions that returned strings
 2731/    3E20 :                        
 2732/    3E20 : C07C 007F              	AND.w		#$7F,d0				; mask byte
 2733/    3E24 : D040                   	ADD.w		d0,d0					; *2 (2 bytes per function offset)
 2734/    3E26 :                        
 2735/    3E26 : 41FA 20B0              	LEA		LAB_FTBL(pc),a0			; pointer to functions vector table
 2736/    3E2A : 3230 0000              	MOVE.w	(a0,d0.w),d1			; get function vector offset
 2737/    3E2E : 4870 1000              	PEA		(a0,d1.w)				; push function vector
 2738/    3E32 :                        
 2739/    3E32 : 41FA 2058              	LEA		LAB_FTPP(pc),a0			; pointer to functions preprocess vector table
 2740/    3E36 : 3030 0000              	MOVE.w	(a0,d0.w),d0			; get function preprocess vector offset
 2741/    3E3A : 6712                   	BEQ.s		LAB_1C2A				; no preprocess vector so go do function
 2742/    3E3C :                        
 2743/    3E3C : 41F0 0000              	LEA		(a0,d0.w),a0			; get function preprocess vector
 2744/    3E40 : 4ED0                   	JMP		(a0)					; go do preprocess routine then function
 2745/    3E42 :                        
 2746/    3E42 :                        
 2747/    3E42 :                        ;************************************************************************************
 2748/    3E42 :                        ;
 2749/    3E42 :                        ; process string expression in parenthesis
 2750/    3E42 :                        
 2751/    3E42 :                        LAB_PPFS
 2752/    3E42 : 6100 FF54              	BSR		LAB_1BF7				; process expression in parenthesis
 2753/    3E46 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type
 2754/    3E4A : 6A00 F2F0              	BPL		LAB_TMER				; if numeric do Type missmatch Error/warm start
 2755/    3E4E :                        
 2756/    3E4E :                        LAB_1C2A
 2757/    3E4E : 4E75                   	RTS							; else do function
 2758/    3E50 :                        
 2759/    3E50 :                        
 2760/    3E50 :                        ;************************************************************************************
 2761/    3E50 :                        ;
 2762/    3E50 :                        ; process numeric expression in parenthesis
 2763/    3E50 :                        
 2764/    3E50 :                        LAB_PPFN
 2765/    3E50 : 6100 FF46              	BSR		LAB_1BF7				; process expression in parenthesis
 2766/    3E54 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type
 2767/    3E58 : 6B00 F2E2              	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
 2768/    3E5C :                        
 2769/    3E5C : 4E75                   	RTS							; else do function
 2770/    3E5E :                        
 2771/    3E5E :                        
 2772/    3E5E :                        ;************************************************************************************
 2773/    3E5E :                        ;
 2774/    3E5E :                        ; set numeric data type and increment BASIC execute pointer
 2775/    3E5E :                        
 2776/    3E5E :                        LAB_PPBI
 2777/    3E5E : 177C 0000 05B5         	MOVE.b	#$00,Dtypef(a3)			; clear data type flag, $00=float
 2778/    3E64 : 101D                   	MOVE.b	(a5)+,d0				; get next BASIC byte
 2779/    3E66 : 4E75                   	RTS							; do function
 2780/    3E68 :                        
 2781/    3E68 :                        
 2782/    3E68 :                        ;************************************************************************************
 2783/    3E68 :                        ;
 2784/    3E68 :                        ; process string for LEFT$, RIGHT$ or MID$
 2785/    3E68 :                        
 2786/    3E68 :                        LAB_LRMS
 2787/    3E68 : 6100 FDE6              	BSR		LAB_EVEZ				; evaluate (should be string) expression
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 51 - 12/13/2023 15:59:9


 2788/    3E6C : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type flag
 2789/    3E70 : 6A00 F2CA              	BPL		LAB_TMER				; if type is not string do type mismatch error
 2790/    3E74 :                        
 2791/    3E74 : 141D                   	MOVE.b	(a5)+,d2				; get BASIC byte
 2792/    3E76 : B43C 002C              	CMP.b		#',',d2				; compare with comma
 2793/    3E7A : 6600 F2EC              	BNE		LAB_SNER				; if not "," go do syntax error/warm start
 2794/    3E7E :                        
 2795/    3E7E : 2F2B 0590              	MOVE.l	FAC1_m(a3),-(sp)			; save descriptor pointer
 2796/    3E82 : 6100 08AC              	BSR		LAB_GTWO				; get word parameter, result in d0 and Itemp
 2797/    3E86 : 205F                   	MOVEA.l	(sp)+,a0				; restore descriptor pointer
 2798/    3E88 : 4E75                   	RTS							; do function
 2799/    3E8A :                        
 2800/    3E8A :                        
 2801/    3E8A :                        ;************************************************************************************
 2802/    3E8A :                        ;
 2803/    3E8A :                        ; process numeric expression(s) for BIN$ or HEX$
 2804/    3E8A :                        
 2805/    3E8A :                        LAB_BHSS
 2806/    3E8A : 6100 FDC4              	BSR		LAB_EVEZ				; evaluate expression (no decrement)
 2807/    3E8E : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type
 2808/    3E92 : 6B00 F2A8              	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
 2809/    3E96 :                        
 2810/    3E96 : 6100 0DD0              	BSR		LAB_2831				; convert FAC1 floating to fixed
 2811/    3E9A :                        								; result in d0 and Itemp
 2812/    3E9A : 7200                   	MOVEQ		#0,d1					; set default to no leading "0"s
 2813/    3E9C : 141D                   	MOVE.b	(a5)+,d2				; get BASIC byte
 2814/    3E9E : B43C 002C              	CMP.b		#',',d2				; compare with comma
 2815/    3EA2 : 660C                   	BNE.s		LAB_BHCB				; if not "," go check close bracket
 2816/    3EA4 :                        
 2817/    3EA4 : 2F00                   	MOVE.l	d0,-(sp)				; copy number to stack
 2818/    3EA6 : 6100 0872              	BSR		LAB_GTBY				; get byte value
 2819/    3EAA : 2200                   	MOVE.l	d0,d1					; copy leading 0s #
 2820/    3EAC : 201F                   	MOVE.l	(sp)+,d0				; restore number from stack
 2821/    3EAE : 141D                   	MOVE.b	(a5)+,d2				; get BASIC byte
 2822/    3EB0 :                        LAB_BHCB
 2823/    3EB0 : B43C 0029              	CMP.b		#')',d2				; compare with close bracket
 2824/    3EB4 : 6600 F2B2              	BNE		LAB_SNER				; if not ")" do Syntax Error/warm start
 2825/    3EB8 :                        
 2826/    3EB8 : 4E75                   	RTS							; go do function
 2827/    3EBA :                        
 2828/    3EBA :                        
 2829/    3EBA :                        ;************************************************************************************
 2830/    3EBA :                        ;
 2831/    3EBA :                        ; perform EOR
 2832/    3EBA :                        
 2833/    3EBA :                        LAB_EOR
 2834/    3EBA : 6116                   	BSR.s		GetFirst				; get two values for OR, AND or EOR
 2835/    3EBC :                        								; first in d0, and Itemp, second in d2
 2836/    3EBC : B580                   	EOR.l		d2,d0					; EOR values
 2837/    3EBE : 6000 03F0              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
 2838/    3EC2 :                        
 2839/    3EC2 :                        
 2840/    3EC2 :                        ;************************************************************************************
 2841/    3EC2 :                        ;
 2842/    3EC2 :                        ; perform OR
 2843/    3EC2 :                        
 2844/    3EC2 :                        LAB_OR
 2845/    3EC2 : 610E                   	BSR.s		GetFirst				; get two values for OR, AND or EOR
 2846/    3EC4 :                        								; first in d0, and Itemp, second in d2
 2847/    3EC4 : 8082                   	OR.l		d2,d0					; do OR
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 52 - 12/13/2023 15:59:9


 2848/    3EC6 : 6000 03E8              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
 2849/    3ECA :                        
 2850/    3ECA :                        
 2851/    3ECA :                        ;************************************************************************************
 2852/    3ECA :                        ;
 2853/    3ECA :                        ; perform AND
 2854/    3ECA :                        
 2855/    3ECA :                        LAB_AND
 2856/    3ECA : 6106                   	BSR.s		GetFirst				; get two values for OR, AND or EOR
 2857/    3ECC :                        								; first in d0, and Itemp, second in d2
 2858/    3ECC : C082                   	AND.l		d2,d0					; do AND
 2859/    3ECE : 6000 03E0              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
 2860/    3ED2 :                        
 2861/    3ED2 :                        
 2862/    3ED2 :                        ;************************************************************************************
 2863/    3ED2 :                        ;
 2864/    3ED2 :                        ; get two values for OR, AND, EOR
 2865/    3ED2 :                        ; first in d0, second in d2
 2866/    3ED2 :                        
 2867/    3ED2 :                        GetFirst
 2868/    3ED2 : 6100 0228              	BSR		LAB_EVIR				; evaluate integer expression (no sign check)
 2869/    3ED6 :                        								; result in d0 and Itemp
 2870/    3ED6 : 2400                   	MOVE.l	d0,d2					; copy second value
 2871/    3ED8 : 6100 0CF6              	BSR		LAB_279B				; copy FAC2 to FAC1, get first value in
 2872/    3EDC :                        								; expression
 2873/    3EDC : 6000 021E              	BRA		LAB_EVIR				; evaluate integer expression (no sign check)
 2874/    3EE0 :                        								; result in d0 and Itemp & return
 2875/    3EE0 :                        
 2876/    3EE0 :                        
 2877/    3EE0 :                        ;************************************************************************************
 2878/    3EE0 :                        ;
 2879/    3EE0 :                        ; perform NOT
 2880/    3EE0 :                        
 2881/    3EE0 :                        LAB_EQUAL
 2882/    3EE0 : 6100 021A              	BSR		LAB_EVIR				; evaluate integer expression (no sign check)
 2883/    3EE4 :                        								; result in d0 and Itemp
 2884/    3EE4 : 4680                   	NOT.l		d0					; bitwise invert
 2885/    3EE6 : 6000 03C8              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
 2886/    3EEA :                        
 2887/    3EEA :                        
 2888/    3EEA :                        ;************************************************************************************
 2889/    3EEA :                        ;
 2890/    3EEA :                        ; perform comparisons
 2891/    3EEA :                        ; do < compare
 2892/    3EEA :                        
 2893/    3EEA :                        LAB_LTHAN
 2894/    3EEA : 6100 FD4E              	BSR		LAB_CKTM				; type match check, set C for string
 2895/    3EEE : 6506                   	BCS.s		LAB_1CAE				; branch if string
 2896/    3EF0 :                        
 2897/    3EF0 :                        								; do numeric < compare
 2898/    3EF0 : 6100 0D4A              	BSR		LAB_27FA				; compare FAC1 with FAC2
 2899/    3EF4 :                        								; returns d0=+1 if FAC1 > FAC2
 2900/    3EF4 :                        								; returns d0= 0 if FAC1 = FAC2
 2901/    3EF4 :                        								; returns d0=-1 if FAC1 < FAC2
 2902/    3EF4 : 6042                   	BRA.s		LAB_1CF2				; process result
 2903/    3EF6 :                        
 2904/    3EF6 :                        								; do string < compare
 2905/    3EF6 :                        LAB_1CAE
 2906/    3EF6 : 177C 0000 05B5         	MOVE.b	#$00,Dtypef(a3)			; clear data type, $80=string, $40=integer,
 2907/    3EFC :                        								; $00=float
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 53 - 12/13/2023 15:59:9


 2908/    3EFC : 6100 06BC              	BSR		LAB_22B6				; pop string off descriptor stack, or from top
 2909/    3F00 :                        								; of string space returns d0 = length,
 2910/    3F00 :                        								; a0 = pointer
 2911/    3F00 : 2248                   	MOVEA.l	a0,a1					; copy string 2 pointer
 2912/    3F02 : 2200                   	MOVE.l	d0,d1					; copy string 2 length
 2913/    3F04 : 206B 0598              	MOVEA.l	FAC2_m(a3),a0			; get string 1 descriptor pointer
 2914/    3F08 : 6100 06B4              	BSR		LAB_22BA				; pop (a0) descriptor, returns with ..
 2915/    3F0C :                        								; d0 = length, a0 = pointer
 2916/    3F0C : 2400                   	MOVE.l	d0,d2					; copy length
 2917/    3F0E : 6604                   	BNE.s		LAB_1CB5				; branch if not null string
 2918/    3F10 :                        
 2919/    3F10 : 4A81                   	TST.l		d1					; test if string 2 is null also
 2920/    3F12 : 6724                   	BEQ.s		LAB_1CF2				; if so do string 1 = string 2
 2921/    3F14 :                        
 2922/    3F14 :                        LAB_1CB5
 2923/    3F14 : 9481                   	SUB.l		d1,d2					; subtract string 2 length
 2924/    3F16 : 670C                   	BEQ.s		LAB_1CD5				; branch if strings = length
 2925/    3F18 :                        
 2926/    3F18 : 6504                   	BCS.s		LAB_1CD4				; branch if string 1 < string 2
 2927/    3F1A :                        
 2928/    3F1A : 70FF                   	MOVEQ		#-1,d0				; set for string 1 > string 2
 2929/    3F1C : 6008                   	BRA.s		LAB_1CD6				; go do character comapare
 2930/    3F1E :                        
 2931/    3F1E :                        LAB_1CD4
 2932/    3F1E : 2200                   	MOVE.l	d0,d1					; string 1 length is compare length
 2933/    3F20 : 7001                   	MOVEQ		#1,d0					; and set for string 1 < string 2
 2934/    3F22 : 6002                   	BRA.s		LAB_1CD6				; go do character comapare
 2935/    3F24 :                        
 2936/    3F24 :                        LAB_1CD5
 2937/    3F24 : 2002                   	MOVE.l	d2,d0					; set for string 1 = string 2
 2938/    3F26 :                        LAB_1CD6
 2939/    3F26 : 5381                   	SUBQ.l	#1,d1					; adjust length for DBcc loop
 2940/    3F28 :                        
 2941/    3F28 :                        								; d1 is length to compare, d0 is <=> for length
 2942/    3F28 :                        								; a0 is string 1 pointer, a1 is string 2 pointer
 2943/    3F28 :                        LAB_1CE6
 2944/    3F28 : B308                   	CMPM.b	(a0)+,(a1)+				; compare string bytes (1 with 2)
 2945/    3F2A : 56C9 FFFC              	DBNE		d1,LAB_1CE6				; loop if same and not end yet
 2946/    3F2E :                        
 2947/    3F2E : 6708                   	BEQ.s		LAB_1CF2				; if = to here, then go use length compare
 2948/    3F30 :                        
 2949/    3F30 : 6404                   	BCC.s		LAB_1CDB				; else branch if string 1 > string 2
 2950/    3F32 :                        
 2951/    3F32 : 70FF                   	MOVEQ		#-1,d0				; else set for string 1 < string 2
 2952/    3F34 : 6002                   	BRA.s		LAB_1CF2				; go set result
 2953/    3F36 :                        
 2954/    3F36 :                        LAB_1CDB
 2955/    3F36 : 7001                   	MOVEQ		#1,d0					; and set for string 1 > string 2
 2956/    3F38 :                        
 2957/    3F38 :                        LAB_1CF2
 2958/    3F38 : 5200                   	ADDQ.b	#1,d0					; make result 0, 1 or 2
 2959/    3F3A : 1200                   	MOVE.b	d0,d1					; copy to d1
 2960/    3F3C : 7001                   	MOVEQ		#1,d0					; set d0 longword
 2961/    3F3E : E338                   	ROL.b		d1,d0					; make 1, 2 or 4 (result = flag bit)
 2962/    3F40 : C02B 05E1              	AND.b		Cflag(a3),d0			; AND with comparison evaluation flag
 2963/    3F44 : 6700 0CDE              	BEQ		LAB_27DB				; exit if not a wanted result (i.e. false)
 2964/    3F48 :                        
 2965/    3F48 : 70FF                   	MOVEQ		#-1,d0				; else set -1 (true)
 2966/    3F4A : 6000 0CD8              	BRA		LAB_27DB				; save d0 as integer & return
 2967/    3F4E :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 54 - 12/13/2023 15:59:9


 2968/    3F4E :                        
 2969/    3F4E :                        LAB_1CFE
 2970/    3F4E : 6100 FE54              	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
 2971/    3F52 :                        
 2972/    3F52 :                        
 2973/    3F52 :                        ;************************************************************************************
 2974/    3F52 :                        ;
 2975/    3F52 :                        ; perform DIM
 2976/    3F52 :                        
 2977/    3F52 :                        LAB_DIM
 2978/    3F52 : 72FF                   	MOVEQ		#-1,d1				; set "DIM" flag
 2979/    3F54 : 6170                   	BSR.s		LAB_1D10				; search for or dimension a variable
 2980/    3F56 : 6100 FE58              	BSR		LAB_GBYT				; scan memory
 2981/    3F5A : 66F2                   	BNE.s		LAB_1CFE				; loop and scan for "," if not null
 2982/    3F5C :                        
 2983/    3F5C : 4E75                   	RTS
 2984/    3F5E :                        
 2985/    3F5E :                        
 2986/    3F5E :                        ;************************************************************************************
 2987/    3F5E :                        ;
 2988/    3F5E :                        ; perform << (left shift)
 2989/    3F5E :                        
 2990/    3F5E :                        LAB_LSHIFT
 2991/    3F5E : 612E                   	BSR.s		GetPair				; get an integer and byte pair
 2992/    3F60 :                        								; byte is in d2, integer is in d0 and Itemp
 2993/    3F60 : 6708                   	BEQ.s		NoShift				; branch if byte zero
 2994/    3F62 :                        
 2995/    3F62 : B43C 0020              	CMP.b		#$20,d2				; compare bit count with 32d
 2996/    3F66 : 6420                   	BCC.s		TooBig				; branch if >=
 2997/    3F68 :                        
 2998/    3F68 : E5A0                   	ASL.l		d2,d0					; shift longword
 2999/    3F6A :                        NoShift
 3000/    3F6A : 6000 0344              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
 3001/    3F6E :                        
 3002/    3F6E :                        
 3003/    3F6E :                        ;************************************************************************************
 3004/    3F6E :                        ;
 3005/    3F6E :                        ; perform >> (right shift)
 3006/    3F6E :                        
 3007/    3F6E :                        LAB_RSHIFT
 3008/    3F6E : 611E                   	BSR.s		GetPair				; get an integer and byte pair
 3009/    3F70 :                        								; byte is in d2, integer is in d0 and Itemp
 3010/    3F70 : 67F8                   	BEQ.s		NoShift				; branch if byte zero
 3011/    3F72 :                        
 3012/    3F72 : B43C 0020              	CMP.b		#$20,d2				; compare bit count with 32d
 3013/    3F76 : 650A                   	BCS.s		Not2Big				; branch if >= (return shift)
 3014/    3F78 :                        
 3015/    3F78 : 4A80                   	TST.l		d0					; test sign bit
 3016/    3F7A : 6A0C                   	BPL.s		TooBig				; branch if +ve
 3017/    3F7C :                        
 3018/    3F7C : 70FF                   	MOVEQ		#-1,d0				; set longword
 3019/    3F7E : 6000 0330              	BRA		LAB_AYFC				; convert d0 to longword in FAC1 & RET
 3020/    3F82 :                        
 3021/    3F82 :                        Not2Big
 3022/    3F82 : E4A0                   	ASR.l		d2,d0					; shift longword
 3023/    3F84 : 6000 032A              	BRA		LAB_AYFC				; convert d0 to longword in FAC1 & RET
 3024/    3F88 :                        
 3025/    3F88 :                        TooBig
 3026/    3F88 : 7000                   	MOVEQ		#0,d0					; clear longword
 3027/    3F8A : 6000 0324              	BRA		LAB_AYFC				; convert d0 to longword in FAC1 & RET
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 55 - 12/13/2023 15:59:9


 3028/    3F8E :                        
 3029/    3F8E :                        
 3030/    3F8E :                        ;************************************************************************************
 3031/    3F8E :                        ;
 3032/    3F8E :                        ; get an integer and byte pair
 3033/    3F8E :                        ; byte is in d2, integer is in d0 and Itemp
 3034/    3F8E :                        
 3035/    3F8E :                        GetPair
 3036/    3F8E : 6100 078E              	BSR		LAB_EVBY				; evaluate byte expression, result in d0 and
 3037/    3F92 :                        								; Itemp
 3038/    3F92 : 1400                   	MOVE.b	d0,d2					; save it
 3039/    3F94 : 6100 0C3A              	BSR		LAB_279B				; copy FAC2 to FAC1, get first value in
 3040/    3F98 :                        								; expression
 3041/    3F98 : 6100 0162              	BSR		LAB_EVIR				; evaluate integer expression (no sign check)
 3042/    3F9C :                        								; result in d0 and Itemp
 3043/    3F9C : 4A02                   	TST.b		d2					; test byte value
 3044/    3F9E : 4E75                   	RTS
 3045/    3FA0 :                        
 3046/    3FA0 :                        
 3047/    3FA0 :                        ;************************************************************************************
 3048/    3FA0 :                        ;
 3049/    3FA0 :                        ; check alpha, return C=0 if<"A" or >"Z" or <"a" to "z">
 3050/    3FA0 :                        
 3051/    3FA0 :                        LAB_CASC
 3052/    3FA0 : B03C 0061              	CMP.b		#$61,d0				; compare with "a"
 3053/    3FA4 : 6410                   	BCC.s		LAB_1D83				; if >="a" go check =<"z"
 3054/    3FA6 :                        
 3055/    3FA6 :                        
 3056/    3FA6 :                        ;************************************************************************************
 3057/    3FA6 :                        ;
 3058/    3FA6 :                        ; check alpha upper case, return C=0 if<"A" or >"Z"
 3059/    3FA6 :                        
 3060/    3FA6 :                        LAB_CAUC
 3061/    3FA6 : B03C 0041              	CMP.b		#$41,d0				; compare with "A"
 3062/    3FAA : 6404                   	BCC.s		LAB_1D8A				; if >="A" go check =<"Z"
 3063/    3FAC :                        
 3064/    3FAC : 8040                   	OR		d0,d0					; make C=0
 3065/    3FAE : 4E75                   	RTS
 3066/    3FB0 :                        
 3067/    3FB0 :                        LAB_1D8A
 3068/    3FB0 : B03C 005B              	CMP.b		#$5B,d0				; compare with "Z"+1
 3069/    3FB4 :                        								; carry set if byte<="Z"
 3070/    3FB4 : 4E75                   	RTS
 3071/    3FB6 :                        
 3072/    3FB6 :                        LAB_1D83
 3073/    3FB6 : B03C 007B              	CMP.b		#$7B,d0				; compare with "z"+1
 3074/    3FBA :                        								; carry set if byte<="z"
 3075/    3FBA : 4E75                   	RTS
 3076/    3FBC :                        
 3077/    3FBC :                        
 3078/    3FBC :                        ;************************************************************************************
 3079/    3FBC :                        ;
 3080/    3FBC :                        ; search for or create variable. this is used to automatically create a variable if
 3081/    3FBC :                        ; it is not found. any routines that need to create the variable call LAB_GVAR via
 3082/    3FBC :                        ; this point and error generation is supressed and the variable will be created
 3083/    3FBC :                        ;
 3084/    3FBC :                        ; return pointer to variable in Cvaral and a0
 3085/    3FBC :                        ; set data type to variable type
 3086/    3FBC :                        
 3087/    3FBC :                        LAB_SVAR
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 56 - 12/13/2023 15:59:9


 3088/    3FBC : 6102                   	BSR.s		LAB_GVAR				; search for variable
 3089/    3FBE :                        LAB_FVAR
 3090/    3FBE : 4E75                   	RTS
 3091/    3FC0 :                        
 3092/    3FC0 :                        
 3093/    3FC0 :                        ;************************************************************************************
 3094/    3FC0 :                        ;
 3095/    3FC0 :                        ; search for variable. if this routine is called from anywhere but the above call and
 3096/    3FC0 :                        ; the variable searched for does not exist then an error will be returned
 3097/    3FC0 :                        ;
 3098/    3FC0 :                        ; DIM flag is in d1.b
 3099/    3FC0 :                        ; return pointer to variable in Cvaral and a0
 3100/    3FC0 :                        ; set data type to variable type
 3101/    3FC0 :                        
 3102/    3FC0 :                        LAB_GVAR
 3103/    3FC0 : 7200                   	MOVEQ		#$00,d1				; set DIM flag = $00
 3104/    3FC2 : 6100 FDEC              	BSR		LAB_GBYT				; scan memory (1st character)
 3105/    3FC6 :                        LAB_1D10
 3106/    3FC6 : 1741 05B4              	MOVE.b	d1,Defdim(a3)			; save DIM flag
 3107/    3FCA :                        
 3108/    3FCA :                        ; search for FN name entry point
 3109/    3FCA :                        
 3110/    3FCA :                        LAB_1D12
 3111/    3FCA : 61D4                   	BSR.s		LAB_CASC				; check byte, return C=0 if<"A" or >"Z"
 3112/    3FCC : 6400 F19A              	BCC		LAB_SNER				; if not, syntax error then warm start
 3113/    3FD0 :                        
 3114/    3FD0 :                        								; it is a variable name so ...
 3115/    3FD0 : 7200                   	MOVEQ		#$0,d1				; set index for name byte
 3116/    3FD2 : 41EB 046A              	LEA		Varname(a3),a0			; pointer to variable name
 3117/    3FD6 : 2081                   	MOVE.l	d1,(a0)				; clear the variable name
 3118/    3FD8 : 1741 05B5              	MOVE.b	d1,Dtypef(a3)			; clear the data type, $80=string, $40=integer,
 3119/    3FDC :                        								; $00=float
 3120/    3FDC :                        
 3121/    3FDC :                        LAB_1D2D
 3122/    3FDC : B27C 0004              	CMP.w		#$04,d1				; done all significant characters?
 3123/    3FE0 : 6406                   	BCC.s		LAB_1D2E				; if so go ignore any more
 3124/    3FE2 :                        
 3125/    3FE2 : 1180 1000              	MOVE.b	d0,(a0,d1.w)			; save the character
 3126/    3FE6 : 5241                   	ADDQ.w	#1,d1					; increment index
 3127/    3FE8 :                        LAB_1D2E
 3128/    3FE8 : 6100 FDC4              	BSR		LAB_IGBY				; increment & scan memory (next character)
 3129/    3FEC : 65EE                   	BCS.s		LAB_1D2D				; branch if character = "0"-"9" (ok)
 3130/    3FEE :                        
 3131/    3FEE :                        								; character wasn't "0" to "9" so ...
 3132/    3FEE : 61B0                   	BSR.s		LAB_CASC				; check byte, return C=0 if<"A" or >"Z"
 3133/    3FF0 : 65EA                   	BCS.s		LAB_1D2D				; branch if = "A"-"Z" (ok)
 3134/    3FF2 :                        
 3135/    3FF2 :                        								; check if string variable
 3136/    3FF2 : B03C 0024              	CMP.b		#'$',d0				; compare with "$"
 3137/    3FF6 : 660C                   	BNE.s		LAB_1D44				; branch if not string
 3138/    3FF8 :                        
 3139/    3FF8 :                        								; type is string
 3140/    3FF8 : 002B 0080 046B         	OR.b		#$80,Varname+1(a3)		; set top bit of 2nd character, indicate string
 3141/    3FFE : 6100 FDAE              	BSR		LAB_IGBY				; increment & scan memory
 3142/    4002 : 6010                   	BRA.s		LAB_1D45				; skip integer check
 3143/    4004 :                        
 3144/    4004 :                        								; check if integer variable
 3145/    4004 :                        LAB_1D44
 3146/    4004 : B03C 0026              	CMP.b		#'&',d0				; compare with "&"
 3147/    4008 : 660A                   	BNE.s		LAB_1D45				; branch if not integer
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 57 - 12/13/2023 15:59:9


 3148/    400A :                        
 3149/    400A :                        								; type is integer
 3150/    400A : 002B 0080 046C         	OR.b		#$80,Varname+2(a3)		; set top bit of 3rd character, indicate integer
 3151/    4010 : 6100 FD9C              	BSR		LAB_IGBY				; increment & scan memory
 3152/    4014 :                        
 3153/    4014 :                        ; after we have determined the variable type we need to determine
 3154/    4014 :                        ; if it's an array of type
 3155/    4014 :                        
 3156/    4014 :                        								; gets here with character after var name in d0
 3157/    4014 :                        LAB_1D45
 3158/    4014 : 4A2B 05DF              	TST.b		Sufnxf(a3)				; test function name flag
 3159/    4018 : 670E                   	BEQ.s		LAB_1D48				; if not FN or FN variable continue
 3160/    401A :                        
 3161/    401A : 6A14                   	BPL.s		LAB_1D49				; if FN variable go find or create it
 3162/    401C :                        
 3163/    401C :                        								; else was FN name
 3164/    401C : 202B 046A              	MOVE.l	Varname(a3),d0			; get whole function name
 3165/    4020 : 7208                   	MOVEQ		#8,d1					; set step to next function size -4
 3166/    4022 : 41EB 0432              	LEA		Sfncl(a3),a0			; get pointer to start of functions
 3167/    4026 : 601C                   	BRA.s		LAB_1D4B				; go find function
 3168/    4028 :                        
 3169/    4028 :                        LAB_1D48
 3170/    4028 : 903C 0028              	SUB.b		#'(',d0				; subtract "("
 3171/    402C : 6700 00F4              	BEQ		LAB_1E17				; if "(" go find, or make, array
 3172/    4030 :                        
 3173/    4030 :                        ; either find or create var
 3174/    4030 :                        ; var name (1st four characters only!) is in Varname
 3175/    4030 :                        
 3176/    4030 :                        								; variable name wasn't var( .. so look for
 3177/    4030 :                        								; plain variable
 3178/    4030 :                        LAB_1D49
 3179/    4030 : 202B 046A              	MOVE.l	Varname(a3),d0			; get whole variable name
 3180/    4034 :                        LAB_1D4A
 3181/    4034 : 7204                   	MOVEQ		#4,d1					; set step to next variable size -4
 3182/    4036 : 41EB 0436              	LEA		Svarl(a3),a0			; get pointer to start of variables
 3183/    403A :                        
 3184/    403A : 0800 0017              	BTST.l	#23,d0				; test if string name
 3185/    403E : 6704                   	BEQ.s		LAB_1D4B				; branch if not
 3186/    4040 :                        
 3187/    4040 : 5441                   	ADDQ.w	#2,d1					; 6 bytes per string entry
 3188/    4042 : 5848                   	ADDQ.w	#(Sstrl-Svarl),a0			; move to string area
 3189/    4044 :                        
 3190/    4044 :                        LAB_1D4B
 3191/    4044 : 2268 0004              	MOVEA.l	4(a0),a1				; get end address
 3192/    4048 : 2050                   	MOVEA.l	(a0),a0				; get start address
 3193/    404A : 6006                   	BRA.s		LAB_1D5E				; enter loop at exit check
 3194/    404C :                        
 3195/    404C :                        LAB_1D5D
 3196/    404C : B098                   	CMP.l		(a0)+,d0				; compare this variable with name
 3197/    404E : 6776                   	BEQ.s		LAB_1DD7				; branch if match (found var)
 3198/    4050 :                        
 3199/    4050 : D1C1                   	ADDA.l	d1,a0					; add offset to next variable
 3200/    4052 :                        LAB_1D5E
 3201/    4052 : B1C9                   	CMPA.l	a1,a0					; compare address with variable space end
 3202/    4054 : 66F6                   	BNE.s		LAB_1D5D				; if not end go check next
 3203/    4056 :                        
 3204/    4056 : 4A2B 05DF              	TST.b		Sufnxf(a3)				; is it a function or function variable
 3205/    405A : 660A                   	BNE.s		LAB_1D94				; if was go do DEF or function variable
 3206/    405C :                        
 3207/    405C :                        								; reached end of variable mem without match
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 58 - 12/13/2023 15:59:9


 3208/    405C :                        								; ... so create new variable, possibly
 3209/    405C :                        
 3210/    405C : 45FA FF60              	LEA		LAB_FVAR(pc),a2			; get the address of the create if doesn't
 3211/    4060 :                        								; exist call to LAB_GVAR
 3212/    4060 : B5D7                   	CMPA.l	(sp),a2				; compare the return address with expected
 3213/    4062 : 6600 F0C0              	BNE		LAB_UVER				; if not create go do error or return null
 3214/    4066 :                        
 3215/    4066 :                        ; this will only branch if the call to LAB_GVAR wasn't from LAB_SVAR
 3216/    4066 :                        
 3217/    4066 :                        LAB_1D94
 3218/    4066 : 082B 0000 05DF         	BTST.b	#0,Sufnxf(a3)			; test function search flag
 3219/    406C : 6600 F0BE              	BNE		LAB_UFER				; if not doing DEF then go do undefined
 3220/    4070 :                        								; function error
 3221/    4070 :                        
 3222/    4070 :                        								; else create new variable/function
 3223/    4070 :                        LAB_1D98
 3224/    4070 : 246B 0442              	MOVEA.l	Earryl(a3),a2			; get end of block to move
 3225/    4074 : 240A                   	MOVE.l	a2,d2					; copy end of block to move
 3226/    4076 : 9489                   	SUB.l		a1,d2					; calculate block to move size
 3227/    4078 :                        
 3228/    4078 : 204A                   	MOVEA.l	a2,a0					; copy end of block to move
 3229/    407A : 5881                   	ADDQ.l	#4,d1					; space for one variable/function + name
 3230/    407C : D5C1                   	ADDA.l	d1,a2					; add space for one variable/function
 3231/    407E : 274A 0442              	MOVE.l	a2,Earryl(a3)			; set new array mem end
 3232/    4082 : E28A                   	LSR.l		#1,d2					; /2 for word copy
 3233/    4084 : 6712                   	BEQ.s		LAB_1DAF				; skip move if zero length block
 3234/    4086 :                        
 3235/    4086 : 5382                   	SUBQ.l	#1,d2					; -1 for DFB loop
 3236/    4088 : 4842                   	SWAP		d2					; swap high word to low word
 3237/    408A :                        LAB_1DAC
 3238/    408A : 4842                   	SWAP		d2					; swap high word to low word
 3239/    408C :                        LAB_1DAE
 3240/    408C : 3520                   	MOVE.w	-(a0),-(a2)				; copy word
 3241/    408E : 51CA FFFC              	DBF		d2,LAB_1DAE				; loop until done
 3242/    4092 :                        
 3243/    4092 : 4842                   	SWAP		d2					; swap high word to low word
 3244/    4094 : 51CA FFF4              	DBF		d2,LAB_1DAC				; decrement high count and loop until done
 3245/    4098 :                        
 3246/    4098 :                        ; get here after creating either a function, variable or string
 3247/    4098 :                        ; if function set variables start, string start, array start
 3248/    4098 :                        ; if variable set string start, array start
 3249/    4098 :                        ; if string set array start
 3250/    4098 :                        
 3251/    4098 :                        LAB_1DAF
 3252/    4098 : 4A2B 05DF              	TST.b		Sufnxf(a3)				; was it function
 3253/    409C : 6B08                   	BMI.s		LAB_1DB0				; branch if was FN
 3254/    409E :                        
 3255/    409E : 0800 0017              	BTST.l	#23,d0				; was it string
 3256/    40A2 : 660A                   	BNE.s		LAB_1DB2				; branch if string
 3257/    40A4 :                        
 3258/    40A4 : 6004                   	BRA.s		LAB_1DB1				; branch if was plain variable
 3259/    40A6 :                        
 3260/    40A6 :                        LAB_1DB0
 3261/    40A6 : D3AB 0436              	ADD.l		d1,Svarl(a3)			; set new variable memory start
 3262/    40AA :                        LAB_1DB1
 3263/    40AA : D3AB 043A              	ADD.l		d1,Sstrl(a3)			; set new start of strings
 3264/    40AE :                        LAB_1DB2
 3265/    40AE : D3AB 043E              	ADD.l		d1,Sarryl(a3)			; set new array memory start
 3266/    40B2 : 20C0                   	MOVE.l	d0,(a0)+				; save variable/function name
 3267/    40B4 : 20BC 0000 0000         	MOVE.l	#$00,(a0)				; initialise variable
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 59 - 12/13/2023 15:59:9


 3268/    40BA : 0800 0017              	BTST.l	#23,d0				; was it string
 3269/    40BE : 6706                   	BEQ.s		LAB_1DD7				; branch if not string
 3270/    40C0 :                        
 3271/    40C0 : 317C 0000 0004         	MOVE.w	#$00,4(a0)				; else initialise string length
 3272/    40C6 :                        
 3273/    40C6 :                        								; found a match for var ((Vrschl) = ptr)
 3274/    40C6 :                        LAB_1DD7
 3275/    40C6 : 2200                   	MOVE.l	d0,d1					; ........ $....... &....... ........
 3276/    40C8 : D281                   	ADD.l		d1,d1					; .......$ .......& ........ .......0
 3277/    40CA : 4841                   	SWAP		d1					; ........ .......0 .......$ .......&
 3278/    40CC : E219                   	ROR.b		#1,d1					; ........ .......0 .......$ &.......
 3279/    40CE : E249                   	LSR.w		#1,d1					; ........ .......0 0....... $&.....�.
 3280/    40D0 : C23C 00C0              	AND.b		#$C0,d1				; mask the type bits
 3281/    40D4 : 1741 05B5              	MOVE.b	d1,Dtypef(a3)			; save the data type
 3282/    40D8 :                        
 3283/    40D8 : 177C 0000 05DF         	MOVE.b	#$00,Sufnxf(a3)			; clear FN flag byte
 3284/    40DE : 4E75                   	RTS
 3285/    40E0 :                        
 3286/    40E0 :                        
 3287/    40E0 :                        ;************************************************************************************
 3288/    40E0 :                        ;
 3289/    40E0 :                        ; set-up array pointer, d0, to first element in array
 3290/    40E0 :                        ; set d0 to (a0)+2*(Dimcnt)+$0A
 3291/    40E0 :                        
 3292/    40E0 :                        LAB_1DE6
 3293/    40E0 : 7005                   	MOVEQ		#5,d0					; set d0 to 5 (*2 = 10, later)
 3294/    40E2 : D02B 05DB              	ADD.b		Dimcnt(a3),d0			; add # of dimensions (1, 2 or 3)
 3295/    40E6 : D080                   	ADD.l		d0,d0					; *2 (bytes per dimension size)
 3296/    40E8 : D088                   	ADD.l		a0,d0					; add array start pointer
 3297/    40EA : 4E75                   	RTS
 3298/    40EC :                        
 3299/    40EC :                        
 3300/    40EC :                        ;************************************************************************************
 3301/    40EC :                        ;
 3302/    40EC :                        ; evaluate unsigned integer expression
 3303/    40EC :                        
 3304/    40EC :                        LAB_EVIN
 3305/    40EC : 6100 FCC0              	BSR		LAB_IGBY				; increment & scan memory
 3306/    40F0 : 6100 FB44              	BSR		LAB_EVNM				; evaluate expression & check is numeric,
 3307/    40F4 :                        								; else do type mismatch
 3308/    40F4 :                        
 3309/    40F4 :                        
 3310/    40F4 :                        ;************************************************************************************
 3311/    40F4 :                        ;
 3312/    40F4 :                        ; evaluate positive integer expression, result in d0 and Itemp
 3313/    40F4 :                        
 3314/    40F4 :                        LAB_EVPI
 3315/    40F4 : 4A2B 0595              	TST.b		FAC1_s(a3)				; test FAC1 sign (b7)
 3316/    40F8 : 6B00 F062              	BMI		LAB_FCER				; do function call error if -ve
 3317/    40FC :                        
 3318/    40FC :                        
 3319/    40FC :                        ;************************************************************************************
 3320/    40FC :                        ;
 3321/    40FC :                        ; evaluate integer expression, no sign check
 3322/    40FC :                        ; result in d0 and Itemp, exit with flags set correctly
 3323/    40FC :                        
 3324/    40FC :                        LAB_EVIR
 3325/    40FC : 0C2B 00A0 0594         	CMPI.b	#$A0,FAC1_e(a3)			; compare exponent with exponent = 2^32 (n>2^31)
 3326/    4102 : 6500 0B64              	BCS		LAB_2831				; convert FAC1 floating to fixed
 3327/    4106 :                        								; result in d0 and Itemp
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 60 - 12/13/2023 15:59:9


 3328/    4106 : 6600 F054              	BNE		LAB_FCER				; if > do function call error, then warm start
 3329/    410A :                        
 3330/    410A : 4A2B 0595              	TST.b		FAC1_s(a3)				; test sign of FAC1
 3331/    410E : 6A00 0B58              	BPL		LAB_2831				; if +ve then ok
 3332/    4112 :                        
 3333/    4112 : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get mantissa
 3334/    4116 : 4480                   	NEG.l		d0					; do -d0
 3335/    4118 : 6800 F042              	BVC		LAB_FCER				; if not $80000000 do FC error, then warm start
 3336/    411C :                        
 3337/    411C : 2740 042A              	MOVE.l	d0,Itemp(a3)			; else just set it
 3338/    4120 : 4E75                   	RTS
 3339/    4122 :                        
 3340/    4122 :                        
 3341/    4122 :                        ;************************************************************************************
 3342/    4122 :                        ;
 3343/    4122 :                        ; find or make array
 3344/    4122 :                        
 3345/    4122 :                        LAB_1E17
 3346/    4122 : 3F2B 05B4              	MOVE.w	Defdim(a3),-(sp)			; get DIM flag and data type flag (word in mem)
 3347/    4126 : 7200                   	MOVEQ		#0,d1					; clear dimensions count
 3348/    4128 :                        
 3349/    4128 :                        ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
 3350/    4128 :                        
 3351/    4128 :                        LAB_1E1F
 3352/    4128 : 3F01                   	MOVE.w	d1,-(sp)				; save dimensions count
 3353/    412A : 2F2B 046A              	MOVE.l	Varname(a3),-(sp)			; save variable name
 3354/    412E : 61BC                   	BSR.s		LAB_EVIN				; evaluate integer expression
 3355/    4130 :                        
 3356/    4130 : 4840                   	SWAP		d0					; swap high word to low word
 3357/    4132 : 4A40                   	TST.w		d0					; test swapped high word
 3358/    4134 : 6600 F016              	BNE		LAB_ABER				; if too big do array bounds error
 3359/    4138 :                        
 3360/    4138 : 275F 046A              	MOVE.l	(sp)+,Varname(a3)			; restore variable name
 3361/    413C : 321F                   	MOVE.w	(sp)+,d1				; restore dimensions count
 3362/    413E : 301F                   	MOVE.w	(sp)+,d0				; restore DIM and data type flags
 3363/    4140 : 3F2B 042C              	MOVE.w	Itemp+2(a3),-(sp)			; stack this dimension size
 3364/    4144 : 3F00                   	MOVE.w	d0,-(sp)				; save DIM and data type flags
 3365/    4146 : 5241                   	ADDQ.w	#1,d1					; increment dimensions count
 3366/    4148 : 6100 FC66              	BSR		LAB_GBYT				; scan memory
 3367/    414C : B03C 002C              	CMP.b		#$2C,d0				; compare with ","
 3368/    4150 : 67D6                   	BEQ.s		LAB_1E1F				; if found go do next dimension
 3369/    4152 :                        
 3370/    4152 : 1741 05DB              	MOVE.b	d1,Dimcnt(a3)			; store dimensions count
 3371/    4156 : 6100 FC44              	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
 3372/    415A : 375F 05B4              	MOVE.w	(sp)+,Defdim(a3)			; restore DIM and data type flags (word in mem)
 3373/    415E : 206B 043E              	MOVEA.l	Sarryl(a3),a0			; get array mem start
 3374/    4162 :                        
 3375/    4162 :                        ; now check to see if we are at the end of array memory (we would be if there were
 3376/    4162 :                        ; no arrays).
 3377/    4162 :                        
 3378/    4162 :                        LAB_1E5C
 3379/    4162 : 2748 05AC              	MOVE.l	a0,Astrtl(a3)			; save as array start pointer
 3380/    4166 : B1EB 0442              	CMPA.l	Earryl(a3),a0			; compare with array mem end
 3381/    416A : 672E                   	BEQ.s		LAB_1EA1				; go build array if not found
 3382/    416C :                        
 3383/    416C :                        								; search for array
 3384/    416C : 2010                   	MOVE.l	(a0),d0				; get this array name
 3385/    416E : B0AB 046A              	CMP.l		Varname(a3),d0			; compare with array name
 3386/    4172 : 670A                   	BEQ.s		LAB_1E8D				; array found so branch
 3387/    4174 :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 61 - 12/13/2023 15:59:9


 3388/    4174 :                        								; no match
 3389/    4174 : 2068 0004              	MOVEA.l	4(a0),a0				; get this array size
 3390/    4178 : D1EB 05AC              	ADDA.l	Astrtl(a3),a0			; add to array start pointer
 3391/    417C : 60E4                   	BRA.s		LAB_1E5C				; go check next array
 3392/    417E :                        
 3393/    417E :                        								; found array, are we trying to dimension it?
 3394/    417E :                        LAB_1E8D
 3395/    417E : 4A2B 05B4              	TST.b		Defdim(a3)				; are we trying to dimension it?
 3396/    4182 : 6600 EFC4              	BNE		LAB_DDER				; if so do double dimension error/warm start
 3397/    4186 :                        
 3398/    4186 :                        ; found the array and we're not dimensioning it so we must find an element in it
 3399/    4186 :                        
 3400/    4186 : 6100 FF58              	BSR		LAB_1DE6				; set data pointer, d0, to the first element
 3401/    418A :                        								; in the array
 3402/    418A : 5048                   	ADDQ.w	#8,a0					; index to dimension count
 3403/    418C : 3018                   	MOVE.w	(a0)+,d0				; get no of dimensions
 3404/    418E : B02B 05DB              	CMP.b		Dimcnt(a3),d0			; compare with dimensions count
 3405/    4192 : 6700 0094              	BEQ		LAB_1F28				; found array so go get element
 3406/    4196 :                        
 3407/    4196 : 6000 EF84              	BRA		LAB_WDER				; else wrong so do "Wrong dimensions" error
 3408/    419A :                        
 3409/    419A :                        								; array not found, so possibly build it
 3410/    419A :                        LAB_1EA1
 3411/    419A : 4A2B 05B4              	TST.b		Defdim(a3)				; test the default DIM flag
 3412/    419E : 6700 EF80              	BEQ		LAB_UDER				; if default flag is clear then we are not
 3413/    41A2 :                        								; explicitly dimensioning an array so go
 3414/    41A2 :                        								; do an "Undimensioned array" error
 3415/    41A2 :                        
 3416/    41A2 : 6100 FF3C              	BSR		LAB_1DE6				; set data pointer, d0, to the first element
 3417/    41A6 :                        								; in the array
 3418/    41A6 : 202B 046A              	MOVE.l	Varname(a3),d0			; get array name
 3419/    41AA : 20C0                   	MOVE.l	d0,(a0)+				; save array name
 3420/    41AC : 7204                   	MOVEQ		#4,d1					; set 4 bytes per element
 3421/    41AE : 0800 0017              	BTST.l	#23,d0				; test if string array
 3422/    41B2 : 6702                   	BEQ.s		LAB_1EDF				; branch if not string
 3423/    41B4 :                        
 3424/    41B4 : 7206                   	MOVEQ		#6,d1					; else 6 bytes per element
 3425/    41B6 :                        LAB_1EDF
 3426/    41B6 : 2741 05A8              	MOVE.l	d1,Asptl(a3)			; set array data size (bytes per element)
 3427/    41BA : 122B 05DB              	MOVE.b	Dimcnt(a3),d1			; get dimensions count
 3428/    41BE : 5848                   	ADDQ.w	#4,a0					; skip the array size now (don't know it yet!)
 3429/    41C0 : 30C1                   	MOVE.w	d1,(a0)+				; set array's dimensions count
 3430/    41C2 :                        
 3431/    41C2 :                        ; now calculate the array data space size
 3432/    41C2 :                        
 3433/    41C2 :                        LAB_1EC0
 3434/    41C2 :                        
 3435/    41C2 :                        ; If you want arrays to dimension themselves by default then comment out the test
 3436/    41C2 :                        ; above and uncomment the next three code lines and the label LAB_1ED0
 3437/    41C2 :                        
 3438/    41C2 :                        ;	MOVE.w	#$0A,d1				; set default dimension value, allow 0 to 9
 3439/    41C2 :                        ;	TST.b		Defdim(a3)				; test default DIM flag
 3440/    41C2 :                        ;	BNE.s		LAB_1ED0				; branch if b6 of Defdim is clear
 3441/    41C2 :                        
 3442/    41C2 : 321F                   	MOVE.w	(sp)+,d1				; get dimension size
 3443/    41C4 :                        ;LAB_1ED0
 3444/    41C4 : 30C1                   	MOVE.w	d1,(a0)+				; save to array header
 3445/    41C6 : 6100 00AE              	BSR		LAB_1F7C				; do this dimension size+1	; array size
 3446/    41CA :                        								; (d1+1)*(Asptl), result in d0
 3447/    41CA : 2740 05A8              	MOVE.l	d0,Asptl(a3)			; save array data size
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 62 - 12/13/2023 15:59:9


 3448/    41CE : 532B 05DB              	SUBQ.b	#1,Dimcnt(a3)			; decrement dimensions count
 3449/    41D2 : 66EE                   	BNE.s		LAB_1EC0				; loop while not = 0
 3450/    41D4 :                        
 3451/    41D4 : D1EB 05A8              	ADDA.l	Asptl(a3),a0			; add size to first element address
 3452/    41D8 : 6500 EF7A              	BCS		LAB_OMER				; if overflow go do "Out of memory" error
 3453/    41DC :                        
 3454/    41DC : B1EB 0446              	CMPA.l	Sstorl(a3),a0			; compare with bottom of string memory
 3455/    41E0 : 650C                   	BCS.s		LAB_1ED6				; branch if less (is ok)
 3456/    41E2 :                        
 3457/    41E2 : 6100 028E              	BSR		LAB_GARB				; do garbage collection routine
 3458/    41E6 : B1EB 0446              	CMPA.l	Sstorl(a3),a0			; compare with bottom of string memory
 3459/    41EA : 6400 EF68              	BCC		LAB_OMER				; if Sstorl <= a0 do "Out of memory"
 3460/    41EE :                        								; error then warm start
 3461/    41EE :                        
 3462/    41EE :                        LAB_1ED6							; ok exit, carry set
 3463/    41EE : 2748 0442              	MOVE.l	a0,Earryl(a3)			; save array mem end
 3464/    41F2 : 7000                   	MOVEQ		#0,d0					; zero d0
 3465/    41F4 : 222B 05A8              	MOVE.l	Asptl(a3),d1			; get size in bytes
 3466/    41F8 : E289                   	LSR.l		#1,d1					; /2 for word fill (may be odd # words)
 3467/    41FA : 5341                   	SUBQ.w	#1,d1					; adjust for DBF loop
 3468/    41FC :                        LAB_1ED8
 3469/    41FC : 3100                   	MOVE.w	d0,-(a0)				; decrement pointer and clear word
 3470/    41FE : 51C9 FFFC              	DBF		d1,LAB_1ED8				; decrement & loop until low word done
 3471/    4202 :                        
 3472/    4202 : 4841                   	SWAP		d1					; swap words
 3473/    4204 : 4A41                   	TST.w		d1					; test high word
 3474/    4206 : 6706                   	BEQ.s		LAB_1F07				; exit if done
 3475/    4208 :                        
 3476/    4208 : 5341                   	SUBQ.w	#1,d1					; decrement low (high) word
 3477/    420A : 4841                   	SWAP		d1					; swap back
 3478/    420C : 60EE                   	BRA.s		LAB_1ED8				; go do a whole block
 3479/    420E :                        
 3480/    420E :                        ; now we need to calculate the array size by doing Earryl - Astrtl
 3481/    420E :                        
 3482/    420E :                        LAB_1F07
 3483/    420E : 206B 05AC              	MOVEA.l	Astrtl(a3),a0			; get for calculation and as pointer
 3484/    4212 : 202B 0442              	MOVE.l	Earryl(a3),d0			; get array memory end
 3485/    4216 : 9088                   	SUB.l		a0,d0					; calculate array size
 3486/    4218 : 2140 0004              	MOVE.l	d0,4(a0)				; save size to array
 3487/    421C : 4A2B 05B4              	TST.b		Defdim(a3)				; test default DIM flag
 3488/    4220 : 6652                   	BNE.s		RTS_011				; exit (RET) if this was a DIM command
 3489/    4222 :                        
 3490/    4222 :                        								; else, find element
 3491/    4222 : 5048                   	ADDQ.w	#8,a0					; index to dimension count
 3492/    4224 : 3758 05DB              	MOVE.w	(a0)+,Dimcnt(a3)			; get array's dimension count
 3493/    4228 :                        
 3494/    4228 :                        ; we have found, or built, the array. now we need to find the element
 3495/    4228 :                        
 3496/    4228 :                        LAB_1F28
 3497/    4228 : 7000                   	MOVEQ		#0,d0					; clear first result
 3498/    422A : 2740 05A8              	MOVE.l	d0,Asptl(a3)			; clear array data pointer
 3499/    422E :                        
 3500/    422E :                        ; compare nth dimension bound (a0) with nth index (sp)+
 3501/    422E :                        ; if greater do array bounds error
 3502/    422E :                        
 3503/    422E :                        LAB_1F2C
 3504/    422E : 3218                   	MOVE.w	(a0)+,d1				; get nth dimension bound
 3505/    4230 : B257                   	CMP.w		(sp),d1				; compare nth index with nth dimension bound
 3506/    4232 : 6500 EF18              	BCS		LAB_ABER				; if d1 less or = do array bounds error
 3507/    4236 :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 63 - 12/13/2023 15:59:9


 3508/    4236 :                        ; now do pointer = pointer	; nth dimension + nth index
 3509/    4236 :                        
 3510/    4236 : 4A80                   	TST.l		d0					; test pointer
 3511/    4238 : 6702                   	BEQ.s		LAB_1F5A				; skip multiply if last result = null
 3512/    423A :                        
 3513/    423A : 613A                   	BSR.s		LAB_1F7C				; do this dimension size+1	; array size
 3514/    423C :                        LAB_1F5A
 3515/    423C : 7200                   	MOVEQ		#0,d1					; clear longword
 3516/    423E : 321F                   	MOVE.w	(sp)+,d1				; get nth dimension index
 3517/    4240 : D081                   	ADD.l		d1,d0					; add index to size
 3518/    4242 : 2740 05A8              	MOVE.l	d0,Asptl(a3)			; save array data pointer
 3519/    4246 :                        
 3520/    4246 : 532B 05DB              	SUBQ.b	#1,Dimcnt(a3)			; decrement dimensions count
 3521/    424A : 66E2                   	BNE.s		LAB_1F2C				; loop if dimensions still to do
 3522/    424C :                        
 3523/    424C : 177C 0000 05B5         	MOVE.b	#0,Dtypef(a3)			; set data type to float
 3524/    4252 : 7203                   	MOVEQ		#3,d1					; set for numeric array
 3525/    4254 : 4A2B 046B              	TST.b		Varname+1(a3)			; test if string array
 3526/    4258 : 6A0A                   	BPL.s		LAB_1F6A				; branch if not string
 3527/    425A :                        
 3528/    425A : 7205                   	MOVEQ		#5,d1					; else set for string array
 3529/    425C : 177C 0080 05B5         	MOVE.b	#$80,Dtypef(a3)			; and set data type to string
 3530/    4262 : 600C                   	BRA.s		LAB_1F6B				; skip integer test
 3531/    4264 :                        
 3532/    4264 :                        LAB_1F6A
 3533/    4264 : 4A2B 046C              	TST.b		Varname+2(a3)			; test if integer array
 3534/    4268 : 6A06                   	BPL.s		LAB_1F6B				; branch if not integer
 3535/    426A :                        
 3536/    426A : 177C 0040 05B5         	MOVE.b	#$40,Dtypef(a3)			; else set data type to integer
 3537/    4270 :                        LAB_1F6B
 3538/    4270 : 6104                   	BSR.s		LAB_1F7C				; do element size (d1)	; array size (Asptl)
 3539/    4272 : D1C0                   	ADDA.l	d0,a0					; add array data start pointer
 3540/    4274 :                        RTS_011
 3541/    4274 : 4E75                   	RTS
 3542/    4276 :                        
 3543/    4276 :                        
 3544/    4276 :                        ;************************************************************************************
 3545/    4276 :                        ;
 3546/    4276 :                        ; do this dimension size (d1)	; array data size (Asptl)
 3547/    4276 :                        
 3548/    4276 :                        ; do a 16 x 32 bit multiply
 3549/    4276 :                        ; d1 holds the 16 bit multiplier
 3550/    4276 :                        ; Asptl holds the 32 bit multiplicand
 3551/    4276 :                        
 3552/    4276 :                        ; d0	bbbb  bbbb
 3553/    4276 :                        ; d1	0000  aaaa
 3554/    4276 :                        ;	----------
 3555/    4276 :                        ; d0	rrrr  rrrr
 3556/    4276 :                        
 3557/    4276 :                        LAB_1F7C
 3558/    4276 : 202B 05A8              	MOVE.l	Asptl(a3),d0			; get result
 3559/    427A : 2400                   	MOVE.l	d0,d2					; copy it
 3560/    427C : 4842                   	SWAP		d2					; shift high word to low word
 3561/    427E : C0C1                   	MULU.w	d1,d0					; d1	; low word = low result
 3562/    4280 : C4C1                   	MULU.w	d1,d2					; d1	; high word = high result
 3563/    4282 : 4842                   	SWAP		d2					; align words for test
 3564/    4284 : 4A42                   	TST.w		d2					; must be zero
 3565/    4286 : 6600 EECC              	BNE		LAB_OMER				; if overflow go do "Out of memory" error
 3566/    428A :                        
 3567/    428A : D082                   	ADD.l		d2,d0					; calculate result
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 64 - 12/13/2023 15:59:9


 3568/    428C : 6500 EEC6              	BCS		LAB_OMER				; if overflow go do "Out of memory" error
 3569/    4290 :                        
 3570/    4290 : D0AB 05A8              	ADD.l		Asptl(a3),d0			; add original
 3571/    4294 : 6500 EEBE              	BCS		LAB_OMER				; if overflow go do "Out of memory" error
 3572/    4298 :                        
 3573/    4298 : 4E75                   	RTS
 3574/    429A :                        
 3575/    429A :                        
 3576/    429A :                        ;************************************************************************************
 3577/    429A :                        ;
 3578/    429A :                        ; perform FRE()
 3579/    429A :                        
 3580/    429A :                        LAB_FRE
 3581/    429A : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
 3582/    429E :                        								; $00=float
 3583/    429E : 6A04                   	BPL.s		LAB_1FB4				; branch if numeric
 3584/    42A0 :                        
 3585/    42A0 : 6100 0318              	BSR		LAB_22B6				; pop string off descriptor stack, or from
 3586/    42A4 :                        								; top of string space, returns d0 = length,
 3587/    42A4 :                        								; a0 = pointer
 3588/    42A4 :                        
 3589/    42A4 :                        								; FRE(n) was numeric so do this
 3590/    42A4 :                        LAB_1FB4
 3591/    42A4 : 6100 01CC              	BSR		LAB_GARB				; go do garbage collection
 3592/    42A8 : 202B 0446              	MOVE.l	Sstorl(a3),d0			; get bottom of string space
 3593/    42AC : 90AB 0442              	SUB.l		Earryl(a3),d0			; subtract array mem end
 3594/    42B0 :                        
 3595/    42B0 :                        
 3596/    42B0 :                        ;************************************************************************************
 3597/    42B0 :                        ;
 3598/    42B0 :                        ; convert d0 to signed longword in FAC1
 3599/    42B0 :                        
 3600/    42B0 :                        LAB_AYFC
 3601/    42B0 : 177C 0000 05B5         	MOVE.b	#$00,Dtypef(a3)			; clear data type, $80=string, $40=integer,
 3602/    42B6 :                        								; $00=float
 3603/    42B6 : 377C A000 0594         	MOVE.w	#$A000,FAC1_e(a3)			; set FAC1 exponent and clear sign (b7)
 3604/    42BC : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; save FAC1 mantissa
 3605/    42C0 : 6A00 0640              	BPL		LAB_24D0				; convert if +ve
 3606/    42C4 :                        
 3607/    42C4 : 003C 0001              	ORI.b		#1,CCR				; else set carry
 3608/    42C8 : 6000 0638              	BRA		LAB_24D0				; do +/- (carry is sign) & normalise FAC1
 3609/    42CC :                        
 3610/    42CC :                        
 3611/    42CC :                        ;************************************************************************************
 3612/    42CC :                        ;
 3613/    42CC :                        ; remember if the line length is zero (infinite line) then POS(n) will return
 3614/    42CC :                        ; position MOD tabsize
 3615/    42CC :                        
 3616/    42CC :                        ; perform POS()
 3617/    42CC :                        
 3618/    42CC :                        LAB_POS
 3619/    42CC : 102B 05E5              	MOVE.b	TPos(a3),d0				; get terminal position
 3620/    42D0 :                        
 3621/    42D0 :                        ; convert d0 to unsigned byte in FAC1
 3622/    42D0 :                        
 3623/    42D0 :                        LAB_1FD0
 3624/    42D0 : C0BC 0000 00FF         	AND.l		#$FF,d0				; clear high bits
 3625/    42D6 : 60D8                   	BRA.s		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
 3626/    42D8 :                        
 3627/    42D8 :                        ; check not direct (used by DEF and INPUT)
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 65 - 12/13/2023 15:59:9


 3628/    42D8 :                        
 3629/    42D8 :                        LAB_CKRN
 3630/    42D8 : 4A2B 0452              	TST.b		Clinel(a3)				; test current line #
 3631/    42DC : 6B00 EE62              	BMI		LAB_IDER				; if -ve go do illegal direct error then warm
 3632/    42E0 :                        								; start
 3633/    42E0 :                        
 3634/    42E0 : 4E75                   	RTS							; can continue so return
 3635/    42E2 :                        
 3636/    42E2 :                        
 3637/    42E2 :                        ;************************************************************************************
 3638/    42E2 :                        ;
 3639/    42E2 :                        ; perform DEF
 3640/    42E2 :                        
 3641/    42E2 :                        LAB_DEF
 3642/    42E2 : 70AB                   	MOVEQ		#TK_FN-$100,d0			; get FN token
 3643/    42E4 : 6100 FAC0              	BSR		LAB_SCCA				; scan for CHR$(d0), else syntax error and
 3644/    42E8 :                        								; warm start
 3645/    42E8 :                        								; return character after d0
 3646/    42E8 : 177C 0080 05DF         	MOVE.b	#$80,Sufnxf(a3)			; set FN flag bit
 3647/    42EE : 6100 FCDA              	BSR		LAB_1D12				; get FN name
 3648/    42F2 : 2748 05B0              	MOVE.l	a0,func_l(a3)			; save function pointer
 3649/    42F6 :                        
 3650/    42F6 : 61E0                   	BSR.s		LAB_CKRN				; check not direct (back here if ok)
 3651/    42F8 : 0C1D 0028              	CMP.b		#$28,(a5)+				; check next byte is "(" and increment
 3652/    42FC : 6600 EE6A              	BNE		LAB_SNER				; else do syntax error/warm start
 3653/    4300 :                        
 3654/    4300 : 177C 007E 05DF         	MOVE.b	#$7E,Sufnxf(a3)			; set FN variable flag bits
 3655/    4306 : 6100 FCB4              	BSR		LAB_SVAR				; search for or create a variable
 3656/    430A :                        								; return the variable address in a0
 3657/    430A : 6100 FA90              	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
 3658/    430E : 70BD                   	MOVEQ		#TK_EQUAL-$100,d0			; = token
 3659/    4310 : 6100 FA94              	BSR		LAB_SCCA				; scan for CHR$(A), else syntax error/warm start
 3660/    4314 :                        								; return character after d0
 3661/    4314 : 2F2B 046A              	MOVE.l	Varname(a3),-(sp)			; push current variable name
 3662/    4318 : 2F0D                   	MOVE.l	a5,-(sp)				; push BASIC execute pointer
 3663/    431A : 6100 F412              	BSR		LAB_DATA				; go perform DATA, find end of DEF FN statement
 3664/    431E : 206B 05B0              	MOVEA.l	func_l(a3),a0			; get the function pointer
 3665/    4322 : 209F                   	MOVE.l	(sp)+,(a0)				; save BASIC execute pointer to function
 3666/    4324 : 215F 0004              	MOVE.l	(sp)+,4(a0)				; save current variable name to function
 3667/    4328 : 4E75                   	RTS
 3668/    432A :                        
 3669/    432A :                        
 3670/    432A :                        ;************************************************************************************
 3671/    432A :                        ;
 3672/    432A :                        ; evaluate FNx
 3673/    432A :                        
 3674/    432A :                        LAB_201E
 3675/    432A : 177C 0081 05DF         	MOVE.b	#$81,Sufnxf(a3)			; set FN flag (find not create)
 3676/    4330 : 6100 FA7C              	BSR		LAB_IGBY				; increment & scan memory
 3677/    4334 : 6100 FC94              	BSR		LAB_1D12				; get FN name
 3678/    4338 : 1F2B 05B5              	MOVE.b	Dtypef(a3),-(sp)			; push data type flag (function type)
 3679/    433C : 2F08                   	MOVE.l	a0,-(sp)				; push function pointer
 3680/    433E : 0C15 0028              	CMP.b		#$28,(a5)				; check next byte is "(", no increment
 3681/    4342 : 6600 EE24              	BNE		LAB_SNER				; else do syntax error/warm start
 3682/    4346 :                        
 3683/    4346 : 6100 FA50              	BSR		LAB_1BF7				; evaluate expression within parentheses
 3684/    434A : 205F                   	MOVEA.l	(sp)+,a0				; pop function pointer
 3685/    434C : 2748 05B0              	MOVE.l	a0,func_l(a3)			; set function pointer
 3686/    4350 : 1F2B 05B5              	MOVE.b	Dtypef(a3),-(sp)			; push data type flag (function expression type)
 3687/    4354 :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 66 - 12/13/2023 15:59:9


 3688/    4354 : 2028 0004              	MOVE.l	4(a0),d0				; get function variable name
 3689/    4358 : 6100 FCDA              	BSR		LAB_1D4A				; go find function variable (already created)
 3690/    435C :                        
 3691/    435C :                        								; now check type match for variable
 3692/    435C : 101F                   	MOVE.b	(sp)+,d0				; pop data type flag (function expression type)
 3693/    435E : E318                   	ROL.b		#1,d0					; set carry if type = string
 3694/    4360 : 6100 F8D8              	BSR		LAB_CKTM				; type match check, set C for string
 3695/    4364 :                        
 3696/    4364 :                        								; now stack the function variable value before
 3697/    4364 :                        								; use
 3698/    4364 : 6712                   	BEQ.s		LAB_2043				; branch if not string
 3699/    4366 :                        
 3700/    4366 : 43EB 0476              	LEA		des_sk_e(a3),a1			; get string stack pointer max+1
 3701/    436A : B9C9                   	CMPA.l	a1,a4					; compare string stack pointer with max+1
 3702/    436C : 6700 EDC6              	BEQ		LAB_SCER				; if no space on the stack go do string too
 3703/    4370 :                        								; complex error
 3704/    4370 :                        
 3705/    4370 : 3928 0004              	MOVE.w	4(a0),-(a4)				; string length on descriptor stack
 3706/    4374 : 2910                   	MOVE.l	(a0),-(a4)				; string address on stack
 3707/    4376 : 6002                   	BRA.s		LAB_204S				; skip var push
 3708/    4378 :                        
 3709/    4378 :                        LAB_2043
 3710/    4378 : 2F10                   	MOVE.l	(a0),-(sp)				; push variable
 3711/    437A :                        LAB_204S
 3712/    437A : 2F08                   	MOVE.l	a0,-(sp)				; push variable address
 3713/    437C : 1F2B 05B5              	MOVE.b	Dtypef(a3),-(sp)			; push variable data type
 3714/    4380 :                        
 3715/    4380 : 6132                   	BSR.s		LAB_2045				; pack function expression value into (a0)
 3716/    4382 :                        								; (function variable)
 3717/    4382 : 2F0D                   	MOVE.l	a5,-(sp)				; push BASIC execute pointer
 3718/    4384 : 206B 05B0              	MOVEA.l	func_l(a3),a0			; get function pointer
 3719/    4388 : 2A50                   	MOVEA.l	(a0),a5				; save function execute ptr as BASIC execute ptr
 3720/    438A : 6100 F8C2              	BSR		LAB_EVEX				; evaluate expression
 3721/    438E : 6100 FA20              	BSR		LAB_GBYT				; scan memory
 3722/    4392 : 6600 EDD4              	BNE		LAB_SNER				; if not [EOL] or [EOS] do syntax error and
 3723/    4396 :                        								; warm start
 3724/    4396 :                        
 3725/    4396 : 2A5F                   	MOVE.l	(sp)+,a5				; restore BASIC execute pointer
 3726/    4398 :                        
 3727/    4398 :                        ; restore variable from stack and test data type
 3728/    4398 :                        
 3729/    4398 : 101F                   	MOVE.b	(sp)+,d0				; pull variable data type
 3730/    439A : 205F                   	MOVEA.l	(sp)+,a0				; pull variable address
 3731/    439C : 4A00                   	TST.b		d0					; test variable data type
 3732/    439E : 6A08                   	BPL.s		LAB_204T				; branch if not string
 3733/    43A0 :                        
 3734/    43A0 : 209C                   	MOVE.l	(a4)+,(a0)				; string address from descriptor stack
 3735/    43A2 : 315C 0004              	MOVE.w	(a4)+,4(a0)				; string length from descriptor stack
 3736/    43A6 : 6002                   	BRA.s		LAB_2044				; skip variable pull
 3737/    43A8 :                        
 3738/    43A8 :                        LAB_204T
 3739/    43A8 : 209F                   	MOVE.l	(sp)+,(a0)				; restore variable from stack
 3740/    43AA :                        LAB_2044
 3741/    43AA : 101F                   	MOVE.b	(sp)+,d0				; pop data type flag (function type)
 3742/    43AC : E318                   	ROL.b		#1,d0					; set carry if type = string
 3743/    43AE : 6100 F88A              	BSR		LAB_CKTM				; type match check, set C for string
 3744/    43B2 : 4E75                   	RTS
 3745/    43B4 :                        
 3746/    43B4 :                        LAB_2045
 3747/    43B4 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 67 - 12/13/2023 15:59:9


 3748/    43B8 : 6A00 07F0              	BPL		LAB_2778				; if numeric pack FAC1 into variable (a0)
 3749/    43BC :                        								; and return
 3750/    43BC :                        
 3751/    43BC : 2448                   	MOVEA.l	a0,a2					; copy variable pointer
 3752/    43BE : 6000 F512              	BRA		LAB_17D6				; go do string LET & return
 3753/    43C2 :                        
 3754/    43C2 :                        
 3755/    43C2 :                        
 3756/    43C2 :                        ;************************************************************************************
 3757/    43C2 :                        ;
 3758/    43C2 :                        ; perform STR$()
 3759/    43C2 :                        
 3760/    43C2 :                        LAB_STRS
 3761/    43C2 : 6100 0950              	BSR		LAB_2970				; convert FAC1 to string
 3762/    43C6 :                        
 3763/    43C6 :                        ; scan, set up string
 3764/    43C6 :                        ; print " terminated string to FAC1 stack
 3765/    43C6 :                        
 3766/    43C6 :                        LAB_20AE
 3767/    43C6 : 7422                   	MOVEQ		#$22,d2				; set Srchc character (terminator 1)
 3768/    43C8 : 3602                   	MOVE.w	d2,d3					; set Asrch character (terminator 2)
 3769/    43CA :                        
 3770/    43CA :                        ; print d2/d3 terminated string to FAC1 stack
 3771/    43CA :                        ; d2 = Srchc, d3 = Asrch, a0 is source
 3772/    43CA :                        ; a6 is temp
 3773/    43CA :                        
 3774/    43CA :                        LAB_20B4
 3775/    43CA : 7200                   	MOVEQ		#0,d1					; clear longword
 3776/    43CC : 5341                   	SUBQ.w	#1,d1					; set length to -1
 3777/    43CE : 2448                   	MOVEA.l	a0,a2					; copy start to calculate end
 3778/    43D0 :                        LAB_20BE
 3779/    43D0 : 5241                   	ADDQ.w	#1,d1					; increment length
 3780/    43D2 : 1030 1000              	MOVE.b	(a0,d1.w),d0			; get byte from string
 3781/    43D6 : 6710                   	BEQ.s		LAB_20D0				; exit loop if null byte [EOS]
 3782/    43D8 :                        
 3783/    43D8 : B002                   	CMP.b		d2,d0					; compare with search character (terminator 1)
 3784/    43DA : 6704                   	BEQ.s		LAB_20CB				; branch if terminator
 3785/    43DC :                        
 3786/    43DC : B003                   	CMP.b		d3,d0					; compare with terminator 2
 3787/    43DE : 66F0                   	BNE.s		LAB_20BE				; loop if not terminator 2 (or null string)
 3788/    43E0 :                        
 3789/    43E0 :                        LAB_20CB
 3790/    43E0 : B03C 0022              	CMP.b		#$22,d0				; compare with "
 3791/    43E4 : 6602                   	BNE.s		LAB_20D0				; branch if not "
 3792/    43E6 :                        
 3793/    43E6 : 524A                   	ADDQ.w	#1,a2					; else increment string start (skip " at end)
 3794/    43E8 :                        LAB_20D0
 3795/    43E8 : D5C1                   	ADDA.l	d1,a2					; add longowrd length to make string end+1
 3796/    43EA :                        
 3797/    43EA : B1CB                   	CMPA.l	a3,a0					; is string in ram
 3798/    43EC : 651E                   	BCS.s		LAB_RTST				; if not go push descriptor on stack & exit
 3799/    43EE :                        								; (could be message string from ROM)
 3800/    43EE :                        
 3801/    43EE : B1EB 042E              	CMPA.l	Smeml(a3),a0			; is string in utility ram
 3802/    43F2 : 6418                   	BCC.s		LAB_RTST				; if not go push descriptor on stack & exit
 3803/    43F4 :                        								; (is in string or program space)
 3804/    43F4 :                        
 3805/    43F4 :                        								; (else) copy string to string memory
 3806/    43F4 :                        LAB_20C9
 3807/    43F4 : 2248                   	MOVEA.l	a0,a1					; copy descriptor pointer
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 68 - 12/13/2023 15:59:9


 3808/    43F6 : 2001                   	MOVE.l	d1,d0					; copy longword length
 3809/    43F8 : 6604                   	BNE.s		LAB_20D8				; branch if not null string
 3810/    43FA :                        
 3811/    43FA : 2041                   	MOVEA.l	d1,a0					; make null pointer
 3812/    43FC : 600E                   	BRA.s		LAB_RTST				; go push descriptor on stack & exit
 3813/    43FE :                        
 3814/    43FE :                        LAB_20D8
 3815/    43FE : 6126                   	BSR.s		LAB_2115				; make string space d1 bytes long
 3816/    4400 : D1C1                   	ADDA.l	d1,a0					; new string end
 3817/    4402 : D3C1                   	ADDA.l	d1,a1					; old string end
 3818/    4404 : 5340                   	SUBQ.w	#1,d0					; -1 for DBF loop
 3819/    4406 :                        LAB_20E0
 3820/    4406 : 1121                   	MOVE.b	-(a1),-(a0)				; copy byte (source can be odd aligned)
 3821/    4408 : 51C8 FFFC              	DBF		d0,LAB_20E0				; loop until done
 3822/    440C :                        
 3823/    440C :                        
 3824/    440C :                        
 3825/    440C :                        ;************************************************************************************
 3826/    440C :                        ;
 3827/    440C :                        ; check for space on descriptor stack then ...
 3828/    440C :                        ; put string address and length on descriptor stack & update stack pointers
 3829/    440C :                        ; start is in a0, length is in d1
 3830/    440C :                        
 3831/    440C :                        LAB_RTST
 3832/    440C : 43EB 0476              	LEA		des_sk_e(a3),a1			; get string stack pointer max+1
 3833/    4410 : B9C9                   	CMPA.l	a1,a4					; compare string stack pointer with max+1
 3834/    4412 : 6700 ED20              	BEQ		LAB_SCER				; if no space on string stack ..
 3835/    4416 :                        								; .. go do 'string too complex' error
 3836/    4416 :                        
 3837/    4416 :                        								; push string & update pointers
 3838/    4416 : 3901                   	MOVE.w	d1,-(a4)				; string length on descriptor stack
 3839/    4418 : 2908                   	MOVE.l	a0,-(a4)				; string address on stack
 3840/    441A : 274C 0590              	MOVE.l	a4,FAC1_m(a3)			; string descriptor pointer in FAC1
 3841/    441E : 177C 0080 05B5         	MOVE.b	#$80,Dtypef(a3)			; save data type flag, $80=string
 3842/    4424 : 4E75                   	RTS
 3843/    4426 :                        
 3844/    4426 :                        
 3845/    4426 :                        ;************************************************************************************
 3846/    4426 :                        ;
 3847/    4426 :                        ; build descriptor a0/d1
 3848/    4426 :                        ; make space in string memory for string d1.w long
 3849/    4426 :                        ; return pointer in a0/Sutill
 3850/    4426 :                        
 3851/    4426 :                        LAB_2115
 3852/    4426 : 4A41                   	TST.w		d1					; test length
 3853/    4428 : 672E                   	BEQ.s		LAB_2128				; branch if user wants null string
 3854/    442A :                        
 3855/    442A :                        								; make space for string d1 long
 3856/    442A : 2F00                   	MOVE.l	d0,-(sp)				; save d0
 3857/    442C : 7000                   	MOVEQ		#0,d0					; clear longword
 3858/    442E : 1740 05DE              	MOVE.b	d0,Gclctd(a3)			; clear garbage collected flag (b7)
 3859/    4432 : 7001                   	MOVEQ		#1,d0					; +1 to possibly round up
 3860/    4434 : C041                   	AND.w		d1,d0					; mask odd bit
 3861/    4436 : D041                   	ADD.w		d1,d0					; ensure d0 is even length
 3862/    4438 : 6404                   	BCC.s		LAB_2117				; branch if no overflow
 3863/    443A :                        
 3864/    443A : 7001                   	MOVEQ		#1,d0					; set to allocate 65536 bytes
 3865/    443C : 4840                   	SWAP		d0					; makes $00010000
 3866/    443E :                        LAB_2117
 3867/    443E : 206B 0446              	MOVEA.l	Sstorl(a3),a0			; get bottom of string space
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 69 - 12/13/2023 15:59:9


 3868/    4442 : 91C0                   	SUBA.l	d0,a0					; subtract string length
 3869/    4444 : B1EB 0442              	CMPA.l	Earryl(a3),a0			; compare with top of array space
 3870/    4448 : 6512                   	BCS.s		LAB_2137				; if less do out of memory error
 3871/    444A :                        
 3872/    444A : 2748 0446              	MOVE.l	a0,Sstorl(a3)			; save bottom of string space
 3873/    444E : 2748 044E              	MOVE.l	a0,Sutill(a3)			; save string utility pointer
 3874/    4452 : 201F                   	MOVE.l	(sp)+,d0				; restore d0
 3875/    4454 : 4A41                   	TST.w		d1					; set flags on length
 3876/    4456 : 4E75                   	RTS
 3877/    4458 :                        
 3878/    4458 :                        LAB_2128
 3879/    4458 : 3041                   	MOVEA.w	d1,a0					; make null pointer
 3880/    445A : 4E75                   	RTS
 3881/    445C :                        
 3882/    445C :                        LAB_2137
 3883/    445C : 4A2B 05DE              	TST.b		Gclctd(a3)				; get garbage collected flag
 3884/    4460 : 6B00 ECF2              	BMI		LAB_OMER				; do "Out of memory" error, then warm start
 3885/    4464 :                        
 3886/    4464 : 2F09                   	MOVE.l	a1,-(sp)				; save a1
 3887/    4466 : 610A                   	BSR.s		LAB_GARB				; else go do garbage collection
 3888/    4468 : 225F                   	MOVEA.l	(sp)+,a1				; restore a1
 3889/    446A : 177C 0080 05DE         	MOVE.b	#$80,Gclctd(a3)			; set garbage collected flag
 3890/    4470 : 60CC                   	BRA.s		LAB_2117				; go try again
 3891/    4472 :                        
 3892/    4472 :                        
 3893/    4472 :                        ;************************************************************************************
 3894/    4472 :                        ;
 3895/    4472 :                        ; garbage collection routine
 3896/    4472 :                        
 3897/    4472 :                        LAB_GARB
 3898/    4472 : 48E7 E0E0              	MOVEM.l	d0-d2/a0-a2,-(sp)			; save registers
 3899/    4476 : 276B 044A 0446         	MOVE.l	Ememl(a3),Sstorl(a3)		; start with no strings
 3900/    447C :                        
 3901/    447C :                        								; re-run routine from last ending
 3902/    447C :                        LAB_214B
 3903/    447C : 222B 0442              	MOVE.l	Earryl(a3),d1			; set highest uncollected string so far
 3904/    4480 : 7000                   	MOVEQ		#0,d0					; clear longword
 3905/    4482 : 2240                   	MOVEA.l	d0,a1					; clear string to move pointer
 3906/    4484 : 206B 043A              	MOVEA.l	Sstrl(a3),a0			; set pointer to start of strings
 3907/    4488 : 41E8 0004              	LEA		4(a0),a0				; index to string pointer
 3908/    448C : 246B 043E              	MOVEA.l	Sarryl(a3),a2			; set end pointer to start of arrays (end of
 3909/    4490 :                        								; strings)
 3910/    4490 : 6008                   	BRA.s		LAB_2176				; branch into loop at end loop test
 3911/    4492 :                        
 3912/    4492 :                        LAB_2161
 3913/    4492 : 6100 0084              	BSR		LAB_2206				; test and set if this is the highest string
 3914/    4496 : 41E8 000A              	LEA		10(a0),a0				; increment to next string
 3915/    449A :                        LAB_2176
 3916/    449A : B1CA                   	CMPA.l	a2,a0					; compare end of area with pointer
 3917/    449C : 65F4                   	BCS.s		LAB_2161				; go do next if not at end
 3918/    449E :                        
 3919/    449E :                        ; done strings, now do arrays.
 3920/    449E :                        
 3921/    449E : 41E8 FFFC              	LEA		-4(a0),a0				; decrement pointer to start of arrays
 3922/    44A2 : 246B 0442              	MOVEA.l	Earryl(a3),a2			; set end pointer to end of arrays
 3923/    44A6 : 6024                   	BRA.s		LAB_218F				; branch into loop at end loop test
 3924/    44A8 :                        
 3925/    44A8 :                        LAB_217E
 3926/    44A8 : 2428 0004              	MOVE.l	4(a0),d2				; get array size
 3927/    44AC : D488                   	ADD.l		a0,d2					; makes start of next array
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 70 - 12/13/2023 15:59:9


 3928/    44AE :                        
 3929/    44AE : 2010                   	MOVE.l	(a0),d0				; get array name
 3930/    44B0 : 0800 0017              	BTST		#23,d0				; test string flag
 3931/    44B4 : 6714                   	BEQ.s		LAB_218B				; branch if not string
 3932/    44B6 :                        
 3933/    44B6 : 3028 0008              	MOVE.w	8(a0),d0				; get # of dimensions
 3934/    44BA : D040                   	ADD.w		d0,d0					; *2
 3935/    44BC : D0C0                   	ADDA.w	d0,a0					; add to skip dimension size(s)
 3936/    44BE : 41E8 000A              	LEA		10(a0),a0				; increment to first element
 3937/    44C2 :                        LAB_2183
 3938/    44C2 : 6154                   	BSR.s		LAB_2206				; test and set if this is the highest string
 3939/    44C4 : 5C48                   	ADDQ.w	#6,a0					; increment to next element
 3940/    44C6 : B1C2                   	CMPA.l	d2,a0					; compare with start of next array
 3941/    44C8 : 66F8                   	BNE.s		LAB_2183				; go do next if not at end of array
 3942/    44CA :                        
 3943/    44CA :                        LAB_218B
 3944/    44CA : 2042                   	MOVEA.l	d2,a0					; pointer to next array
 3945/    44CC :                        LAB_218F
 3946/    44CC : B5C8                   	CMPA.l	a0,a2					; compare pointer with array end
 3947/    44CE : 66D8                   	BNE.s		LAB_217E				; go do next if not at end
 3948/    44D0 :                        
 3949/    44D0 :                        ; done arrays and variables, now just the descriptor stack to do
 3950/    44D0 :                        
 3951/    44D0 : 204C                   	MOVEA.l	a4,a0					; get descriptor stack pointer
 3952/    44D2 : 45EB 048E              	LEA		des_sk(a3),a2			; set end pointer to end of stack
 3953/    44D6 : 6006                   	BRA.s		LAB_21C4				; branch into loop at end loop test
 3954/    44D8 :                        
 3955/    44D8 :                        LAB_21C2
 3956/    44D8 : 613E                   	BSR.s		LAB_2206				; test and set if this is the highest string
 3957/    44DA : 41E8 0006              	LEA		6(a0),a0				; increment to next string
 3958/    44DE :                        LAB_21C4
 3959/    44DE : B5C8                   	CMPA.l	a0,a2					; compare pointer with stack end
 3960/    44E0 : 66F6                   	BNE.s		LAB_21C2				; go do next if not at end
 3961/    44E2 :                        
 3962/    44E2 :                        ; descriptor search complete, now either exit or set-up and move string
 3963/    44E2 :                        
 3964/    44E2 : 2009                   	MOVE.l	a1,d0					; set the flags (a1 is move string)
 3965/    44E4 : 672C                   	BEQ.s		LAB_21D1				; go tidy up and exit if no move
 3966/    44E6 :                        
 3967/    44E6 : 2051                   	MOVEA.l	(a1),a0				; a0 is now string start
 3968/    44E8 : 7200                   	MOVEQ		#0,d1					; clear d1
 3969/    44EA : 3229 0004              	MOVE.w	4(a1),d1				; d1 is string length
 3970/    44EE : 5281                   	ADDQ.l	#1,d1					; +1
 3971/    44F0 : C23C 00FE              	AND.b		#$FE,d1				; make even length
 3972/    44F4 : D1C1                   	ADDA.l	d1,a0					; pointer is now to string end+1
 3973/    44F6 : 246B 0446              	MOVEA.l	Sstorl(a3),a2			; is destination end+1
 3974/    44FA : B1CA                   	CMPA.l	a2,a0					; does the string need moving
 3975/    44FC : 670C                   	BEQ.s		LAB_2240				; branch if not
 3976/    44FE :                        
 3977/    44FE : E289                   	LSR.l		#1,d1					; word move so do /2
 3978/    4500 : 5341                   	SUBQ.w	#1,d1					; -1 for DBF loop
 3979/    4502 :                        LAB_2216
 3980/    4502 : 3520                   	MOVE.w	-(a0),-(a2)				; copy word
 3981/    4504 : 51C9 FFFC              	DBF		d1,LAB_2216				; loop until done
 3982/    4508 :                        
 3983/    4508 : 228A                   	MOVE.l	a2,(a1)				; save new string start
 3984/    450A :                        LAB_2240
 3985/    450A : 2751 0446              	MOVE.l	(a1),Sstorl(a3)			; string start is new string mem start
 3986/    450E : 6000 FF6C              	BRA		LAB_214B				; re-run routine from last ending
 3987/    4512 :                        								; (but don't collect this string)
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 71 - 12/13/2023 15:59:9


 3988/    4512 :                        
 3989/    4512 :                        LAB_21D1
 3990/    4512 : 4CDF 0707              	MOVEM.l	(sp)+,d0-d2/a0-a2			; restore registers
 3991/    4516 : 4E75                   	RTS
 3992/    4518 :                        
 3993/    4518 :                        ; test and set if this is the highest string
 3994/    4518 :                        
 3995/    4518 :                        LAB_2206
 3996/    4518 : 2010                   	MOVE.l	(a0),d0				; get this string pointer
 3997/    451A : 6728                   	BEQ.s		RTS_012				; exit if null string
 3998/    451C :                        
 3999/    451C : B280                   	CMP.l		d0,d1					; compare with highest uncollected string so far
 4000/    451E : 6424                   	BCC.s		RTS_012				; exit if <= with highest so far
 4001/    4520 :                        
 4002/    4520 : B0AB 0446              	CMP.l		Sstorl(a3),d0			; compare with bottom of string space
 4003/    4524 : 641E                   	BCC.s		RTS_012				; exit if >= bottom of string space
 4004/    4526 :                        
 4005/    4526 : 70FF                   	MOVEQ		#-1,d0				; d0 = $FFFFFFFF
 4006/    4528 : 3028 0004              	MOVE.w	4(a0),d0				; d0 is string length
 4007/    452C : 4440                   	NEG.w		d0					; make -ve
 4008/    452E : C03C 00FE              	AND.b		#$FE,d0				; make -ve even length
 4009/    4532 : D0AB 0446              	ADD.l		Sstorl(a3),d0			; add string store to -ve length
 4010/    4536 : B090                   	CMP.l		(a0),d0				; compare with string address
 4011/    4538 : 6706                   	BEQ.s		LAB_2212				; if = go move string store pointer down
 4012/    453A :                        
 4013/    453A : 2210                   	MOVE.l	(a0),d1				; highest = current
 4014/    453C : 2248                   	MOVEA.l	a0,a1					; string to move = current
 4015/    453E : 4E75                   	RTS
 4016/    4540 :                        
 4017/    4540 :                        LAB_2212
 4018/    4540 : 2740 0446              	MOVE.l	d0,Sstorl(a3)			; set new string store start
 4019/    4544 :                        RTS_012
 4020/    4544 : 4E75                   	RTS
 4021/    4546 :                        
 4022/    4546 :                        
 4023/    4546 :                        ;************************************************************************************
 4024/    4546 :                        ;
 4025/    4546 :                        ; concatenate - add strings
 4026/    4546 :                        ; string descriptor 1 is in FAC1_m, string 2 is in line
 4027/    4546 :                        
 4028/    4546 :                        LAB_224D
 4029/    4546 : 487A F738              	PEA		LAB_1ADB(pc)			; continue evaluation after concatenate
 4030/    454A : 2F2B 0590              	MOVE.l	FAC1_m(a3),-(sp)			; stack descriptor pointer for string 1
 4031/    454E :                        
 4032/    454E : 6100 F80C              	BSR		LAB_GVAL				; get value from line
 4033/    4552 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type flag
 4034/    4556 : 6A00 EBE4              	BPL		LAB_TMER				; if type is not string do type mismatch error
 4035/    455A :                        
 4036/    455A : 205F                   	MOVEA.l	(sp)+,a0				; restore descriptor pointer for string 1
 4037/    455C :                        
 4038/    455C :                        ;************************************************************************************
 4039/    455C :                        ;
 4040/    455C :                        ; concatenate
 4041/    455C :                        ; string descriptor 1 is in a0, string descriptor 2 is in FAC1_m
 4042/    455C :                        
 4043/    455C :                        LAB_224E
 4044/    455C : 226B 0590              	MOVEA.l	FAC1_m(a3),a1			; copy descriptor pointer 2
 4045/    4560 : 3228 0004              	MOVE.w	4(a0),d1				; get length 1
 4046/    4564 : D269 0004              	ADD.w		4(a1),d1				; add length 2
 4047/    4568 : 6500 EBCE              	BCS		LAB_SLER				; if overflow go do 'string too long' error
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 72 - 12/13/2023 15:59:9


 4048/    456C :                        
 4049/    456C : 2F08                   	MOVE.l	a0,-(sp)				; save descriptor pointer 1
 4050/    456E : 6100 FEB6              	BSR		LAB_2115				; make space d1 bytes long
 4051/    4572 : 2748 0598              	MOVE.l	a0,FAC2_m(a3)			; save new string start pointer
 4052/    4576 : 2057                   	MOVEA.l	(sp),a0				; copy descriptor pointer 1 from stack
 4053/    4578 : 3028 0004              	MOVE.w	4(a0),d0				; get length
 4054/    457C : 2050                   	MOVEA.l	(a0),a0				; get string pointer
 4055/    457E : 6120                   	BSR.s		LAB_229E				; copy string d0 bytes long from a0 to Sutill
 4056/    4580 :                        								; return with a0 = pointer, d1 = length
 4057/    4580 :                        
 4058/    4580 : 206B 0590              	MOVEA.l	FAC1_m(a3),a0			; get descriptor pointer for string 2
 4059/    4584 : 6138                   	BSR.s		LAB_22BA				; pop (a0) descriptor, returns with ..
 4060/    4586 :                        								; a0 = pointer, d0 = length
 4061/    4586 : 6118                   	BSR.s		LAB_229E				; copy string d0 bytes long from a0 to Sutill
 4062/    4588 :                        								; return with a0 = pointer, d1 = length
 4063/    4588 :                        
 4064/    4588 : 205F                   	MOVEA.l	(sp)+,a0				; get descriptor pointer for string 1
 4065/    458A : 6132                   	BSR.s		LAB_22BA				; pop (a0) descriptor, returns with ..
 4066/    458C :                        								; d0 = length, a0 = pointer
 4067/    458C :                        
 4068/    458C : 206B 0598              	MOVEA.l	FAC2_m(a3),a0			; retreive the result string pointer
 4069/    4590 : 2208                   	MOVE.l	a0,d1					; copy the result string pointer
 4070/    4592 : 6700 FE78              	BEQ		LAB_RTST				; if it is a null string just return it
 4071/    4596 :                        								; a0 = pointer, d1 = length
 4072/    4596 :                        
 4073/    4596 : 4481                   	NEG.l		d1					; else make the start pointer negative
 4074/    4598 : D2AB 044E              	ADD.l		Sutill(a3),d1			; add the end pointert to give the length
 4075/    459C : 6000 FE6E              	BRA		LAB_RTST				; push string on descriptor stack
 4076/    45A0 :                        								; a0 = pointer, d1 = length
 4077/    45A0 :                        
 4078/    45A0 :                        
 4079/    45A0 :                        ;************************************************************************************
 4080/    45A0 :                        ;
 4081/    45A0 :                        ; copy string d0 bytes long from a0 to Sutill
 4082/    45A0 :                        ; return with a0 = pointer, d1 = length
 4083/    45A0 :                        
 4084/    45A0 :                        LAB_229E
 4085/    45A0 : 3200                   	MOVE.w	d0,d1					; copy and check length
 4086/    45A2 : 6714                   	BEQ.s		RTS_013				; skip copy if null
 4087/    45A4 :                        
 4088/    45A4 : 226B 044E              	MOVEA.l	Sutill(a3),a1			; get destination pointer
 4089/    45A8 : 2F09                   	MOVE.l	a1,-(sp)				; save destination string pointer
 4090/    45AA : 5340                   	SUBQ.w	#1,d0					; subtract for DBF loop
 4091/    45AC :                        LAB_22A0
 4092/    45AC : 12D8                   	MOVE.b	(a0)+,(a1)+				; copy byte
 4093/    45AE : 51C8 FFFC              	DBF		d0,LAB_22A0				; loop if not done
 4094/    45B2 :                        
 4095/    45B2 : 2749 044E              	MOVE.l	a1,Sutill(a3)			; update Sutill to end of copied string
 4096/    45B6 : 205F                   	MOVEA.l	(sp)+,a0				; restore destination string pointer
 4097/    45B8 :                        RTS_013
 4098/    45B8 : 4E75                   	RTS
 4099/    45BA :                        
 4100/    45BA :                        
 4101/    45BA :                        ;************************************************************************************
 4102/    45BA :                        ;
 4103/    45BA :                        ; pop string off descriptor stack, or from top of string space
 4104/    45BA :                        ; returns with d0.l = length, a0 = pointer
 4105/    45BA :                        
 4106/    45BA :                        LAB_22B6
 4107/    45BA : 206B 0590              	MOVEA.l	FAC1_m(a3),a0			; get descriptor pointer
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 73 - 12/13/2023 15:59:9


 4108/    45BE :                        
 4109/    45BE :                        
 4110/    45BE :                        ;************************************************************************************
 4111/    45BE :                        ;
 4112/    45BE :                        ; pop (a0) descriptor off stack or from string space
 4113/    45BE :                        ; returns with d0.l = length, a0 = pointer
 4114/    45BE :                        
 4115/    45BE :                        LAB_22BA
 4116/    45BE : 48E7 4040              	MOVEM.l	a1/d1,-(sp)				; save other regs
 4117/    45C2 : B9C8                   	CMPA.l	a0,a4					; is string on the descriptor stack
 4118/    45C4 : 6602                   	BNE.s		LAB_22BD				; skip pop if not
 4119/    45C6 :                        
 4120/    45C6 : 5C4C                   	ADDQ.w	#$06,a4				; else update stack pointer
 4121/    45C8 :                        LAB_22BD
 4122/    45C8 : 7000                   	MOVEQ		#0,d0					; clear string length longword
 4123/    45CA : 2258                   	MOVEA.l	(a0)+,a1				; get string address
 4124/    45CC : 3018                   	MOVE.w	(a0)+,d0				; get string length
 4125/    45CE :                        
 4126/    45CE : B9C8                   	CMPA.l	a0,a4					; was it on the descriptor stack
 4127/    45D0 : 6610                   	BNE.s		LAB_22E6				; branch if it wasn't
 4128/    45D2 :                        
 4129/    45D2 : B3EB 0446              	CMPA.l	Sstorl(a3),a1			; compare string address with bottom of string
 4130/    45D6 :                        								; space
 4131/    45D6 : 660A                   	BNE.s		LAB_22E6				; branch if <>
 4132/    45D8 :                        
 4133/    45D8 : 7201                   	MOVEQ		#1,d1					; mask for odd bit
 4134/    45DA : C240                   	AND.w		d0,d1					; AND length
 4135/    45DC : D280                   	ADD.l		d0,d1					; make it fit word aligned length
 4136/    45DE :                        
 4137/    45DE : D3AB 0446              	ADD.l		d1,Sstorl(a3)			; add to bottom of string space
 4138/    45E2 :                        LAB_22E6
 4139/    45E2 : 2049                   	MOVEA.l	a1,a0					; copy to a0
 4140/    45E4 : 4CDF 0202              	MOVEM.l	(sp)+,a1/d1				; restore other regs
 4141/    45E8 : 4A80                   	TST.l		d0					; set flags on length
 4142/    45EA : 4E75                   	RTS
 4143/    45EC :                        
 4144/    45EC :                        
 4145/    45EC :                        ;************************************************************************************
 4146/    45EC :                        ;
 4147/    45EC :                        ; perform CHR$()
 4148/    45EC :                        
 4149/    45EC :                        LAB_CHRS
 4150/    45EC : 6100 0130              	BSR		LAB_EVBY				; evaluate byte expression, result in d0 and
 4151/    45F0 :                        								; Itemp
 4152/    45F0 :                        LAB_MKCHR
 4153/    45F0 : 7201                   	MOVEQ		#1,d1					; string is single byte
 4154/    45F2 : 6100 FE32              	BSR		LAB_2115				; make string space d1 bytes long
 4155/    45F6 :                        								; return a0/Sutill = pointer, others unchanged
 4156/    45F6 : 1080                   	MOVE.b	d0,(a0)				; save byte in string (byte IS string!)
 4157/    45F8 : 6000 FE12              	BRA		LAB_RTST				; push string on descriptor stack
 4158/    45FC :                        								; a0 = pointer, d1 = length
 4159/    45FC :                        
 4160/    45FC :                        
 4161/    45FC :                        ;************************************************************************************
 4162/    45FC :                        ;
 4163/    45FC :                        ; perform LEFT$()
 4164/    45FC :                        
 4165/    45FC :                        ; enter with a0 is descriptor, d0 & Itemp is word 1
 4166/    45FC :                        
 4167/    45FC :                        LAB_LEFT
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 74 - 12/13/2023 15:59:9


 4168/    45FC : C141                   	EXG		d0,d1					; word in d1
 4169/    45FE : 6100 F79C              	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
 4170/    4602 :                        
 4171/    4602 : 4A81                   	TST.l		d1					; test returned length
 4172/    4604 : 6722                   	BEQ.s		LAB_231C				; branch if null return
 4173/    4606 :                        
 4174/    4606 : 7000                   	MOVEQ		#0,d0					; clear start offset
 4175/    4608 : B268 0004              	CMP.w		4(a0),d1				; compare word parameter with string length
 4176/    460C : 651A                   	BCS.s		LAB_231C				; branch if string length > word parameter
 4177/    460E :                        
 4178/    460E : 6014                   	BRA.s		LAB_2317				; go copy whole string
 4179/    4610 :                        
 4180/    4610 :                        
 4181/    4610 :                        ;************************************************************************************
 4182/    4610 :                        ;
 4183/    4610 :                        ; perform RIGHT$()
 4184/    4610 :                        
 4185/    4610 :                        ; enter with a0 is descriptor, d0 & Itemp is word 1
 4186/    4610 :                        
 4187/    4610 :                        LAB_RIGHT
 4188/    4610 : C141                   	EXG		d0,d1					; word in d1
 4189/    4612 : 6100 F788              	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
 4190/    4616 :                        
 4191/    4616 : 4A81                   	TST.l		d1					; test returned length
 4192/    4618 : 670E                   	BEQ.s		LAB_231C				; branch if null return
 4193/    461A :                        
 4194/    461A : 3028 0004              	MOVE.w	4(a0),d0				; get string length
 4195/    461E : 9081                   	SUB.l		d1,d0					; subtract word
 4196/    4620 : 6406                   	BCC.s		LAB_231C				; branch if string length > word parameter
 4197/    4622 :                        
 4198/    4622 :                        								; else copy whole string
 4199/    4622 :                        LAB_2316
 4200/    4622 : 7000                   	MOVEQ		#0,d0					; clear start offset
 4201/    4624 :                        LAB_2317
 4202/    4624 : 3228 0004              	MOVE.w	4(a0),d1				; else make parameter = length
 4203/    4628 :                        
 4204/    4628 :                        ; get here with ...
 4205/    4628 :                        ;   a0 - points to descriptor
 4206/    4628 :                        ;   d0 - is offset from string start
 4207/    4628 :                        ;   d1 - is required string length
 4208/    4628 :                        
 4209/    4628 :                        LAB_231C
 4210/    4628 : 2248                   	MOVEA.l	a0,a1					; save string descriptor pointer
 4211/    462A : 6100 FDFA              	BSR		LAB_2115				; make string space d1 bytes long
 4212/    462E :                        								; return a0/Sutill = pointer, others unchanged
 4213/    462E : 2049                   	MOVEA.l	a1,a0					; restore string descriptor pointer
 4214/    4630 : 2F00                   	MOVE.l	d0,-(sp)				; save start offset (longword)
 4215/    4632 : 618A                   	BSR.s		LAB_22BA				; pop (a0) descriptor, returns with ..
 4216/    4634 :                        								; d0 = length, a0 = pointer
 4217/    4634 : D1DF                   	ADDA.l	(sp)+,a0				; adjust pointer to start of wanted string
 4218/    4636 : 3001                   	MOVE.w	d1,d0					; length to d0
 4219/    4638 : 6100 FF66              	BSR		LAB_229E				; store string d0 bytes long from (a0) to
 4220/    463C :                        								; (Sutill) return with a0 = pointer,
 4221/    463C :                        								; d1 = length
 4222/    463C : 6000 FDCE              	BRA		LAB_RTST				; push string on descriptor stack
 4223/    4640 :                        								; a0 = pointer, d1 = length
 4224/    4640 :                        
 4225/    4640 :                        
 4226/    4640 :                        ;************************************************************************************
 4227/    4640 :                        ;
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 75 - 12/13/2023 15:59:9


 4228/    4640 :                        ; perform MID$()
 4229/    4640 :                        
 4230/    4640 :                        ; enter with a0 is descriptor, d0 & Itemp is word 1
 4231/    4640 :                        
 4232/    4640 :                        LAB_MIDS
 4233/    4640 : 7E00                   	MOVEQ		#0,d7					; clear longword
 4234/    4642 : 5347                   	SUBQ.w	#1,d7					; set default length = 65535
 4235/    4644 : 2F00                   	MOVE.l	d0,-(sp)				; save word 1
 4236/    4646 : 6100 F768              	BSR		LAB_GBYT				; scan memory
 4237/    464A : B03C 002C              	CMP.b		#',',d0				; was it ","
 4238/    464E : 660C                   	BNE.s		LAB_2358				; branch if not "," (skip second byte get)
 4239/    4650 :                        
 4240/    4650 : 101D                   	MOVE.b	(a5)+,d0				; increment pointer past ","
 4241/    4652 : 2F08                   	MOVE.l	a0,-(sp)				; save descriptor pointer
 4242/    4654 : 6100 00DA              	BSR		LAB_GTWO				; get word parameter, result in d0 and Itemp
 4243/    4658 : 205F                   	MOVEA.l	(sp)+,a0				; restore descriptor pointer
 4244/    465A : 2E00                   	MOVE.l	d0,d7					; copy length
 4245/    465C :                        LAB_2358
 4246/    465C : 6100 F73E              	BSR		LAB_1BFB				; scan for ")", else do syntax error then warm
 4247/    4660 :                        								; start
 4248/    4660 : 201F                   	MOVE.l	(sp)+,d0				; restore word 1
 4249/    4662 : 7200                   	MOVEQ		#0,d1					; null length
 4250/    4664 : 5380                   	SUBQ.l	#1,d0					; decrement start index (word 1)
 4251/    4666 : 6B00 EAF4              	BMI		LAB_FCER				; if was null do function call error then warm
 4252/    466A :                        								; start
 4253/    466A :                        
 4254/    466A : B068 0004              	CMP.w		4(a0),d0				; compare string length with start index
 4255/    466E : 64B8                   	BCC.s		LAB_231C				; if start not in string do null string (d1=0)
 4256/    4670 :                        
 4257/    4670 : 2207                   	MOVE.l	d7,d1					; get length back
 4258/    4672 : DE40                   	ADD.w		d0,d7					; d7 now = MID$() end
 4259/    4674 : 6506                   	BCS.s		LAB_2368				; already too long so do RIGHT$ equivalent
 4260/    4676 :                        
 4261/    4676 : BE68 0004              	CMP.w		4(a0),d7				; compare string length with start index+length
 4262/    467A : 65AC                   	BCS.s		LAB_231C				; if end in string go do string
 4263/    467C :                        
 4264/    467C :                        LAB_2368
 4265/    467C : 3228 0004              	MOVE.w	4(a0),d1				; get string length
 4266/    4680 : 9240                   	SUB.w		d0,d1					; subtract start offset
 4267/    4682 : 60A4                   	BRA.s		LAB_231C				; go do string (effectively RIGHT$)
 4268/    4684 :                        
 4269/    4684 :                        
 4270/    4684 :                        ;************************************************************************************
 4271/    4684 :                        ;
 4272/    4684 :                        ; perform LCASE$()
 4273/    4684 :                        
 4274/    4684 :                        LAB_LCASE
 4275/    4684 : 6100 FF34              	BSR		LAB_22B6				; pop string off descriptor stack or from memory
 4276/    4688 :                        								; returns with d0 = length, a0 = pointer
 4277/    4688 : 2200                   	MOVE.l	d0,d1					; copy the string length
 4278/    468A : 6756                   	BEQ.s		NoString				; if null go return a null string
 4279/    468C :                        
 4280/    468C :                        ; else copy and change the string
 4281/    468C :                        
 4282/    468C : 2248                   	MOVEA.l	a0,a1					; copy the string address
 4283/    468E : 6100 FD96              	BSR		LAB_2115				; make a string space d1 bytes long
 4284/    4692 : D1C1                   	ADDA.l	d1,a0					; new string end
 4285/    4694 : D3C1                   	ADDA.l	d1,a1					; old string end
 4286/    4696 : 3401                   	MOVE.w	d1,d2					; copy length for loop
 4287/    4698 : 5342                   	SUBQ.w	#1,d2					; -1 for DBF loop
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 76 - 12/13/2023 15:59:9


 4288/    469A :                        LC_loop
 4289/    469A : 1021                   	MOVE.b	-(a1),d0				; get byte from string
 4290/    469C :                        
 4291/    469C : B03C 005B              	CMP.b		#$5B,d0				; compare with "Z"+1
 4292/    46A0 : 640A                   	BCC.s		NoUcase				; if > "Z" skip change
 4293/    46A2 :                        
 4294/    46A2 : B03C 0041              	CMP.b		#$41,d0				; compare with "A"
 4295/    46A6 : 6504                   	BCS.s		NoUcase				; if < "A" skip change
 4296/    46A8 :                        
 4297/    46A8 : 0000 0020              	ORI.b		#$20,d0				; convert upper case to lower case
 4298/    46AC :                        NoUcase
 4299/    46AC : 1100                   	MOVE.b	d0,-(a0)				; copy upper case byte back to string
 4300/    46AE : 51CA FFEA              	DBF		d2,LC_loop				; decrement and loop if not all done
 4301/    46B2 :                        
 4302/    46B2 : 602E                   	BRA.s		NoString				; tidy up & exit (branch always)
 4303/    46B4 :                        
 4304/    46B4 :                        
 4305/    46B4 :                        ;************************************************************************************
 4306/    46B4 :                        ;
 4307/    46B4 :                        ; perform UCASE$()
 4308/    46B4 :                        
 4309/    46B4 :                        LAB_UCASE
 4310/    46B4 : 6100 FF04              	BSR		LAB_22B6				; pop string off descriptor stack or from memory
 4311/    46B8 :                        								; returns with d0 = length, a0 = pointer
 4312/    46B8 : 2200                   	MOVE.l	d0,d1					; copy the string length
 4313/    46BA : 6726                   	BEQ.s		NoString				; if null go return a null string
 4314/    46BC :                        
 4315/    46BC :                        ; else copy and change the string
 4316/    46BC :                        
 4317/    46BC : 2248                   	MOVEA.l	a0,a1					; copy the string address
 4318/    46BE : 6100 FD66              	BSR		LAB_2115				; make a string space d1 bytes long
 4319/    46C2 : D1C1                   	ADDA.l	d1,a0					; new string end
 4320/    46C4 : D3C1                   	ADDA.l	d1,a1					; old string end
 4321/    46C6 : 3401                   	MOVE.w	d1,d2					; copy length for loop
 4322/    46C8 : 5342                   	SUBQ.w	#1,d2					; -1 for DBF loop
 4323/    46CA :                        UC_loop
 4324/    46CA : 1021                   	MOVE.b	-(a1),d0				; get a byte from the string
 4325/    46CC :                        
 4326/    46CC : B03C 0061              	CMP.b		#$61,d0				; compare with "a"
 4327/    46D0 : 650A                   	BCS.s		NoLcase				; if < "a" skip change
 4328/    46D2 :                        
 4329/    46D2 : B03C 007B              	CMP.b		#$7B,d0				; compare with "z"+1
 4330/    46D6 : 6404                   	BCC.s		NoLcase				; if > "z" skip change
 4331/    46D8 :                        
 4332/    46D8 : 0200 00DF              	ANDI.b	#$DF,d0				; convert lower case to upper case
 4333/    46DC :                        NoLcase
 4334/    46DC : 1100                   	MOVE.b	d0,-(a0)				; copy upper case byte back to string
 4335/    46DE : 51CA FFEA              	DBF		d2,UC_loop				; decrement and loop if not all done
 4336/    46E2 :                        
 4337/    46E2 :                        NoString
 4338/    46E2 : 6000 FD28              	BRA		LAB_RTST				; push string on descriptor stack
 4339/    46E6 :                        								; a0 = pointer, d1 = length
 4340/    46E6 :                        
 4341/    46E6 :                        
 4342/    46E6 :                        ;************************************************************************************
 4343/    46E6 :                        ;
 4344/    46E6 :                        ; perform SADD()
 4345/    46E6 :                        
 4346/    46E6 :                        LAB_SADD
 4347/    46E6 : 101D                   	MOVE.b	(a5)+,d0				; increment pointer
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 77 - 12/13/2023 15:59:9


 4348/    46E8 : 6100 F8D6              	BSR		LAB_GVAR				; get variable address in a0
 4349/    46EC : 6100 F6AE              	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
 4350/    46F0 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type flag
 4351/    46F4 : 6A00 EA46              	BPL		LAB_TMER				; if numeric do Type missmatch Error
 4352/    46F8 : 2010                   	MOVE.l	(a0),d0					; get string address
 4353/    46FA : 6000 FBB4              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
 4354/    46FE :                        
 4355/    46FE :                        
 4356/    46FE :                        ;************************************************************************************
 4357/    46FE :                        ;
 4358/    46FE :                        ; perform LEN()
 4359/    46FE :                        
 4360/    46FE :                        LAB_LENS
 4361/    46FE : 487A FBB0              	PEA		LAB_AYFC(pc)			; set return address to convert d0 to signed
 4362/    4702 :                        								; longword in FAC1
 4363/    4702 : 6000 FEB6              	BRA		LAB_22B6				; pop string off descriptor stack or from memory
 4364/    4706 :                        								; returns with d0 = length, a0 = pointer
 4365/    4706 :                        
 4366/    4706 :                        
 4367/    4706 :                        ;************************************************************************************
 4368/    4706 :                        ;
 4369/    4706 :                        ; perform ASC()
 4370/    4706 :                        
 4371/    4706 :                        LAB_ASC
 4372/    4706 : 6100 FEB2              	BSR		LAB_22B6				; pop string off descriptor stack or from memory
 4373/    470A :                        								; returns with d0 = length, a0 = pointer
 4374/    470A : 4A40                   	TST.w		d0					; test length
 4375/    470C : 6700 EA4E              	BEQ		LAB_FCER				; if null do function call error then warm start
 4376/    4710 :                        
 4377/    4710 : 1010                   	MOVE.b	(a0),d0				; get first character byte
 4378/    4712 : 6000 FBBC              	BRA		LAB_1FD0				; convert d0 to unsigned byte in FAC1 & return
 4379/    4716 :                        
 4380/    4716 :                        
 4381/    4716 :                        ;************************************************************************************
 4382/    4716 :                        ;
 4383/    4716 :                        ; increment and get byte, result in d0 and Itemp
 4384/    4716 :                        
 4385/    4716 :                        LAB_SGBY
 4386/    4716 : 6100 F696              	BSR		LAB_IGBY				; increment & scan memory
 4387/    471A :                        
 4388/    471A :                        
 4389/    471A :                        ;************************************************************************************
 4390/    471A :                        ;
 4391/    471A :                        ; get byte parameter, result in d0 and Itemp
 4392/    471A :                        
 4393/    471A :                        LAB_GTBY
 4394/    471A : 6100 F51A              	BSR		LAB_EVNM				; evaluate expression & check is numeric,
 4395/    471E :                        								; else do type mismatch
 4396/    471E :                        
 4397/    471E :                        
 4398/    471E :                        ;************************************************************************************
 4399/    471E :                        ;
 4400/    471E :                        ; evaluate byte expression, result in d0 and Itemp
 4401/    471E :                        
 4402/    471E :                        LAB_EVBY
 4403/    471E : 6100 F9D4              	BSR		LAB_EVPI				; evaluate positive integer expression
 4404/    4722 :                        								; result in d0 and Itemp
 4405/    4722 : 123C 0080              	MOVE.b		#$80,d1				; set mask/2
 4406/    4726 : D281                   	ADD.l		d1,d1					; =$FFFFFF00
 4407/    4728 : C280                   	AND.l		d0,d1					; check top 24 bits
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 78 - 12/13/2023 15:59:9


 4408/    472A : 6600 EA30              	BNE		LAB_FCER				; if <> 0 do function call error/warm start
 4409/    472E :                        
 4410/    472E : 4E75                   	RTS
 4411/    4730 :                        
 4412/    4730 :                        
 4413/    4730 :                        ;************************************************************************************
 4414/    4730 :                        ;
 4415/    4730 :                        ; get word parameter, result in d0 and Itemp
 4416/    4730 :                        
 4417/    4730 :                        LAB_GTWO
 4418/    4730 : 6100 F504              	BSR		LAB_EVNM				; evaluate expression & check is numeric,
 4419/    4734 :                        								; else do type mismatch
 4420/    4734 : 6100 F9BE              	BSR		LAB_EVPI				; evaluate positive integer expression
 4421/    4738 :                        								; result in d0 and Itemp
 4422/    4738 : 4840                   	SWAP		d0					; copy high word to low word
 4423/    473A : 4A40                   	TST.w		d0					; set flags
 4424/    473C : 6600 EA1E              	BNE		LAB_FCER				; if <> 0 do function call error/warm start
 4425/    4740 :                        
 4426/    4740 : 4840                   	SWAP		d0					; copy high word to low word
 4427/    4742 : 4E75                   	RTS
 4428/    4744 :                        
 4429/    4744 :                        
 4430/    4744 :                        ;************************************************************************************
 4431/    4744 :                        ;
 4432/    4744 :                        ; perform VAL()
 4433/    4744 :                        
 4434/    4744 :                        LAB_VAL
 4435/    4744 : 6100 FE74              	BSR		LAB_22B6				; pop string off descriptor stack or from memory
 4436/    4748 :                        								; returns with d0 = length, a0 = pointer
 4437/    4748 : 6722                   	BEQ.s		LAB_VALZ				; string was null so set result = $00
 4438/    474A :                        								; clear FAC1 exponent & sign & return
 4439/    474A :                        
 4440/    474A : 2C4D                   	MOVEA.l	a5,a6					; save BASIC execute pointer
 4441/    474C : 2A48                   	MOVEA.l	a0,a5					; copy string pointer to execute pointer
 4442/    474E : D1C0                   	ADDA.l	d0,a0					; string end+1
 4443/    4750 : 1010                   	MOVE.b	(a0),d0				; get byte from string+1
 4444/    4752 : 3F00                   	MOVE.w	d0,-(sp)				; save it
 4445/    4754 : 2F08                   	MOVE.l	a0,-(sp)				; save address
 4446/    4756 : 10BC 0000              	MOVE.b	#0,(a0)				; null terminate string
 4447/    475A : 6100 F654              	BSR		LAB_GBYT				; scan memory
 4448/    475E : 6100 114C              	BSR		LAB_2887				; get FAC1 from string
 4449/    4762 : 205F                   	MOVEA.l	(sp)+,a0				; restore pointer
 4450/    4764 : 301F                   	MOVE.w	(sp)+,d0				; pop byte
 4451/    4766 : 1080                   	MOVE.b	d0,(a0)				; restore to memory
 4452/    4768 : 2A4E                   	MOVEA.l	a6,a5					; restore BASIC execute pointer
 4453/    476A : 4E75                   	RTS
 4454/    476C :                        
 4455/    476C :                        LAB_VALZ
 4456/    476C : 3740 0594              	MOVE.w	d0,FAC1_e(a3)			; clear FAC1 exponent & sign
 4457/    4770 : 4E75                   	RTS
 4458/    4772 :                        
 4459/    4772 :                        
 4460/    4772 :                        ;************************************************************************************
 4461/    4772 :                        ;
 4462/    4772 :                        ; get two parameters for POKE or WAIT, first parameter in a0, second in d0
 4463/    4772 :                        
 4464/    4772 :                        LAB_GADB
 4465/    4772 : 6100 F4C2              	BSR		LAB_EVNM				; evaluate expression & check is numeric,
 4466/    4776 :                        								; else do type mismatch
 4467/    4776 : 6100 F984              	BSR		LAB_EVIR				; evaluate integer expression
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 79 - 12/13/2023 15:59:9


 4468/    477A :                        								; (does FC error not OF error if out of range)
 4469/    477A : 2F00                   	MOVE.l	d0,-(sp)				; copy to stack
 4470/    477C : 6100 F626              	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
 4471/    4780 : 6198                   	BSR.s		LAB_GTBY				; get byte parameter, result in d0 and Itemp
 4472/    4782 : 205F                   	MOVEA.l	(sp)+,a0				; pull address
 4473/    4784 : 4E75                   	RTS
 4474/    4786 :                        
 4475/    4786 :                        
 4476/    4786 :                        ;************************************************************************************
 4477/    4786 :                        ;
 4478/    4786 :                        ; get two parameters for DOKE or WAITW, first parameter in a0, second in d0
 4479/    4786 :                        
 4480/    4786 :                        LAB_GADW
 4481/    4786 : 611E                   	BSR.s		LAB_GEAD				; get even address for word/long memory actions
 4482/    4788 :                        								; address returned in d0 and on the stack
 4483/    4788 : 6100 F61A              	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
 4484/    478C : 6100 F4A8              	BSR		LAB_EVNM				; evaluate expression & check is numeric,
 4485/    4790 :                        								; else do type mismatch
 4486/    4790 : 6100 F96A              	BSR		LAB_EVIR				; evaluate integer expression
 4487/    4794 :                        								; result in d0 and Itemp
 4488/    4794 : 4840                   	SWAP		d0					; swap words
 4489/    4796 : 4A40                   	TST.w		d0					; test high word
 4490/    4798 : 6706                   	BEQ.s		LAB_XGADW				; exit if null
 4491/    479A :                        
 4492/    479A : 5240                   	ADDQ.w	#1,d0					; increment word
 4493/    479C : 6600 E9BE              	BNE		LAB_FCER				; if <> 0 do function call error/warm start
 4494/    47A0 :                        
 4495/    47A0 :                        LAB_XGADW
 4496/    47A0 : 4840                   	SWAP		d0					; swap words back
 4497/    47A2 : 205F                   	MOVEA.l	(sp)+,a0				; pull address
 4498/    47A4 : 4E75                   	RTS
 4499/    47A6 :                        
 4500/    47A6 :                        
 4501/    47A6 :                        ;************************************************************************************
 4502/    47A6 :                        ;
 4503/    47A6 :                        ; get even address (for word or longword memory actions)
 4504/    47A6 :                        ; address returned in d0 and on the stack
 4505/    47A6 :                        ; does address error if the address is odd
 4506/    47A6 :                        
 4507/    47A6 :                        LAB_GEAD
 4508/    47A6 : 6100 F48E              	BSR		LAB_EVNM				; evaluate expression & check is numeric,
 4509/    47AA :                        								; else do type mismatch
 4510/    47AA : 6100 F950              	BSR		LAB_EVIR				; evaluate integer expression
 4511/    47AE :                        								; (does FC error not OF error if out of range)
 4512/    47AE : 0800 0000              	BTST		#0,d0					; test low bit of longword
 4513/    47B2 : 6600 E964              	BNE		LAB_ADER				; if address is odd do address error/warm start
 4514/    47B6 :                        
 4515/    47B6 : 2057                   	MOVEA.l	(sp),a0				; copy return address
 4516/    47B8 : 2E80                   	MOVE.l	d0,(sp)				; even address on stack
 4517/    47BA : 4ED0                   	JMP		(a0)					; effectively RTS
 4518/    47BC :                        
 4519/    47BC :                        
 4520/    47BC :                        ;************************************************************************************
 4521/    47BC :                        ;
 4522/    47BC :                        ; perform PEEK()
 4523/    47BC :                        
 4524/    47BC :                        LAB_PEEK
 4525/    47BC : 6100 F93E              	BSR		LAB_EVIR				; evaluate integer expression
 4526/    47C0 :                        								; (does FC error not OF error if out of range)
 4527/    47C0 : 2040                   	MOVEA.l	d0,a0					; copy to address register
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 80 - 12/13/2023 15:59:9


 4528/    47C2 : 1010                   	MOVE.b	(a0),d0				; get byte
 4529/    47C4 : 6000 FB0A              	BRA		LAB_1FD0				; convert d0 to unsigned byte in FAC1 & return
 4530/    47C8 :                        
 4531/    47C8 :                        
 4532/    47C8 :                        ;************************************************************************************
 4533/    47C8 :                        ;
 4534/    47C8 :                        ; perform POKE
 4535/    47C8 :                        
 4536/    47C8 :                        LAB_POKE
 4537/    47C8 : 61A8                   	BSR.s		LAB_GADB				; get two parameters for POKE or WAIT
 4538/    47CA :                        								; first parameter in a0, second in d0
 4539/    47CA : 1080                   	MOVE.b	d0,(a0)				; put byte in memory
 4540/    47CC : 4E75                   	RTS
 4541/    47CE :                        
 4542/    47CE :                        
 4543/    47CE :                        ;************************************************************************************
 4544/    47CE :                        ;
 4545/    47CE :                        ; perform DEEK()
 4546/    47CE :                        
 4547/    47CE :                        LAB_DEEK
 4548/    47CE : 6100 F92C              	BSR		LAB_EVIR				; evaluate integer expression
 4549/    47D2 :                        								; (does FC error not OF error if out of range)
 4550/    47D2 : E208                   	LSR.b		#1,d0					; shift bit 0 to carry
 4551/    47D4 : 6500 E942              	BCS		LAB_ADER				; if address is odd do address error/warm start
 4552/    47D8 :                        
 4553/    47D8 : D000                   	ADD.b		d0,d0					; shift byte back
 4554/    47DA : C188                   	EXG		d0,a0					; copy to address register
 4555/    47DC : 7000                   	MOVEQ		#0,d0					; clear top bits
 4556/    47DE : 3010                   	MOVE.w	(a0),d0				; get word
 4557/    47E0 : 6000 FACE              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
 4558/    47E4 :                        
 4559/    47E4 :                        
 4560/    47E4 :                        ;************************************************************************************
 4561/    47E4 :                        ;
 4562/    47E4 :                        ; perform LEEK()
 4563/    47E4 :                        
 4564/    47E4 :                        LAB_LEEK
 4565/    47E4 : 6100 F916              	BSR		LAB_EVIR				; evaluate integer expression
 4566/    47E8 :                        								; (does FC error not OF error if out of range)
 4567/    47E8 : E208                   	LSR.b		#1,d0					; shift bit 0 to carry
 4568/    47EA : 6500 E92C              	BCS		LAB_ADER				; if address is odd do address error/warm start
 4569/    47EE :                        
 4570/    47EE : D000                   	ADD.b		d0,d0					; shift byte back
 4571/    47F0 : C188                   	EXG		d0,a0					; copy to address register
 4572/    47F2 : 2010                   	MOVE.l	(a0),d0				; get longword
 4573/    47F4 : 6000 FABA              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
 4574/    47F8 :                        
 4575/    47F8 :                        
 4576/    47F8 :                        ;************************************************************************************
 4577/    47F8 :                        ;
 4578/    47F8 :                        ; perform DOKE
 4579/    47F8 :                        
 4580/    47F8 :                        LAB_DOKE
 4581/    47F8 : 618C                   	BSR.s		LAB_GADW				; get two parameters for DOKE or WAIT
 4582/    47FA :                        								; first parameter in a0, second in d0
 4583/    47FA : 3080                   	MOVE.w	d0,(a0)				; put word in memory
 4584/    47FC : 4E75                   	RTS
 4585/    47FE :                        
 4586/    47FE :                        
 4587/    47FE :                        ;************************************************************************************
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 81 - 12/13/2023 15:59:9


 4588/    47FE :                        ;
 4589/    47FE :                        ; perform LOKE
 4590/    47FE :                        
 4591/    47FE :                        LAB_LOKE
 4592/    47FE : 61A6                   	BSR.s		LAB_GEAD				; get even address for word/long memory actions
 4593/    4800 :                        								; address returned in d0 and on the stack
 4594/    4800 : 6100 F5A2              	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
 4595/    4804 : 6100 F430              	BSR		LAB_EVNM				; evaluate expression & check is numeric,
 4596/    4808 :                        								; else do type mismatch
 4597/    4808 : 6100 F8F2              	BSR		LAB_EVIR				; evaluate integer value (no sign check)
 4598/    480C : 205F                   	MOVEA.l	(sp)+,a0				; pull address
 4599/    480E : 2080                   	MOVE.l	d0,(a0)				; put longword in memory
 4600/    4810 :                        RTS_015
 4601/    4810 : 4E75                   	RTS
 4602/    4812 :                        
 4603/    4812 :                        
 4604/    4812 :                        ;************************************************************************************
 4605/    4812 :                        ;
 4606/    4812 :                        ; perform SWAP
 4607/    4812 :                        
 4608/    4812 :                        LAB_SWAP
 4609/    4812 : 6100 F7AC              	BSR		LAB_GVAR				; get variable 1 address in a0
 4610/    4816 : 2F08                   	MOVE.l	a0,-(sp)				; save variable 1 address
 4611/    4818 : 182B 05B5              	MOVE.b	Dtypef(a3),d4			; copy variable 1 data type, $80=string,
 4612/    481C :                        								; $40=inetger, $00=float
 4613/    481C :                        
 4614/    481C : 6100 F586              	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
 4615/    4820 : 6100 F79E              	BSR		LAB_GVAR				; get variable 2 address in a0
 4616/    4824 : 245F                   	MOVEA.l	(sp)+,a2				; restore variable 1 address
 4617/    4826 : B82B 05B5              	CMP.b		Dtypef(a3),d4			; compare variable 1 data type with variable 2
 4618/    482A :                        								; data type
 4619/    482A : 6600 E910              	BNE		LAB_TMER				; if not both the same type do "Type mismatch"
 4620/    482E :                        								; error then warm start
 4621/    482E :                        
 4622/    482E : 2010                   	MOVE.l	(a0),d0				; get variable 2
 4623/    4830 : 20D2                   	MOVE.l	(a2),(a0)+				; copy variable 1 to variable 2
 4624/    4832 : 24C0                   	MOVE.l	d0,(a2)+				; save variable 2 to variable 1
 4625/    4834 :                        
 4626/    4834 : 4A04                   	TST.b		d4					; check data type
 4627/    4836 : 6AD8                   	BPL.s		RTS_015				; exit if not string
 4628/    4838 :                        
 4629/    4838 : 3010                   	MOVE.w	(a0),d0				; get string 2 length
 4630/    483A : 3092                   	MOVE.w	(a2),(a0)				; copy string 1 length to string 2 length
 4631/    483C : 3480                   	MOVE.w	d0,(a2)				; save string 2 length to string 1 length
 4632/    483E : 4E75                   	RTS
 4633/    4840 :                        
 4634/    4840 :                        
 4635/    4840 :                        ;************************************************************************************
 4636/    4840 :                        ;
 4637/    4840 :                        ; perform USR
 4638/    4840 :                        
 4639/    4840 :                        LAB_USR
 4640/    4840 : 4EAB 0406              	JSR		Usrjmp(a3)				; do user vector
 4641/    4844 : 6000 F556              	BRA		LAB_1BFB				; scan for ")", else do syntax error/warm start
 4642/    4848 :                        
 4643/    4848 :                        
 4644/    4848 :                        ;************************************************************************************
 4645/    4848 :                        ;
 4646/    4848 :                        ; perform LOAD
 4647/    4848 :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 82 - 12/13/2023 15:59:9


 4648/    4848 :                        LAB_LOAD
 4649/    4848 : 4EEB 0418              	JMP		V_LOAD(a3)				; do load vector
 4650/    484C :                        
 4651/    484C :                        
 4652/    484C :                        ;************************************************************************************
 4653/    484C :                        ;
 4654/    484C :                        ; perform SAVE
 4655/    484C :                        
 4656/    484C :                        LAB_SAVE
 4657/    484C : 4EEB 041E              	JMP		V_SAVE(a3)				; do save vector
 4658/    4850 :                        
 4659/    4850 :                        
 4660/    4850 :                        ;************************************************************************************
 4661/    4850 :                        ;
 4662/    4850 :                        ; perform CALL
 4663/    4850 :                        
 4664/    4850 :                        LAB_CALL
 4665/    4850 : 487A F55E              	PEA		LAB_GBYT(pc)			; put return address on stack
 4666/    4854 : 6100 FF50              	BSR		LAB_GEAD				; get even address for word/long memory actions
 4667/    4858 :                        								; address returned in d0 and on the stack
 4668/    4858 : 4E75                   	RTS							; effectively calls the routine
 4669/    485A :                        
 4670/    485A :                        ; if the called routine exits correctly then it will return via the get byte routine.
 4671/    485A :                        ; this will then get the next byte for the interpreter and return
 4672/    485A :                        
 4673/    485A :                        
 4674/    485A :                        ;************************************************************************************
 4675/    485A :                        ;
 4676/    485A :                        ; perform WAIT
 4677/    485A :                        
 4678/    485A :                        LAB_WAIT
 4679/    485A : 6100 FF16              	BSR		LAB_GADB				; get two parameters for POKE or WAIT
 4680/    485E :                        								; first parameter in a0, second in d0
 4681/    485E : 2F08                   	MOVE.l	a0,-(sp)				; save address
 4682/    4860 : 3F00                   	MOVE.w	d0,-(sp)				; save byte
 4683/    4862 : 7400                   	MOVEQ		#0,d2					; clear mask
 4684/    4864 : 6100 F54A              	BSR		LAB_GBYT				; scan memory
 4685/    4868 : 6706                   	BEQ.s		LAB_2441				; skip if no third argument
 4686/    486A :                        
 4687/    486A : 6100 F534              	BSR		LAB_SCGB				; scan for "," & get byte,
 4688/    486E :                        								; else do syntax error/warm start
 4689/    486E : 2400                   	MOVE.l	d0,d2					; copy mask
 4690/    4870 :                        LAB_2441
 4691/    4870 : 321F                   	MOVE.w	(sp)+,d1				; get byte
 4692/    4872 : 205F                   	MOVEA.l	(sp)+,a0				; get address
 4693/    4874 :                        LAB_2445
 4694/    4874 : 1010                   	MOVE.b	(a0),d0				; read memory byte
 4695/    4876 : B500                   	EOR.b		d2,d0					; EOR with second argument (mask)
 4696/    4878 : C001                   	AND.b		d1,d0					; AND with first argument (byte)
 4697/    487A : 67F8                   	BEQ.s		LAB_2445				; loop if result is zero
 4698/    487C :                        
 4699/    487C : 4E75                   	RTS
 4700/    487E :                        
 4701/    487E :                        
 4702/    487E :                        ;************************************************************************************
 4703/    487E :                        ;
 4704/    487E :                        ; perform subtraction, FAC1 from FAC2
 4705/    487E :                        
 4706/    487E :                        LAB_SUBTRACT
 4707/    487E : 0A2B 0080 0595         	EORI.b	#$80,FAC1_s(a3)			; complement FAC1 sign
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 83 - 12/13/2023 15:59:9


 4708/    4884 : 176B 059D 059E         	MOVE.b	FAC2_s(a3),FAC_sc(a3)		; copy FAC2 sign byte
 4709/    488A :                        
 4710/    488A : 102B 0595              	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign byte
 4711/    488E : B12B 059E              	EOR.b		d0,FAC_sc(a3)			; EOR with FAC2 sign
 4712/    4892 :                        
 4713/    4892 :                        
 4714/    4892 :                        ;************************************************************************************
 4715/    4892 :                        ;
 4716/    4892 :                        ; add FAC2 to FAC1
 4717/    4892 :                        
 4718/    4892 :                        LAB_ADD
 4719/    4892 : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get exponent
 4720/    4896 : 6700 0338              	BEQ		LAB_279B				; FAC1 was zero so copy FAC2 to FAC1 & return
 4721/    489A :                        
 4722/    489A :                        								; FAC1 is non zero
 4723/    489A : 41EB 0598              	LEA		FAC2_m(a3),a0			; set pointer1 to FAC2 mantissa
 4724/    489E : 102B 059C              	MOVE.b	FAC2_e(a3),d0			; get FAC2 exponent
 4725/    48A2 : 6746                   	BEQ.s		RTS_016				; exit if zero
 4726/    48A4 :                        
 4727/    48A4 : 902B 0594              	SUB.b		FAC1_e(a3),d0			; subtract FAC1 exponent
 4728/    48A8 : 6722                   	BEQ.s		LAB_24A8				; branch if = (go add mantissa)
 4729/    48AA :                        
 4730/    48AA : 650A                   	BCS.s		LAB_249C				; branch if FAC2 < FAC1
 4731/    48AC :                        
 4732/    48AC :                        								; FAC2 > FAC1
 4733/    48AC : 376B 059C 0594         	MOVE.w	FAC2_e(a3),FAC1_e(a3)		; copy sign and exponent of FAC2
 4734/    48B2 : 4400                   	NEG.b		d0					; negate exponent difference (make diff -ve)
 4735/    48B4 : 5148                   	SUBQ.w	#8,a0					; pointer1 to FAC1
 4736/    48B6 :                        
 4737/    48B6 :                        LAB_249C
 4738/    48B6 : 4400                   	NEG.b		d0					; negate exponent difference (make diff +ve)
 4739/    48B8 : 2F01                   	MOVE.l	d1,-(sp)				; save d1
 4740/    48BA : B03C 0020              	CMP.b		#32,d0				; compare exponent diff with 32
 4741/    48BE : 6D04                   	BLT.s		LAB_2467				; branch if range >= 32
 4742/    48C0 :                        
 4743/    48C0 : 7200                   	MOVEQ		#0,d1					; clear d1
 4744/    48C2 : 6004                   	BRA.s		LAB_2468				; go clear smaller mantissa
 4745/    48C4 :                        
 4746/    48C4 :                        LAB_2467
 4747/    48C4 : 2210                   	MOVE.l	(a0),d1				; get FACx mantissa
 4748/    48C6 : E0A9                   	LSR.l		d0,d1					; shift d0 times right
 4749/    48C8 :                        LAB_2468
 4750/    48C8 : 2081                   	MOVE.l	d1,(a0)				; save it back
 4751/    48CA : 221F                   	MOVE.l	(sp)+,d1				; restore d1
 4752/    48CC :                        
 4753/    48CC :                        								; exponents are equal now do mantissa add or
 4754/    48CC :                        								; subtract
 4755/    48CC :                        LAB_24A8
 4756/    48CC : 4A2B 059E              	TST.b		FAC_sc(a3)				; test sign compare (FAC1 EOR FAC2)
 4757/    48D0 : 6B1A                   	BMI.s		LAB_24F8				; if <> go do subtract
 4758/    48D2 :                        
 4759/    48D2 : 202B 0598              	MOVE.l	FAC2_m(a3),d0			; get FAC2 mantissa
 4760/    48D6 : D0AB 0590              	ADD.l		FAC1_m(a3),d0			; add FAC1 mantissa
 4761/    48DA : 640A                   	BCC.s		LAB_24F7				; save and exit if no carry (FAC1 is normal)
 4762/    48DC :                        
 4763/    48DC : E290                   	ROXR.l	#1,d0					; else shift carry back into mantissa
 4764/    48DE : 522B 0594              	ADDQ.b	#1,FAC1_e(a3)			; increment FAC1 exponent
 4765/    48E2 : 6500 E874              	BCS		LAB_OFER				; if carry do overflow error & warm start
 4766/    48E6 :                        
 4767/    48E6 :                        LAB_24F7
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 84 - 12/13/2023 15:59:9


 4768/    48E6 : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; save mantissa
 4769/    48EA :                        RTS_016
 4770/    48EA : 4E75                   	RTS
 4771/    48EC :                        								; signs are different
 4772/    48EC :                        LAB_24F8
 4773/    48EC : 43EB 0590              	LEA		FAC1_m(a3),a1			; pointer 2 to FAC1
 4774/    48F0 : B3C8                   	CMPA.l	a0,a1					; compare pointers
 4775/    48F2 : 6602                   	BNE.s		LAB_24B4				; branch if <>
 4776/    48F4 :                        
 4777/    48F4 : 5049                   	ADDQ.w	#8,a1					; else pointer2 to FAC2
 4778/    48F6 :                        
 4779/    48F6 :                        								; take smaller from bigger (take sign of bigger)
 4780/    48F6 :                        LAB_24B4
 4781/    48F6 : 2011                   	MOVE.l	(a1),d0				; get larger mantissa
 4782/    48F8 : 2210                   	MOVE.l	(a0),d1				; get smaller mantissa
 4783/    48FA : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; save larger mantissa
 4784/    48FE : 93AB 0590              	SUB.l		d1,FAC1_m(a3)			; subtract smaller
 4785/    4902 :                        
 4786/    4902 :                        
 4787/    4902 :                        ;************************************************************************************
 4788/    4902 :                        ;
 4789/    4902 :                        ; do +/- (carry is sign) & normalise FAC1
 4790/    4902 :                        
 4791/    4902 :                        LAB_24D0
 4792/    4902 : 640A                   	BCC.s		LAB_24D5				; branch if result is +ve
 4793/    4904 :                        
 4794/    4904 :                        								; erk! subtract is the wrong way round so
 4795/    4904 :                        								; negate everything
 4796/    4904 : 0A2B 00FF 0595         	EORI.b	#$FF,FAC1_s(a3)			; complement FAC1 sign
 4797/    490A : 44AB 0590              	NEG.l		FAC1_m(a3)				; negate FAC1 mantissa
 4798/    490E :                        
 4799/    490E :                        
 4800/    490E :                        ;************************************************************************************
 4801/    490E :                        ;
 4802/    490E :                        ; normalise FAC1
 4803/    490E :                        
 4804/    490E :                        LAB_24D5
 4805/    490E : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get mantissa
 4806/    4912 : 6B2E                   	BMI.s		LAB_24DA				; mantissa is normal so just exit
 4807/    4914 :                        
 4808/    4914 : 6606                   	BNE.s		LAB_24D9				; mantissa is not zero so go normalise FAC1
 4809/    4916 :                        
 4810/    4916 : 3740 0594              	MOVE.w	d0,FAC1_e(a3)			; else make FAC1 = +zero
 4811/    491A : 4E75                   	RTS
 4812/    491C :                        
 4813/    491C :                        LAB_24D9
 4814/    491C : 2F01                   	MOVE.l	d1,-(sp)				; save d1
 4815/    491E : 2200                   	MOVE.l	d0,d1					; mantissa to d1
 4816/    4920 : 7000                   	MOVEQ		#0,d0					; clear d0
 4817/    4922 : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get exponent byte
 4818/    4926 : 6714                   	BEQ.s		LAB_24D8				; if exponent is zero then clean up and exit
 4819/    4928 :                        LAB_24D6
 4820/    4928 : D281                   	ADD.l		d1,d1					; shift mantissa, ADD is quicker for a single
 4821/    492A :                        								; shift
 4822/    492A : 5BC8 FFFC              	DBMI		d0,LAB_24D6				; decrement exponent and loop if mantissa and
 4823/    492E :                        								; exponent +ve
 4824/    492E :                        
 4825/    492E : 4A40                   	TST.w		d0					; test exponent
 4826/    4930 : 670A                   	BEQ.s		LAB_24D8				; if exponent is zero make FAC1 zero
 4827/    4932 :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 85 - 12/13/2023 15:59:9


 4828/    4932 : 6A02                   	BPL.s		LAB_24D7				; if exponent is >zero go save FAC1
 4829/    4934 :                        
 4830/    4934 : 7001                   	MOVEQ		#1,d0					; else set for zero after correction
 4831/    4936 :                        LAB_24D7
 4832/    4936 : 5300                   	SUBQ.b	#1,d0					; adjust exponent for loop
 4833/    4938 : 2741 0590              	MOVE.l	d1,FAC1_m(a3)			; save normalised mantissa
 4834/    493C :                        LAB_24D8
 4835/    493C : 221F                   	MOVE.l	(sp)+,d1				; restore d1
 4836/    493E : 1740 0594              	MOVE.b	d0,FAC1_e(a3)			; save corrected exponent
 4837/    4942 :                        LAB_24DA
 4838/    4942 : 4E75                   	RTS
 4839/    4944 :                        
 4840/    4944 :                        
 4841/    4944 :                        ;************************************************************************************
 4842/    4944 :                        ;
 4843/    4944 :                        ; perform LOG()
 4844/    4944 :                        
 4845/    4944 :                        LAB_LOG
 4846/    4944 : 4A2B 0595              	TST.b		FAC1_s(a3)				; test sign
 4847/    4948 : 6B00 E812              	BMI		LAB_FCER				; if -ve do function call error/warm start
 4848/    494C :                        
 4849/    494C : 7E00                   	MOVEQ		#0,d7					; clear d7
 4850/    494E : 1747 059E              	MOVE.b	d7,FAC_sc(a3)			; clear sign compare
 4851/    4952 : 1E2B 0594              	MOVE.b	FAC1_e(a3),d7			; get exponent
 4852/    4956 : 6700 E804              	BEQ		LAB_FCER				; if 0 do function call error/warm start
 4853/    495A :                        
 4854/    495A : 9EBC 0000 0081         	SUB.l		#$81,d7				; normalise exponent
 4855/    4960 : 177C 0081 0594         	MOVE.b	#$81,FAC1_e(a3)			; force a value between 1 and 2
 4856/    4966 : 2C2B 0590              	MOVE.l	FAC1_m(a3),d6			; copy mantissa
 4857/    496A :                        
 4858/    496A : 277C 8000 0000 0598    	MOVE.l	#$80000000,FAC2_m(a3)		; set mantissa for 1
 4859/    4972 : 377C 8100 059C         	MOVE.w	#$8100,FAC2_e(a3)			; set exponent for 1
 4860/    4978 : 6100 FF18              	BSR		LAB_ADD				; find arg+1
 4861/    497C : 7000                   	MOVEQ		#0,d0					; setup for calc skip
 4862/    497E : 3740 059C              	MOVE.w	d0,FAC2_e(a3)			; set FAC1 for zero result
 4863/    4982 : DC86                   	ADD.l		d6,d6					; shift 1 bit out
 4864/    4984 : 2746 0598              	MOVE.l	d6,FAC2_m(a3)			; put back FAC2
 4865/    4988 : 6758                   	BEQ.s		LAB_LONN				; if 0 skip calculation
 4866/    498A :                        
 4867/    498A : 377C 8000 059C         	MOVE.w	#$8000,FAC2_e(a3)			; set exponent for .5
 4868/    4990 : 6100 0130              	BSR		LAB_DIVIDE				; do (arg-1)/(arg+1)
 4869/    4994 : 4A2B 0594              	TST.b		FAC1_e(a3)				; test exponent
 4870/    4998 : 6748                   	BEQ.s		LAB_LONN				; if 0 skip calculation
 4871/    499A :                        
 4872/    499A : 122B 0594              	MOVE.b	FAC1_e(a3),d1			; get exponent
 4873/    499E : 923C 0082              	SUB.b		#$82,d1				; normalise and two integer bits
 4874/    49A2 : 4401                   	NEG.b		d1					; negate for shift
 4875/    49A4 :                        ;	CMP.b		#$1F,d1				; will mantissa vanish?
 4876/    49A4 :                        ;	BGT.s		LAB_dunno				; if so do ???
 4877/    49A4 :                        
 4878/    49A4 : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get mantissa
 4879/    49A8 : E2A8                   	LSR.l		d1,d0					; shift in two integer bits
 4880/    49AA :                        
 4881/    49AA :                        ; d0 = arg
 4882/    49AA :                        ; d0 = x, d1 = y
 4883/    49AA :                        ; d2 = x1, d3 = y1
 4884/    49AA :                        ; d4 = shift count
 4885/    49AA :                        ; d5 = loop count
 4886/    49AA :                        ; d6 = z
 4887/    49AA :                        ; a0 = table pointer
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 86 - 12/13/2023 15:59:9


 4888/    49AA :                        
 4889/    49AA : 7C00                   	MOVEQ		#0,d6					; z = 0
 4890/    49AC : 223C 4000 0000         	MOVE.l	#1<<30,d1				; y = 1
 4891/    49B2 : 41FA 1408              	LEA		TAB_HTHET(pc),a0			; get pointer to hyperbolic tangent table
 4892/    49B6 : 7A1E                   	MOVEQ		#30,d5				; loop 31 times
 4893/    49B8 : 7801                   	MOVEQ		#1,d4					; set shift count
 4894/    49BA : 6006                   	BRA.s		LAB_LOCC				; entry point for loop
 4895/    49BC :                        
 4896/    49BC :                        LAB_LAAD
 4897/    49BC : E8A2                   	ASR.l		d4,d2					; x1 >> i
 4898/    49BE : 9282                   	SUB.l		d2,d1					; y = y - x1
 4899/    49C0 : DC90                   	ADD.l		(a0),d6				; z = z + tanh(i)
 4900/    49C2 :                        LAB_LOCC
 4901/    49C2 : 2400                   	MOVE.l	d0,d2					; x1 = x
 4902/    49C4 : 2601                   	MOVE.l	d1,d3					; y1 = Y
 4903/    49C6 : E8A3                   	ASR.l		d4,d3					; y1 >> i
 4904/    49C8 : 6402                   	BCC.s		LAB_LOLP
 4905/    49CA :                        
 4906/    49CA : 5283                   	ADDQ.l	#1,d3
 4907/    49CC :                        LAB_LOLP
 4908/    49CC : 9083                   	SUB.l		d3,d0					; x = x - y1
 4909/    49CE : 6AEC                   	BPL.s		LAB_LAAD				; branch if > 0
 4910/    49D0 :                        
 4911/    49D0 : 2002                   	MOVE.l	d2,d0					; get x back
 4912/    49D2 : 5848                   	ADDQ.w	#4,a0					; next entry
 4913/    49D4 : 5284                   	ADDQ.l	#1,d4					; next i
 4914/    49D6 : E28B                   	LSR.l		#1,d3					; /2
 4915/    49D8 : 6704                   	BEQ.s		LAB_LOCX				; branch y1 = 0
 4916/    49DA :                        
 4917/    49DA : 51CD FFF0              	DBF		d5,LAB_LOLP				; decrement and loop if not done
 4918/    49DE :                        
 4919/    49DE :                        								; now sort out the result
 4920/    49DE :                        LAB_LOCX
 4921/    49DE : DC86                   	ADD.l		d6,d6					; *2
 4922/    49E0 : 2006                   	MOVE.l	d6,d0					; setup for d7 = 0
 4923/    49E2 :                        LAB_LONN
 4924/    49E2 : 2800                   	MOVE.l	d0,d4					; save cordic result
 4925/    49E4 : 7A00                   	MOVEQ		#0,d5					; set default exponent sign
 4926/    49E6 : 4A87                   	TST.l		d7					; check original exponent sign
 4927/    49E8 : 6716                   	BEQ.s		LAB_LOXO				; branch if original was 0
 4928/    49EA :                        
 4929/    49EA : 6A04                   	BPL.s		LAB_LOXP				; branch if was +ve
 4930/    49EC :                        
 4931/    49EC : 4487                   	NEG.l		d7					; make original exponent +ve
 4932/    49EE : 7A80                   	MOVEQ		#$80-$100,d5			; make sign -ve
 4933/    49F0 :                        LAB_LOXP
 4934/    49F0 : 1745 0595              	MOVE.b	d5,FAC1_s(a3)			; save original exponent sign
 4935/    49F4 : 4847                   	SWAP		d7					; 16 bit shift
 4936/    49F6 : E18F                   	LSL.l		#8,d7					; easy first part
 4937/    49F8 : 7A88                   	MOVEQ		#$88-$100,d5			; start with byte
 4938/    49FA :                        LAB_LONE
 4939/    49FA : 5385                   	SUBQ.l	#1,d5					; decrement exponent
 4940/    49FC : DE87                   	ADD.l		d7,d7					; shift mantissa
 4941/    49FE : 6AFA                   	BPL.s		LAB_LONE				; loop if not normal
 4942/    4A00 :                        
 4943/    4A00 :                        LAB_LOXO
 4944/    4A00 : 2747 0590              	MOVE.l	d7,FAC1_m(a3)			; save original exponent as mantissa
 4945/    4A04 : 1745 0594              	MOVE.b	d5,FAC1_e(a3)			; save exponent for this
 4946/    4A08 : 277C B172 17F8 0598    	MOVE.l	#$B17217F8,FAC2_m(a3)		; LOG(2) mantissa
 4947/    4A10 : 377C 8000 059C         	MOVE.w	#$8000,FAC2_e(a3)			; LOG(2) exponent & sign
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 87 - 12/13/2023 15:59:9


 4948/    4A16 : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; make sign compare = FAC1 sign
 4949/    4A1C : 6118                   	BSR.s		LAB_MULTIPLY			; do multiply
 4950/    4A1E : 2744 0598              	MOVE.l	d4,FAC2_m(a3)			; save cordic result
 4951/    4A22 : 6710                   	BEQ.s		LAB_LOWZ				; branch if zero
 4952/    4A24 :                        
 4953/    4A24 : 377C 8200 059C         	MOVE.w	#$8200,FAC2_e(a3)			; set exponent & sign
 4954/    4A2A : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; clear sign compare
 4955/    4A30 : 6100 FE60              	BSR		LAB_ADD				; and add for final result
 4956/    4A34 :                        
 4957/    4A34 :                        LAB_LOWZ
 4958/    4A34 : 4E75                   	RTS
 4959/    4A36 :                        
 4960/    4A36 :                        
 4961/    4A36 :                        ;************************************************************************************
 4962/    4A36 :                        ;
 4963/    4A36 :                        ; multiply FAC1 by FAC2
 4964/    4A36 :                        
 4965/    4A36 :                        LAB_MULTIPLY
 4966/    4A36 : 48E7 F800              	MOVEM.l	d0-d4,-(sp)				; save registers
 4967/    4A3A : 4A2B 0594              	TST.b		FAC1_e(a3)				; test FAC1 exponent
 4968/    4A3E : 6776                   	BEQ.s		LAB_MUUF				; if exponent zero go make result zero
 4969/    4A40 :                        
 4970/    4A40 : 102B 059C              	MOVE.b	FAC2_e(a3),d0			; get FAC2 exponent
 4971/    4A44 : 6770                   	BEQ.s		LAB_MUUF				; if exponent zero go make result zero
 4972/    4A46 :                        
 4973/    4A46 : 176B 059E 0595         	MOVE.b	FAC_sc(a3),FAC1_s(a3)		; sign compare becomes sign
 4974/    4A4C :                        
 4975/    4A4C : D02B 0594              	ADD.b		FAC1_e(a3),d0			; multiply exponents by adding
 4976/    4A50 : 640A                   	BCC.s		LAB_MNOC				; branch if no carry
 4977/    4A52 :                        
 4978/    4A52 : 903C 0080              	SUB.b		#$80,d0				; normalise result
 4979/    4A56 : 6400 E700              	BCC		LAB_OFER				; if no carry do overflow
 4980/    4A5A :                        
 4981/    4A5A : 6006                   	BRA.s		LAB_MADD				; branch
 4982/    4A5C :                        
 4983/    4A5C :                        								; no carry for exponent add
 4984/    4A5C :                        LAB_MNOC
 4985/    4A5C : 903C 0080              	SUB.b		#$80,d0				; normalise result
 4986/    4A60 : 6554                   	BCS.s		LAB_MUUF				; return zero if underflow
 4987/    4A62 :                        
 4988/    4A62 :                        LAB_MADD
 4989/    4A62 : 1740 0594              	MOVE.b	d0,FAC1_e(a3)			; save exponent
 4990/    4A66 :                        
 4991/    4A66 :                        								; d1 (FAC1) x d2 (FAC2)
 4992/    4A66 : 222B 0590              	MOVE.l	FAC1_m(a3),d1			; get FAC1 mantissa
 4993/    4A6A : 242B 0598              	MOVE.l	FAC2_m(a3),d2			; get FAC2 mantissa
 4994/    4A6E :                        
 4995/    4A6E : 3801                   	MOVE.w	d1,d4					; copy low word FAC1
 4996/    4A70 : 2001                   	MOVE.l	d1,d0					; copy long word FAC1
 4997/    4A72 : 4840                   	SWAP		d0					; high word FAC1 to low word FAC1
 4998/    4A74 : 3600                   	MOVE.w	d0,d3					; copy high word FAC1
 4999/    4A76 :                        
 5000/    4A76 : C2C2                   	MULU		d2,d1					; low word FAC2 x low word FAC1
 5001/    4A78 : C0C2                   	MULU		d2,d0					; low word FAC2 x high word FAC1
 5002/    4A7A : 4842                   	SWAP		d2					; high word FAC2 to low word FAC2
 5003/    4A7C : C8C2                   	MULU		d2,d4					; high word FAC2 x low word FAC1
 5004/    4A7E : C6C2                   	MULU		d2,d3					; high word FAC2 x high word FAC1
 5005/    4A80 :                        
 5006/    4A80 :                        ; done multiply, now add partial products
 5007/    4A80 :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 88 - 12/13/2023 15:59:9


 5008/    4A80 :                        ;			d1 =					aaaa  ----	FAC2_L x FAC1_L
 5009/    4A80 :                        ;			d0 =				bbbb  aaaa		FAC2_L x FAC1_H
 5010/    4A80 :                        ;			d4 =				bbbb  aaaa		FAC2_H x FAC1_L
 5011/    4A80 :                        ;			d3 =			cccc  bbbb			FAC2_H x FAC1_H
 5012/    4A80 :                        ;			product =		mmmm  mmmm
 5013/    4A80 :                        
 5014/    4A80 : D2BC 0000 8000         	ADD.L		#$8000,d1				; round up lowest word
 5015/    4A86 : 4241                   	CLR.w		d1					; clear low word, don't need it
 5016/    4A88 : 4841                   	SWAP		d1					; align high word
 5017/    4A8A : D280                   	ADD.l		d0,d1					; add FAC2_L x FAC1_H (can't be carry)
 5018/    4A8C :                        LAB_MUF1
 5019/    4A8C : D284                   	ADD.l		d4,d1					; now add intermediate (FAC2_H x FAC1_L)
 5020/    4A8E : 6406                   	BCC.s		LAB_MUF2				; branch if no carry
 5021/    4A90 :                        
 5022/    4A90 : D6BC 0001 0000         	ADD.l		#$10000,d3				; else correct result
 5023/    4A96 :                        LAB_MUF2
 5024/    4A96 : D2BC 0000 8000         	ADD.l		#$8000,d1				; round up low word
 5025/    4A9C : 4241                   	CLR.w		d1					; clear low word
 5026/    4A9E : 4841                   	SWAP		d1					; align for final add
 5027/    4AA0 : D283                   	ADD.l		d3,d1					; add FAC2_H x FAC1_H, result
 5028/    4AA2 : 6B08                   	BMI.s		LAB_MUF3				; branch if normalisation not needed
 5029/    4AA4 :                        
 5030/    4AA4 : D281                   	ADD.l		d1,d1					; shift mantissa
 5031/    4AA6 : 532B 0594              	SUBQ.b	#1,FAC1_e(a3)			; adjust exponent
 5032/    4AAA : 670A                   	BEQ.s		LAB_MUUF				; branch if underflow
 5033/    4AAC :                        
 5034/    4AAC :                        LAB_MUF3
 5035/    4AAC : 2741 0590              	MOVE.l	d1,FAC1_m(a3)			; save mantissa
 5036/    4AB0 :                        LAB_MUEX
 5037/    4AB0 : 4CDF 001F              	MOVEM.l	(sp)+,d0-d4				; restore registers
 5038/    4AB4 : 4E75                   	RTS
 5039/    4AB6 :                        								; either zero or underflow result
 5040/    4AB6 :                        LAB_MUUF
 5041/    4AB6 : 7000                   	MOVEQ		#0,d0					; quick clear
 5042/    4AB8 : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; clear mantissa
 5043/    4ABC : 3740 0594              	MOVE.w	d0,FAC1_e(a3)			; clear sign and exponent
 5044/    4AC0 : 60EE                   	BRA.s		LAB_MUEX				; restore regs & exit
 5045/    4AC2 :                        
 5046/    4AC2 :                        
 5047/    4AC2 :                        ;************************************************************************************
 5048/    4AC2 :                        ;
 5049/    4AC2 :                        ; do FAC2/FAC1, result in FAC1
 5050/    4AC2 :                        ; fast hardware divide version
 5051/    4AC2 :                        
 5052/    4AC2 :                        LAB_DIVIDE
 5053/    4AC2 : 2F07                   	MOVE.l	d7,-(sp)				; save d7
 5054/    4AC4 : 7000                   	MOVEQ		#0,d0					; clear FAC2 exponent
 5055/    4AC6 : 2400                   	MOVE.l	d0,d2					; clear FAC1 exponent
 5056/    4AC8 :                        
 5057/    4AC8 : 142B 0594              	MOVE.b	FAC1_e(a3),d2			; get FAC1 exponent
 5058/    4ACC : 6700 E676              	BEQ		LAB_DZER				; if zero go do /0 error
 5059/    4AD0 :                        
 5060/    4AD0 : 102B 059C              	MOVE.b	FAC2_e(a3),d0			; get FAC2 exponent
 5061/    4AD4 : 6766                   	BEQ.s		LAB_DIV0				; if zero return zero
 5062/    4AD6 :                        
 5063/    4AD6 : 9042                   	SUB.w		d2,d0					; get result exponent by subtracting
 5064/    4AD8 : D07C 0080              	ADD.w		#$80,d0				; correct 16 bit exponent result
 5065/    4ADC :                        
 5066/    4ADC : 176B 059E 0595         	MOVE.b	FAC_sc(a3),FAC1_s(a3)		; sign compare is result sign
 5067/    4AE2 :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 89 - 12/13/2023 15:59:9


 5068/    4AE2 :                        ; now to do 32/32 bit mantissa divide
 5069/    4AE2 :                        
 5070/    4AE2 : 422B 059F              	CLR.b		flag(a3)				; clear 'flag' byte
 5071/    4AE6 : 262B 0590              	MOVE.l	FAC1_m(a3),d3			; get FAC1 mantissa
 5072/    4AEA : 282B 0598              	MOVE.l	FAC2_m(a3),d4			; get FAC2 mantissa
 5073/    4AEE : B883                   	CMP.l		d3,d4					; compare FAC2 with FAC1 mantissa
 5074/    4AF0 : 6744                   	BEQ.s		LAB_MAN1				; set mantissa result = 1 if equal
 5075/    4AF2 :                        
 5076/    4AF2 : 6506                   	BCS.s		AC1gtAC2				; branch if FAC1 > FAC2
 5077/    4AF4 :                        
 5078/    4AF4 : 9883                   	SUB.l		d3,d4					; subtract FAC1 from FAC2, result now must be <1
 5079/    4AF6 : 562B 059F              	ADDQ.b	#3,flag(a3)				; FAC2>FAC1 so set 'flag' byte
 5080/    4AFA :                        AC1gtAC2
 5081/    4AFA : 6146                   	BSR.s		LAB_32_16				; do 32/16 divide
 5082/    4AFC : 4841                   	SWAP		d1					; move 16 bit result to high word
 5083/    4AFE : 2802                   	MOVE.l	d2,d4					; copy remainder longword
 5084/    4B00 : 6142                   	BSR.s		LAB_3216				; do 32/16 divide again (skip copy d4 to d2)
 5085/    4B02 : 84C5                   	DIVU.w	d5,d2					; now divide remainder to make guard word
 5086/    4B04 : 1E2B 059F              	MOVE.b	flag(a3),d7				; now normalise, get flag byte back
 5087/    4B08 : 6708                   	BEQ.s		LAB_DIVX				; skip add if null
 5088/    4B0A :                        
 5089/    4B0A :                        ; else result was >1 so we need to add 1 to result mantissa and adjust exponent
 5090/    4B0A :                        
 5091/    4B0A : E20F                   	LSR.b		#1,d7					; shift 1 into eXtend
 5092/    4B0C : E291                   	ROXR.l	#1,d1					; shift extend result >>
 5093/    4B0E : E252                   	ROXR.w	#1,d2					; shift extend guard word >>
 5094/    4B10 : 5200                   	ADDQ.b	#1,d0					; adjust exponent
 5095/    4B12 :                        
 5096/    4B12 :                        ; now round result to 32 bits
 5097/    4B12 :                        
 5098/    4B12 :                        LAB_DIVX
 5099/    4B12 : D442                   	ADD.w		d2,d2					; guard bit into eXtend bit
 5100/    4B14 : 6408                   	BCC.s		L_DIVRND				; branch if guard=0
 5101/    4B16 :                        
 5102/    4B16 : 5281                   	ADDQ.l	#1,d1					; add guard to mantissa
 5103/    4B18 : 6404                   	BCC.s		L_DIVRND				; branch if no overflow
 5104/    4B1A :                        
 5105/    4B1A :                        LAB_SET1
 5106/    4B1A : E291                   	ROXR.l	#1,d1					; shift extend result >>
 5107/    4B1C : 5240                   	ADDQ.w	#1,d0					; adjust exponent
 5108/    4B1E :                        
 5109/    4B1E :                        								; test for over/under flow
 5110/    4B1E :                        L_DIVRND
 5111/    4B1E : 3600                   	MOVE.w	d0,d3					; copy exponent
 5112/    4B20 : 6B1A                   	BMI.s		LAB_DIV0				; if -ve return zero
 5113/    4B22 :                        
 5114/    4B22 : 0243 FF00              	ANDI.w	#$FF00,d3				; mask word high byte
 5115/    4B26 : 6600 E630              	BNE		LAB_OFER				; branch if overflow
 5116/    4B2A :                        
 5117/    4B2A :                        								; move result into FAC1
 5118/    4B2A :                        LAB_XDIV
 5119/    4B2A : 2E1F                   	MOVE.l	(sp)+,d7				; restore d7
 5120/    4B2C : 1740 0594              	MOVE.b	d0,FAC1_e(a3)			; save result exponent
 5121/    4B30 : 2741 0590              	MOVE.l	d1,FAC1_m(a3)			; save result mantissa
 5122/    4B34 : 4E75                   	RTS
 5123/    4B36 :                        
 5124/    4B36 :                        ; FAC1 mantissa = FAC2 mantissa so set result mantissa
 5125/    4B36 :                        
 5126/    4B36 :                        LAB_MAN1
 5127/    4B36 : 7201                   	MOVEQ		#1,d1					; set bit
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 90 - 12/13/2023 15:59:9


 5128/    4B38 : E2A9                   	LSR.l		d1,d1					; bit into eXtend
 5129/    4B3A : 60DE                   	BRA.s		LAB_SET1				; set mantissa, adjust exponent and exit
 5130/    4B3C :                        
 5131/    4B3C :                        ; result is zero
 5132/    4B3C :                        
 5133/    4B3C :                        LAB_DIV0
 5134/    4B3C : 7000                   	MOVEQ		#0,d0					; zero exponent & sign
 5135/    4B3E : 2200                   	MOVE.l	d0,d1					; zero mantissa
 5136/    4B40 : 60E8                   	BRA		LAB_XDIV				; exit divide
 5137/    4B42 :                        
 5138/    4B42 :                        ; divide 16 bits into 32, AB/Ex
 5139/    4B42 :                        ;
 5140/    4B42 :                        ; d4			AAAA	BBBB				; 32 bit numerator
 5141/    4B42 :                        ; d3			EEEE	xxxx				; 16 bit denominator
 5142/    4B42 :                        ;
 5143/    4B42 :                        ; returns -
 5144/    4B42 :                        ;
 5145/    4B42 :                        ; d1			xxxx	DDDD				; 16 bit result
 5146/    4B42 :                        ; d2				HHHH	IIII			; 32 bit remainder
 5147/    4B42 :                        
 5148/    4B42 :                        LAB_32_16
 5149/    4B42 : 2404                   	MOVE.l	d4,d2					; copy FAC2 mantissa		(AB)
 5150/    4B44 :                        LAB_3216
 5151/    4B44 : 2A03                   	MOVE.l	d3,d5					; copy FAC1 mantissa		(EF)
 5152/    4B46 : 4245                   	CLR.w		d5					; clear low word d1		(Ex)
 5153/    4B48 : 4845                   	SWAP		d5					; swap high word to low word	(xE)
 5154/    4B4A :                        
 5155/    4B4A :                        ; d3			EEEE	FFFF				; denominator copy
 5156/    4B4A :                        ; d5		0000	EEEE					; denominator high word
 5157/    4B4A :                        ; d2			AAAA	BBBB				; numerator copy
 5158/    4B4A :                        ; d4			AAAA	BBBB				; numerator
 5159/    4B4A :                        
 5160/    4B4A : 88C5                   	DIVU.w	d5,d4					; do FAC2/FAC1 high word	(AB/E)
 5161/    4B4C : 6802                   	BVC.s		LAB_LT_1				; if no overflow DIV was ok
 5162/    4B4E :                        
 5163/    4B4E : 78FF                   	MOVEQ		#-1,d4				; else set default value
 5164/    4B50 :                        
 5165/    4B50 :                        ; done the divide, now check the result, we have ...
 5166/    4B50 :                        
 5167/    4B50 :                        ; d3			EEEE	FFFF				; denominator copy
 5168/    4B50 :                        ; d5		0000	EEEE					; denominator high word
 5169/    4B50 :                        ; d2			AAAA	BBBB				; numerator copy
 5170/    4B50 :                        ; d4			MMMM	DDDD				; result MOD and DIV
 5171/    4B50 :                        
 5172/    4B50 :                        LAB_LT_1
 5173/    4B50 : 3C04                   	MOVE.w	d4,d6					; copy 16 bit result
 5174/    4B52 : 3204                   	MOVE.w	d4,d1					; copy 16 bit result again
 5175/    4B54 :                        
 5176/    4B54 :                        ; we now have ..
 5177/    4B54 :                        ; d3			EEEE	FFFF				; denominator copy
 5178/    4B54 :                        ; d5		0000	EEEE					; denominator high word
 5179/    4B54 :                        ; d6			xxxx  DDDD				; result DIV copy
 5180/    4B54 :                        ; d1			xxxx  DDDD				; result DIV copy
 5181/    4B54 :                        ; d2			AAAA	BBBB				; numerator copy
 5182/    4B54 :                        ; d4			MMMM	DDDD				; result MOD and DIV
 5183/    4B54 :                        
 5184/    4B54 :                        ; now multiply out 32 bit denominator by 16 bit result
 5185/    4B54 :                        ; QRS = AB*D
 5186/    4B54 :                        
 5187/    4B54 : CCC3                   	MULU.w	d3,d6					; FFFF	; DDDD =       rrrr  SSSS
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 91 - 12/13/2023 15:59:9


 5188/    4B56 : C8C5                   	MULU.w	d5,d4					; EEEE	; DDDD = QQQQ  rrrr
 5189/    4B58 :                        
 5190/    4B58 :                        ; we now have ..
 5191/    4B58 :                        ; d3			EEEE	FFFF				; denominator copy
 5192/    4B58 :                        ; d5		0000	EEEE					; denominator high word
 5193/    4B58 :                        ; d6				rrrr  SSSS			; 48 bit result partial low
 5194/    4B58 :                        ; d1			xxxx  DDDD				; result DIV copy
 5195/    4B58 :                        ; d2			AAAA	BBBB				; numerator copy
 5196/    4B58 :                        ; d4			QQQQ	rrrr				; 48 bit result partial
 5197/    4B58 :                        
 5198/    4B58 : 3E06                   	MOVE.w	d6,d7					; copy low word of low multiply
 5199/    4B5A :                        
 5200/    4B5A :                        ; d7				xxxx	SSSS			; 48 bit result partial low
 5201/    4B5A :                        
 5202/    4B5A : 4246                   	CLR.w		d6					; clear low word of low multiply
 5203/    4B5C : 4846                   	SWAP		d6					; high word of low multiply to low word
 5204/    4B5E :                        
 5205/    4B5E :                        ; d6			0000	rrrr				; high word of 48 bit result partial low
 5206/    4B5E :                        
 5207/    4B5E : D886                   	ADD.l		d6,d4
 5208/    4B60 :                        
 5209/    4B60 :                        ; d4			QQQQ	RRRR				; 48 bit result partial high longword
 5210/    4B60 :                        
 5211/    4B60 : 7C00                   	MOVEQ		#0,d6					; clear to extend numerator to 48 bits
 5212/    4B62 :                        
 5213/    4B62 :                        ; now do GHI = AB0 - QRS (which is the remainder)
 5214/    4B62 :                        
 5215/    4B62 : 9C47                   	SUB.w		d7,d6					; low word subtract
 5216/    4B64 :                        
 5217/    4B64 :                        ; d6				xxxx	IIII			; remainder low word
 5218/    4B64 :                        
 5219/    4B64 : 9584                   	SUBX.l	d4,d2					; high longword subtract
 5220/    4B66 :                        
 5221/    4B66 :                        ; d2			GGGG	HHHH				; remainder high longword
 5222/    4B66 :                        
 5223/    4B66 :                        ; now if we got the divide correct then the remainder high longword will be +ve
 5224/    4B66 :                        
 5225/    4B66 : 6A08                   	BPL.s		L_DDIV				; branch if result is ok (<needed)
 5226/    4B68 :                        
 5227/    4B68 :                        ; remainder was -ve so DDDD is too big
 5228/    4B68 :                        
 5229/    4B68 :                        LAB_REMM
 5230/    4B68 : 5341                   	SUBQ.w	#1,d1					; adjust DDDD
 5231/    4B6A :                        
 5232/    4B6A :                        ; d3				xxxx	FFFF			; denominator copy
 5233/    4B6A :                        ; d6				xxxx	IIII			; remainder low word
 5234/    4B6A :                        
 5235/    4B6A : DC43                   	ADD.w		d3,d6					; add EF*1 low remainder low word
 5236/    4B6C :                        
 5237/    4B6C :                        ; d5			0000	EEEE				; denominator high word
 5238/    4B6C :                        ; d2			GGGG	HHHH				; remainder high longword
 5239/    4B6C :                        
 5240/    4B6C : D585                   	ADDX.l	d5,d2					; add extend EF*1 to remainder high longword
 5241/    4B6E : 6BF8                   	BMI.s		LAB_REMM				; loop if result still too big
 5242/    4B70 :                        
 5243/    4B70 :                        ; all done and result correct or <
 5244/    4B70 :                        
 5245/    4B70 :                        L_DDIV
 5246/    4B70 : 4842                   	SWAP		d2					; remainder mid word to high word
 5247/    4B72 :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 92 - 12/13/2023 15:59:9


 5248/    4B72 :                        ; d2			HHHH	GGGG				; (high word /should/ be $0000)
 5249/    4B72 :                        
 5250/    4B72 : 3406                   	MOVE.w	d6,d2					; remainder in high word
 5251/    4B74 :                        
 5252/    4B74 :                        ; d2				HHHH	IIII			; now is 32 bit remainder
 5253/    4B74 :                        ; d1			xxxx	DDDD				; 16 bit result
 5254/    4B74 :                        
 5255/    4B74 : 4E75                   	RTS
 5256/    4B76 :                        
 5257/    4B76 :                        
 5258/    4B76 :                        ;************************************************************************************
 5259/    4B76 :                        ;
 5260/    4B76 :                        ; unpack memory (a0) into FAC1
 5261/    4B76 :                        
 5262/    4B76 :                        LAB_UFAC
 5263/    4B76 : 2010                   	MOVE.l	(a0),d0				; get packed value
 5264/    4B78 : 4840                   	SWAP		d0					; exponent and sign into least significant word
 5265/    4B7A : 3740 0594              	MOVE.w	d0,FAC1_e(a3)			; save exponent and sign
 5266/    4B7E : 6708                   	BEQ.s		LAB_NB1T				; branch if exponent (and the rest) zero
 5267/    4B80 :                        
 5268/    4B80 : 807C 0080              	OR.w		#$80,d0				; set MSb
 5269/    4B84 : 4840                   	SWAP		d0					; word order back to normal
 5270/    4B86 : E180                   	ASL.l		#8,d0					; shift exponent & clear guard byte
 5271/    4B88 :                        LAB_NB1T
 5272/    4B88 : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; move into FAC1
 5273/    4B8C :                        
 5274/    4B8C : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
 5275/    4B90 : 4E75                   	RTS
 5276/    4B92 :                        
 5277/    4B92 :                        
 5278/    4B92 :                        ;************************************************************************************
 5279/    4B92 :                        ;
 5280/    4B92 :                        ; set numeric variable, pack FAC1 into Lvarpl
 5281/    4B92 :                        
 5282/    4B92 :                        LAB_PFAC
 5283/    4B92 : 2F08                   	MOVE.l	a0,-(sp)				; save pointer
 5284/    4B94 : 206B 0472              	MOVEA.l	Lvarpl(a3),a0			; get destination pointer
 5285/    4B98 : 082B 0006 05B5         	BTST		#6,Dtypef(a3)			; test data type
 5286/    4B9E : 670C                   	BEQ.s		LAB_277C				; branch if floating
 5287/    4BA0 :                        
 5288/    4BA0 : 6100 00C6              	BSR		LAB_2831				; convert FAC1 floating to fixed
 5289/    4BA4 :                        								; result in d0 and Itemp
 5290/    4BA4 : 2080                   	MOVE.l	d0,(a0)				; save in var
 5291/    4BA6 : 205F                   	MOVE.l	(sp)+,a0				; restore pointer
 5292/    4BA8 : 4E75                   	RTS
 5293/    4BAA :                        
 5294/    4BAA :                        
 5295/    4BAA :                        ;************************************************************************************
 5296/    4BAA :                        ;
 5297/    4BAA :                        ; normalise round and pack FAC1 into (a0)
 5298/    4BAA :                        
 5299/    4BAA :                        LAB_2778
 5300/    4BAA : 2F08                   	MOVE.l	a0,-(sp)				; save pointer
 5301/    4BAC :                        LAB_277C
 5302/    4BAC : 6100 FD60              	BSR		LAB_24D5				; normalise FAC1
 5303/    4BB0 : 612C                   	BSR.s		LAB_27BA				; round FAC1
 5304/    4BB2 : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get FAC1 mantissa
 5305/    4BB6 : E098                   	ROR.l		#8,d0					; align 24/32 bit mantissa
 5306/    4BB8 : 4840                   	SWAP		d0					; exponent/sign into 0-15
 5307/    4BBA : C07C 007F              	AND.w		#$7F,d0				; clear exponent and sign bit
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 93 - 12/13/2023 15:59:9


 5308/    4BBE : 022B 0080 0595         	ANDI.b	#$80,FAC1_s(a3)			; clear non sign bits in sign
 5309/    4BC4 : 806B 0594              	OR.w		FAC1_e(a3),d0			; OR in exponent and sign
 5310/    4BC8 : 4840                   	SWAP		d0					; move exponent and sign back to 16-31
 5311/    4BCA : 2080                   	MOVE.l	d0,(a0)				; store in destination
 5312/    4BCC : 205F                   	MOVE.l	(sp)+,a0				; restore pointer
 5313/    4BCE : 4E75                   	RTS
 5314/    4BD0 :                        
 5315/    4BD0 :                        
 5316/    4BD0 :                        ;************************************************************************************
 5317/    4BD0 :                        ;
 5318/    4BD0 :                        ; copy FAC2 to FAC1
 5319/    4BD0 :                        
 5320/    4BD0 :                        LAB_279B
 5321/    4BD0 : 376B 059C 0594         	MOVE.w	FAC2_e(a3),FAC1_e(a3)		; copy exponent & sign
 5322/    4BD6 : 276B 0598 0590         	MOVE.l	FAC2_m(a3),FAC1_m(a3)		; copy mantissa
 5323/    4BDC : 4E75                   	RTS
 5324/    4BDE :                        
 5325/    4BDE :                        
 5326/    4BDE :                        ;************************************************************************************
 5327/    4BDE :                        ;
 5328/    4BDE :                        ; round FAC1
 5329/    4BDE :                        
 5330/    4BDE :                        LAB_27BA
 5331/    4BDE : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
 5332/    4BE2 : 6720                   	BEQ.s		LAB_27C4				; branch if zero
 5333/    4BE4 :                        
 5334/    4BE4 : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get FAC1
 5335/    4BE8 : D0BC 0000 0080         	ADD.l		#$80,d0				; round to 24 bit
 5336/    4BEE : 640A                   	BCC.s		LAB_27C3				; branch if no overflow
 5337/    4BF0 :                        
 5338/    4BF0 : E290                   	ROXR.l	#1,d0					; shift FAC1 mantissa
 5339/    4BF2 : 522B 0594              	ADDQ.b	#1,FAC1_e(a3)			; correct exponent
 5340/    4BF6 : 6500 E560              	BCS		LAB_OFER				; if carry do overflow error & warm start
 5341/    4BFA :                        
 5342/    4BFA :                        LAB_27C3
 5343/    4BFA : C03C 0000              	AND.b		#$00,d0				; clear guard byte
 5344/    4BFE : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; save back to FAC1
 5345/    4C02 : 4E75                   	RTS
 5346/    4C04 :                        
 5347/    4C04 :                        LAB_27C4
 5348/    4C04 : 1740 0595              	MOVE.b	d0,FAC1_s(a3)			; make zero always +ve
 5349/    4C08 :                        RTS_017
 5350/    4C08 : 4E75                   	RTS
 5351/    4C0A :                        
 5352/    4C0A :                        
 5353/    4C0A :                        ;************************************************************************************
 5354/    4C0A :                        ;
 5355/    4C0A :                        ; get FAC1 sign
 5356/    4C0A :                        ; return d0=-1,C=1/-ve d0=+1,C=0/+ve
 5357/    4C0A :                        
 5358/    4C0A :                        LAB_27CA
 5359/    4C0A : 7000                   	MOVEQ		#0,d0					; clear d0
 5360/    4C0C : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
 5361/    4C10 : 67F6                   	BEQ.s		RTS_017				; exit if zero (already correct SGN(0)=0)
 5362/    4C12 :                        
 5363/    4C12 :                        
 5364/    4C12 :                        ;************************************************************************************
 5365/    4C12 :                        ;
 5366/    4C12 :                        ; return d0=-1,C=1/-ve d0=+1,C=0/+ve
 5367/    4C12 :                        ; no = 0 check
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 94 - 12/13/2023 15:59:9


 5368/    4C12 :                        
 5369/    4C12 :                        LAB_27CE
 5370/    4C12 : 102B 0595              	MOVE.b	FAC1_s(a3),d0			; else get FAC1 sign (b7)
 5371/    4C16 :                        
 5372/    4C16 :                        
 5373/    4C16 :                        ;************************************************************************************
 5374/    4C16 :                        ;
 5375/    4C16 :                        ; return d0=-1,C=1/-ve d0=+1,C=0/+ve
 5376/    4C16 :                        ; no = 0 check, sign in d0
 5377/    4C16 :                        
 5378/    4C16 :                        LAB_27D0
 5379/    4C16 : 4880                   	EXT.w		d0					; make word
 5380/    4C18 : 48C0                   	EXT.l		d0					; make longword
 5381/    4C1A : E080                   	ASR.l		#8,d0					; move sign bit through byte to carry
 5382/    4C1C : 65EA                   	BCS.s		RTS_017				; exit if carry set
 5383/    4C1E :                        
 5384/    4C1E : 7001                   	MOVEQ		#1,d0					; set result for +ve sign
 5385/    4C20 : 4E75                   	RTS
 5386/    4C22 :                        
 5387/    4C22 :                        
 5388/    4C22 :                        ;************************************************************************************
 5389/    4C22 :                        ;
 5390/    4C22 :                        ; perform SGN()
 5391/    4C22 :                        
 5392/    4C22 :                        LAB_SGN
 5393/    4C22 : 61E6                   	BSR.s		LAB_27CA				; get FAC1 sign
 5394/    4C24 :                        								; return d0=-1/-ve d0=+1/+ve
 5395/    4C24 :                        
 5396/    4C24 :                        
 5397/    4C24 :                        ;************************************************************************************
 5398/    4C24 :                        ;
 5399/    4C24 :                        ; save d0 as integer longword
 5400/    4C24 :                        
 5401/    4C24 :                        LAB_27DB
 5402/    4C24 : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; save FAC1 mantissa
 5403/    4C28 : 377C A000 0594         	MOVE.w	#$A000,FAC1_e(a3)			; set FAC1 exponent & sign
 5404/    4C2E : D080                   	ADD.l		d0,d0					; top bit into carry
 5405/    4C30 : 6000 FCD0              	BRA		LAB_24D0				; do +/- (carry is sign) & normalise FAC1
 5406/    4C34 :                        
 5407/    4C34 :                        
 5408/    4C34 :                        ;************************************************************************************
 5409/    4C34 :                        ;
 5410/    4C34 :                        ; perform ABS()
 5411/    4C34 :                        
 5412/    4C34 :                        LAB_ABS
 5413/    4C34 : 177C 0000 0595         	MOVE.b	#0,FAC1_s(a3)			; clear FAC1 sign
 5414/    4C3A : 4E75                   	RTS
 5415/    4C3C :                        
 5416/    4C3C :                        
 5417/    4C3C :                        ;************************************************************************************
 5418/    4C3C :                        ;
 5419/    4C3C :                        ; compare FAC1 with FAC2
 5420/    4C3C :                        ; returns d0=+1 Cb=0 if FAC1 > FAC2
 5421/    4C3C :                        ; returns d0= 0 Cb=0 if FAC1 = FAC2
 5422/    4C3C :                        ; returns d0=-1 Cb=1 if FAC1 < FAC2
 5423/    4C3C :                        
 5424/    4C3C :                        LAB_27FA
 5425/    4C3C : 122B 059C              	MOVE.b	FAC2_e(a3),d1			; get FAC2 exponent
 5426/    4C40 : 67C8                   	BEQ.s		LAB_27CA				; branch if FAC2 exponent=0 & get FAC1 sign
 5427/    4C42 :                        								; d0=-1,C=1/-ve d0=+1,C=0/+ve
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 95 - 12/13/2023 15:59:9


 5428/    4C42 :                        
 5429/    4C42 : 102B 059E              	MOVE.b	FAC_sc(a3),d0			; get FAC sign compare
 5430/    4C46 : 6BCA                   	BMI.s		LAB_27CE				; if signs <> do return d0=-1,C=1/-ve
 5431/    4C48 :                        								; d0=+1,C=0/+ve & return
 5432/    4C48 :                        
 5433/    4C48 : 102B 0595              	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
 5434/    4C4C : B22B 0594              	CMP.b		FAC1_e(a3),d1			; compare FAC1 exponent with FAC2 exponent
 5435/    4C50 : 660A                   	BNE.s		LAB_2828				; branch if different
 5436/    4C52 :                        
 5437/    4C52 : 222B 0598              	MOVE.l	FAC2_m(a3),d1			; get FAC2 mantissa
 5438/    4C56 : B2AB 0590              	CMP.l		FAC1_m(a3),d1			; compare mantissas
 5439/    4C5A : 6708                   	BEQ.s		LAB_282F				; exit if mantissas equal
 5440/    4C5C :                        
 5441/    4C5C :                        ; gets here if number <> FAC1
 5442/    4C5C :                        
 5443/    4C5C :                        LAB_2828
 5444/    4C5C : 65B8                   	BCS.s		LAB_27D0				; if FAC1 > FAC2 return d0=-1,C=1/-ve d0=+1,
 5445/    4C5E :                        								; C=0/+ve
 5446/    4C5E :                        
 5447/    4C5E : 0A00 0080              	EORI.b	#$80,d0				; else toggle FAC1 sign
 5448/    4C62 :                        LAB_282E
 5449/    4C62 : 60B2                   	BRA.s		LAB_27D0				; return d0=-1,C=1/-ve d0=+1,C=0/+ve
 5450/    4C64 :                        
 5451/    4C64 :                        LAB_282F
 5452/    4C64 : 7000                   	MOVEQ		#0,d0					; clear result
 5453/    4C66 : 4E75                   	RTS
 5454/    4C68 :                        
 5455/    4C68 :                        
 5456/    4C68 :                        ;************************************************************************************
 5457/    4C68 :                        ;
 5458/    4C68 :                        ; convert FAC1 floating to fixed
 5459/    4C68 :                        ; result in d0 and Itemp, sets flags correctly
 5460/    4C68 :                        
 5461/    4C68 :                        LAB_2831
 5462/    4C68 : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; copy mantissa
 5463/    4C6C : 6732                   	BEQ.s		LAB_284J				; branch if mantissa = 0
 5464/    4C6E :                        
 5465/    4C6E : 2F01                   	MOVE.l	d1,-(sp)				; save d1
 5466/    4C70 : 123C 00A0              	MOVE.b		#$A0,d1				; set for no floating bits
 5467/    4C74 : 922B 0594              	SUB.b		FAC1_e(a3),d1			; subtract FAC1 exponent
 5468/    4C78 : 6500 E4DE              	BCS		LAB_OFER				; do overflow if too big
 5469/    4C7C :                        
 5470/    4C7C : 660E                   	BNE.s		LAB_284G				; branch if exponent was not $A0
 5471/    4C7E :                        
 5472/    4C7E : 4A2B 0595              	TST.b		FAC1_s(a3)				; test FAC1 sign
 5473/    4C82 : 6A1A                   	BPL.s		LAB_284H				; branch if FAC1 +ve
 5474/    4C84 :                        
 5475/    4C84 : 4480                   	NEG.l		d0
 5476/    4C86 : 6916                   	BVS.s		LAB_284H				; branch if was $80000000
 5477/    4C88 :                        
 5478/    4C88 : 6000 E4CE              	BRA		LAB_OFER				; do overflow if too big
 5479/    4C8C :                        
 5480/    4C8C :                        LAB_284G
 5481/    4C8C : B23C 0020              	CMP.b		#$20,d1				; compare with minimum result for integer
 5482/    4C90 : 6502                   	BCS.s		LAB_284L				; if < minimum just do shift
 5483/    4C92 :                        
 5484/    4C92 : 7000                   	MOVEQ		#0,d0					; else return zero
 5485/    4C94 :                        LAB_284L
 5486/    4C94 : E2A8                   	LSR.l		d1,d0					; shift integer
 5487/    4C96 :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 96 - 12/13/2023 15:59:9


 5488/    4C96 : 4A2B 0595              	TST.b		FAC1_s(a3)				; test FAC1 sign (b7)
 5489/    4C9A : 6A02                   	BPL.s		LAB_284H				; branch if FAC1 +ve
 5490/    4C9C :                        
 5491/    4C9C : 4480                   	NEG.l		d0					; negate integer value
 5492/    4C9E :                        LAB_284H
 5493/    4C9E : 221F                   	MOVE.l	(sp)+,d1				; restore d1
 5494/    4CA0 :                        LAB_284J
 5495/    4CA0 : 2740 042A              	MOVE.l	d0,Itemp(a3)			; save result to Itemp
 5496/    4CA4 : 4E75                   	RTS
 5497/    4CA6 :                        
 5498/    4CA6 :                        
 5499/    4CA6 :                        ;************************************************************************************
 5500/    4CA6 :                        ;
 5501/    4CA6 :                        ; perform INT()
 5502/    4CA6 :                        
 5503/    4CA6 :                        LAB_INT
 5504/    4CA6 : 103C 00A0              	MOVE.b		#$A0,d0				; set for no floating bits
 5505/    4CAA : 902B 0594              	SUB.b		FAC1_e(a3),d0			; subtract FAC1 exponent
 5506/    4CAE : 6310                   	BLS.s		LAB_IRTS				; exit if exponent >= $A0
 5507/    4CB0 :                        								; (too big for fraction part!)
 5508/    4CB0 :                        
 5509/    4CB0 : B03C 0020              	CMP.b		#$20,d0				; compare with minimum result for integer
 5510/    4CB4 : 6400 0262              	BCC		LAB_POZE				; if >= minimum go return 0
 5511/    4CB8 :                        								; (too small for integer part!)
 5512/    4CB8 :                        
 5513/    4CB8 : 72FF                   	MOVEQ		#-1,d1				; set integer mask
 5514/    4CBA : E1A1                   	ASL.l		d0,d1					; shift mask [8+2*d0]
 5515/    4CBC : C3AB 0590              	AND.l		d1,FAC1_m(a3)			; mask mantissa
 5516/    4CC0 :                        LAB_IRTS
 5517/    4CC0 : 4E75                   	RTS
 5518/    4CC2 :                        
 5519/    4CC2 :                        
 5520/    4CC2 :                        ;************************************************************************************
 5521/    4CC2 :                        ;
 5522/    4CC2 :                        ; print " in line [LINE #]"
 5523/    4CC2 :                        
 5524/    4CC2 :                        LAB_2953
 5525/    4CC2 : 41FA 1800              	LEA		LAB_LMSG(pc),a0			; point to " in line " message
 5526/    4CC6 : 6100 ED1C              	BSR		LAB_18C3				; print null terminated string
 5527/    4CCA :                        
 5528/    4CCA :                        								; Print Basic line #
 5529/    4CCA : 202B 0452              	MOVE.l	Clinel(a3),d0			; get current line
 5530/    4CCE :                        
 5531/    4CCE :                        
 5532/    4CCE :                        ;************************************************************************************
 5533/    4CCE :                        ;
 5534/    4CCE :                        ; print d0 as unsigned integer
 5535/    4CCE :                        
 5536/    4CCE :                        LAB_295E
 5537/    4CCE : 43FA 0DEE              	LEA		Bin2dec(pc),a1			; get table address
 5538/    4CD2 : 7200                   	MOVEQ		#0,d1					; table index
 5539/    4CD4 : 41EB 05CC              	LEA		Usdss(a3),a0			; output string start
 5540/    4CD8 : 2401                   	MOVE.l	d1,d2					; output string index
 5541/    4CDA :                        LAB_2967
 5542/    4CDA : 2631 1000              	MOVE.l	(a1,d1.w),d3			; get table value
 5543/    4CDE : 6714                   	BEQ.s		LAB_2969				; exit if end marker
 5544/    4CE0 :                        
 5545/    4CE0 : 782F                   	MOVEQ		#'0'-1,d4				; set character to "0"-1
 5546/    4CE2 :                        LAB_2968
 5547/    4CE2 : 5244                   	ADDQ.w	#1,d4					; next numeric character
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 97 - 12/13/2023 15:59:9


 5548/    4CE4 : 9083                   	SUB.l		d3,d0					; subtract table value
 5549/    4CE6 : 6AFA                   	BPL.s		LAB_2968				; not overdone so loop
 5550/    4CE8 :                        
 5551/    4CE8 : D083                   	ADD.l		d3,d0					; correct value
 5552/    4CEA : 1184 2000              	MOVE.b	d4,(a0,d2.w)			; character out to string
 5553/    4CEE : 5841                   	ADDQ.w	#4,d1					; increment table pointer
 5554/    4CF0 : 5242                   	ADDQ.w	#1,d2					; increment output string pointer
 5555/    4CF2 : 60E6                   	BRA.s		LAB_2967				; loop
 5556/    4CF4 :                        
 5557/    4CF4 :                        LAB_2969
 5558/    4CF4 : D03C 0030              	ADD.b		#'0',d0				; make last character
 5559/    4CF8 : 1180 2000              	MOVE.b	d0,(a0,d2.w)			; character out to string
 5560/    4CFC : 5348                   	SUBQ.w	#1,a0					; decrement a0 (allow simple loop)
 5561/    4CFE :                        
 5562/    4CFE :                        								; now find non zero start of string
 5563/    4CFE :                        LAB_296A
 5564/    4CFE : 5248                   	ADDQ.w	#1,a0					; increment a0 (this will never carry to b16)
 5565/    4D00 : 43EB 05D5              	LEA		BHsend-1(a3),a1			; get string end
 5566/    4D04 : B1C9                   	CMPA.l	a1,a0					; are we at end
 5567/    4D06 : 6700 ECDC              	BEQ		LAB_18C3				; if so print null terminated string and RETURN
 5568/    4D0A :                        
 5569/    4D0A : 0C10 0030              	CMPI.b	#'0',(a0)				; is character "0" ?
 5570/    4D0E : 67EE                   	BEQ.s		LAB_296A				; loop if so
 5571/    4D10 :                        
 5572/    4D10 : 6000 ECD2              	BRA		LAB_18C3				; print null terminated string from memory & RET
 5573/    4D14 :                        
 5574/    4D14 :                        
 5575/    4D14 :                        ;************************************************************************************
 5576/    4D14 :                        ;
 5577/    4D14 :                        ; convert FAC1 to ASCII string result in (a0)
 5578/    4D14 :                        ; STR$() function enters here
 5579/    4D14 :                        
 5580/    4D14 :                        ; now outputs 7 significant digits
 5581/    4D14 :                        
 5582/    4D14 :                        ; d0 is character out
 5583/    4D14 :                        ; d1 is save index
 5584/    4D14 :                        ; d2 is gash
 5585/    4D14 :                        
 5586/    4D14 :                        ; a0 is output string pointer
 5587/    4D14 :                        
 5588/    4D14 :                        LAB_2970
 5589/    4D14 : 43EB 05C6              	LEA		Decss(a3),a1			; set output string start
 5590/    4D18 :                        
 5591/    4D18 : 7420                   	MOVEQ		#' ',d2				; character = " ", assume +ve
 5592/    4D1A : 08AB 0007 0595         	BCLR.b	#7,FAC1_s(a3)			; test and clear FAC1 sign (b7)
 5593/    4D20 : 6702                   	BEQ.s		LAB_2978				; branch if +ve
 5594/    4D22 :                        
 5595/    4D22 : 742D                   	MOVEQ		#'-',d2				; else character = "-"
 5596/    4D24 :                        LAB_2978
 5597/    4D24 : 1282                   	MOVE.b	d2,(a1)				; save the sign character
 5598/    4D26 : 142B 0594              	MOVE.b	FAC1_e(a3),d2			; get FAC1 exponent
 5599/    4D2A : 6608                   	BNE.s		LAB_2989				; branch if FAC1<>0
 5600/    4D2C :                        
 5601/    4D2C :                        								; exponent was $00 so FAC1 is 0
 5602/    4D2C : 7030                   	MOVEQ		#'0',d0				; set character = "0"
 5603/    4D2E : 7201                   	MOVEQ		#1,d1					; set output string index
 5604/    4D30 : 6000 01A8              	BRA		LAB_2A89				; save last character, [EOT] & exit
 5605/    4D34 :                        
 5606/    4D34 :                        								; FAC1 is some non zero value
 5607/    4D34 :                        LAB_2989
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 98 - 12/13/2023 15:59:9


 5608/    4D34 : 177C 0000 05AC         	MOVE.b	#0,numexp(a3)			; clear number exponent count
 5609/    4D3A : B43C 0081              	CMP.b		#$81,d2				; compare FAC1 exponent with $81 (>1.00000)
 5610/    4D3E :                        
 5611/    4D3E : 6448                   	BCC.s		LAB_299C				; branch if FAC1=>1
 5612/    4D40 :                        
 5613/    4D40 :                        								; else FAC1 < 1
 5614/    4D40 : 277C 9896 8000 0598    	MOVE.l	#$98968000,FAC2_m(a3)		; 10000000 mantissa
 5615/    4D48 : 377C 9800 059C         	MOVE.w	#$9800,FAC2_e(a3)			; 10000000 exponent & sign
 5616/    4D4E : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; make FAC1 sign sign compare
 5617/    4D54 : 6100 FCE0              	BSR		LAB_MULTIPLY			; do FAC2*FAC1
 5618/    4D58 :                        
 5619/    4D58 : 177C 00F9 05AC         	MOVE.b	#$F9,numexp(a3)			; set number exponent count (-7)
 5620/    4D5E : 6028                   	BRA.s		LAB_299C				; go test for fit
 5621/    4D60 :                        
 5622/    4D60 :                        LAB_29B9
 5623/    4D60 : 376B 0594 059C         	MOVE.w	FAC1_e(a3),FAC2_e(a3)		; copy exponent & sign from FAC1 to FAC2
 5624/    4D66 : 276B 0590 0598         	MOVE.l	FAC1_m(a3),FAC2_m(a3)		; copy FAC1 mantissa to FAC2 mantissa
 5625/    4D6C : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; save FAC1_s as sign compare
 5626/    4D72 :                        
 5627/    4D72 : 277C CCCC CCCD 0590    	MOVE.l	#$CCCCCCCD,FAC1_m(a3)		; 1/10 mantissa
 5628/    4D7A : 377C 7D00 0594         	MOVE.w	#$7D00,FAC1_e(a3)			; 1/10 exponent & sign
 5629/    4D80 : 6100 FCB4              	BSR		LAB_MULTIPLY			; do FAC2*FAC1, effectively divide by 10 but
 5630/    4D84 :                        								; faster
 5631/    4D84 :                        
 5632/    4D84 : 522B 05AC              	ADDQ.b	#1,numexp(a3)			; increment number exponent count
 5633/    4D88 :                        LAB_299C
 5634/    4D88 : 277C 9896 7F70 0598    	MOVE.l	#$98967F70,FAC2_m(a3)		; 9999999.4375 mantissa
 5635/    4D90 : 377C 9800 059C         	MOVE.w	#$9800,FAC2_e(a3)			; 9999999.4375 exponent & sign
 5636/    4D96 :                        								; (max before scientific notation)
 5637/    4D96 : 6100 0150              	BSR		LAB_27F0				; fast compare FAC1 with FAC2
 5638/    4D9A :                        								; returns d0=+1 C=0 if FAC1 > FAC2
 5639/    4D9A :                        								; returns d0= 0 C=0 if FAC1 = FAC2
 5640/    4D9A :                        								; returns d0=-1 C=1 if FAC1 < FAC2
 5641/    4D9A : 62C4                   	BHI.s		LAB_29B9				; go do /10 if FAC1 > 9999999.4375
 5642/    4D9C :                        
 5643/    4D9C : 6750                   	BEQ.s		LAB_29C3				; branch if FAC1 = 9999999.4375
 5644/    4D9E :                        
 5645/    4D9E :                        								; FAC1 < 9999999.4375
 5646/    4D9E : 277C F423 F800 0598    	MOVE.l	#$F423F800,FAC2_m(a3)		; set mantissa for 999999.5
 5647/    4DA6 : 377C 9400 059C         	MOVE.w	#$9400,FAC2_e(a3)			; set exponent for 999999.5
 5648/    4DAC :                        
 5649/    4DAC : 41EB 0590              	LEA		FAC1_m(a3),a0			; set pointer for x10
 5650/    4DB0 :                        LAB_29A7
 5651/    4DB0 : 6100 0136              	BSR		LAB_27F0				; fast compare FAC1 with FAC2
 5652/    4DB4 :                        								; returns d0=+1 C=0 if FAC1 > FAC2
 5653/    4DB4 :                        								; returns d0= 0 C=0 if FAC1 = FAC2
 5654/    4DB4 :                        								; returns d0=-1 C=1 if FAC1 < FAC2
 5655/    4DB4 : 6220                   	BHI.s		LAB_29C0				; branch if FAC1 > 99999.9375,no decimal places
 5656/    4DB6 :                        
 5657/    4DB6 :                        								; FAC1 <= 999999.5 so do x 10
 5658/    4DB6 : 2010                   	MOVE.l	(a0),d0				; get FAC1 mantissa
 5659/    4DB8 : 1228 0004              	MOVE.b	4(a0),d1				; get FAC1 exponent
 5660/    4DBC : 2400                   	MOVE.l	d0,d2					; copy it
 5661/    4DBE : E488                   	LSR.l		#2,d0					; /4
 5662/    4DC0 : D082                   	ADD.l		d2,d0					; add FAC1 (x1.125)
 5663/    4DC2 : 6404                   	BCC.s		LAB_29B7				; branch if no carry
 5664/    4DC4 :                        
 5665/    4DC4 : E290                   	ROXR.l	#1,d0					; shift carry back in
 5666/    4DC6 : 5201                   	ADDQ.b	#1,d1					; increment exponent (never overflows)
 5667/    4DC8 :                        LAB_29B7
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 99 - 12/13/2023 15:59:9


 5668/    4DC8 : 5601                   	ADDQ.b	#3,d1					; correct exponent ( 8 x 1.125 = 10 )
 5669/    4DCA :                        								; (never overflows)
 5670/    4DCA : 2080                   	MOVE.l	d0,(a0)				; save new mantissa
 5671/    4DCC : 1141 0004              	MOVE.b	d1,4(a0)				; save new exponent
 5672/    4DD0 : 532B 05AC              	SUBQ.b	#1,numexp(a3)			; decrement number exponent count
 5673/    4DD4 : 60DA                   	BRA.s		LAB_29A7				; go test again
 5674/    4DD6 :                        
 5675/    4DD6 :                        								; now we have just the digits to do
 5676/    4DD6 :                        LAB_29C0
 5677/    4DD6 : 277C 8000 0000 0598    	MOVE.l	#$80000000,FAC2_m(a3)		; set mantissa for 0.5
 5678/    4DDE : 377C 8000 059C         	MOVE.w	#$8000,FAC2_e(a3)			; set exponent for 0.5
 5679/    4DE4 : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; sign compare = sign
 5680/    4DEA : 6100 FAA6              	BSR		LAB_ADD				; add the 0.5 to FAC1 (round FAC1)
 5681/    4DEE :                        
 5682/    4DEE :                        LAB_29C3
 5683/    4DEE : 6100 FE78              	BSR		LAB_2831				; convert FAC1 floating to fixed
 5684/    4DF2 :                        								; result in d0 and Itemp
 5685/    4DF2 : 7401                   	MOVEQ		#$01,d2				; set default digits before dp = 1
 5686/    4DF4 : 102B 05AC              	MOVE.b	numexp(a3),d0			; get number exponent count
 5687/    4DF8 : D03C 0008              	ADD.b		#8,d0					; allow 7 digits before point
 5688/    4DFC : 6B0C                   	BMI.s		LAB_29D9				; if -ve then 1 digit before dp
 5689/    4DFE :                        
 5690/    4DFE : B03C 0009              	CMP.b		#$09,d0				; d0>=9 if n>=1E7
 5691/    4E02 : 6406                   	BCC.s		LAB_29D9				; branch if >= $09
 5692/    4E04 :                        
 5693/    4E04 :                        								; < $08
 5694/    4E04 : 5300                   	SUBQ.b	#1,d0					; take 1 from digit count
 5695/    4E06 : 1400                   	MOVE.b	d0,d2					; copy byte
 5696/    4E08 : 7002                   	MOVEQ		#$02,d0				; set exponent adjust
 5697/    4E0A :                        LAB_29D9
 5698/    4E0A : 7200                   	MOVEQ		#0,d1					; set output string index
 5699/    4E0C : 5500                   	SUBQ.b	#2,d0					; -2
 5700/    4E0E : 1740 05AD              	MOVE.b	d0,expcnt(a3)			; save exponent adjust
 5701/    4E12 : 1742 05AC              	MOVE.b	d2,numexp(a3)			; save digits before dp count
 5702/    4E16 : 1002                   	MOVE.b	d2,d0					; copy digits before dp count
 5703/    4E18 : 6702                   	BEQ.s		LAB_29E4				; branch if no digits before dp
 5704/    4E1A :                        
 5705/    4E1A : 6A14                   	BPL.s		LAB_29F7				; branch if digits before dp
 5706/    4E1C :                        
 5707/    4E1C :                        LAB_29E4
 5708/    4E1C : 5281                   	ADDQ.l	#1,d1					; increment index
 5709/    4E1E : 13BC 002E 1000         	MOVE.b	#'.',(a1,d1.w)			; save to output string
 5710/    4E24 :                        
 5711/    4E24 : 4A02                   	TST.b		d2					; test digits before dp count
 5712/    4E26 : 6708                   	BEQ.s		LAB_29F7				; branch if no digits before dp
 5713/    4E28 :                        
 5714/    4E28 : 5281                   	ADDQ.l	#1,d1					; increment index
 5715/    4E2A : 13BC 0030 1000         	MOVE.b	#'0',(a1,d1.w)			; save to output string
 5716/    4E30 :                        LAB_29F7
 5717/    4E30 : 7400                   	MOVEQ		#0,d2					; clear index (point to 1,000,000)
 5718/    4E32 : 7080                   	MOVEQ		#$80-$100,d0			; set output character
 5719/    4E34 :                        LAB_29FB
 5720/    4E34 : 41FA 1122              	LEA		LAB_2A9A(pc),a0			; get base of table
 5721/    4E38 : 2630 2000              	MOVE.l	(a0,d2.w),d3			; get table value
 5722/    4E3C :                        LAB_29FD
 5723/    4E3C : 5200                   	ADDQ.b	#1,d0					; increment output character
 5724/    4E3E : D7AB 042A              	ADD.l		d3,Itemp(a3)			; add to (now fixed) mantissa
 5725/    4E42 : 0800 0007              	BTST		#7,d0					; set test sense (z flag only)
 5726/    4E46 : 6504                   	BCS.s		LAB_2A18				; did carry so has wrapped past zero
 5727/    4E48 :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 100 - 12/13/2023 15:59:9


 5728/    4E48 : 67F2                   	BEQ.s		LAB_29FD				; no wrap and +ve test so try again
 5729/    4E4A :                        
 5730/    4E4A : 6002                   	BRA.s		LAB_2A1A				; found this digit
 5731/    4E4C :                        
 5732/    4E4C :                        LAB_2A18
 5733/    4E4C : 66EE                   	BNE.s		LAB_29FD				; wrap and -ve test so try again
 5734/    4E4E :                        
 5735/    4E4E :                        LAB_2A1A
 5736/    4E4E : 6406                   	BCC.s		LAB_2A21				; branch if +ve test result
 5737/    4E50 :                        
 5738/    4E50 : 4400                   	NEG.b		d0					; negate the digit number
 5739/    4E52 : D03C 000B              	ADD.b		#$0B,d0				; and subtract from 11 decimal
 5740/    4E56 :                        LAB_2A21
 5741/    4E56 : D03C 002F              	ADD.b		#$2F,d0				; add "0"-1 to result
 5742/    4E5A : 5842                   	ADDQ.w	#4,d2					; increment index to next less power of ten
 5743/    4E5C : 5241                   	ADDQ.w	#1,d1					; increment output string index
 5744/    4E5E : 1600                   	MOVE.b	d0,d3					; copy character to d3
 5745/    4E60 : C63C 007F              	AND.b		#$7F,d3				; mask out top bit
 5746/    4E64 : 1383 1000              	MOVE.b	d3,(a1,d1.w)			; save to output string
 5747/    4E68 : 042B 0001 05AC         	SUB.b		#1,numexp(a3)			; decrement # of characters before the dp
 5748/    4E6E : 6608                   	BNE.s		LAB_2A3B				; branch if still characters to do
 5749/    4E70 :                        
 5750/    4E70 :                        								; else output the point
 5751/    4E70 : 5281                   	ADDQ.l	#1,d1					; increment index
 5752/    4E72 : 13BC 002E 1000         	MOVE.b	#'.',(a1,d1.w)			; save to output string
 5753/    4E78 :                        LAB_2A3B
 5754/    4E78 : C03C 0080              	AND.b		#$80,d0				; mask test sense bit
 5755/    4E7C : 0A00 0080              	EORI.b	#$80,d0				; invert it
 5756/    4E80 : B43C 001C              	CMP.b		#LAB_2A9B-LAB_2A9A,d2		; compare table index with max+4
 5757/    4E84 : 66AE                   	BNE.s		LAB_29FB				; loop if not max
 5758/    4E86 :                        
 5759/    4E86 :                        								; now remove trailing zeroes
 5760/    4E86 :                        LAB_2A4B
 5761/    4E86 : 1031 1000              	MOVE.b	(a1,d1.w),d0			; get character from output string
 5762/    4E8A : 5381                   	SUBQ.l	#1,d1					; decrement output string index
 5763/    4E8C : B03C 0030              	CMP.b		#'0',d0				; compare with "0"
 5764/    4E90 : 67F4                   	BEQ.s		LAB_2A4B				; loop until non "0" character found
 5765/    4E92 :                        
 5766/    4E92 : B03C 002E              	CMP.b		#'.',d0				; compare with "."
 5767/    4E96 : 6702                   	BEQ.s		LAB_2A58				; branch if was dp
 5768/    4E98 :                        
 5769/    4E98 :                        								; else restore last character
 5770/    4E98 : 5281                   	ADDQ.l	#1,d1					; increment output string index
 5771/    4E9A :                        LAB_2A58
 5772/    4E9A : 13BC 002B 1002         	MOVE.b	#'+',2(a1,d1.w)			; save character "+" to output string
 5773/    4EA0 : 4A2B 05AD              	TST.b		expcnt(a3)				; test exponent count
 5774/    4EA4 : 6738                   	BEQ.s		LAB_2A8C				; if zero go set null terminator & exit
 5775/    4EA6 :                        
 5776/    4EA6 :                        								; exponent isn't zero so write exponent
 5777/    4EA6 : 6A0A                   	BPL.s		LAB_2A68				; branch if exponent count +ve
 5778/    4EA8 :                        
 5779/    4EA8 : 13BC 002D 1002         	MOVE.b	#'-',2(a1,d1.w)			; save character "-" to output string
 5780/    4EAE : 442B 05AD              	NEG.b		expcnt(a3)				; convert -ve to +ve
 5781/    4EB2 :                        LAB_2A68
 5782/    4EB2 : 13BC 0045 1001         	MOVE.b	#'E',1(a1,d1.w)			; save character "E" to output string
 5783/    4EB8 : 142B 05AD              	MOVE.b	expcnt(a3),d2			; get exponent count
 5784/    4EBC : 702F                   	MOVEQ		#$2F,d0				; one less than "0" character
 5785/    4EBE :                        LAB_2A74
 5786/    4EBE : 5200                   	ADDQ.b	#1,d0					; increment 10's character
 5787/    4EC0 : 943C 000A              	SUB.b		#$0A,d2				; subtract 10 from exponent count
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 101 - 12/13/2023 15:59:9


 5788/    4EC4 : 64F8                   	BCC.s		LAB_2A74				; loop while still >= 0
 5789/    4EC6 :                        
 5790/    4EC6 : D43C 003A              	ADD.b		#$3A,d2				; add character ":", $30+$0A, result is 10-value
 5791/    4ECA : 1380 1003              	MOVE.b	d0,3(a1,d1.w)			; save 10's character to output string
 5792/    4ECE : 1382 1004              	MOVE.b	d2,4(a1,d1.w)			; save 1's character to output string
 5793/    4ED2 : 13BC 0000 1005         	MOVE.b	#0,5(a1,d1.w)			; save null terminator after last character
 5794/    4ED8 : 600A                   	BRA.s		LAB_2A91				; go set string pointer (a0) and exit
 5795/    4EDA :                        
 5796/    4EDA :                        LAB_2A89
 5797/    4EDA : 1380 1000              	MOVE.b	d0,(a1,d1.w)			; save last character to output string
 5798/    4EDE :                        LAB_2A8C
 5799/    4EDE : 13BC 0000 1001         	MOVE.b	#0,1(a1,d1.w)			; save null terminator after last character
 5800/    4EE4 :                        LAB_2A91
 5801/    4EE4 : 2049                   	MOVEA.l	a1,a0					; set result string pointer (a0)
 5802/    4EE6 : 4E75                   	RTS
 5803/    4EE8 :                        
 5804/    4EE8 :                        
 5805/    4EE8 :                        ;************************************************************************************
 5806/    4EE8 :                        ;
 5807/    4EE8 :                        ; fast compare FAC1 with FAC2
 5808/    4EE8 :                        ; assumes both are +ve and FAC2>0
 5809/    4EE8 :                        ; returns d0=+1 C=0 if FAC1 > FAC2
 5810/    4EE8 :                        ; returns d0= 0 C=0 if FAC1 = FAC2
 5811/    4EE8 :                        ; returns d0=-1 C=1 if FAC1 < FAC2
 5812/    4EE8 :                        
 5813/    4EE8 :                        LAB_27F0
 5814/    4EE8 : 7000                   	MOVEQ		#0,d0					; set for FAC1 = FAC2
 5815/    4EEA : 122B 059C              	MOVE.b	FAC2_e(a3),d1			; get FAC2 exponent
 5816/    4EEE : B22B 0594              	CMP.b		FAC1_e(a3),d1			; compare FAC1 exponent with FAC2 exponent
 5817/    4EF2 : 660A                   	BNE.s		LAB_27F1				; branch if different
 5818/    4EF4 :                        
 5819/    4EF4 : 222B 0598              	MOVE.l	FAC2_m(a3),d1			; get FAC2 mantissa
 5820/    4EF8 : B2AB 0590              	CMP.l		FAC1_m(a3),d1			; compare mantissas
 5821/    4EFC : 6708                   	BEQ.s		LAB_27F3				; exit if mantissas equal
 5822/    4EFE :                        
 5823/    4EFE :                        LAB_27F1
 5824/    4EFE : 6504                   	BCS.s		LAB_27F2				; if FAC1 > FAC2 return d0=+1,C=0
 5825/    4F00 :                        
 5826/    4F00 : 5380                   	SUBQ.l	#1,d0					; else FAC1 < FAC2 return d0=-1,C=1
 5827/    4F02 : 4E75                   	RTS
 5828/    4F04 :                        
 5829/    4F04 :                        LAB_27F2
 5830/    4F04 : 5280                   	ADDQ.l	#1,d0
 5831/    4F06 :                        LAB_27F3
 5832/    4F06 : 4E75                   	RTS
 5833/    4F08 :                        
 5834/    4F08 :                        
 5835/    4F08 :                        ;************************************************************************************
 5836/    4F08 :                        ;
 5837/    4F08 :                        ; make FAC1 = 1
 5838/    4F08 :                        
 5839/    4F08 :                        LAB_POON
 5840/    4F08 : 277C 8000 0000 0590    	MOVE.l	#$80000000,FAC1_m(a3)		; 1 mantissa
 5841/    4F10 : 377C 8100 0594         	MOVE.w	#$8100,FAC1_e(a3)			; 1 exonent & sign
 5842/    4F16 : 4E75                   	RTS
 5843/    4F18 :                        
 5844/    4F18 :                        
 5845/    4F18 :                        ;************************************************************************************
 5846/    4F18 :                        ;
 5847/    4F18 :                        ; make FAC1 = 0
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 102 - 12/13/2023 15:59:9


 5848/    4F18 :                        
 5849/    4F18 :                        LAB_POZE
 5850/    4F18 : 7000                   	MOVEQ		#0,d0					; clear longword
 5851/    4F1A : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; 0 mantissa
 5852/    4F1E : 3740 0594              	MOVE.w	d0,FAC1_e(a3)			; 0 exonent & sign
 5853/    4F22 : 4E75                   	RTS
 5854/    4F24 :                        
 5855/    4F24 :                        
 5856/    4F24 :                        ;************************************************************************************
 5857/    4F24 :                        ;
 5858/    4F24 :                        ; perform power function
 5859/    4F24 :                        ; the number is in FAC2, the power is in FAC1
 5860/    4F24 :                        ; no longer trashes Itemp
 5861/    4F24 :                        
 5862/    4F24 :                        LAB_POWER
 5863/    4F24 : 4A2B 0594              	TST.b		FAC1_e(a3)				; test power
 5864/    4F28 : 67DE                   	BEQ.s		LAB_POON				; if zero go return 1
 5865/    4F2A :                        
 5866/    4F2A : 4A2B 059C              	TST.b		FAC2_e(a3)				; test number
 5867/    4F2E : 67E8                   	BEQ.s		LAB_POZE				; if zero go return 0
 5868/    4F30 :                        
 5869/    4F30 : 1F2B 059D              	MOVE.b	FAC2_s(a3),-(sp)			; save number sign
 5870/    4F34 : 6A20                   	BPL.s		LAB_POWP				; power of positive number
 5871/    4F36 :                        
 5872/    4F36 : 7200                   	MOVEQ		#0,d1					; clear d1
 5873/    4F38 : 1741 059D              	MOVE.b	d1,FAC2_s(a3)			; make sign +ve
 5874/    4F3C :                        
 5875/    4F3C :                        								; number sign was -ve and can only be raised to
 5876/    4F3C :                        								; an integer power which gives an x +j0 result,
 5877/    4F3C :                        								; else do 'function call' error
 5878/    4F3C : 122B 0594              	MOVE.b	FAC1_e(a3),d1			; get power exponent
 5879/    4F40 : 927C 0080              	SUB.w		#$80,d1				; normalise to .5
 5880/    4F44 : 6300 E216              	BLS		LAB_FCER				; if 0<power<1 then do 'function call' error
 5881/    4F48 :                        
 5882/    4F48 :                        								; now shift all the integer bits out
 5883/    4F48 : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get power mantissa
 5884/    4F4C : E3A0                   	ASL.l		d1,d0					; shift mantissa
 5885/    4F4E : 6600 E20C              	BNE		LAB_FCER				; if power<>INT(power) then do 'function call'
 5886/    4F52 :                        								; error
 5887/    4F52 :                        
 5888/    4F52 : 6502                   	BCS.s		LAB_POWP				; if integer value odd then leave result -ve
 5889/    4F54 :                        
 5890/    4F54 : 1E80                   	MOVE.b	d0,(sp)				; save result sign +ve
 5891/    4F56 :                        LAB_POWP
 5892/    4F56 : 2F2B 0590              	MOVE.l	FAC1_m(a3),-(sp)			; save power mantissa
 5893/    4F5A : 3F2B 0594              	MOVE.w	FAC1_e(a3),-(sp)			; save power sign & exponent
 5894/    4F5E :                        
 5895/    4F5E : 6100 FC70              	BSR		LAB_279B				; copy number to FAC1
 5896/    4F62 : 6100 F9E0              	BSR		LAB_LOG				; find log of number
 5897/    4F66 :                        
 5898/    4F66 : 301F                   	MOVE.w	(sp)+,d0				; get power sign & exponent
 5899/    4F68 : 275F 0598              	MOVE.l	(sp)+,FAC2_m(a3)			; get power mantissa
 5900/    4F6C : 3740 059C              	MOVE.w	d0,FAC2_e(a3)			; save sign & exponent to FAC2
 5901/    4F70 : 1740 059E              	MOVE.b	d0,FAC_sc(a3)			; save sign as sign compare
 5902/    4F74 : 102B 0595              	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
 5903/    4F78 : B12B 059E              	EOR.b		d0,FAC_sc(a3)			; make sign compare (FAC1_s EOR FAC2_s)
 5904/    4F7C :                        
 5905/    4F7C : 6100 FAB8              	BSR		LAB_MULTIPLY			; multiply by power
 5906/    4F80 : 6158                   	BSR.s		LAB_EXP				; find exponential
 5907/    4F82 : 175F 0595              	MOVE.b	(sp)+,FAC1_s(a3)			; restore number sign
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 103 - 12/13/2023 15:59:9


 5908/    4F86 : 4E75                   	RTS
 5909/    4F88 :                        
 5910/    4F88 :                        
 5911/    4F88 :                        ;************************************************************************************
 5912/    4F88 :                        ;
 5913/    4F88 :                        ; do - FAC1
 5914/    4F88 :                        
 5915/    4F88 :                        LAB_GTHAN
 5916/    4F88 : 4A2B 0594              	TST.b		FAC1_e(a3)				; test for non zero FAC1
 5917/    4F8C : 6706                   	BEQ.s		RTS_020				; branch if null
 5918/    4F8E :                        
 5919/    4F8E : 0A2B 0080 0595         	EORI.b	#$80,FAC1_s(a3)			; (else) toggle FAC1 sign bit
 5920/    4F94 :                        RTS_020
 5921/    4F94 : 4E75                   	RTS
 5922/    4F96 :                        
 5923/    4F96 :                        
 5924/    4F96 :                        ;************************************************************************************
 5925/    4F96 :                        ;
 5926/    4F96 :                        								; return +1
 5927/    4F96 :                        LAB_EX1
 5928/    4F96 : 277C 8000 0000 0590    	MOVE.l	#$80000000,FAC1_m(a3)		; +1 mantissa
 5929/    4F9E : 377C 8100 0594         	MOVE.w	#$8100,FAC1_e(a3)			; +1 sign & exponent
 5930/    4FA4 : 4E75                   	RTS
 5931/    4FA6 :                        								; do over/under flow
 5932/    4FA6 :                        LAB_EXOU
 5933/    4FA6 : 4A2B 0595              	TST.b		FAC1_s(a3)				; test sign
 5934/    4FAA : 6A00 E1AC              	BPL		LAB_OFER				; was +ve so do overflow error
 5935/    4FAE :                        
 5936/    4FAE :                        								; else underflow so return zero
 5937/    4FAE : 7000                   	MOVEQ		#0,d0					; clear longword
 5938/    4FB0 : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; 0 mantissa
 5939/    4FB4 : 3740 0594              	MOVE.w	d0,FAC1_e(a3)			; 0 sign & exponent
 5940/    4FB8 : 4E75                   	RTS
 5941/    4FBA :                        								; fraction was zero so do 2^n
 5942/    4FBA :                        LAB_EXOF
 5943/    4FBA : 277C 8000 0000 0590    	MOVE.l	#$80000000,FAC1_m(a3)		; +n mantissa
 5944/    4FC2 : 177C 0000 0595         	MOVE.b	#0,FAC1_s(a3)			; clear sign
 5945/    4FC8 : 4A2B 05B4              	TST.b		cosout(a3)				; test sign flag
 5946/    4FCC : 6A02                   	BPL.s		LAB_EXOL				; branch if +ve
 5947/    4FCE :                        
 5948/    4FCE : 4481                   	NEG.l		d1					; else do 1/2^n
 5949/    4FD0 :                        LAB_EXOL
 5950/    4FD0 : D23C 0081              	ADD.b		#$81,d1				; adjust exponent
 5951/    4FD4 : 1741 0594              	MOVE.b	d1,FAC1_e(a3)			; save exponent
 5952/    4FD8 : 4E75                   	RTS
 5953/    4FDA :                        
 5954/    4FDA :                        ; perform EXP()	(x^e)
 5955/    4FDA :                        ; valid input range is -88 to +88
 5956/    4FDA :                        
 5957/    4FDA :                        LAB_EXP
 5958/    4FDA : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get exponent
 5959/    4FDE : 67B6                   	BEQ.s		LAB_EX1				; return 1 for zero in
 5960/    4FE0 :                        
 5961/    4FE0 : B03C 0064              	CMP.b		#$64,d0				; compare exponent with min
 5962/    4FE4 : 65B0                   	BCS.s		LAB_EX1				; if smaller just return 1
 5963/    4FE6 :                        
 5964/    4FE6 :                        ;	MOVEM.l	d1-d6/a0,-(sp)			; save the registers
 5965/    4FE6 : 177C 0000 05B4         	MOVE.b	#0,cosout(a3)			; flag +ve number
 5966/    4FEC : 222B 0590              	MOVE.l	FAC1_m(a3),d1			; get mantissa
 5967/    4FF0 : B03C 0087              	CMP.b		#$87,d0				; compare exponent with max
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 104 - 12/13/2023 15:59:9


 5968/    4FF4 : 62B0                   	BHI.s		LAB_EXOU				; go do over/under flow if greater
 5969/    4FF6 :                        
 5970/    4FF6 : 6608                   	BNE.s		LAB_EXCM				; branch if less
 5971/    4FF8 :                        
 5972/    4FF8 :                        								; else is 2^7
 5973/    4FF8 : B2BC B00F 33C7         	CMP.l		#$B00F33C7,d1			; compare mantissa with n*2^7 max
 5974/    4FFE : 64A6                   	BCC.s		LAB_EXOU				; if => go over/underflow
 5975/    5000 :                        
 5976/    5000 :                        LAB_EXCM
 5977/    5000 : 4A2B 0595              	TST.b		FAC1_s(a3)				; test sign
 5978/    5004 : 6A0C                   	BPL.s		LAB_EXPS				; branch if arg +ve
 5979/    5006 :                        
 5980/    5006 : 177C 00FF 05B4         	MOVE.b	#$FF,cosout(a3)			; flag -ve number
 5981/    500C : 177C 0000 0595         	MOVE.b	#0,FAC1_s(a3)			; take absolute value
 5982/    5012 :                        LAB_EXPS
 5983/    5012 :                        								; now do n/LOG(2)
 5984/    5012 : 277C B8AA 3B29 0598    	MOVE.l	#$B8AA3B29,FAC2_m(a3)		; 1/LOG(2) mantissa
 5985/    501A : 377C 8100 059C         	MOVE.w	#$8100,FAC2_e(a3)			; 1/LOG(2) exponent & sign
 5986/    5020 : 177C 0000 059E         	MOVE.b	#0,FAC_sc(a3)			; we know they're both +ve
 5987/    5026 : 6100 FA0E              	BSR		LAB_MULTIPLY			; effectively divide by log(2)
 5988/    502A :                        
 5989/    502A :                        								; max here is +/- 127
 5990/    502A :                        								; now separate integer and fraction
 5991/    502A : 177C 0000 05D9         	MOVE.b	#0,tpower(a3)			; clear exponent add byte
 5992/    5030 : 1A2B 0594              	MOVE.b	FAC1_e(a3),d5			; get exponent
 5993/    5034 : 9A3C 0080              	SUB.b		#$80,d5				; normalise
 5994/    5038 : 6324                   	BLS.s		LAB_ESML				; branch if < 1 (d5 is 0 or -ve)
 5995/    503A :                        
 5996/    503A :                        								; result is > 1
 5997/    503A : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get mantissa
 5998/    503E : 2200                   	MOVE.l	d0,d1					; copy it
 5999/    5040 : 2C05                   	MOVE.l	d5,d6					; copy normalised exponent
 6000/    5042 :                        
 6001/    5042 : 4446                   	NEG.w		d6					; make -ve
 6002/    5044 : DC7C 0020              	ADD.w		#32,d6				; is now 32-d6
 6003/    5048 : ECA9                   	LSR.l		d6,d1					; just integer bits
 6004/    504A : 1741 05D9              	MOVE.b	d1,tpower(a3)			; set exponent add byte
 6005/    504E :                        
 6006/    504E : EBA8                   	LSL.l		d5,d0					; shift out integer bits
 6007/    5050 : 6700 FF68              	BEQ		LAB_EXOF				; fraction is zero so do 2^n
 6008/    5054 :                        
 6009/    5054 : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; fraction to FAC1
 6010/    5058 : 377C 8000 0594         	MOVE.w	#$8000,FAC1_e(a3)			; set exponent & sign
 6011/    505E :                        
 6012/    505E :                        								; multiple was < 1
 6013/    505E :                        LAB_ESML
 6014/    505E : 277C B172 17F8 0598    	MOVE.l	#$B17217F8,FAC2_m(a3)		; LOG(2) mantissa
 6015/    5066 : 377C 8000 059C         	MOVE.w	#$8000,FAC2_e(a3)			; LOG(2) exponent & sign
 6016/    506C : 177C 0000 059E         	MOVE.b	#0,FAC_sc(a3)			; clear sign compare
 6017/    5072 : 6100 F9C2              	BSR		LAB_MULTIPLY			; multiply by log(2)
 6018/    5076 :                        
 6019/    5076 : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get mantissa
 6020/    507A : 1A2B 0594              	MOVE.b	FAC1_e(a3),d5			; get exponent
 6021/    507E : 9A7C 0082              	SUB.w		#$82,d5				; normalise and -2 (result is -1 to -30)
 6022/    5082 : 4445                   	NEG.w		d5					; make +ve
 6023/    5084 : EAA8                   	LSR.l		d5,d0					; shift for 2 integer bits
 6024/    5086 :                        
 6025/    5086 :                        ; d0 = arg
 6026/    5086 :                        ; d6 = x, d1 = y
 6027/    5086 :                        ; d2 = x1, d3 = y1
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 105 - 12/13/2023 15:59:9


 6028/    5086 :                        ; d4 = shift count
 6029/    5086 :                        ; d5 = loop count
 6030/    5086 :                        								; now do cordic set-up
 6031/    5086 : 7200                   	MOVEQ		#0,d1					; y = 0
 6032/    5088 : 2C3C 26A3 D110         	MOVE.l	#KFCTSEED,d6			; x = 1 with jkh inverse factored out
 6033/    508E : 41FA 0D2C              	LEA		TAB_HTHET(pc),a0			; get pointer to hyperbolic arctan table
 6034/    5092 : 7800                   	MOVEQ		#0,d4					; clear shift count
 6035/    5094 :                         
 6036/    5094 :                        								; cordic loop, shifts 4 and 13 (and 39
 6037/    5094 :                        								; if it went that far) need to be repeated
 6038/    5094 : 7A03                   	MOVEQ		#3,d5					; 4 loops
 6039/    5096 : 6136                   	BSR.s		LAB_EXCC				; do loops 1 through 4
 6040/    5098 : 5948                   	SUBQ.w	#4,a0					; do table entry again
 6041/    509A : 5384                   	SUBQ.l	#1,d4					; do shift count again
 6042/    509C : 7A09                   	MOVEQ		#9,d5					; 10 loops
 6043/    509E : 612E                   	BSR.s		LAB_EXCC				; do loops 4 (again) through 13
 6044/    50A0 : 5948                   	SUBQ.w	#4,a0					; do table entry again
 6045/    50A2 : 5384                   	SUBQ.l	#1,d4					; do shift count again
 6046/    50A4 : 7A12                   	MOVEQ		#18,d5				; 19 loops
 6047/    50A6 : 6126                   	BSR.s		LAB_EXCC				; do loops 13 (again) through 31
 6048/    50A8 :                         
 6049/    50A8 :                        								; now get the result
 6050/    50A8 : 4A2B 05B4              	TST.b		cosout(a3)				; test sign flag
 6051/    50AC : 6A06                   	BPL.s		LAB_EXPL				; branch if +ve
 6052/    50AE :                        
 6053/    50AE : 4481                   	NEG.l		d1					; do -y
 6054/    50B0 : 442B 05D9              	NEG.b		tpower(a3)				; do -exp
 6055/    50B4 :                        LAB_EXPL
 6056/    50B4 : 7083                   	MOVEQ		#$83-$100,d0			; set exponent
 6057/    50B6 : DC81                   	ADD.l		d1,d6					; y = y +/- x
 6058/    50B8 : 6B06                   	BMI.s		LAB_EXRN				; branch if result normal
 6059/    50BA :                        
 6060/    50BA :                        LAB_EXNN
 6061/    50BA : 5380                   	SUBQ.l	#1,d0					; decrement exponent
 6062/    50BC : DC86                   	ADD.l		d6,d6					; shift mantissa
 6063/    50BE : 6AFA                   	BPL.s		LAB_EXNN				; loop if not normal
 6064/    50C0 :                        
 6065/    50C0 :                        LAB_EXRN
 6066/    50C0 : 2746 0590              	MOVE.l	d6,FAC1_m(a3)			; save exponent result
 6067/    50C4 : D02B 05D9              	ADD.b		tpower(a3),d0			; add integer part
 6068/    50C8 : 1740 0594              	MOVE.b	d0,FAC1_e(a3)			; save exponent
 6069/    50CC :                        ;	MOVEM.l	(sp)+,d1-d6/a0			; restore registers
 6070/    50CC : 4E75                   	RTS
 6071/    50CE :                         
 6072/    50CE :                        								; cordic loop
 6073/    50CE :                        LAB_EXCC
 6074/    50CE : 5284                   	ADDQ.l	#1,d4					; increment shift count
 6075/    50D0 : 2406                   	MOVE.l	d6,d2					; x1 = x
 6076/    50D2 : E8A2                   	ASR.l		d4,d2					; x1 >> n
 6077/    50D4 : 2601                   	MOVE.l	d1,d3					; y1 = y
 6078/    50D6 : E8A3                   	ASR.l		d4,d3					; y1 >> n
 6079/    50D8 : 4A80                   	TST.l		d0					; test arg
 6080/    50DA : 6B0C                   	BMI.s		LAB_EXAD				; branch if -ve
 6081/    50DC :                        
 6082/    50DC : D282                   	ADD.l		d2,d1					; y = y + x1
 6083/    50DE : DC83                   	ADD.l		d3,d6					; x = x + y1
 6084/    50E0 : 9098                   	SUB.l		(a0)+,d0				; arg = arg - atnh(a0)
 6085/    50E2 : 51CD FFEA              	DBF		d5,LAB_EXCC				; decrement and loop if not done
 6086/    50E6 :                        
 6087/    50E6 : 4E75                   	RTS
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 106 - 12/13/2023 15:59:9


 6088/    50E8 :                        
 6089/    50E8 :                        LAB_EXAD
 6090/    50E8 : 9282                   	SUB.l		d2,d1					; y = y - x1
 6091/    50EA : 9C83                   	SUB.l		d3,d6					; x = x + y1
 6092/    50EC : D098                   	ADD.l		(a0)+,d0				; arg = arg + atnh(a0)
 6093/    50EE : 51CD FFDE              	DBF		d5,LAB_EXCC				; decrement and loop if not done
 6094/    50F2 :                        
 6095/    50F2 : 4E75                   	RTS
 6096/    50F4 :                        
 6097/    50F4 :                        
 6098/    50F4 :                        ;************************************************************************************
 6099/    50F4 :                        ;
 6100/    50F4 :                        ; RND(n), 32 bit Galois version. make n=0 for 19th next number in sequence or n<>0
 6101/    50F4 :                        ; to get 19th next number in sequence after seed n. This version of the PRNG uses
 6102/    50F4 :                        ; the Galois method and a sample of 65536 bytes produced gives the following values.
 6103/    50F4 :                        
 6104/    50F4 :                        ; Entropy = 7.997442 bits per byte
 6105/    50F4 :                        ; Optimum compression would reduce these 65536 bytes by 0 percent
 6106/    50F4 :                        
 6107/    50F4 :                        ; Chi square distribution for 65536 samples is 232.01, and
 6108/    50F4 :                        ; randomly would exceed this value 75.00 percent of the time
 6109/    50F4 :                        
 6110/    50F4 :                        ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
 6111/    50F4 :                        ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
 6112/    50F4 :                        ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
 6113/    50F4 :                        
 6114/    50F4 :                        LAB_RND
 6115/    50F4 : 4A2B 0594              	TST.b		FAC1_e(a3)				; get FAC1 exponent
 6116/    50F8 : 6708                   	BEQ.s		NextPRN				; do next random number if zero
 6117/    50FA :                        
 6118/    50FA :                        								; else get seed into random number store
 6119/    50FA : 41EB 05A0              	LEA		PRNlword(a3),a0			; set PRNG pointer
 6120/    50FE : 6100 FAAA              	BSR		LAB_2778				; pack FAC1 into (a0)
 6121/    5102 :                        NextPRN
 6122/    5102 : 72AF                   	MOVEQ		#$AF-$100,d1			; set EOR value
 6123/    5104 : 7412                   	MOVEQ		#18,d2				; do this 19 times
 6124/    5106 : 202B 05A0              	MOVE.l	PRNlword(a3),d0			; get current
 6125/    510A :                        Ninc0
 6126/    510A : D080                   	ADD.l		d0,d0					; shift left 1 bit
 6127/    510C : 6402                   	BCC.s		Ninc1					; branch if bit 32 not set
 6128/    510E :                        
 6129/    510E : B300                   	EOR.b		d1,d0					; do Galois LFSR feedback
 6130/    5110 :                        Ninc1
 6131/    5110 : 51CA FFF8              	DBF		d2,Ninc0				; loop
 6132/    5114 :                        
 6133/    5114 : 2740 05A0              	MOVE.l	d0,PRNlword(a3)			; save back to seed word
 6134/    5118 : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; copy to FAC1 mantissa
 6135/    511C : 377C 8000 0594         	MOVE.w	#$8000,FAC1_e(a3)			; set the exponent and clear the sign
 6136/    5122 : 6000 F7EA              	BRA		LAB_24D5				; normalise FAC1 & return
 6137/    5126 :                        
 6138/    5126 :                        
 6139/    5126 :                        ;************************************************************************************
 6140/    5126 :                        ;
 6141/    5126 :                        ; cordic TAN(x) routine, TAN(x) = SIN(x)/COS(x)
 6142/    5126 :                        ; x = angle in radians
 6143/    5126 :                        
 6144/    5126 :                        LAB_TAN
 6145/    5126 : 6138                   	BSR.s		LAB_SIN				; go do SIN/COS cordic compute
 6146/    5128 : 376B 0594 059C         	MOVE.w	FAC1_e(a3),FAC2_e(a3)		; copy exponent & sign from FAC1 to FAC2
 6147/    512E : 276B 0590 0598         	MOVE.l	FAC1_m(a3),FAC2_m(a3)		; copy FAC1 mantissa to FAC2 mantissa
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 107 - 12/13/2023 15:59:9


 6148/    5134 : 2741 0590              	MOVE.l	d1,FAC1_m(a3)			; get COS(x) mantissa
 6149/    5138 : 1743 0594              	MOVE.b	d3,FAC1_e(a3)			; get COS(x) exponent
 6150/    513C : 6700 E01A              	BEQ		LAB_OFER				; do overflow if COS = 0
 6151/    5140 :                        
 6152/    5140 : 6100 F7CC              	BSR		LAB_24D5				; normalise FAC1
 6153/    5144 : 6000 F97C              	BRA		LAB_DIVIDE				; do FAC2/FAC1 and return, FAC_sc set by SIN
 6154/    5148 :                        								; COS calculation
 6155/    5148 :                        
 6156/    5148 :                        
 6157/    5148 :                        ;************************************************************************************
 6158/    5148 :                        ;
 6159/    5148 :                        ; cordic SIN(x), COS(x) routine
 6160/    5148 :                        ; x = angle in radians
 6161/    5148 :                        
 6162/    5148 :                        LAB_COS
 6163/    5148 : 277C C90F DAA3 0598    	MOVE.l	#$C90FDAA3,FAC2_m(a3)		; pi/2 mantissa (LSB is rounded up so
 6164/    5150 :                        								; COS(PI/2)=0)
 6165/    5150 : 377C 8100 059C         	MOVE.w	#$8100,FAC2_e(a3)			; pi/2 exponent and sign
 6166/    5156 : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; sign = FAC1 sign (b7)
 6167/    515C : 6100 F734              	BSR		LAB_ADD				; add FAC2 to FAC1, adjust for COS(x)
 6168/    5160 :                        
 6169/    5160 :                        
 6170/    5160 :                        ;************************************************************************************
 6171/    5160 :                        ;
 6172/    5160 :                        ; SIN/COS cordic calculator
 6173/    5160 :                        
 6174/    5160 :                        LAB_SIN
 6175/    5160 : 177C 0000 05B4         	MOVE.b	#0,cosout(a3)			; set needed result
 6176/    5166 :                        
 6177/    5166 : 277C A2F9 836F 0598    	MOVE.l	#$A2F9836F,FAC2_m(a3)		; 1/pi mantissa (LSB is rounded up so SIN(PI)=0)
 6178/    516E : 377C 7F00 059C         	MOVE.w	#$7F00,FAC2_e(a3)			; 1/pi exponent & sign
 6179/    5174 : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; sign = FAC1 sign (b7)
 6180/    517A : 6100 F8BA              	BSR		LAB_MULTIPLY			; multiply by 1/pi
 6181/    517E :                        
 6182/    517E : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
 6183/    5182 : 671C                   	BEQ.s		LAB_SCZE				; branch if zero
 6184/    5184 :                        
 6185/    5184 : 41FA 0B36              	LEA		TAB_SNCO(pc),a0			; get pointer to constants table
 6186/    5188 : 2C2B 0590              	MOVE.l	FAC1_m(a3),d6			; get FAC1 mantissa
 6187/    518C : 5300                   	SUBQ.b	#1,d0					; 2 radians in 360 degrees so /2
 6188/    518E : 6710                   	BEQ.s		LAB_SCZE				; branch if zero
 6189/    5190 :                        
 6190/    5190 : 903C 0080              	SUB.b		#$80,d0				; normalise exponent
 6191/    5194 : 6B18                   	BMI.s		LAB_SCL0				; branch if < 1
 6192/    5196 :                        
 6193/    5196 :                        								; X is > 1
 6194/    5196 : B03C 0020              	CMP.b		#$20,d0				; is it >= 2^32
 6195/    519A : 6404                   	BCC.s		LAB_SCZE				; may as well do zero
 6196/    519C :                        
 6197/    519C : E1AE                   	LSL.l		d0,d6					; shift out integer part bits
 6198/    519E : 6618                   	BNE.s		LAB_CORD				; if fraction go test quadrant and adjust
 6199/    51A0 :                        
 6200/    51A0 :                        								; else no fraction so do zero
 6201/    51A0 :                        LAB_SCZE
 6202/    51A0 : 7481                   	MOVEQ		#$81-$100,d2			; set exponent for 1.0
 6203/    51A2 : 7600                   	MOVEQ		#0,d3					; set exponent for 0.0
 6204/    51A4 : 203C 8000 0000         	MOVE.l	#$80000000,d0			; mantissa for 1.0
 6205/    51AA : 2203                   	MOVE.l	d3,d1					; mantissa for 0.0
 6206/    51AC : 6062                   	BRA.s		outloop				; go output it
 6207/    51AE :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 108 - 12/13/2023 15:59:9


 6208/    51AE :                        								; x is < 1
 6209/    51AE :                        LAB_SCL0
 6210/    51AE : 4400                   	NEG.b		d0					; make +ve
 6211/    51B0 : B03C 001E              	CMP.b		#$1E,d0				; is it <= 2^-30
 6212/    51B4 : 64EA                   	BCC.s		LAB_SCZE				; may as well do zero
 6213/    51B6 :                        
 6214/    51B6 : E0AE                   	LSR.l		d0,d6					; shift out <= 2^-32 bits
 6215/    51B8 :                        
 6216/    51B8 :                        ; cordic calculator, argument in d6
 6217/    51B8 :                        ; table pointer in a0, returns in d0-d3
 6218/    51B8 :                        
 6219/    51B8 :                        LAB_CORD
 6220/    51B8 : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; copy as sign compare for TAN
 6221/    51BE : DC86                   	ADD.l		d6,d6					; shift 0.5 bit into carry
 6222/    51C0 : 6406                   	BCC.s		LAB_LTPF				; branch if less than 0.5
 6223/    51C2 :                        
 6224/    51C2 : 0A2B 00FF 0595         	EORI.b	#$FF,FAC1_s(a3)			; toggle result sign
 6225/    51C8 :                        LAB_LTPF
 6226/    51C8 : DC86                   	ADD.l		d6,d6					; shift 0.25 bit into carry
 6227/    51CA : 640C                   	BCC.s		LAB_LTPT				; branch if less than 0.25
 6228/    51CC :                        
 6229/    51CC : 0A2B 00FF 05B4         	EORI.b	#$FF,cosout(a3)			; toggle needed result
 6230/    51D2 : 0A2B 00FF 059E         	EORI.b	#$FF,FAC_sc(a3)			; toggle sign compare for TAN
 6231/    51D8 :                        
 6232/    51D8 :                        LAB_LTPT
 6233/    51D8 : E48E                   	LSR.l		#2,d6					; shift the bits back (clear integer bits)
 6234/    51DA : 67C4                   	BEQ.s		LAB_SCZE				; no fraction so go do zero
 6235/    51DC :                        
 6236/    51DC :                        								; set start values
 6237/    51DC : 7A01                   	MOVEQ		#1,d5					; set bit count
 6238/    51DE : 2028 FFFC              	MOVE.l	-4(a0),d0				; get multiply constant (1st itteration d0)
 6239/    51E2 : 2200                   	MOVE.l	d0,d1					; 1st itteration d1
 6240/    51E4 : 9C98                   	SUB.l		(a0)+,d6				; 1st always +ve so do 1st step
 6241/    51E6 : 6008                   	BRA.s		mainloop				; jump into routine
 6242/    51E8 :                        
 6243/    51E8 :                        subloop
 6244/    51E8 : 9C98                   	SUB.l		(a0)+,d6				; z = z - arctan(i)/2pi
 6245/    51EA : 9083                   	SUB.l		d3,d0					; x = x - y1
 6246/    51EC : D282                   	ADD.l		d2,d1					; y = y + x1
 6247/    51EE : 6012                   	BRA.s		nexta					; back to main loop
 6248/    51F0 :                        
 6249/    51F0 :                        mainloop
 6250/    51F0 : 2400                   	MOVE.l	d0,d2					; x1 = x
 6251/    51F2 : EAA2                   	ASR.l		d5,d2					; / (2 ^ i)
 6252/    51F4 : 2601                   	MOVE.l	d1,d3					; y1 = y
 6253/    51F6 : EAA3                   	ASR.l		d5,d3					; / (2 ^ i)
 6254/    51F8 : 4A86                   	TST.l		d6					; test sign (is 2^0 bit)
 6255/    51FA : 6AEC                   	BPL.s		subloop				; go do subtract if > 1
 6256/    51FC :                        
 6257/    51FC : DC98                   	ADD.l		(a0)+,d6				; z = z + arctan(i)/2pi
 6258/    51FE : D083                   	ADD.l		d3,d0					; x = x + y1
 6259/    5200 : 9282                   	SUB.l		d2,d1					; y = y + x1
 6260/    5202 :                        nexta
 6261/    5202 : 5285                   	ADDQ.l	#1,d5					; i = i + 1
 6262/    5204 : BABC 0000 001E         	CMP.l		#$1E,d5				; check end condition
 6263/    520A : 66E4                   	BNE.s		mainloop				; loop if not all done
 6264/    520C :                        
 6265/    520C :                        								; now untangle output value
 6266/    520C : 7481                   	MOVEQ		#$81-$100,d2			; set exponent for 0 to .99 rec.
 6267/    520E : 2602                   	MOVE.l	d2,d3					; copy it for cos output
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 109 - 12/13/2023 15:59:9


 6268/    5210 :                        outloop
 6269/    5210 : 4A2B 05B4              	TST.b		cosout(a3)				; did we want cos output?
 6270/    5214 : 6B04                   	BMI.s		subexit				; if so skip
 6271/    5216 :                        
 6272/    5216 : C141                   	EXG		d0,d1					; swap SIN and COS mantissas
 6273/    5218 : C543                   	EXG		d2,d3					; swap SIN and COS exponents
 6274/    521A :                        subexit
 6275/    521A : 2740 0590              	MOVE.l	d0,FAC1_m(a3)			; set result mantissa
 6276/    521E : 1742 0594              	MOVE.b	d2,FAC1_e(a3)			; set result exponent
 6277/    5222 : 6000 F6EA              	BRA		LAB_24D5				; normalise FAC1 & return
 6278/    5226 :                        
 6279/    5226 :                        
 6280/    5226 :                        
 6281/    5226 :                        ;************************************************************************************
 6282/    5226 :                        ;
 6283/    5226 :                        ; perform ATN()
 6284/    5226 :                        
 6285/    5226 :                        LAB_ATN
 6286/    5226 : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
 6287/    522A : 6700 00AC              	BEQ		RTS_021				; ATN(0) = 0 so skip calculation
 6288/    522E :                        
 6289/    522E : 177C 0000 05B4         	MOVE.b	#0,cosout(a3)			; set result needed
 6290/    5234 : B03C 0081              	CMP.b		#$81,d0				; compare exponent with 1
 6291/    5238 : 6528                   	BCS.s		LAB_ATLE				; branch if n<1
 6292/    523A :                        
 6293/    523A : 6608                   	BNE.s		LAB_ATGO				; branch if n>1
 6294/    523C :                        
 6295/    523C : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get mantissa
 6296/    5240 : D080                   	ADD.l		d0,d0					; shift left
 6297/    5242 : 671E                   	BEQ.s		LAB_ATLE				; branch if n=1
 6298/    5244 :                        
 6299/    5244 :                        LAB_ATGO
 6300/    5244 : 277C 8000 0000 0598    	MOVE.l	#$80000000,FAC2_m(a3)		; set mantissa for 1
 6301/    524C : 377C 8100 059C         	MOVE.w	#$8100,FAC2_e(a3)			; set exponent for 1
 6302/    5252 : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; sign compare = sign
 6303/    5258 : 6100 F868              	BSR		LAB_DIVIDE				; do 1/n
 6304/    525C : 177C 00FF 05B4         	MOVE.b	#$FF,cosout(a3)			; set inverse result needed
 6305/    5262 :                        LAB_ATLE
 6306/    5262 : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; get FAC1 mantissa
 6307/    5266 : 123C 0082              	MOVE.b		#$82,d1				; set to correct exponent
 6308/    526A : 922B 0594              	SUB.b		FAC1_e(a3),d1			; subtract FAC1 exponent (always <= 1)
 6309/    526E : E2A8                   	LSR.l		d1,d0					; shift in two integer part bits
 6310/    5270 : 41FA 0ACA              	LEA		TAB_ATNC(pc),a0			; get pointer to arctan table
 6311/    5274 : 7C00                   	MOVEQ		#0,d6					; Z = 0
 6312/    5276 : 223C 4000 0000         	MOVE.l	#1<<30,d1				; y = 1
 6313/    527C : 7A1D                   	MOVEQ		#29,d5				; loop 30 times
 6314/    527E : 7801                   	MOVEQ		#1,d4					; shift counter
 6315/    5280 : 6006                   	BRA.s		LAB_ATCD				; enter loop
 6316/    5282 :                        
 6317/    5282 :                        LAB_ATNP
 6318/    5282 : E8A2                   	ASR.l		d4,d2					; x1 / 2^i
 6319/    5284 : D282                   	ADD.l		d2,d1					; y = y + x1
 6320/    5286 : DC90                   	ADD.l		(a0),d6				; z = z + atn(i)
 6321/    5288 :                        LAB_ATCD
 6322/    5288 : 2400                   	MOVE.l	d0,d2					; x1 = x
 6323/    528A : 2601                   	MOVE.l	d1,d3					; y1 = y
 6324/    528C : E8A3                   	ASR.l		d4,d3					; y1 / 2^i
 6325/    528E :                        LAB_CATN
 6326/    528E : 9083                   	SUB.l		d3,d0					; x = x - y1
 6327/    5290 : 6AF0                   	BPL.s		LAB_ATNP				; branch if x >= 0
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 110 - 12/13/2023 15:59:9


 6328/    5292 :                        
 6329/    5292 : 2002                   	MOVE.l	d2,d0					; else get x back
 6330/    5294 : 5848                   	ADDQ.w	#4,a0					; increment pointer
 6331/    5296 : 5284                   	ADDQ.l	#1,d4					; increment i
 6332/    5298 : E283                   	ASR.l		#1,d3					; y1 / 2^i
 6333/    529A : 51CD FFF2              	DBF		d5,LAB_CATN				; decrement and loop if not done
 6334/    529E :                        
 6335/    529E : 177C 0082 0594         	MOVE.b	#$82,FAC1_e(a3)			; set new exponent
 6336/    52A4 : 2746 0590              	MOVE.l	d6,FAC1_m(a3)			; save mantissa
 6337/    52A8 : 6100 F664              	BSR		LAB_24D5				; normalise FAC1
 6338/    52AC :                        
 6339/    52AC : 4A2B 05B4              	TST.b		cosout(a3)				; was it > 1 ?
 6340/    52B0 : 6A26                   	BPL.s		RTS_021				; branch if not
 6341/    52B2 :                        
 6342/    52B2 : 1E2B 0595              	MOVE.b	FAC1_s(a3),d7			; get sign
 6343/    52B6 : 177C 0000 0595         	MOVE.b	#0,FAC1_s(a3)			; clear sign
 6344/    52BC : 277C C90F DAA2 0598    	MOVE.l	#$C90FDAA2,FAC2_m(a3)		; set -(pi/2)
 6345/    52C4 : 377C 8180 059C         	MOVE.w	#$8180,FAC2_e(a3)			; set exponent and sign
 6346/    52CA : 177C 00FF 059E         	MOVE.b	#$FF,FAC_sc(a3)			; set sign compare
 6347/    52D0 : 6100 F5C0              	BSR		LAB_ADD				; perform addition, FAC2 to FAC1
 6348/    52D4 : 1747 0595              	MOVE.b	d7,FAC1_s(a3)			; restore sign
 6349/    52D8 :                        RTS_021
 6350/    52D8 : 4E75                   	RTS
 6351/    52DA :                        
 6352/    52DA :                        
 6353/    52DA :                        ;************************************************************************************
 6354/    52DA :                        ;
 6355/    52DA :                        ; perform BITSET
 6356/    52DA :                        
 6357/    52DA :                        LAB_BITSET
 6358/    52DA : 6100 F496              	BSR		LAB_GADB				; get two parameters for POKE or WAIT
 6359/    52DE :                        								; first parameter in a0, second in d0
 6360/    52DE : B03C 0008              	CMP.b		#$08,d0				; only 0 to 7 are allowed
 6361/    52E2 : 6400 DE78              	BCC		LAB_FCER				; branch if > 7
 6362/    52E6 :                        
 6363/    52E6 : 01D0                   	BSET		d0,(a0)				; set bit
 6364/    52E8 : 4E75                   	RTS
 6365/    52EA :                        
 6366/    52EA :                        
 6367/    52EA :                        ;************************************************************************************
 6368/    52EA :                        ;
 6369/    52EA :                        ; perform BITCLR
 6370/    52EA :                        
 6371/    52EA :                        LAB_BITCLR
 6372/    52EA : 6100 F486              	BSR		LAB_GADB				; get two parameters for POKE or WAIT
 6373/    52EE :                        								; first parameter in a0, second in d0
 6374/    52EE : B03C 0008              	CMP.b		#$08,d0				; only 0 to 7 are allowed
 6375/    52F2 : 6400 DE68              	BCC		LAB_FCER				; branch if > 7
 6376/    52F6 :                        
 6377/    52F6 : 0190                   	BCLR		d0,(a0)				; clear bit
 6378/    52F8 : 4E75                   	RTS
 6379/    52FA :                        
 6380/    52FA :                        
 6381/    52FA :                        ;************************************************************************************
 6382/    52FA :                        ;
 6383/    52FA :                        ; perform BITTST()
 6384/    52FA :                        
 6385/    52FA :                        LAB_BTST
 6386/    52FA : 101D                   	MOVE.b	(a5)+,d0				; increment BASIC pointer
 6387/    52FC : 6100 F474              	BSR		LAB_GADB				; get two parameters for POKE or WAIT
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 111 - 12/13/2023 15:59:9


 6388/    5300 :                        								; first parameter in a0, second in d0
 6389/    5300 : B03C 0008              	CMP.b		#$08,d0				; only 0 to 7 are allowed
 6390/    5304 : 6400 DE56              	BCC		LAB_FCER				; branch if > 7
 6391/    5308 :                        
 6392/    5308 : 2200                   	MOVE.l	d0,d1					; copy bit # to test
 6393/    530A : 6100 EAA4              	BSR		LAB_GBYT				; get next BASIC byte
 6394/    530E : B03C 0029              	CMP.b		#')',d0				; is next character ")"
 6395/    5312 : 6600 DE54              	BNE		LAB_SNER				; if not ")" go do syntax error, then warm start
 6396/    5316 :                        
 6397/    5316 : 6100 EA96              	BSR		LAB_IGBY				; update execute pointer (to character past ")")
 6398/    531A : 7000                   	MOVEQ		#0,d0					; set the result as zero
 6399/    531C : 0310                   	BTST		d1,(a0)				; test bit
 6400/    531E : 6700 F904              	BEQ		LAB_27DB				; branch if zero (already correct)
 6401/    5322 :                        
 6402/    5322 : 70FF                   	MOVEQ		#-1,d0				; set for -1 result
 6403/    5324 : 6000 F8FE              	BRA		LAB_27DB				; go do SGN tail
 6404/    5328 :                        
 6405/    5328 :                        
 6406/    5328 :                        ;************************************************************************************
 6407/    5328 :                        ;
 6408/    5328 :                        ; perform USING$()
 6409/    5328 :                        
 6410/    5328 : =$0                    fsd		EQU	 0						;   (sp) format string descriptor pointer
 6411/    5328 : =$4                    fsti	EQU	 4						;  4(sp) format string this index
 6412/    5328 : =$6                    fsli	EQU	 6						;  6(sp) format string last index
 6413/    5328 : =$8                    fsdpi	EQU	 8						;  8(sp) format string decimal point index
 6414/    5328 : =$A                    fsdc	EQU	10						; 10(sp) format string decimal characters
 6415/    5328 : =$8                    fend	EQU	12-4						;  x(sp) end-4, fsd is popped by itself
 6416/    5328 :                        
 6417/    5328 : ='#'                   ofchr	EQU	'#'						; the overflow character
 6418/    5328 :                        
 6419/    5328 :                        LAB_USINGS
 6420/    5328 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type, $80=string
 6421/    532C : 6A00 DDE6              	BPL		LAB_FOER				; if not string type go do format error
 6422/    5330 :                        
 6423/    5330 : 246B 0590              	MOVEA.l	FAC1_m(a3),a2			; get the format string descriptor pointer
 6424/    5334 : 3E2A 0004              	MOVE.w	4(a2),d7				; get the format string length
 6425/    5338 : 6700 DDDA              	BEQ		LAB_FOER				; if null string go do format error
 6426/    533C :                        
 6427/    533C :                        ; clear the format string values
 6428/    533C :                        
 6429/    533C : 7000                   	MOVEQ		#0,d0					; clear d0
 6430/    533E : 3F00                   	MOVE.w	d0,-(sp)				; clear the format string decimal characters
 6431/    5340 : 3F00                   	MOVE.w	d0,-(sp)				; clear the format string decimal point index
 6432/    5342 : 3F00                   	MOVE.w	d0,-(sp)				; clear the format string last index
 6433/    5344 : 3F00                   	MOVE.w	d0,-(sp)				; clear the format string this index
 6434/    5346 : 2F0A                   	MOVE.l	a2,-(sp)				; save the format string descriptor pointer
 6435/    5348 :                        
 6436/    5348 :                        ; make a null return string for the first string add
 6437/    5348 :                        
 6438/    5348 : 7200                   	MOVEQ		#0,d1					; make a null string
 6439/    534A : 2041                   	MOVEA.l	d1,a0					; with a null pointer
 6440/    534C : 6100 F0BE              	BSR		LAB_RTST				; push a string on the descriptor stack
 6441/    5350 :                        								; a0 = pointer, d1 = length
 6442/    5350 :                        
 6443/    5350 :                        ; do the USING$() function next value
 6444/    5350 :                        
 6445/    5350 : 101D                   	MOVE.b	(a5)+,d0				; get the next BASIC byte
 6446/    5352 :                        LAB_U002
 6447/    5352 : B03C 002C              	CMP.b		#',',d0				; compare with comma
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 112 - 12/13/2023 15:59:9


 6448/    5356 : 6600 DE10              	BNE		LAB_SNER				; if not "," go do syntax error
 6449/    535A :                        
 6450/    535A : 6100 028E              	BSR		LAB_ProcFo				; process the format string
 6451/    535E : 4A02                   	TST.b		d2					; test the special characters flag
 6452/    5360 : 6700 DDB2              	BEQ		LAB_FOER				; if no special characters go do format error
 6453/    5364 :                        
 6454/    5364 : 6100 E8E8              	BSR		LAB_EVEX				; evaluate the expression
 6455/    5368 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test the data type
 6456/    536C : 6B00 DDCE              	BMI		LAB_TMER				; if string type go do type missmatch error
 6457/    5370 :                        
 6458/    5370 : 4A2B 0594              	TST.b		FAC1_e(a3)				; test FAC1 exponent
 6459/    5374 : 6732                   	BEQ.s		LAB_U004				; if FAC1 = 0 skip the rounding
 6460/    5376 :                        
 6461/    5376 : 322F 000A              	MOVE.w	fsdc(sp),d1				; get the format string decimal character count
 6462/    537A : B27C 0008              	CMP.w		#8,d1					; compare the fraction digit count with 8
 6463/    537E : 6428                   	BCC.s		LAB_U004				; if >= 8 skip the rounding
 6464/    5380 :                        
 6465/    5380 : 3001                   	MOVE.w	d1,d0					; else copy the fraction digit count
 6466/    5382 : D241                   	ADD.w		d1,d1					;	; 2
 6467/    5384 : D240                   	ADD.w		d0,d1					;	; 3
 6468/    5386 : D241                   	ADD.w		d1,d1					;	; 6
 6469/    5388 : 41FA 0844              	LEA		LAB_P_10(pc),a0			; get the rounding table base
 6470/    538C : 2770 1002 0598         	MOVE.l	2(a0,d1.w),FAC2_m(a3)		; get the rounding mantissa
 6471/    5392 : 3030 1000              	MOVE.w	(a0,d1.w),d0			; get the rounding exponent
 6472/    5396 : 907C 0100              	SUB.w		#$100,d0				; effectively divide the mantissa by 2
 6473/    539A : 3740 059C              	MOVE.w	d0,FAC2_e(a3)			; save the rounding exponent
 6474/    539E : 177C 0000 059E         	MOVE.b	#$00,FAC_sc(a3)			; clear the sign compare
 6475/    53A4 : 6100 F4EC              	BSR		LAB_ADD				; round the value to n places
 6476/    53A8 :                        LAB_U004
 6477/    53A8 : 6100 F96A              	BSR		LAB_2970				; convert FAC1 to string - not on stack
 6478/    53AC :                        
 6479/    53AC : 6100 01FE              	BSR		LAB_DupFmt				; duplicate the processed format string section
 6480/    53B0 :                        								; returns length in d1, pointer in a0
 6481/    53B0 :                        
 6482/    53B0 :                        ; process the number string, length in d6, decimal point index in d2
 6483/    53B0 :                        
 6484/    53B0 : 45EB 05C6              	LEA		Decss(a3),a2			; set the number string start
 6485/    53B4 : 7C00                   	MOVEQ		#0,d6					; clear the number string index
 6486/    53B6 : 782E                   	MOVEQ		#'.',d4				; set the decimal point character
 6487/    53B8 :                        LAB_U005
 6488/    53B8 : 3406                   	MOVE.w	d6,d2					; save the index to flag the decimal point
 6489/    53BA :                        LAB_U006
 6490/    53BA : 5246                   	ADDQ.w	#1,d6					; increment the number string index
 6491/    53BC : 1032 6000              	MOVE.b	(a2,d6.w),d0			; get a number string character
 6492/    53C0 : 677A                   	BEQ.s		LAB_U010				; if null then number complete
 6493/    53C2 :                        
 6494/    53C2 : B03C 0045              	CMP.b		#'E',d0				; compare the character with an "E"
 6495/    53C6 : 6706                   	BEQ.s		LAB_U008				; was sx[.x]Esxx so go handle sci notation
 6496/    53C8 :                        
 6497/    53C8 : B004                   	CMP.b		d4,d0					; compare the character with "."
 6498/    53CA : 66EE                   	BNE.s		LAB_U006				; if not decimal point go get the next digit
 6499/    53CC :                        
 6500/    53CC : 60EA                   	BRA.s		LAB_U005				; go save the index and get the next digit
 6501/    53CE :                        
 6502/    53CE :                        ; have found an sx[.x]Esxx number, the [.x] will not be present for a single digit
 6503/    53CE :                        
 6504/    53CE :                        LAB_U008
 6505/    53CE : 3606                   	MOVE.w	d6,d3					; copy the index to the "E"
 6506/    53D0 : 5343                   	SUBQ.w	#1,d3					; -1 gives the last digit index
 6507/    53D2 :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 113 - 12/13/2023 15:59:9


 6508/    53D2 : 5246                   	ADDQ.w	#1,d6					; increment the index to the exponent sign
 6509/    53D4 : 1032 6000              	MOVE.b	(a2,d6.w),d0			; get the exponent sign character
 6510/    53D8 : B03C 002D              	CMP.b		#'-',d0				; compare the exponent sign with "-"
 6511/    53DC : 6600 DD7E              	BNE		LAB_FCER				; if it wasn't sx[.x]E-xx go do function
 6512/    53E0 :                        								; call error
 6513/    53E0 :                        
 6514/    53E0 :                        ; found an sx[.x]E-xx number so check the exponent magnitude
 6515/    53E0 :                        
 6516/    53E0 : 5246                   	ADDQ.w	#1,d6					; increment the index to the exponent 10s
 6517/    53E2 : 1032 6000              	MOVE.b	(a2,d6.w),d0			; get the exponent 10s character
 6518/    53E6 : B03C 0030              	CMP.b		#'0',d0				; compare the exponent 10s with "0"
 6519/    53EA : 6704                   	BEQ.s		LAB_U009				; if it was sx[.x]E-0x go get the exponent
 6520/    53EC :                        								; 1s character
 6521/    53EC :                        
 6522/    53EC : 700A                   	MOVEQ		#10,d0				; else start writing at index 10
 6523/    53EE : 6008                   	BRA.s		LAB_U00A				; go copy the digits
 6524/    53F0 :                        
 6525/    53F0 :                        ; found an sx[.x]E-0x number so get the exponent magnitude
 6526/    53F0 :                        
 6527/    53F0 :                        LAB_U009
 6528/    53F0 : 5246                   	ADDQ.w	#1,d6					; increment the index to the exponent 1s
 6529/    53F2 : 700F                   	MOVEQ		#$0F,d0				; set the mask for the exponent 1s digit
 6530/    53F4 : C032 6000              	AND.b		(a2,d6.w),d0			; get and convert the exponent 1s digit
 6531/    53F8 :                        LAB_U00A
 6532/    53F8 : 3403                   	MOVE.w	d3,d2					; copy the number last digit index
 6533/    53FA : 0C42 0001              	CMPI.w	#1,d2					; is the number of the form sxE-0x
 6534/    53FE : 6602                   	BNE.s		LAB_U00B				; if it is sx.xE-0x skip the increment
 6535/    5400 :                        
 6536/    5400 :                        								; else make room for the decimal point
 6537/    5400 : 5242                   	ADDQ.w	#1,d2					; add 1 to the write index
 6538/    5402 :                        LAB_U00B
 6539/    5402 : D440                   	ADD.w		d0,d2					; add the exponent 1s to the write index
 6540/    5404 : 700A                   	MOVEQ		#10,d0				; set the maximum write index
 6541/    5406 : 9042                   	SUB.w		d2,d0					; compare the index with the maximum
 6542/    5408 : 6E0C                   	BGT.s		LAB_U00C				; if the index < the maximum continue
 6543/    540A :                        
 6544/    540A : D440                   	ADD.w		d0,d2					; else set the index to the maximum
 6545/    540C : D640                   	ADD.w		d0,d3					; adjust the read index
 6546/    540E : 0C43 0001              	CMPI.w	#1,d3					; compare the adjusted index with 1
 6547/    5412 : 6E02                   	BGT.s		LAB_U00C				; if > 1 continue
 6548/    5414 :                        
 6549/    5414 : 7600                   	MOVEQ		#0,d3					; else allow for the decimal point
 6550/    5416 :                        LAB_U00C
 6551/    5416 : 3C02                   	MOVE.w		d2,d6					; copy the write index as the number
 6552/    5418 :                        								; string length
 6553/    5418 : 7000                   	MOVEQ		#0,d0					; clear d0 to null terminate the number
 6554/    541A :                        								; string
 6555/    541A :                        LAB_U00D
 6556/    541A : 1580 2000              	MOVE.b	d0,(a2,d2.w)			; save the character to the number string
 6557/    541E : 5342                   	SUBQ.w	#1,d2					; decrement the number write index
 6558/    5420 : 0C42 0001              	CMPI.w	#1,d2					; compare the number write index with 1
 6559/    5424 : 6712                   	BEQ.s		LAB_U00F				; if at the decimal point go save it
 6560/    5426 :                        
 6561/    5426 :                        								; else write a digit to the number string
 6562/    5426 : 7030                   	MOVEQ		#'0',d0				; default to "0"
 6563/    5428 : 4A43                   	TST.w		d3					; test the number read index
 6564/    542A : 67EE                   	BEQ.s		LAB_U00D				; if zero just go save the "0"
 6565/    542C :                        
 6566/    542C :                        LAB_U00E
 6567/    542C : 1032 3000              	MOVE.b	(a2,d3.w),d0			; read the next number digit
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 114 - 12/13/2023 15:59:9


 6568/    5430 : 5343                   	SUBQ.w	#1,d3					; decrement the read index
 6569/    5432 : B004                   	CMP.b		d4,d0					; compare the digit with "."
 6570/    5434 : 66E4                   	BNE.s		LAB_U00D				; if not "." go save the digit
 6571/    5436 :                        
 6572/    5436 : 60F4                   	BRA.s		LAB_U00E				; else go get the next digit
 6573/    5438 :                        
 6574/    5438 :                        LAB_U00F
 6575/    5438 : 1584 2000              	MOVE.b	d4,(a2,d2.w)			; save the decimal point
 6576/    543C :                        LAB_U010
 6577/    543C : 4A42                   	TST.w		d2					; test the number string decimal point index
 6578/    543E : 6602                   	BNE.s		LAB_U014				; if dp present skip the reset
 6579/    5440 :                        
 6580/    5440 : 3406                   	MOVE.w	d6,d2					; make the decimal point index = the length
 6581/    5442 :                        
 6582/    5442 :                        ; copy the fractional digit characters from the number string
 6583/    5442 :                        
 6584/    5442 :                        LAB_U014
 6585/    5442 : 3602                   	MOVE.w	d2,d3					; copy the number string decimal point index
 6586/    5444 : 5243                   	ADDQ.w	#1,d3					; increment the number string index
 6587/    5446 : 382F 0008              	MOVE.w	fsdpi(sp),d4			; get the new format string decimal point index
 6588/    544A :                        LAB_U018
 6589/    544A : 5244                   	ADDQ.w	#1,d4					; increment the new format string index
 6590/    544C : B244                   	CMP.w		d4,d1					; compare it with the new format string length
 6591/    544E : 6322                   	BLS.s		LAB_U022				; if done the fraction digits go do integer
 6592/    5450 :                        
 6593/    5450 : 1030 4000              	MOVE.b	(a0,d4.w),d0			; get a new format string character
 6594/    5454 : B03C 0025              	CMP.b		#'%',d0				; compare it with "%"
 6595/    5458 : 6706                   	BEQ.s		LAB_U01C				; if "%" go copy a number character
 6596/    545A :                        
 6597/    545A : B03C 0023              	CMP.b		#'#',d0				; compare it with "#"
 6598/    545E : 66EA                   	BNE.s		LAB_U018				; if not "#" go do the next new format character
 6599/    5460 :                        
 6600/    5460 :                        LAB_U01C
 6601/    5460 : 7030                   	MOVEQ		#'0',d0				; default to "0" character
 6602/    5462 : BC43                   	CMP.w		d3,d6					; compare the number string index with length
 6603/    5464 : 6306                   	BLS.s		LAB_U020				; if there skip the character get
 6604/    5466 :                        
 6605/    5466 : 1032 3000              	MOVE.b	(a2,d3.w),d0			; get a character from the number string
 6606/    546A : 5243                   	ADDQ.w	#1,d3					; increment the number string index
 6607/    546C :                        LAB_U020
 6608/    546C : 1180 4000              	MOVE.b	d0,(a0,d4.w)			; save the number character to the new format
 6609/    5470 :                        								; string
 6610/    5470 : 60D8                   	BRA.s		LAB_U018				; go do the next new format character
 6611/    5472 :                        
 6612/    5472 :                        ; now copy the integer digit characters from the number string
 6613/    5472 :                        
 6614/    5472 :                        LAB_U022
 6615/    5472 : 7C00                   	MOVEQ		#0,d6					; clear the sign done flag
 6616/    5474 : 7A00                   	MOVEQ		#0,d5					; clear the sign present flag
 6617/    5476 : 5342                   	SUBQ.w	#1,d2					; decrement the number string index
 6618/    5478 : 6608                   	BNE.s		LAB_U026				; if not now at sign continue
 6619/    547A :                        
 6620/    547A : 7401                   	MOVEQ		#1,d2					; increment the number string index
 6621/    547C : 15BC 0030 2000         	MOVE.b	#'0',(a2,d2.w)			; replace the point with a zero
 6622/    5482 :                        LAB_U026
 6623/    5482 : 382F 0008              	MOVE.w	fsdpi(sp),d4			; get the new format string decimal point index
 6624/    5486 : B244                   	CMP.w		d4,d1					; compare it with the new format string length
 6625/    5488 : 6402                   	BCC.s		LAB_U02A				; if within the string go use the index
 6626/    548A :                        
 6627/    548A : 3801                   	MOVE.w	d1,d4					; else set the index to the end of the string
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 115 - 12/13/2023 15:59:9


 6628/    548C :                        LAB_U02A
 6629/    548C : 5344                   	SUBQ.w	#1,d4					; decrement the new format string index
 6630/    548E : 6B62                   	BMI.s		LAB_U03E				; if all done go test for any overflow
 6631/    5490 :                        
 6632/    5490 : 1030 4000              	MOVE.b	(a0,d4.w),d0			; else get a new format string character
 6633/    5494 :                        
 6634/    5494 : 7E30                   	MOVEQ		#'0',d7				; default to "0" character
 6635/    5496 : B03C 0025              	CMP.b		#'%',d0				; compare it with "%"
 6636/    549A : 6708                   	BEQ.s		LAB_U02B				; if "%" go copy a number character
 6637/    549C :                        
 6638/    549C : 7E20                   	MOVEQ		#' ',d7				; default to " " character
 6639/    549E : B03C 0023              	CMP.b		#'#',d0				; compare it with "#"
 6640/    54A2 : 6606                   	BNE.s		LAB_U02C				; if not "#" go try ","
 6641/    54A4 :                        
 6642/    54A4 :                        LAB_U02B
 6643/    54A4 : 4A42                   	TST.w		d2					; test the number string index
 6644/    54A6 : 6634                   	BNE.s		LAB_U036				; if not at the sign go get a number character
 6645/    54A8 :                        
 6646/    54A8 : 6042                   	BRA.s		LAB_U03C				; else go save the default character
 6647/    54AA :                        
 6648/    54AA :                        LAB_U02C
 6649/    54AA : B03C 002C              	CMP.b		#',',d0				; compare it with ","
 6650/    54AE : 6610                   	BNE.s		LAB_U030				; if not "," go try the sign characters
 6651/    54B0 :                        
 6652/    54B0 : 4A42                   	TST.w		d2					; test the number string index
 6653/    54B2 : 6608                   	BNE.s		LAB_U02E				; if not at the sign keep the ","
 6654/    54B4 :                        
 6655/    54B4 : 0C30 0025 40FF         	CMP.b		#'%',-1(a0,d4.w)			; else compare the next format string character
 6656/    54BA :                        								; with "%"
 6657/    54BA : 6630                   	BNE.s		LAB_U03C				; if not "%" keep the default character
 6658/    54BC :                        
 6659/    54BC :                        LAB_U02E
 6660/    54BC : 1E00                   	MOVE.b	d0,d7					; else use the "," character
 6661/    54BE : 602C                   	BRA.s		LAB_U03C				; go save the character to the string
 6662/    54C0 :                        
 6663/    54C0 :                        LAB_U030
 6664/    54C0 : B03C 002D              	CMP.b		#'-',d0				; compare it with "-"
 6665/    54C4 : 6710                   	BEQ.s		LAB_U034				; if "-" go do the sign character
 6666/    54C6 :                        
 6667/    54C6 : B03C 002B              	CMP.b		#'+',d0				; compare it with "+"
 6668/    54CA : 66C0                   	BNE.s		LAB_U02A				; if not "+" go do the next new format character
 6669/    54CC :                        
 6670/    54CC : 0C12 002D              	CMP.b		#'-',(a2)				; compare the sign character with "-"
 6671/    54D0 : 6704                   	BEQ.s		LAB_U034				; if "-" don't change the sign character
 6672/    54D2 :                        
 6673/    54D2 : 14BC 002B              	MOVE.b	#'+',(a2)				; else make the sign character "+"
 6674/    54D6 :                        LAB_U034
 6675/    54D6 : 1A00                   	MOVE.b	d0,d5					; set the sign present flag
 6676/    54D8 : 4A42                   	TST.w		d2					; test the number string index
 6677/    54DA : 6708                   	BEQ.s		LAB_U038				; if at the sign keep the default character
 6678/    54DC :                        
 6679/    54DC :                        LAB_U036
 6680/    54DC : 1E32 2000              	MOVE.b	(a2,d2.w),d7			; else get a character from the number string
 6681/    54E0 : 5342                   	SUBQ.w	#1,d2					; decrement the number string index
 6682/    54E2 : 6008                   	BRA.s		LAB_U03C				; go save the character
 6683/    54E4 :                        
 6684/    54E4 :                        LAB_U038
 6685/    54E4 : 4A06                   	TST.b		d6					; test the sign done flag
 6686/    54E6 : 6604                   	BNE.s		LAB_U03C				; if the sign has been done go use the space
 6687/    54E8 :                        								; character
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 116 - 12/13/2023 15:59:9


 6688/    54E8 :                        
 6689/    54E8 : 1E12                   	MOVE.b	(a2),d7				; else get the sign character
 6690/    54EA : 1C07                   	MOVE.b	d7,d6					; flag that the sign has been done
 6691/    54EC :                        LAB_U03C
 6692/    54EC : 1187 4000              	MOVE.b	d7,(a0,d4.w)			; save the number character to the new format
 6693/    54F0 :                        								; string
 6694/    54F0 : 609A                   	BRA.s		LAB_U02A				; go do the next new format character
 6695/    54F2 :                        
 6696/    54F2 :                        ; test for overflow conditions
 6697/    54F2 :                        
 6698/    54F2 :                        LAB_U03E
 6699/    54F2 : 4A42                   	TST.w		d2					; test the number string index
 6700/    54F4 : 6614                   	BNE.s		LAB_U040				; if all the digits aren't done go output
 6701/    54F6 :                        								; an overflow indication
 6702/    54F6 :                        
 6703/    54F6 :                        ; test for sign overflows
 6704/    54F6 :                        
 6705/    54F6 : 4A05                   	TST.b		d5					; test the sign present flag
 6706/    54F8 : 6754                   	BEQ.s		LAB_U04A				; if no sign present go add the string
 6707/    54FA :                        
 6708/    54FA :                        ; there was a sign in the format string
 6709/    54FA :                        
 6710/    54FA : 4A06                   	TST.b		d6					; test the sign done flag
 6711/    54FC : 6650                   	BNE.s		LAB_U04A				; if the sign is done go add the string
 6712/    54FE :                        
 6713/    54FE :                        ; the sign isn't done so see if it was mandatory
 6714/    54FE :                        
 6715/    54FE : 0C05 002B              	CMPI.b	#'+',d5				; compare the sign with "+"
 6716/    5502 : 6706                   	BEQ.s		LAB_U040				; if it was "+" go output an overflow
 6717/    5504 :                        								; indication
 6718/    5504 :                        
 6719/    5504 :                        ; the sign wasn't mandatory but the number may have been negative
 6720/    5504 :                        
 6721/    5504 : 0C12 002D              	CMP.b		#'-',(a2)				; compare the sign character with "-"
 6722/    5508 : 6644                   	BNE.s		LAB_U04A				; if it wasn't "-" go add the string
 6723/    550A :                        
 6724/    550A :                        ; else the sign was "-" and a sign hasn't been output so ..
 6725/    550A :                        
 6726/    550A :                        ; the number overflowed the format string so replace all the special format characters
 6727/    550A :                        ; with the overflow character
 6728/    550A :                        
 6729/    550A :                        LAB_U040
 6730/    550A : 7A23                   	MOVEQ		#ofchr,d5				; set the overflow character
 6731/    550C : 3E01                   	MOVE.w	d1,d7					; copy the new format string length
 6732/    550E : 5347                   	SUBQ.w	#1,d7					; adjust for the loop type
 6733/    5510 : 3C2F 0004              	MOVE.w	fsti(sp),d6				; copy the new format string last index
 6734/    5514 : 5346                   	SUBQ.w	#1,d6					; -1 gives the last character of this string
 6735/    5516 : 6E02                   	BGT.s		LAB_U044				; if not zero continue
 6736/    5518 :                        
 6737/    5518 : 3C07                   	MOVE.w	d7,d6					; else set the format string index to the end
 6738/    551A :                        LAB_U044
 6739/    551A : 1031 6000              	MOVE.b	(a1,d6.w),d0			; get a character from the format string
 6740/    551E : 0C00 0023              	CMPI.b	#'#',d0				; compare it with "#" special format character
 6741/    5522 : 671E                   	BEQ.s		LAB_U046				; if "#" go use the overflow character
 6742/    5524 :                        
 6743/    5524 : 0C00 0025              	CMPI.b	#'%',d0				; compare it with "%" special format character
 6744/    5528 : 6718                   	BEQ.s		LAB_U046				; if "%" go use the overflow character
 6745/    552A :                        
 6746/    552A : 0C00 002C              	CMPI.b	#',',d0				; compare it with "," special format character
 6747/    552E : 6712                   	BEQ.s		LAB_U046				; if "," go use the overflow character
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 117 - 12/13/2023 15:59:9


 6748/    5530 :                        
 6749/    5530 : 0C00 002B              	CMPI.b	#'+',d0				; compare it with "+" special format character
 6750/    5534 : 670C                   	BEQ.s		LAB_U046				; if "+" go use the overflow character
 6751/    5536 :                        
 6752/    5536 : 0C00 002D              	CMPI.b	#'-',d0				; compare it with "-" special format character
 6753/    553A : 6706                   	BEQ.s		LAB_U046				; if "-" go use the overflow character
 6754/    553C :                        
 6755/    553C : 0C00 002E              	CMPI.b	#'.',d0				; compare it with "." special format character
 6756/    5540 : 6602                   	BNE.s		LAB_U048				; if not "." skip the using overflow character
 6757/    5542 :                        
 6758/    5542 :                        LAB_U046
 6759/    5542 : 1005                   	MOVE.b	d5,d0					; use the overflow character
 6760/    5544 :                        LAB_U048
 6761/    5544 : 1180 7000              	MOVE.b	d0,(a0,d7.w)			; save the character to the new format string
 6762/    5548 : 5346                   	SUBQ.w	#1,d6					; decrement the format string index
 6763/    554A : 51CF FFCE              	DBF		d7,LAB_U044				; decrement the count and loop if not all done
 6764/    554E :                        
 6765/    554E :                        ; add the new string to the previous string
 6766/    554E :                        
 6767/    554E :                        LAB_U04A
 6768/    554E : 41EC 0006              	LEA		6(a4),a0				; get the descriptor pointer for string 1
 6769/    5552 : 274C 0590              	MOVE.l	a4,FAC1_m(a3)			; save the descriptor pointer for string 2
 6770/    5556 : 6100 F004              	BSR		LAB_224E				; concatenate the strings
 6771/    555A :                        
 6772/    555A :                        ; now check for any tail on the format string
 6773/    555A :                        
 6774/    555A : 302F 0004              	MOVE.w	fsti(sp),d0				; get this index
 6775/    555E : 6720                   	BEQ.s		LAB_U04C				; if at start of string skip the output
 6776/    5560 :                        
 6777/    5560 : 3F40 0006              	MOVE.w	d0,fsli(sp)				; save this index to the last index
 6778/    5564 : 6100 0084              	BSR		LAB_ProcFo				; now process the format string
 6779/    5568 : 4A02                   	TST.b		d2					; test the special characters flag
 6780/    556A : 6614                   	BNE.s		LAB_U04C				; if special characters present skip the output
 6781/    556C :                        
 6782/    556C :                        ; else output the new string part
 6783/    556C :                        
 6784/    556C : 613E                   	BSR.s		LAB_DupFmt				; duplicate the processed format string section
 6785/    556E : 3F6F 0004 0006         	MOVE.w	fsti(sp),fsli(sp)			; copy this index to the last index
 6786/    5574 :                        
 6787/    5574 :                        ; add the new string to the previous string
 6788/    5574 :                        
 6789/    5574 : 41EC 0006              	LEA		6(a4),a0				; get the descriptor pointer for string 1
 6790/    5578 : 274C 0590              	MOVE.l	a4,FAC1_m(a3)			; save the descriptor pointer for string 2
 6791/    557C : 6100 EFDE              	BSR		LAB_224E				; concatenate the strings
 6792/    5580 :                        
 6793/    5580 :                        ; check for another value or end of function
 6794/    5580 :                        
 6795/    5580 :                        LAB_U04C
 6796/    5580 : 101D                   	MOVE.b	(a5)+,d0				; get the next BASIC byte
 6797/    5582 : B03C 0029              	CMP.b		#')',d0				; compare with close bracket
 6798/    5586 : 6600 FDCA              	BNE		LAB_U002				; if not ")" go do next value
 6799/    558A :                        
 6800/    558A :                        ; pop the result string off the descriptor stack
 6801/    558A :                        
 6802/    558A : 204C                   	MOVEA.l	a4,a0					; copy the result string descriptor pointer
 6803/    558C : 222B 0446              	MOVE.l	Sstorl(a3),d1			; save the bottom of string space
 6804/    5590 : 6100 F02C              	BSR		LAB_22BA				; pop (a0) descriptor, returns with ..
 6805/    5594 :                        								; d0 = length, a0 = pointer
 6806/    5594 : 2741 0446              	MOVE.l	d1,Sstorl(a3)			; restore the bottom of string space
 6807/    5598 : 2248                   	MOVEA.l	a0,a1					; copy the string result pointer
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 118 - 12/13/2023 15:59:9


 6808/    559A : 3200                   	MOVE.w	d0,d1					; copy the string result length
 6809/    559C :                        
 6810/    559C :                        ; pop the format string off the descriptor stack
 6811/    559C :                        
 6812/    559C : 205F                   	MOVEA.l	(sp)+,a0				; pull the format string descriptor pointer
 6813/    559E : 6100 F01E              	BSR		LAB_22BA				; pop (a0) descriptor, returns with ..
 6814/    55A2 :                        								; d0 = length, a0 = pointer
 6815/    55A2 :                        
 6816/    55A2 : 4FEF 0008              	LEA		fend(sp),sp				; dump the saved values
 6817/    55A6 :                        
 6818/    55A6 :                        ; push the result string back on the descriptor stack and return
 6819/    55A6 :                        
 6820/    55A6 : 2049                   	MOVEA.l	a1,a0					; copy the result string pointer back
 6821/    55A8 : 6000 EE62              	BRA		LAB_RTST				; push a string on the descriptor stack and
 6822/    55AC :                        								; return. a0 = pointer, d1 = length
 6823/    55AC :                        
 6824/    55AC :                        
 6825/    55AC :                        ;************************************************************************************
 6826/    55AC :                        ;
 6827/    55AC :                        ; duplicate the processed format string section
 6828/    55AC :                        
 6829/    55AC :                        								; make a string as long as the format string
 6830/    55AC :                        LAB_DupFmt
 6831/    55AC : 226F 0004              	MOVEA.l	4+fsd(sp),a1			; get the format string descriptor pointer
 6832/    55B0 : 3E29 0004              	MOVE.w	4(a1),d7				; get the format string length
 6833/    55B4 : 342F 000A              	MOVE.w	4+fsli(sp),d2			; get the format string last index
 6834/    55B8 : 3C2F 0008              	MOVE.w	4+fsti(sp),d6			; get the format string this index
 6835/    55BC : 3206                   	MOVE.w	d6,d1					; copy the format string this index
 6836/    55BE : 9242                   	SUB.w		d2,d1					; subtract the format string last index
 6837/    55C0 : 6202                   	BHI.s		LAB_D002				; if > 0 skip the correction
 6838/    55C2 :                        
 6839/    55C2 : D247                   	ADD.w		d7,d1					; else add the format string length as the
 6840/    55C4 :                        								; correction
 6841/    55C4 :                        LAB_D002
 6842/    55C4 : 6100 EE60              	BSR		LAB_2115				; make string space d1 bytes long
 6843/    55C8 :                        								; return a0/Sutill = pointer, others unchanged
 6844/    55C8 :                        
 6845/    55C8 :                        ; push the new string on the descriptor stack
 6846/    55C8 :                        
 6847/    55C8 : 6100 EE42              	BSR		LAB_RTST				; push a string on the descriptor stack and
 6848/    55CC :                        								; return. a0 = pointer, d1 = length
 6849/    55CC :                        
 6850/    55CC :                        ; copy the characters from the format string
 6851/    55CC :                        
 6852/    55CC : 226F 0004              	MOVEA.l	4+fsd(sp),a1			; get the format string descriptor pointer
 6853/    55D0 : 2251                   	MOVEA.l	(a1),a1				; get the format string pointer
 6854/    55D2 : 7800                   	MOVEQ		#0,d4					; clear the new string index
 6855/    55D4 :                        LAB_D00A
 6856/    55D4 : 11B1 2000 4000         	MOVE.b	(a1,d2.w),(a0,d4.w)		; get a character from the format string and
 6857/    55DA :                        								; save it to the new string
 6858/    55DA : 5244                   	ADDQ.w	#1,d4					; increment the new string index
 6859/    55DC : 5242                   	ADDQ.w	#1,d2					; increment the format string index
 6860/    55DE : BE42                   	CMP.w		d2,d7					; compare the format index with the length
 6861/    55E0 : 6602                   	BNE.s		LAB_D00E				; if not there skip the reset
 6862/    55E2 :                        
 6863/    55E2 : 7400                   	MOVEQ		#0,d2					; else reset the format string index
 6864/    55E4 :                        LAB_D00E
 6865/    55E4 : BC42                   	CMP.w		d2,d6					; compare the index with this index
 6866/    55E6 : 66EC                   	BNE.s		LAB_D00A				; if not equal go do the next character
 6867/    55E8 :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 119 - 12/13/2023 15:59:9


 6868/    55E8 : 4E75                   	RTS
 6869/    55EA :                        
 6870/    55EA :                        
 6871/    55EA :                        ;************************************************************************************
 6872/    55EA :                        ;
 6873/    55EA :                        ; process the format string
 6874/    55EA :                        
 6875/    55EA :                        LAB_ProcFo
 6876/    55EA : 226F 0004              	MOVEA.l	4+fsd(sp),a1			; get the format string descriptor pointer
 6877/    55EE : 3E29 0004              	MOVE.w	4(a1),d7				; get the format string length
 6878/    55F2 : 2251                   	MOVEA.l	(a1),a1				; get the format string pointer
 6879/    55F4 : 3C2F 000A              	MOVE.w	4+fsli(sp),d6			; get the format string last index
 6880/    55F8 :                        
 6881/    55F8 : 3F47 000C              	MOVE.w	d7,4+fsdpi(sp)			; set the format string decimal point index
 6882/    55FC :                        ;##	MOVE.w	#-1,4+fsdpi(sp)			; set the format string decimal point index
 6883/    55FC : 7A00                   	MOVEQ		#0,d5					; no decimal point
 6884/    55FE : 7600                   	MOVEQ		#0,d3					; no decimal characters
 6885/    5600 : 7400                   	MOVEQ		#0,d2					; no special characters
 6886/    5602 :                        LAB_P004
 6887/    5602 : 1031 6000              	MOVE.b	(a1,d6.w),d0			; get a format string byte
 6888/    5606 :                        
 6889/    5606 : B03C 002C              	CMP.b		#',',d0				; compare it with ","
 6890/    560A : 6742                   	BEQ.s		LAB_P01A				; if "," go do the next format string byte
 6891/    560C :                        
 6892/    560C : B03C 0023              	CMP.b		#'#',d0				; compare it with "#"
 6893/    5610 : 6706                   	BEQ.s		LAB_P008				; if "#" go flag special characters
 6894/    5612 :                        
 6895/    5612 : B03C 0025              	CMP.b		#'%',d0				; compare it with "%"
 6896/    5616 : 6608                   	BNE.s		LAB_P00C				; if not "%" go try "+"
 6897/    5618 :                        
 6898/    5618 :                        LAB_P008
 6899/    5618 : 4A85                   	TST.l		d5					; test the decimal point flag
 6900/    561A : 6A10                   	BPL.s		LAB_P00E				; if no point skip counting decimal characters
 6901/    561C :                        
 6902/    561C : 5243                   	ADDQ.w	#1,d3					; else increment the decimal character count
 6903/    561E : 602E                   	BRA.s		LAB_P01A				; go do the next character
 6904/    5620 :                        
 6905/    5620 :                        LAB_P00C
 6906/    5620 : B03C 002B              	CMP.b		#'+',d0				; compare it with "+"
 6907/    5624 : 6706                   	BEQ.s		LAB_P00E				; if "+" go flag special characters
 6908/    5626 :                        
 6909/    5626 : B03C 002D              	CMP.b		#'-',d0				; compare it with "-"
 6910/    562A : 6604                   	BNE.s		LAB_P010				; if not "-" go check decimal point
 6911/    562C :                        
 6912/    562C :                        LAB_P00E
 6913/    562C : 8400                   	OR.b		d0,d2					; flag special characters
 6914/    562E : 601E                   	BRA.s		LAB_P01A				; go do the next character
 6915/    5630 :                        
 6916/    5630 :                        LAB_P010
 6917/    5630 : B03C 002E              	CMP.b		#'.',d0				; compare it with "."
 6918/    5634 : 6614                   	BNE.s		LAB_P018				; if not "." go check next
 6919/    5636 :                        
 6920/    5636 :                        ; "." a decimal point
 6921/    5636 :                        
 6922/    5636 : 4A85                   	TST.l		d5					; if there is already a decimal point
 6923/    5638 : 6B14                   	BMI.s		LAB_P01A				; go do the next character
 6924/    563A :                        
 6925/    563A : 3006                   	MOVE.w	d6,d0					; copy the decimal point index
 6926/    563C : 906F 000A              	SUB.w		4+fsli(sp),d0			; calculate it from the scan start
 6927/    5640 : 3F40 000C              	MOVE.w	d0,4+fsdpi(sp)			; save the decimal point index
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 120 - 12/13/2023 15:59:9


 6928/    5644 : 7AFF                   	MOVEQ		#-1,d5				; flag decimal point
 6929/    5646 : 8400                   	OR.b		d0,d2					; flag special characters
 6930/    5648 : 6004                   	BRA.s		LAB_P01A				; go do the next character
 6931/    564A :                        
 6932/    564A :                        ; was not a special character
 6933/    564A :                        
 6934/    564A :                        LAB_P018
 6935/    564A : 4A02                   	TST.b		d2					; test if there have been special characters
 6936/    564C : 6608                   	BNE.s		LAB_P01E				; if so exit the format string process
 6937/    564E :                        
 6938/    564E :                        LAB_P01A
 6939/    564E : 5246                   	ADDQ.w	#1,d6					; increment the format string index
 6940/    5650 : BE46                   	CMP.w		d6,d7					; compare it with the format string length
 6941/    5652 : 62AE                   	BHI.s		LAB_P004				; if length > index go get the next character
 6942/    5654 :                        
 6943/    5654 : 7C00                   	MOVEQ		#0,d6					; length = index so reset the format string
 6944/    5656 :                        								; index
 6945/    5656 :                        LAB_P01E
 6946/    5656 : 3F46 0008              	MOVE.w	d6,4+fsti(sp)			; save the format string this index
 6947/    565A : 3F43 000E              	MOVE.w	d3,4+fsdc(sp)			; save the format string decimal characters
 6948/    565E :                        
 6949/    565E : 4E75                   	RTS
 6950/    5660 :                        
 6951/    5660 :                        
 6952/    5660 :                        ;************************************************************************************
 6953/    5660 :                        ;
 6954/    5660 :                        ; perform BIN$()
 6955/    5660 :                        ; # of leading 0s is in d1, the number is in d0
 6956/    5660 :                        
 6957/    5660 :                        LAB_BINS
 6958/    5660 : B23C 0021              	CMP.b		#$21,d1				; max + 1
 6959/    5664 : 6400 DAF6              	BCC		LAB_FCER				; exit if too big ( > or = )
 6960/    5668 :                        
 6961/    5668 : 741F                   	MOVEQ		#$1F,d2				; bit count-1
 6962/    566A : 41EB 05B6              	LEA		Binss(a3),a0			; point to string
 6963/    566E : 7830                   	MOVEQ		#$30,d4				; "0" character for ADDX
 6964/    5670 :                        NextB1
 6965/    5670 : 7600                   	MOVEQ		#0,d3					; clear byte
 6966/    5672 : E288                   	LSR.l		#1,d0					; shift bit into Xb
 6967/    5674 : D704                   	ADDX.b	d4,d3					; add carry and character to zero
 6968/    5676 : 1183 2000              	MOVE.b	d3,(a0,d2.w)			; save character to string
 6969/    567A : 51CA FFF4              	DBF		d2,NextB1				; decrement and loop if not done
 6970/    567E :                        
 6971/    567E :                        ; this is the exit code and is also used by HEX$()
 6972/    567E :                        
 6973/    567E :                        EndBHS
 6974/    567E : 177C 0000 05D6         	MOVE.b	#0,BHsend(a3)			; null terminate the string
 6975/    5684 : 4A01                   	TST.b		d1					; test # of characters
 6976/    5686 : 670E                   	BEQ.s		NextB2				; go truncate string
 6977/    5688 :                        
 6978/    5688 : 4481                   	NEG.l		d1					; make -ve
 6979/    568A : D2BC 0000 05D6         	ADD.l		#BHsend,d1				; effectively (end-length)
 6980/    5690 : 41F3 1000              	LEA		0(a3,d1.w),a0			; effectively add (end-length) to pointer
 6981/    5694 : 600E                   	BRA.s		BinPr					; go print string
 6982/    5696 :                        
 6983/    5696 :                        ; truncate string to remove leading "0"s
 6984/    5696 :                        
 6985/    5696 :                        NextB2
 6986/    5696 : 1010                   	MOVE.b	(a0),d0				; get byte
 6987/    5698 : 670A                   	BEQ.s		BinPr					; if null then end of string so add 1 and go
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 121 - 12/13/2023 15:59:9


 6988/    569A :                        								; print it
 6989/    569A :                        
 6990/    569A : B03C 0030              	CMP.b		#'0',d0				; compare with "0"
 6991/    569E : 660E                   	BNE.s		GoPr					; if not "0" then go print string from here
 6992/    56A0 :                        
 6993/    56A0 : 5248                   	ADDQ.w	#1,a0					; else increment pointer
 6994/    56A2 : 60F2                   	BRA.s		NextB2				; loop always
 6995/    56A4 :                        
 6996/    56A4 :                        ; make fixed length output string - ignore overflows!
 6997/    56A4 :                        
 6998/    56A4 :                        BinPr
 6999/    56A4 : 43EB 05D6              	LEA		BHsend(a3),a1			; get string end
 7000/    56A8 : B1C9                   	CMPA.l	a1,a0					; are we at the string end
 7001/    56AA : 6602                   	BNE.s		GoPr					; branch if not
 7002/    56AC :                        
 7003/    56AC : 5348                   	SUBQ.w	#1,a0					; else need at least one zero
 7004/    56AE :                        GoPr
 7005/    56AE : 6000 ED16              	BRA		LAB_20AE				; print " terminated string to FAC1, stack & RET
 7006/    56B2 :                        
 7007/    56B2 :                        
 7008/    56B2 :                        ;************************************************************************************
 7009/    56B2 :                        ;
 7010/    56B2 :                        ; perform HEX$()
 7011/    56B2 :                        ; # of leading 0s is in d1, the number is in d0
 7012/    56B2 :                        
 7013/    56B2 :                        LAB_HEXS
 7014/    56B2 : B23C 0009              	CMP.b		#$09,d1				; max + 1
 7015/    56B6 : 6400 DAA4              	BCC		LAB_FCER				; exit if too big ( > or = )
 7016/    56BA :                        
 7017/    56BA : 7407                   	MOVEQ		#$07,d2				; nibble count-1
 7018/    56BC : 41EB 05CE              	LEA		Hexss(a3),a0			; point to string
 7019/    56C0 : 7830                   	MOVEQ		#$30,d4				; "0" character for ABCD
 7020/    56C2 :                        NextH1
 7021/    56C2 : 1600                   	MOVE.b	d0,d3					; copy lowest byte
 7022/    56C4 : E898                   	ROR.l		#4,d0					; shift nibble into 0-3
 7023/    56C6 : C63C 000F              	AND.b		#$0F,d3				; just this nibble
 7024/    56CA : 1A03                   	MOVE.b	d3,d5					; copy it
 7025/    56CC : DA3C 00F6              	ADD.b		#$F6,d5				; set extend bit
 7026/    56D0 : C704                   	ABCD		d4,d3					; decimal add extend and character to zero
 7027/    56D2 : 1183 2000              	MOVE.b	d3,(a0,d2.w)			; save character to string
 7028/    56D6 : 51CA FFEA              	DBF		d2,NextH1				; decrement and loop if not done
 7029/    56DA :                        
 7030/    56DA : 60A2                   	BRA.s		EndBHS				; go process string
 7031/    56DC :                        
 7032/    56DC :                        
 7033/    56DC :                        ;************************************************************************************
 7034/    56DC :                        ;
 7035/    56DC :                        ; ctrl-c check routine. includes limited "life" byte save for INGET routine
 7036/    56DC :                        
 7037/    56DC :                        VEC_CC
 7038/    56DC : 4A2B 05E8              	TST.b		ccflag(a3)				; check [CTRL-C] check flag
 7039/    56E0 : 661E                   	BNE.s		RTS_022				; exit if [CTRL-C] check inhibited
 7040/    56E2 :                        
 7041/    56E2 : 4EAB 040C              	JSR		V_INPT(a3)				; scan input device
 7042/    56E6 : 640E                   	BCC.s		LAB_FBA0				; exit if buffer empty
 7043/    56E8 :                        
 7044/    56E8 : 1740 05E9              	MOVE.b	d0,ccbyte(a3)			; save received byte
 7045/    56EC : 177C 0020 05EA         	MOVE.b	#$20,ccnull(a3)			; set "life" timer for bytes countdown
 7046/    56F2 : 6000 DEDE              	BRA		LAB_1636				; return to BASIC
 7047/    56F6 :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 122 - 12/13/2023 15:59:9


 7048/    56F6 :                        LAB_FBA0
 7049/    56F6 : 4A2B 05EA              	TST.b		ccnull(a3)				; get countdown byte
 7050/    56FA : 6704                   	BEQ.s		RTS_022				; exit if finished
 7051/    56FC :                        
 7052/    56FC : 532B 05EA              	SUBQ.b	#1,ccnull(a3)			; else decrement countdown
 7053/    5700 :                        RTS_022
 7054/    5700 : 4E75                   	RTS
 7055/    5702 :                        
 7056/    5702 :                        
 7057/    5702 :                        ;************************************************************************************
 7058/    5702 :                        ;
 7059/    5702 :                        ; get byte from input device, no waiting
 7060/    5702 :                        ; returns with carry set if byte in A
 7061/    5702 :                        
 7062/    5702 :                        INGET
 7063/    5702 : 4EAB 040C              	JSR		V_INPT(a3)				; call scan input device
 7064/    5706 : 650A                   	BCS.s		LAB_FB95				; if byte go reset timer
 7065/    5708 :                        
 7066/    5708 : 102B 05EA              	MOVE.b	ccnull(a3),d0			; get countdown
 7067/    570C : 67F2                   	BEQ.s		RTS_022				; exit if empty
 7068/    570E :                        
 7069/    570E : 102B 05E9              	MOVE.b	ccbyte(a3),d0			; get last received byte
 7070/    5712 :                        LAB_FB95
 7071/    5712 : 177C 0000 05EA         	MOVE.b	#$00,ccnull(a3)			; clear timer because we got a byte
 7072/    5718 : 003C 0001              	ORI.b		#1,CCR				; set carry, flag we got a byte
 7073/    571C : 4E75                   	RTS
 7074/    571E :                        
 7075/    571E :                        
 7076/    571E :                        ;************************************************************************************
 7077/    571E :                        ;
 7078/    571E :                        ; perform MAX()
 7079/    571E :                        
 7080/    571E :                        LAB_MAX
 7081/    571E : 6100 E530              	BSR		LAB_EVEZ				; evaluate expression (no decrement)
 7082/    5722 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type
 7083/    5726 : 6B00 DA14              	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
 7084/    572A :                        
 7085/    572A :                        LAB_MAXN
 7086/    572A : 612E                   	BSR.s		LAB_PHFA				; push FAC1, evaluate expression,
 7087/    572C :                        								; pull FAC2 & compare with FAC1
 7088/    572C : 64FC                   	BCC.s		LAB_MAXN				; branch if no swap to do
 7089/    572E :                        
 7090/    572E : 6100 F4A0              	BSR		LAB_279B				; copy FAC2 to FAC1
 7091/    5732 : 60F6                   	BRA.s		LAB_MAXN				; go do next
 7092/    5734 :                        
 7093/    5734 :                        
 7094/    5734 :                        ;************************************************************************************
 7095/    5734 :                        ;
 7096/    5734 :                        ; perform MIN()
 7097/    5734 :                        
 7098/    5734 :                        LAB_MIN
 7099/    5734 : 6100 E51A              	BSR		LAB_EVEZ				; evaluate expression (no decrement)
 7100/    5738 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type
 7101/    573C : 6B00 D9FE              	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
 7102/    5740 :                        
 7103/    5740 :                        LAB_MINN
 7104/    5740 : 6118                   	BSR.s		LAB_PHFA				; push FAC1, evaluate expression,
 7105/    5742 :                        								; pull FAC2 & compare with FAC1
 7106/    5742 : 63FC                   	BLS.s		LAB_MINN				; branch if no swap to do
 7107/    5744 :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 123 - 12/13/2023 15:59:9


 7108/    5744 : 6100 F48A              	BSR		LAB_279B				; copy FAC2 to FAC1
 7109/    5748 : 60F6                   	BRA.s		LAB_MINN				; go do next (branch always)
 7110/    574A :                        
 7111/    574A :                        ; exit routine. don't bother returning to the loop code
 7112/    574A :                        ; check for correct exit, else so syntax error
 7113/    574A :                        
 7114/    574A :                        LAB_MMEC
 7115/    574A : B03C 0029              	CMP.b		#')',d0				; is it end of function?
 7116/    574E : 6600 DA18              	BNE		LAB_SNER				; if not do MAX MIN syntax error
 7117/    5752 :                        
 7118/    5752 : 4FEF 0004              	LEA		4(sp),sp				; dump return address (faster)
 7119/    5756 : 6000 E656              	BRA		LAB_IGBY				; update BASIC execute pointer (to chr past ")")
 7120/    575A :                        								; and return
 7121/    575A :                        
 7122/    575A :                        ; check for next, evaluate & return or exit
 7123/    575A :                        ; this is the routine that does most of the work
 7124/    575A :                        
 7125/    575A :                        LAB_PHFA
 7126/    575A : 6100 E654              	BSR		LAB_GBYT				; get next BASIC byte
 7127/    575E : B03C 002C              	CMP.b		#',',d0				; is there more ?
 7128/    5762 : 66E6                   	BNE.s		LAB_MMEC				; if not go do end check
 7129/    5764 :                        
 7130/    5764 : 3F2B 0594              	MOVE.w	FAC1_e(a3),-(sp)			; push exponent and sign
 7131/    5768 : 2F2B 0590              	MOVE.l	FAC1_m(a3),-(sp)			; push mantissa
 7132/    576C :                        
 7133/    576C : 6100 E4E2              	BSR		LAB_EVEZ				; evaluate expression (no decrement)
 7134/    5770 : 4A2B 05B5              	TST.b		Dtypef(a3)				; test data type
 7135/    5774 : 6B00 D9C6              	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
 7136/    5778 :                        
 7137/    5778 :                        
 7138/    5778 :                        								; pop FAC2 (MAX/MIN expression so far)
 7139/    5778 : 275F 0598              	MOVE.l	(sp)+,FAC2_m(a3)			; pop mantissa
 7140/    577C :                        
 7141/    577C : 301F                   	MOVE.w	(sp)+,d0				; pop exponent and sign
 7142/    577E : 3740 059C              	MOVE.w	d0,FAC2_e(a3)			; save exponent and sign
 7143/    5782 : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; get FAC1 sign
 7144/    5788 : B12B 059E              	EOR.b		d0,FAC_sc(a3)			; EOR to create sign compare
 7145/    578C : 6000 F4AE              	BRA		LAB_27FA				; compare FAC1 with FAC2 & return
 7146/    5790 :                        								; returns d0=+1 Cb=0 if FAC1 > FAC2
 7147/    5790 :                        								; returns d0= 0 Cb=0 if FAC1 = FAC2
 7148/    5790 :                        								; returns d0=-1 Cb=1 if FAC1 < FAC2
 7149/    5790 :                        
 7150/    5790 :                        
 7151/    5790 :                        ;************************************************************************************
 7152/    5790 :                        ;
 7153/    5790 :                        ; perform WIDTH
 7154/    5790 :                        
 7155/    5790 :                        LAB_WDTH
 7156/    5790 : B03C 002C              	CMP.b		#',',d0				; is next byte ","
 7157/    5794 : 672C                   	BEQ.s		LAB_TBSZ				; if so do tab size
 7158/    5796 :                        
 7159/    5796 : 6100 EF82              	BSR		LAB_GTBY				; get byte parameter, result in d0 and Itemp
 7160/    579A : 4A00                   	TST.b		d0					; test result
 7161/    579C : 6712                   	BEQ.s		LAB_NSTT				; branch if set for infinite line
 7162/    579E :                        
 7163/    579E : B03C 0010              	CMP.b		#$10,d0				; else make min width = 16d
 7164/    57A2 : 6500 D9B8              	BCS		LAB_FCER				; if less do function call error & exit
 7165/    57A6 :                        
 7166/    57A6 :                        ; this next compare ensures that we can't exit WIDTH via an error leaving the
 7167/    57A6 :                        ; tab size greater than the line length.
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 124 - 12/13/2023 15:59:9


 7168/    57A6 :                        
 7169/    57A6 : B02B 05E2              	CMP.b		TabSiz(a3),d0			; compare with tab size
 7170/    57AA : 6404                   	BCC.s		LAB_NSTT				; branch if >= tab size
 7171/    57AC :                        
 7172/    57AC : 1740 05E2              	MOVE.b	d0,TabSiz(a3)			; else make tab size = terminal width
 7173/    57B0 :                        LAB_NSTT
 7174/    57B0 : 1740 05E6              	MOVE.b	d0,TWidth(a3)			; set the terminal width
 7175/    57B4 : 6100 E5FA              	BSR		LAB_GBYT				; get BASIC byte back
 7176/    57B8 : 672C                   	BEQ.s		WExit					; exit if no following
 7177/    57BA :                        
 7178/    57BA : B03C 002C              	CMP.b		#',',d0				; else is it ","
 7179/    57BE : 6600 D9A8              	BNE		LAB_SNER				; if not do syntax error
 7180/    57C2 :                        
 7181/    57C2 :                        LAB_TBSZ
 7182/    57C2 : 6100 EF52              	BSR		LAB_SGBY				; increment and get byte, result in d0 and Itemp
 7183/    57C6 : 4A00                   	TST.b		d0					; test TAB size
 7184/    57C8 : 6B00 D992              	BMI		LAB_FCER				; if >127 do function call error & exit
 7185/    57CC :                        
 7186/    57CC : B03C 0001              	CMP.b		#1,d0					; compare with min-1
 7187/    57D0 : 6500 D98A              	BCS		LAB_FCER				; if <=1 do function call error & exit
 7188/    57D4 :                        
 7189/    57D4 : 122B 05E6              	MOVE.b	TWidth(a3),d1			; set flags for width
 7190/    57D8 : 6708                   	BEQ.s		LAB_SVTB				; skip check if infinite line
 7191/    57DA :                        
 7192/    57DA : B02B 05E6              	CMP.b		TWidth(a3),d0			; compare TAB with width
 7193/    57DE : 6E00 D97C              	BGT		LAB_FCER				; branch if too big
 7194/    57E2 :                        
 7195/    57E2 :                        LAB_SVTB
 7196/    57E2 : 1740 05E2              	MOVE.b	d0,TabSiz(a3)			; save TAB size
 7197/    57E6 :                        
 7198/    57E6 :                        ; calculate tab column limit from TAB size. The Iclim is set to the last tab
 7199/    57E6 :                        ; position on a line that still has at least one whole tab width between it
 7200/    57E6 :                        ; and the end of the line.
 7201/    57E6 :                        
 7202/    57E6 :                        WExit
 7203/    57E6 : 102B 05E6              	MOVE.b	TWidth(a3),d0			; get width
 7204/    57EA : 670A                   	BEQ.s		LAB_WDLP				; branch if infinite line
 7205/    57EC :                        
 7206/    57EC : B02B 05E2              	CMP.b		TabSiz(a3),d0			; compare with tab size
 7207/    57F0 : 6404                   	BCC.s		LAB_WDLP				; branch if >= tab size
 7208/    57F2 :                        
 7209/    57F2 : 1740 05E2              	MOVE.b	d0,TabSiz(a3)			; else make tab size = terminal width
 7210/    57F6 :                        LAB_WDLP
 7211/    57F6 : 902B 05E2              	SUB.b		TabSiz(a3),d0			; subtract tab size
 7212/    57FA : 64FA                   	BCC.s		LAB_WDLP				; loop while no borrow
 7213/    57FC :                        
 7214/    57FC : D02B 05E2              	ADD.b		TabSiz(a3),d0			; add tab size back
 7215/    5800 : D02B 05E2              	ADD.b		TabSiz(a3),d0			; add tab size back again
 7216/    5804 :                        
 7217/    5804 : 4400                   	NEG.b		d0					; make -ve
 7218/    5806 : D02B 05E6              	ADD.b		TWidth(a3),d0			; subtract remainder from width
 7219/    580A : 1740 05E7              	MOVE.b	d0,Iclim(a3)			; save tab column limit
 7220/    580E :                        RTS_023
 7221/    580E : 4E75                   	RTS
 7222/    5810 :                        
 7223/    5810 :                        
 7224/    5810 :                        ;************************************************************************************
 7225/    5810 :                        ;
 7226/    5810 :                        ; perform SQR()
 7227/    5810 :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 125 - 12/13/2023 15:59:9


 7228/    5810 :                        ; d0 is number to find the root of
 7229/    5810 :                        ; d1 is the root result
 7230/    5810 :                        ; d2 is the remainder
 7231/    5810 :                        ; d3 is a counter
 7232/    5810 :                        ; d4 is temp
 7233/    5810 :                        
 7234/    5810 :                        LAB_SQR
 7235/    5810 : 4A2B 0595              	TST.b		FAC1_s(a3)				; test FAC1 sign
 7236/    5814 : 6B00 D946              	BMI		LAB_FCER				; if -ve do function call error
 7237/    5818 :                        
 7238/    5818 : 4A2B 0594              	TST.b		FAC1_e(a3)				; test exponent
 7239/    581C : 67F0                   	BEQ.s		RTS_023				; exit if zero
 7240/    581E :                        
 7241/    581E : 48E7 7800              	MOVEM.l	d1-d4,-(sp)				; save registers
 7242/    5822 : 202B 0590              	MOVE.l	FAC1_m(a3),d0			; copy FAC1
 7243/    5826 : 7400                   	MOVEQ		#0,d2					; clear remainder
 7244/    5828 : 2202                   	MOVE.l	d2,d1					; clear root
 7245/    582A :                        
 7246/    582A : 761F                   	MOVEQ		#$1F,d3				; $1F for DBF, 64 pairs of bits to
 7247/    582C :                        								; do for a 32 bit result
 7248/    582C : 082B 0000 0594         	BTST		#0,FAC1_e(a3)			; test exponent odd/even
 7249/    5832 : 6606                   	BNE.s		LAB_SQE2				; if odd only 1 shift first time
 7250/    5834 :                        
 7251/    5834 :                        LAB_SQE1
 7252/    5834 : D080                   	ADD.l		d0,d0					; shift highest bit of number ..
 7253/    5836 : D582                   	ADDX.l	d2,d2					; .. into remainder .. never overflows
 7254/    5838 : D281                   	ADD.l		d1,d1					; root = root	; 2 .. never overflows
 7255/    583A :                        LAB_SQE2
 7256/    583A : D080                   	ADD.l		d0,d0					; shift highest bit of number ..
 7257/    583C : D582                   	ADDX.l	d2,d2					; .. into remainder .. never overflows
 7258/    583E :                        
 7259/    583E : 2801                   	MOVE.l	d1,d4					; copy root
 7260/    5840 : D884                   	ADD.l		d4,d4					; 2n
 7261/    5842 : 5284                   	ADDQ.l	#1,d4					; 2n+1
 7262/    5844 :                        
 7263/    5844 : B484                   	CMP.l		d4,d2					; compare 2n+1 to remainder
 7264/    5846 : 6504                   	BCS.s		LAB_SQNS				; skip sub if remainder smaller
 7265/    5848 :                        
 7266/    5848 : 9484                   	SUB.l		d4,d2					; subtract temp from remainder
 7267/    584A : 5281                   	ADDQ.l	#1,d1					; increment root
 7268/    584C :                        LAB_SQNS
 7269/    584C : 51CB FFE6              	DBF		d3,LAB_SQE1				; loop if not all done
 7270/    5850 :                        
 7271/    5850 : 2741 0590              	MOVE.l	d1,FAC1_m(a3)			; save result mantissa
 7272/    5854 : 102B 0594              	MOVE.b	FAC1_e(a3),d0			; get exponent (d0 is clear here)
 7273/    5858 : 907C 0080              	SUB.w		#$80,d0				; normalise
 7274/    585C : E248                   	LSR.w		#1,d0					; /2
 7275/    585E : 6402                   	BCC.s		LAB_SQNA				; skip increment if carry clear
 7276/    5860 :                        
 7277/    5860 : 5240                   	ADDQ.w	#1,d0					; add bit zero back in (allow for half shift)
 7278/    5862 :                        LAB_SQNA
 7279/    5862 : D07C 0080              	ADD.w		#$80,d0				; re-bias to $80
 7280/    5866 : 1740 0594              	MOVE.b	d0,FAC1_e(a3)			; save it
 7281/    586A : 4CDF 001E              	MOVEM.l	(sp)+,d1-d4				; restore registers
 7282/    586E : 6000 F09E              	BRA		LAB_24D5				; normalise FAC1 & return
 7283/    5872 :                        
 7284/    5872 :                        
 7285/    5872 :                        ;************************************************************************************
 7286/    5872 :                        ;
 7287/    5872 :                        ; perform VARPTR()
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 126 - 12/13/2023 15:59:9


 7288/    5872 :                        
 7289/    5872 :                        LAB_VARPTR
 7290/    5872 : 101D                   	MOVE.b	(a5)+,d0				; increment pointer
 7291/    5874 :                        LAB_VARCALL
 7292/    5874 : 6100 E74A              	BSR		LAB_GVAR				; get variable address in a0
 7293/    5878 : 6100 E522              	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
 7294/    587C : 2008                   	MOVE.l	a0,d0					; copy the variable address
 7295/    587E : 6000 EA30              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
 7296/    5882 :                        
 7297/    5882 :                        
 7298/    5882 :                        ;************************************************************************************
 7299/    5882 :                        ;
 7300/    5882 :                        ; perform RAMBASE
 7301/    5882 :                        
 7302/    5882 :                        LAB_RAM
 7303/    5882 : 41F8 0400              	LEA		ram_base,a0			; get start of EhBASIC RAM
 7304/    5886 : 2008                   	MOVE.l	a0,d0					; copy it
 7305/    5888 : 6000 EA26              	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
 7306/    588C :                        
 7307/    588C :                        
 7308/    588C :                        ;************************************************************************************
 7309/    588C :                        ;
 7310/    588C :                        ; perform PI
 7311/    588C :                        
 7312/    588C :                        LAB_PI
 7313/    588C : 277C C90F DAA2 0590    	MOVE.l	#$C90FDAA2,FAC1_m(a3)		; pi mantissa (32 bit)
 7314/    5894 : 377C 8200 0594         	MOVE.w	#$8200,FAC1_e(a3)			; pi exponent and sign
 7315/    589A : 4E75                   	RTS
 7316/    589C :                        
 7317/    589C :                        
 7318/    589C :                        ;************************************************************************************
 7319/    589C :                        ;
 7320/    589C :                        ; perform TWOPI
 7321/    589C :                        
 7322/    589C :                        LAB_TWOPI
 7323/    589C : 277C C90F DAA2 0590    	MOVE.l	#$C90FDAA2,FAC1_m(a3)		; 2pi mantissa (32 bit)
 7324/    58A4 : 377C 8300 0594         	MOVE.w	#$8300,FAC1_e(a3)			; 2pi exponent and sign
 7325/    58AA : 4E75                   	RTS
 7326/    58AC :                        
 7327/    58AC :                        
 7328/    58AC :                        ;************************************************************************************
 7329/    58AC :                        ;
 7330/    58AC :                        ; get ASCII string equivalent into FAC1 as integer32 or float
 7331/    58AC :                        
 7332/    58AC :                        ; entry is with a5 pointing to the first character of the string
 7333/    58AC :                        ; exit with a5 pointing to the first character after the string
 7334/    58AC :                        
 7335/    58AC :                        ; d0 is character
 7336/    58AC :                        ; d1 is mantissa
 7337/    58AC :                        ; d2 is partial and table mantissa
 7338/    58AC :                        ; d3 is mantissa exponent (decimal & binary)
 7339/    58AC :                        ; d4 is decimal exponent
 7340/    58AC :                        
 7341/    58AC :                        ; get FAC1 from string
 7342/    58AC :                        ; this routine now handles hex and binary values from strings
 7343/    58AC :                        ; starting with "$" and "%" respectively
 7344/    58AC :                        
 7345/    58AC :                        LAB_2887
 7346/    58AC : 48E7 7C00              	MOVEM.l	d1-d5,-(sp)				; save registers
 7347/    58B0 : 7200                   	MOVEQ		#$00,d1				; clear temp accumulator
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 127 - 12/13/2023 15:59:9


 7348/    58B2 : 2601                   	MOVE.l	d1,d3					; set mantissa decimal exponent count
 7349/    58B4 : 2801                   	MOVE.l	d1,d4					; clear decimal exponent
 7350/    58B6 : 1741 0595              	MOVE.b	d1,FAC1_s(a3)			; clear sign byte
 7351/    58BA : 1741 05B5              	MOVE.b	d1,Dtypef(a3)			; set float data type
 7352/    58BE : 1741 05AF              	MOVE.b	d1,expneg(a3)			; clear exponent sign
 7353/    58C2 : 6100 E4EC              	BSR		LAB_GBYT				; get first byte back
 7354/    58C6 : 653C                   	BCS.s		LAB_28FE				; go get floating if 1st character numeric
 7355/    58C8 :                        
 7356/    58C8 : B03C 002D              	CMP.b		#'-',d0				; or is it -ve number
 7357/    58CC : 6608                   	BNE.s		LAB_289A				; branch if not
 7358/    58CE :                        
 7359/    58CE : 177C 00FF 0595         	MOVE.b	#$FF,FAC1_s(a3)			; set sign byte
 7360/    58D4 : 6006                   	BRA.s		LAB_289C				; now go scan & check for hex/bin/int
 7361/    58D6 :                        
 7362/    58D6 :                        LAB_289A
 7363/    58D6 :                        								; first character wasn't numeric or -
 7364/    58D6 : B03C 002B              	CMP.b		#'+',d0				; compare with '+'
 7365/    58DA : 6606                   	BNE.s		LAB_289D				; branch if not '+' (go check for '.'/hex/binary
 7366/    58DC :                        								; /integer)
 7367/    58DC :                        	
 7368/    58DC :                        LAB_289C
 7369/    58DC :                        								; was "+" or "-" to start, so get next character
 7370/    58DC : 6100 E4D0              	BSR		LAB_IGBY				; increment & scan memory
 7371/    58E0 : 6522                   	BCS.s		LAB_28FE				; branch if numeric character
 7372/    58E2 :                        
 7373/    58E2 :                        LAB_289D
 7374/    58E2 : B03C 002E              	CMP.b		#'.',d0				; else compare with '.'
 7375/    58E6 : 6700 0092              	BEQ		LAB_2904				; branch if '.'
 7376/    58EA :                        
 7377/    58EA :                        								; code here for hex/binary/integer numbers
 7378/    58EA : B03C 0024              	CMP.b		#'$',d0				; compare with '$'
 7379/    58EE : 6700 010A              	BEQ		LAB_CHEX				; branch if '$'
 7380/    58F2 :                        
 7381/    58F2 : B03C 0025              	CMP.b		#'%',d0				; else compare with '%'
 7382/    58F6 : 6700 0164              	BEQ		LAB_CBIN				; branch if '%'
 7383/    58FA :                        
 7384/    58FA : 6000 008C              	BRA		LAB_2Y01				; not #.$%& so return 0
 7385/    58FE :                        
 7386/    58FE :                        LAB_28FD
 7387/    58FE : 6100 E4AE              	BSR		LAB_IGBY				; get next character
 7388/    5902 : 646C                   	BCC.s		LAB_2902				; exit loop if not a digit
 7389/    5904 :                        
 7390/    5904 :                        LAB_28FE
 7391/    5904 : 6100 01A8              	BSR		d1x10					; multiply d1 by 10 and add character
 7392/    5908 : 64F4                   	BCC.s		LAB_28FD				; loop for more if no overflow
 7393/    590A :                        
 7394/    590A :                        LAB_28FF
 7395/    590A :                        								; overflowed mantissa, count 10s exponent
 7396/    590A : 5283                   	ADDQ.l	#1,d3					; increment mantissa decimal exponent count
 7397/    590C : 6100 E4A0              	BSR		LAB_IGBY				; get next character
 7398/    5910 : 65F8                   	BCS.s		LAB_28FF				; loop while numeric character
 7399/    5912 :                        
 7400/    5912 :                        								; done overflow, now flush fraction or do E
 7401/    5912 : B03C 002E              	CMP.b		#'.',d0				; else compare with '.'
 7402/    5916 : 6606                   	BNE.s		LAB_2901				; branch if not '.'
 7403/    5918 :                        
 7404/    5918 :                        LAB_2900
 7405/    5918 :                        								; flush remaining fraction digits
 7406/    5918 : 6100 E494              	BSR		LAB_IGBY				; get next character
 7407/    591C : 65FA                   	BCS		LAB_2900				; loop while numeric character
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 128 - 12/13/2023 15:59:9


 7408/    591E :                        
 7409/    591E :                        LAB_2901
 7410/    591E :                        								; done number, only (possible) exponent remains
 7411/    591E : B03C 0045              	CMP.b		#'E',d0				; else compare with 'E'
 7412/    5922 : 6664                   	BNE.s		LAB_2Y01				; if not 'E' all done, go evaluate
 7413/    5924 :                        
 7414/    5924 :                        								; process exponent
 7415/    5924 : 6100 E488              	BSR		LAB_IGBY				; get next character
 7416/    5928 : 6528                   	BCS.s		LAB_2X04				; branch if digit
 7417/    592A :                        
 7418/    592A : B03C 002D              	CMP.b		#'-',d0				; or is it -ve number
 7419/    592E : 6706                   	BEQ.s		LAB_2X01				; branch if so
 7420/    5930 :                        
 7421/    5930 : B03C 00B3              	CMP.b		#TK_MINUS,d0			; or is it -ve number
 7422/    5934 : 6608                   	BNE.s		LAB_2X02				; branch if not
 7423/    5936 :                        
 7424/    5936 :                        LAB_2X01
 7425/    5936 : 177C 00FF 05AF         	MOVE.b	#$FF,expneg(a3)			; set exponent sign
 7426/    593C : 600E                   	BRA.s		LAB_2X03				; now go scan & check exponent
 7427/    593E :                        
 7428/    593E :                        LAB_2X02
 7429/    593E : B03C 002B              	CMP.b		#'+',d0				; or is it +ve number
 7430/    5942 : 6708                   	BEQ.s		LAB_2X03				; branch if so
 7431/    5944 :                        
 7432/    5944 : B03C 00B2              	CMP.b		#TK_PLUS,d0				; or is it +ve number
 7433/    5948 : 6600 D81E              	BNE		LAB_SNER				; wasn't - + TK_MINUS TK_PLUS or # so do error
 7434/    594C :                        
 7435/    594C :                        LAB_2X03
 7436/    594C : 6100 E460              	BSR		LAB_IGBY				; get next character
 7437/    5950 : 6436                   	BCC.s		LAB_2Y01				; if not digit all done, go evaluate
 7438/    5952 :                        LAB_2X04
 7439/    5952 : C8FC 000A              	MULU		#10,d4				; multiply decimal exponent by 10
 7440/    5956 : C0BC 0000 00FF         	AND.l		#$FF,d0				; mask character
 7441/    595C : 903C 0030              	SUB.b		#'0',d0				; convert to value
 7442/    5960 : D880                   	ADD.l		d0,d4					; add to decimal exponent
 7443/    5962 : B83C 0030              	CMP.b		#48,d4				; compare with decimal exponent limit+10
 7444/    5966 : 6FE4                   	BLE.s		LAB_2X03				; loop if no overflow/underflow
 7445/    5968 :                        
 7446/    5968 :                        LAB_2X05
 7447/    5968 :                        								; exponent value has overflowed
 7448/    5968 : 6100 E444              	BSR		LAB_IGBY				; get next character
 7449/    596C : 65FA                   	BCS.s		LAB_2X05				; loop while numeric digit
 7450/    596E :                        
 7451/    596E : 6018                   	BRA.s		LAB_2Y01				; all done, go evaluate
 7452/    5970 :                        
 7453/    5970 :                        LAB_2902
 7454/    5970 : B03C 002E              	CMP.b		#'.',d0				; else compare with '.'
 7455/    5974 : 6704                   	BEQ.s		LAB_2904				; branch if was '.'
 7456/    5976 :                        
 7457/    5976 : 60A6                   	BRA.s		LAB_2901				; branch if not '.' (go check/do 'E')
 7458/    5978 :                        
 7459/    5978 :                        LAB_2903
 7460/    5978 : 5383                   	SUBQ.l	#1,d3					; decrement mantissa decimal exponent
 7461/    597A :                        LAB_2904
 7462/    597A :                        								; was dp so get fraction part
 7463/    597A : 6100 E432              	BSR		LAB_IGBY				; get next character
 7464/    597E : 649E                   	BCC.s		LAB_2901				; exit loop if not a digit (go check/do 'E')
 7465/    5980 :                        
 7466/    5980 : 6100 012C              	BSR		d1x10					; multiply d1 by 10 and add character
 7467/    5984 : 64F2                   	BCC.s		LAB_2903				; loop for more if no overflow
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 129 - 12/13/2023 15:59:9


 7468/    5986 :                        
 7469/    5986 : 6090                   	BRA.s		LAB_2900				; else go flush remaining fraction part
 7470/    5988 :                        
 7471/    5988 :                        LAB_2Y01
 7472/    5988 :                        								; now evaluate result
 7473/    5988 : 4A2B 05AF              	TST.b		expneg(a3)				; test exponent sign
 7474/    598C : 6A02                   	BPL.s		LAB_2Y02				; branch if sign positive
 7475/    598E :                        
 7476/    598E : 4484                   	NEG.l		d4					; negate decimal exponent
 7477/    5990 :                        LAB_2Y02
 7478/    5990 : D883                   	ADD.l		d3,d4					; add mantissa decimal exponent
 7479/    5992 : 7620                   	MOVEQ		#32,d3				; set up max binary exponent
 7480/    5994 : 4A81                   	TST.l		d1					; test mantissa
 7481/    5996 : 6752                   	BEQ.s		LAB_rtn0				; if mantissa=0 return 0
 7482/    5998 :                        
 7483/    5998 : 6B08                   	BMI.s		LAB_2Y04				; branch if already mormalised
 7484/    599A :                        
 7485/    599A : 5383                   	SUBQ.l	#1,d3					; decrement bianry exponent for DBMI loop
 7486/    599C :                        LAB_2Y03
 7487/    599C : D281                   	ADD.l		d1,d1					; shift mantissa
 7488/    599E : 5BCB FFFC              	DBMI		d3,LAB_2Y03				; decrement & loop if not normalised
 7489/    59A2 :                        
 7490/    59A2 :                        								; ensure not too big or small
 7491/    59A2 :                        LAB_2Y04
 7492/    59A2 : B8BC 0000 0026         	CMP.l		#38,d4				; compare decimal exponent with max exponent
 7493/    59A8 : 6E00 D7AE              	BGT		LAB_OFER				; if greater do overflow error and warm start
 7494/    59AC :                        
 7495/    59AC : B8BC FFFF FFDA         	CMP.l		#-38,d4				; compare decimal exponent with min exponent
 7496/    59B2 : 6D34                   	BLT.s		LAB_ret0				; if less just return zero
 7497/    59B4 :                        
 7498/    59B4 : 4484                   	NEG.l		d4					; negate decimal exponent to go right way
 7499/    59B6 : C9FC 0006              	MULS		#6,d4					; 6 bytes per entry
 7500/    59BA : 2F08                   	MOVE.l	a0,-(sp)				; save register
 7501/    59BC : 41FA 0210              	LEA		LAB_P_10(pc),a0			; point to table
 7502/    59C0 : 1770 4000 059C         	MOVE.b	(a0,d4.w),FAC2_e(a3)		; copy exponent for multiply
 7503/    59C6 : 2770 4002 0598         	MOVE.l	2(a0,d4.w),FAC2_m(a3)		; copy table mantissa
 7504/    59CC : 205F                   	MOVE.l	(sp)+,a0				; restore register
 7505/    59CE :                        
 7506/    59CE : 0A03 0080              	EORI.b	#$80,d3				; normalise input exponent
 7507/    59D2 : 2741 0590              	MOVE.l	d1,FAC1_m(a3)			; save input mantissa
 7508/    59D6 : 1743 0594              	MOVE.b	d3,FAC1_e(a3)			; save input exponent
 7509/    59DA : 176B 0595 059E         	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; set sign as sign compare
 7510/    59E0 :                        
 7511/    59E0 : 4CDF 003E              	MOVEM.l	(sp)+,d1-d5				; restore registers
 7512/    59E4 : 6000 F050              	BRA		LAB_MULTIPLY			; go multiply input by table
 7513/    59E8 :                        
 7514/    59E8 :                        LAB_ret0
 7515/    59E8 : 7200                   	MOVEQ		#0,d1					; clear mantissa
 7516/    59EA :                        LAB_rtn0
 7517/    59EA : 2601                   	MOVE.l	d1,d3					; clear exponent
 7518/    59EC : 1743 0594              	MOVE.b	d3,FAC1_e(a3)			; save exponent
 7519/    59F0 : 2741 0590              	MOVE.l	d1,FAC1_m(a3)			; save mantissa
 7520/    59F4 : 4CDF 003E              	MOVEM.l	(sp)+,d1-d5				; restore registers
 7521/    59F8 : 4E75                   	RTS
 7522/    59FA :                        
 7523/    59FA :                        
 7524/    59FA :                        ;************************************************************************************
 7525/    59FA :                        ;
 7526/    59FA :                        ; $ for hex add-on
 7527/    59FA :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 130 - 12/13/2023 15:59:9


 7528/    59FA :                        ; gets here if the first character was "$" for hex
 7529/    59FA :                        ; get hex number
 7530/    59FA :                        
 7531/    59FA :                        LAB_CHEX
 7532/    59FA : 177C 0040 05B5         	MOVE.b	#$40,Dtypef(a3)			; set integer numeric data type
 7533/    5A00 : 7620                   	MOVEQ		#32,d3				; set up max binary exponent
 7534/    5A02 :                        LAB_CHXX
 7535/    5A02 : 6100 E3AA              	BSR		LAB_IGBY				; increment & scan memory
 7536/    5A06 : 6514                   	BCS.s		LAB_ISHN				; branch if numeric character
 7537/    5A08 :                        
 7538/    5A08 : 803C 0020              	OR.b		#$20,d0				; case convert, allow "A" to "F" and "a" to "f"
 7539/    5A0C : 903C 0061              	SUB.b		#'a',d0				; subtract "a"
 7540/    5A10 : 652A                   	BCS.s		LAB_CHX3				; exit if <"a"
 7541/    5A12 :                        
 7542/    5A12 : B03C 0006              	CMP.b		#$06,d0				; compare normalised with $06 (max+1)
 7543/    5A16 : 6424                   	BCC.s		LAB_CHX3				; exit if >"f"
 7544/    5A18 :                        
 7545/    5A18 : D03C 003A              	ADD.b		#$3A,d0				; convert to nibble+"0"
 7546/    5A1C :                        LAB_ISHN
 7547/    5A1C : 616C                   	BSR.s		d1x16					; multiply d1 by 16 and add the character
 7548/    5A1E : 64E2                   	BCC.s		LAB_CHXX				; loop for more if no overflow
 7549/    5A20 :                        
 7550/    5A20 :                        								; overflowed mantissa, count 16s exponent
 7551/    5A20 :                        LAB_CHX1
 7552/    5A20 : 5883                   	ADDQ.l	#4,d3					; increment mantissa exponent count
 7553/    5A22 : 6900 D734              	BVS		LAB_OFER				; do overflow error if overflowed
 7554/    5A26 :                        
 7555/    5A26 : 6100 E386              	BSR		LAB_IGBY				; get next character
 7556/    5A2A : 65F4                   	BCS.s		LAB_CHX1				; loop while numeric character
 7557/    5A2C :                        
 7558/    5A2C : 803C 0020              	OR.b		#$20,d0				; case convert, allow "A" to "F" and "a" to "f"
 7559/    5A30 : 903C 0061              	SUB.b		#'a',d0				; subtract "a"
 7560/    5A34 : 6506                   	BCS.s		LAB_CHX3				; exit if <"a"
 7561/    5A36 :                        
 7562/    5A36 : B03C 0006              	CMP.b		#$06,d0				; compare normalised with $06 (max+1)
 7563/    5A3A : 65E4                   	BCS.s		LAB_CHX1				; loop if <="f"
 7564/    5A3C :                        
 7565/    5A3C :                        								; now return value
 7566/    5A3C :                        LAB_CHX3
 7567/    5A3C : 4A81                   	TST.l		d1					; test mantissa
 7568/    5A3E : 67AA                   	BEQ.s		LAB_rtn0				; if mantissa=0 return 0
 7569/    5A40 :                        
 7570/    5A40 : 6B08                   	BMI.s		LAB_exxf				; branch if already mormalised
 7571/    5A42 :                        
 7572/    5A42 : 5383                   	SUBQ.l	#1,d3					; decrement bianry exponent for DBMI loop
 7573/    5A44 :                        LAB_CHX2
 7574/    5A44 : D281                   	ADD.l		d1,d1					; shift mantissa
 7575/    5A46 : 5BCB FFFC              	DBMI		d3,LAB_CHX2				; decrement & loop if not normalised
 7576/    5A4A :                        
 7577/    5A4A :                        LAB_exxf
 7578/    5A4A : 0A03 0080              	EORI.b	#$80,d3				; normalise exponent
 7579/    5A4E : 1743 0594              	MOVE.b	d3,FAC1_e(a3)			; save exponent
 7580/    5A52 : 2741 0590              	MOVE.l	d1,FAC1_m(a3)			; save mantissa
 7581/    5A56 : 4CDF 003E              	MOVEM.l	(sp)+,d1-d5				; restore registers
 7582/    5A5A :                        RTS_024
 7583/    5A5A : 4E75                   	RTS
 7584/    5A5C :                        
 7585/    5A5C :                        
 7586/    5A5C :                        ;************************************************************************************
 7587/    5A5C :                        ;
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 131 - 12/13/2023 15:59:9


 7588/    5A5C :                        ; % for binary add-on
 7589/    5A5C :                        
 7590/    5A5C :                        ; gets here if the first character was "%" for binary
 7591/    5A5C :                        ; get binary number
 7592/    5A5C :                        
 7593/    5A5C :                        LAB_CBIN
 7594/    5A5C : 177C 0040 05B5         	MOVE.b	#$40,Dtypef(a3)			; set integer numeric data type
 7595/    5A62 : 7620                   	MOVEQ		#32,d3				; set up max binary exponent
 7596/    5A64 :                        LAB_CBXN
 7597/    5A64 : 6100 E348              	BSR		LAB_IGBY				; increment & scan memory
 7598/    5A68 : 64D2                   	BCC.s		LAB_CHX3				; if not numeric character go return value
 7599/    5A6A :                        
 7600/    5A6A : B03C 0032              	CMP.b		#'2',d0				; compare with "2" (max+1)
 7601/    5A6E : 64CC                   	BCC.s		LAB_CHX3				; if >="2" go return value
 7602/    5A70 :                        
 7603/    5A70 : 2401                   	MOVE.l	d1,d2					; copy value
 7604/    5A72 : 6124                   	BSR.s		d1x02					; multiply d1 by 2 and add character
 7605/    5A74 : 64EE                   	BCC.s		LAB_CBXN				; loop for more if no overflow
 7606/    5A76 :                        
 7607/    5A76 :                        								; overflowed mantissa, count 2s exponent
 7608/    5A76 :                        LAB_CBX1
 7609/    5A76 : 5283                   	ADDQ.l	#1,d3					; increment mantissa exponent count
 7610/    5A78 : 6900 D6DE              	BVS		LAB_OFER				; do overflow error if overflowed
 7611/    5A7C :                        
 7612/    5A7C : 6100 E330              	BSR		LAB_IGBY				; get next character
 7613/    5A80 : 64BA                   	BCC.s		LAB_CHX3				; if not numeric character go return value
 7614/    5A82 :                        
 7615/    5A82 : B03C 0032              	CMP.b		#'2',d0				; compare with "2" (max+1)
 7616/    5A86 : 65EE                   	BCS.s		LAB_CBX1				; loop if <"2"
 7617/    5A88 :                        
 7618/    5A88 : 60B2                   	BRA.s		LAB_CHX3				; if not numeric character go return value
 7619/    5A8A :                        
 7620/    5A8A :                        ; half way decent times 16 and times 2 with overflow checks
 7621/    5A8A :                        
 7622/    5A8A :                        d1x16
 7623/    5A8A : 2401                   	MOVE.l	d1,d2					; copy value
 7624/    5A8C : D482                   	ADD.l		d2,d2					; times two
 7625/    5A8E : 65CA                   	BCS.s		RTS_024				; return if overflow
 7626/    5A90 :                        
 7627/    5A90 : D482                   	ADD.l		d2,d2					; times four
 7628/    5A92 : 65C6                   	BCS.s		RTS_024				; return if overflow
 7629/    5A94 :                        
 7630/    5A94 : D482                   	ADD.l		d2,d2					; times eight
 7631/    5A96 : 65C2                   	BCS.s		RTS_024				; return if overflow
 7632/    5A98 :                        
 7633/    5A98 :                        d1x02
 7634/    5A98 : D482                   	ADD.l		d2,d2					; times sixteen (ten/two)
 7635/    5A9A : 65BE                   	BCS.s		RTS_024				; return if overflow
 7636/    5A9C :                        
 7637/    5A9C :                        ; now add in new digit
 7638/    5A9C :                        
 7639/    5A9C : C0BC 0000 00FF         	AND.l		#$FF,d0				; mask character
 7640/    5AA2 : 903C 0030              	SUB.b		#'0',d0				; convert to value
 7641/    5AA6 : D480                   	ADD.l		d0,d2					; add to result
 7642/    5AA8 : 65B0                   	BCS.s		RTS_024				; return if overflow, it should never ever do
 7643/    5AAA :                        								; this
 7644/    5AAA :                        
 7645/    5AAA : 2202                   	MOVE.l	d2,d1					; copy result
 7646/    5AAC : 4E75                   	RTS
 7647/    5AAE :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 132 - 12/13/2023 15:59:9


 7648/    5AAE :                        ; half way decent times 10 with overflow checks
 7649/    5AAE :                        
 7650/    5AAE :                        d1x10
 7651/    5AAE : 2401                   	MOVE.l	d1,d2					; copy value
 7652/    5AB0 : D482                   	ADD.l		d2,d2					; times two
 7653/    5AB2 : 6508                   	BCS.s		RTS_025				; return if overflow
 7654/    5AB4 :                        
 7655/    5AB4 : D482                   	ADD.l		d2,d2					; times four
 7656/    5AB6 : 6504                   	BCS.s		RTS_025				; return if overflow
 7657/    5AB8 :                        
 7658/    5AB8 : D481                   	ADD.l		d1,d2					; times five
 7659/    5ABA : 64DC                   	BCC.s		d1x02					; do times two and add in new digit if ok
 7660/    5ABC :                        
 7661/    5ABC :                        RTS_025
 7662/    5ABC : 4E75                   	RTS
 7663/    5ABE :                        
 7664/    5ABE :                        
 7665/    5ABE :                        ;************************************************************************************
 7666/    5ABE :                        ;
 7667/    5ABE :                        ; token values needed for BASIC
 7668/    5ABE :                        
 7669/    5ABE : =$80                   TK_END		EQU $80				; $80
 7670/    5ABE : =$81                   TK_FOR		EQU TK_END+1			; $81
 7671/    5ABE : =$82                   TK_NEXT		EQU TK_FOR+1			; $82
 7672/    5ABE : =$83                   TK_DATA		EQU TK_NEXT+1			; $83
 7673/    5ABE : =$84                   TK_INPUT		EQU TK_DATA+1			; $84
 7674/    5ABE : =$85                   TK_DIM		EQU TK_INPUT+1			; $85
 7675/    5ABE : =$86                   TK_READ		EQU TK_DIM+1			; $86
 7676/    5ABE : =$87                   TK_LET		EQU TK_READ+1			; $87
 7677/    5ABE : =$88                   TK_DEC		EQU TK_LET+1			; $88
 7678/    5ABE : =$89                   TK_GOTO		EQU TK_DEC+1			; $89
 7679/    5ABE : =$8A                   TK_RUN		EQU TK_GOTO+1			; $8A
 7680/    5ABE : =$8B                   TK_IF			EQU TK_RUN+1			; $8B
 7681/    5ABE : =$8C                   TK_RESTORE		EQU TK_IF+1				; $8C
 7682/    5ABE : =$8D                   TK_GOSUB		EQU TK_RESTORE+1			; $8D
 7683/    5ABE : =$8E                   TK_RETURN		EQU TK_GOSUB+1			; $8E
 7684/    5ABE : =$8F                   TK_REM		EQU TK_RETURN+1			; $8F
 7685/    5ABE : =$90                   TK_STOP		EQU TK_REM+1			; $90
 7686/    5ABE : =$91                   TK_ON			EQU TK_STOP+1			; $91
 7687/    5ABE : =$92                   TK_NULL		EQU TK_ON+1				; $92
 7688/    5ABE : =$93                   TK_INC		EQU TK_NULL+1			; $93
 7689/    5ABE : =$94                   TK_WAIT		EQU TK_INC+1			; $94
 7690/    5ABE : =$95                   TK_LOAD		EQU TK_WAIT+1			; $95
 7691/    5ABE : =$96                   TK_SAVE		EQU TK_LOAD+1			; $96
 7692/    5ABE : =$97                   TK_DEF		EQU TK_SAVE+1			; $97
 7693/    5ABE : =$98                   TK_POKE		EQU TK_DEF+1			; $98
 7694/    5ABE : =$99                   TK_DOKE		EQU TK_POKE+1			; $99
 7695/    5ABE : =$9A                   TK_LOKE		EQU TK_DOKE+1			; $9A
 7696/    5ABE : =$9B                   TK_CALL		EQU TK_LOKE+1			; $9B
 7697/    5ABE : =$9C                   TK_DO			EQU TK_CALL+1			; $9C
 7698/    5ABE : =$9D                   TK_LOOP		EQU TK_DO+1				; $9D
 7699/    5ABE : =$9E                   TK_PRINT		EQU TK_LOOP+1			; $9E
 7700/    5ABE : =$9F                   TK_CONT		EQU TK_PRINT+1			; $9F
 7701/    5ABE : =$A0                   TK_LIST		EQU TK_CONT+1			; $A0
 7702/    5ABE : =$A1                   TK_CLEAR		EQU TK_LIST+1			; $A1
 7703/    5ABE : =$A2                   TK_NEW		EQU TK_CLEAR+1			; $A2
 7704/    5ABE : =$A3                   TK_WIDTH		EQU TK_NEW+1			; $A3
 7705/    5ABE : =$A4                   TK_GET		EQU TK_WIDTH+1			; $A4
 7706/    5ABE : =$A5                   TK_SWAP		EQU TK_GET+1			; $A5
 7707/    5ABE : =$A6                   TK_BITSET		EQU TK_SWAP+1			; $A6
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 133 - 12/13/2023 15:59:9


 7708/    5ABE : =$A7                   TK_BITCLR		EQU TK_BITSET+1			; $A7
 7709/    5ABE : =$A8                   TK_TAB		EQU TK_BITCLR+1			; $A8
 7710/    5ABE : =$A9                   TK_ELSE		EQU TK_TAB+1			; $A9
 7711/    5ABE : =$AA                   TK_TO			EQU TK_ELSE+1			; $AA
 7712/    5ABE : =$AB                   TK_FN			EQU TK_TO+1				; $AB
 7713/    5ABE : =$AC                   TK_SPC		EQU TK_FN+1				; $AC
 7714/    5ABE : =$AD                   TK_THEN		EQU TK_SPC+1			; $AD
 7715/    5ABE : =$AE                   TK_NOT		EQU TK_THEN+1			; $AE
 7716/    5ABE : =$AF                   TK_STEP		EQU TK_NOT+1			; $AF
 7717/    5ABE : =$B0                   TK_UNTIL		EQU TK_STEP+1			; $B0
 7718/    5ABE : =$B1                   TK_WHILE		EQU TK_UNTIL+1			; $B1
 7719/    5ABE : =$B2                   TK_PLUS		EQU TK_WHILE+1			; $B2
 7720/    5ABE : =$B3                   TK_MINUS		EQU TK_PLUS+1			; $B3
 7721/    5ABE : =$B4                   TK_MULT		EQU TK_MINUS+1			; $B4
 7722/    5ABE : =$B5                   TK_DIV		EQU TK_MULT+1			; $B5
 7723/    5ABE : =$B6                   TK_POWER		EQU TK_DIV+1			; $B6
 7724/    5ABE : =$B7                   TK_AND		EQU TK_POWER+1			; $B7
 7725/    5ABE : =$B8                   TK_EOR		EQU TK_AND+1			; $B8
 7726/    5ABE : =$B9                   TK_OR			EQU TK_EOR+1			; $B9
 7727/    5ABE : =$BA                   TK_RSHIFT		EQU TK_OR+1				; $BA
 7728/    5ABE : =$BB                   TK_LSHIFT		EQU TK_RSHIFT+1			; $BB
 7729/    5ABE : =$BC                   TK_GT			EQU TK_LSHIFT+1			; $BC
 7730/    5ABE : =$BD                   TK_EQUAL		EQU TK_GT+1				; $BD
 7731/    5ABE : =$BE                   TK_LT			EQU TK_EQUAL+1			; $BE
 7732/    5ABE : =$BF                   TK_SGN		EQU TK_LT+1				; $BF
 7733/    5ABE : =$C0                   TK_INT		EQU TK_SGN+1			; $C0
 7734/    5ABE : =$C1                   TK_ABS		EQU TK_INT+1			; $C1
 7735/    5ABE : =$C2                   TK_USR		EQU TK_ABS+1			; $C2
 7736/    5ABE : =$C3                   TK_FRE		EQU TK_USR+1			; $C3
 7737/    5ABE : =$C4                   TK_POS		EQU TK_FRE+1			; $C4
 7738/    5ABE : =$C5                   TK_SQR		EQU TK_POS+1			; $C5
 7739/    5ABE : =$C6                   TK_RND		EQU TK_SQR+1			; $C6
 7740/    5ABE : =$C7                   TK_LOG		EQU TK_RND+1			; $C7
 7741/    5ABE : =$C8                   TK_EXP		EQU TK_LOG+1			; $C8
 7742/    5ABE : =$C9                   TK_COS		EQU TK_EXP+1			; $C9
 7743/    5ABE : =$CA                   TK_SIN		EQU TK_COS+1			; $CA
 7744/    5ABE : =$CB                   TK_TAN		EQU TK_SIN+1			; $CB
 7745/    5ABE : =$CC                   TK_ATN		EQU TK_TAN+1			; $CC
 7746/    5ABE : =$CD                   TK_PEEK		EQU TK_ATN+1			; $CD
 7747/    5ABE : =$CE                   TK_DEEK		EQU TK_PEEK+1			; $CE
 7748/    5ABE : =$CF                   TK_LEEK		EQU TK_DEEK+1			; $CF
 7749/    5ABE : =$D0                   TK_LEN		EQU TK_LEEK+1			; $D0
 7750/    5ABE : =$D1                   TK_STRS		EQU TK_LEN+1			; $D1
 7751/    5ABE : =$D2                   TK_VAL		EQU TK_STRS+1			; $D2
 7752/    5ABE : =$D3                   TK_ASC		EQU TK_VAL+1			; $D3
 7753/    5ABE : =$D4                   TK_UCASES		EQU TK_ASC+1			; $D4
 7754/    5ABE : =$D5                   TK_LCASES		EQU TK_UCASES+1			; $D5
 7755/    5ABE : =$D6                   TK_CHRS		EQU TK_LCASES+1			; $D6
 7756/    5ABE : =$D7                   TK_HEXS		EQU TK_CHRS+1			; $D7
 7757/    5ABE : =$D8                   TK_BINS		EQU TK_HEXS+1			; $D8
 7758/    5ABE : =$D9                   TK_BITTST		EQU TK_BINS+1			; $D9
 7759/    5ABE : =$DA                   TK_MAX		EQU TK_BITTST+1			; $DA
 7760/    5ABE : =$DB                   TK_MIN		EQU TK_MAX+1			; $DB
 7761/    5ABE : =$DC                   TK_RAM		EQU TK_MIN+1			; $DC
 7762/    5ABE : =$DD                   TK_PI			EQU TK_RAM+1			; $DD
 7763/    5ABE : =$DE                   TK_TWOPI		EQU TK_PI+1				; $DE
 7764/    5ABE : =$DF                   TK_VPTR		EQU TK_TWOPI+1			; $DF
 7765/    5ABE : =$E0                   TK_SADD		EQU TK_VPTR+1			; $E0
 7766/    5ABE : =$E1                   TK_LEFTS		EQU TK_SADD+1			; $E1
 7767/    5ABE : =$E2                   TK_RIGHTS		EQU TK_LEFTS+1			; $E2
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 134 - 12/13/2023 15:59:9


 7768/    5ABE : =$E3                   TK_MIDS		EQU TK_RIGHTS+1			; $E3
 7769/    5ABE : =$E4                   TK_USINGS		EQU TK_MIDS+1			; $E4
 7770/    5ABE :                        
 7771/    5ABE :                        
 7772/    5ABE :                        ;************************************************************************************
 7773/    5ABE :                        ;
 7774/    5ABE :                        ; binary to unsigned decimal table
 7775/    5ABE :                        
 7776/    5ABE :                        Bin2dec
 7777/    5ABE : 3B9A CA00              	dc.l	$3B9ACA00					; 1000000000
 7778/    5AC2 : 05F5 E100              	dc.l	$05F5E100					; 100000000
 7779/    5AC6 : 0098 9680              	dc.l	$00989680					; 10000000
 7780/    5ACA : 000F 4240              	dc.l	$000F4240					; 1000000
 7781/    5ACE : 0001 86A0              	dc.l	$000186A0					; 100000
 7782/    5AD2 : 0000 2710              	dc.l	$00002710					; 10000
 7783/    5AD6 : 0000 03E8              	dc.l	$000003E8					; 1000
 7784/    5ADA : 0000 0064              	dc.l	$00000064					; 100
 7785/    5ADE : 0000 000A              	dc.l	$0000000A					; 10
 7786/    5AE2 : 0000 0000              	dc.l	$00000000					; 0 end marker
 7787/    5AE6 :                        
 7788/    5AE6 :                        LAB_RSED
 7789/    5AE6 : 332E 3232              	dc.l	$332E3232					; 858665522
 7790/    5AEA :                        
 7791/    5AEA :                        ; string to value exponent table
 7792/    5AEA :                        
 7793/    5AEA : FF00                   	dc.w	255<<8					; 10**38
 7794/    5AEC : 9676 9951              	dc.l	$96769951
 7795/    5AF0 : FB00                   	dc.w	251<<8					; 10**37
 7796/    5AF2 : F0BD C21B              	dc.l	$F0BDC21B
 7797/    5AF6 : F800                   	dc.w	248<<8					; 10**36
 7798/    5AF8 : C097 CE7C              	dc.l	$C097CE7C
 7799/    5AFC : F500                   	dc.w	245<<8					; 10**35
 7800/    5AFE : 9A13 0B96              	dc.l	$9A130B96
 7801/    5B02 : F100                   	dc.w	241<<8					; 10**34
 7802/    5B04 : F684 DF57              	dc.l	$F684DF57
 7803/    5B08 : EE00                   	dc.w	238<<8					; 10**33
 7804/    5B0A : C537 1912              	dc.l	$C5371912
 7805/    5B0E : EB00                   	dc.w	235<<8					; 10**32
 7806/    5B10 : 9DC5 ADA8              	dc.l	$9DC5ADA8
 7807/    5B14 : E700                   	dc.w	231<<8					; 10**31
 7808/    5B16 : FC6F 7C40              	dc.l	$FC6F7C40
 7809/    5B1A : E400                   	dc.w	228<<8					; 10**30
 7810/    5B1C : C9F2 C9CD              	dc.l	$C9F2C9CD
 7811/    5B20 : E100                   	dc.w	225<<8					; 10**29
 7812/    5B22 : A18F 07D7              	dc.l	$A18F07D7
 7813/    5B26 : DE00                   	dc.w	222<<8					; 10**28
 7814/    5B28 : 813F 3979              	dc.l	$813F3979
 7815/    5B2C : DA00                   	dc.w	218<<8					; 10**27
 7816/    5B2E : CECB 8F28              	dc.l	$CECB8F28
 7817/    5B32 : D700                   	dc.w	215<<8					; 10**26
 7818/    5B34 : A56F A5BA              	dc.l	$A56FA5BA
 7819/    5B38 : D400                   	dc.w	212<<8					; 10**25
 7820/    5B3A : 8459 5161              	dc.l	$84595161
 7821/    5B3E : D000                   	dc.w	208<<8					; 10**24
 7822/    5B40 : D3C2 1BCF              	dc.l	$D3C21BCF
 7823/    5B44 : CD00                   	dc.w	205<<8					; 10**23
 7824/    5B46 : A968 163F              	dc.l	$A968163F
 7825/    5B4A : CA00                   	dc.w	202<<8					; 10**22
 7826/    5B4C : 8786 7832              	dc.l	$87867832
 7827/    5B50 : C600                   	dc.w	198<<8					; 10**21
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 135 - 12/13/2023 15:59:9


 7828/    5B52 : D8D7 26B7              	dc.l	$D8D726B7
 7829/    5B56 : C300                   	dc.w	195<<8					; 10**20
 7830/    5B58 : AD78 EBC6              	dc.l	$AD78EBC6
 7831/    5B5C : C000                   	dc.w	192<<8					; 10**19
 7832/    5B5E : 8AC7 2305              	dc.l	$8AC72305
 7833/    5B62 : BC00                   	dc.w	188<<8					; 10**18
 7834/    5B64 : DE0B 6B3A              	dc.l	$DE0B6B3A
 7835/    5B68 : B900                   	dc.w	185<<8					; 10**17
 7836/    5B6A : B1A2 BC2F              	dc.l	$B1A2BC2F
 7837/    5B6E : B600                   	dc.w	182<<8					; 10**16
 7838/    5B70 : 8E1B C9BF              	dc.l	$8E1BC9BF
 7839/    5B74 : B200                   	dc.w	178<<8					; 10**15
 7840/    5B76 : E35F A932              	dc.l	$E35FA932
 7841/    5B7A : AF00                   	dc.w	175<<8					; 10**14
 7842/    5B7C : B5E6 20F5              	dc.l	$B5E620F5
 7843/    5B80 : AC00                   	dc.w	172<<8					; 10**13
 7844/    5B82 : 9184 E72A              	dc.l	$9184E72A
 7845/    5B86 : A800                   	dc.w	168<<8					; 10**12
 7846/    5B88 : E8D4 A510              	dc.l	$E8D4A510
 7847/    5B8C : A500                   	dc.w	165<<8					; 10**11
 7848/    5B8E : BA43 B740              	dc.l	$BA43B740
 7849/    5B92 : A200                   	dc.w	162<<8					; 10**10
 7850/    5B94 : 9502 F900              	dc.l	$9502F900
 7851/    5B98 : 9E00                   	dc.w	158<<8					; 10**9
 7852/    5B9A : EE6B 2800              	dc.l	$EE6B2800
 7853/    5B9E : 9B00                   	dc.w	155<<8					; 10**8
 7854/    5BA0 : BEBC 2000              	dc.l	$BEBC2000
 7855/    5BA4 : 9800                   	dc.w	152<<8					; 10**7
 7856/    5BA6 : 9896 8000              	dc.l	$98968000
 7857/    5BAA : 9400                   	dc.w	148<<8					; 10**6
 7858/    5BAC : F424 0000              	dc.l	$F4240000
 7859/    5BB0 : 9100                   	dc.w	145<<8					; 10**5
 7860/    5BB2 : C350 0000              	dc.l	$C3500000
 7861/    5BB6 : 8E00                   	dc.w	142<<8					; 10**4
 7862/    5BB8 : 9C40 0000              	dc.l	$9C400000
 7863/    5BBC : 8A00                   	dc.w	138<<8					; 10**3
 7864/    5BBE : FA00 0000              	dc.l	$FA000000
 7865/    5BC2 : 8700                   	dc.w	135<<8					; 10**2
 7866/    5BC4 : C800 0000              	dc.l	$C8000000
 7867/    5BC8 : 8400                   	dc.w	132<<8					; 10**1
 7868/    5BCA : A000 0000              	dc.l	$A0000000
 7869/    5BCE :                        LAB_P_10
 7870/    5BCE : 8100                   	dc.w	129<<8					; 10**0
 7871/    5BD0 : 8000 0000              	dc.l	$80000000
 7872/    5BD4 : 7D00                   	dc.w	125<<8					; 10**-1
 7873/    5BD6 : CCCC CCCD              	dc.l	$CCCCCCCD
 7874/    5BDA : 7A00                   	dc.w	122<<8					; 10**-2
 7875/    5BDC : A3D7 0A3D              	dc.l	$A3D70A3D
 7876/    5BE0 : 7700                   	dc.w	119<<8					; 10**-3
 7877/    5BE2 : 8312 6E98              	dc.l	$83126E98
 7878/    5BE6 : 7300                   	dc.w	115<<8					; 10**-4
 7879/    5BE8 : D1B7 1759              	dc.l	$D1B71759
 7880/    5BEC : 7000                   	dc.w	112<<8					; 10**-5
 7881/    5BEE : A7C5 AC47              	dc.l	$A7C5AC47
 7882/    5BF2 : 6D00                   	dc.w	109<<8					; 10**-6
 7883/    5BF4 : 8637 BD06              	dc.l	$8637BD06
 7884/    5BF8 : 6900                   	dc.w	105<<8					; 10**-7
 7885/    5BFA : D6BF 94D6              	dc.l	$D6BF94D6
 7886/    5BFE : 6600                   	dc.w	102<<8					; 10**-8
 7887/    5C00 : ABCC 7712              	dc.l	$ABCC7712
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 136 - 12/13/2023 15:59:9


 7888/    5C04 : 6300                   	dc.w	99<<8						; 10**-9
 7889/    5C06 : 8970 5F41              	dc.l	$89705F41
 7890/    5C0A : 5F00                   	dc.w	95<<8						; 10**-10
 7891/    5C0C : DBE6 FECF              	dc.l	$DBE6FECF
 7892/    5C10 : 5C00                   	dc.w	92<<8						; 10**-11
 7893/    5C12 : AFEB FF0C              	dc.l	$AFEBFF0C
 7894/    5C16 : 5900                   	dc.w	89<<8						; 10**-12
 7895/    5C18 : 8CBC CC09              	dc.l	$8CBCCC09
 7896/    5C1C : 5500                   	dc.w	85<<8						; 10**-13
 7897/    5C1E : E12E 1342              	dc.l	$E12E1342
 7898/    5C22 : 5200                   	dc.w	82<<8						; 10**-14
 7899/    5C24 : B424 DC35              	dc.l	$B424DC35
 7900/    5C28 : 4F00                   	dc.w	79<<8						; 10**-15
 7901/    5C2A : 901D 7CF7              	dc.l	$901D7CF7
 7902/    5C2E : 4B00                   	dc.w	75<<8						; 10**-16
 7903/    5C30 : E695 94BF              	dc.l	$E69594BF
 7904/    5C34 : 4800                   	dc.w	72<<8						; 10**-17
 7905/    5C36 : B877 AA32              	dc.l	$B877AA32
 7906/    5C3A : 4500                   	dc.w	69<<8						; 10**-18
 7907/    5C3C : 9392 EE8F              	dc.l	$9392EE8F
 7908/    5C40 : 4100                   	dc.w	65<<8						; 10**-19
 7909/    5C42 : EC1E 4A7E              	dc.l	$EC1E4A7E
 7910/    5C46 : 3E00                   	dc.w	62<<8						; 10**-20
 7911/    5C48 : BCE5 0865              	dc.l	$BCE50865
 7912/    5C4C : 3B00                   	dc.w	59<<8						; 10**-21
 7913/    5C4E : 971D A050              	dc.l	$971DA050
 7914/    5C52 : 3700                   	dc.w	55<<8						; 10**-22
 7915/    5C54 : F1C9 0081              	dc.l	$F1C90081
 7916/    5C58 : 3400                   	dc.w	52<<8						; 10**-23
 7917/    5C5A : C16D 9A01              	dc.l	$C16D9A01
 7918/    5C5E : 3100                   	dc.w	49<<8						; 10**-24
 7919/    5C60 : 9ABE 14CD              	dc.l	$9ABE14CD
 7920/    5C64 : 2D00                   	dc.w	45<<8						; 10**-25
 7921/    5C66 : F796 87AE              	dc.l	$F79687AE
 7922/    5C6A : 2A00                   	dc.w	42<<8						; 10**-26
 7923/    5C6C : C612 0625              	dc.l	$C6120625
 7924/    5C70 : 2700                   	dc.w	39<<8						; 10**-27
 7925/    5C72 : 9E74 D1B8              	dc.l	$9E74D1B8
 7926/    5C76 : 2300                   	dc.w	35<<8						; 10**-28
 7927/    5C78 : FD87 B5F3              	dc.l	$FD87B5F3
 7928/    5C7C : 2000                   	dc.w	32<<8						; 10**-29
 7929/    5C7E : CAD2 F7F5              	dc.l	$CAD2F7F5
 7930/    5C82 : 1D00                   	dc.w	29<<8						; 10**-30
 7931/    5C84 : A242 5FF7              	dc.l	$A2425FF7
 7932/    5C88 : 1A00                   	dc.w	26<<8						; 10**-31
 7933/    5C8A : 81CE B32C              	dc.l	$81CEB32C
 7934/    5C8E : 1600                   	dc.w	22<<8						; 10**-32
 7935/    5C90 : CFB1 1EAD              	dc.l	$CFB11EAD
 7936/    5C94 : 1300                   	dc.w	19<<8						; 10**-33
 7937/    5C96 : A627 4BBE              	dc.l	$A6274BBE
 7938/    5C9A : 1000                   	dc.w	16<<8						; 10**-34
 7939/    5C9C : 84EC 3C98              	dc.l	$84EC3C98
 7940/    5CA0 : 0C00                   	dc.w	12<<8						; 10**-35
 7941/    5CA2 : D4AD 2DC0              	dc.l	$D4AD2DC0
 7942/    5CA6 : 0900                   	dc.w	9<<8						; 10**-36
 7943/    5CA8 : AA24 2499              	dc.l	$AA242499
 7944/    5CAC : 0600                   	dc.w	6<<8						; 10**-37
 7945/    5CAE : 881C EA14              	dc.l	$881CEA14
 7946/    5CB2 : 0200                   	dc.w	2<<8						; 10**-38
 7947/    5CB4 : D9C7 DCED              	dc.l	$D9C7DCED
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 137 - 12/13/2023 15:59:9


 7948/    5CB8 :                        
 7949/    5CB8 :                        
 7950/    5CB8 :                        ;************************************************************************************
 7951/    5CB8 :                        ;
 7952/    5CB8 :                        ; table of constants for cordic SIN/COS/TAN calculations
 7953/    5CB8 :                        ; constants are un normalised fractions and are atn(2^-i)/2pi
 7954/    5CB8 :                        
 7955/    5CB8 : 4DBA 76D4              	dc.l	$4DBA76D4					; SIN/COS multiply constant
 7956/    5CBC :                        TAB_SNCO
 7957/    5CBC : 2000 0000              	dc.l	$20000000					; atn(2^0)/2pi
 7958/    5CC0 : 12E4 051E              	dc.l	$12E4051E					; atn(2^1)/2pi
 7959/    5CC4 : 09FB 385C              	dc.l	$09FB385C					; atn(2^2)/2pi
 7960/    5CC8 : 0511 11D5              	dc.l	$051111D5					; atn(2^3)/2pi
 7961/    5CCC : 028B 0D44              	dc.l	$028B0D44					; atn(2^4)/2pi
 7962/    5CD0 : 0145 D7E2              	dc.l	$0145D7E2					; atn(2^5)/2pi
 7963/    5CD4 : 00A2 F61F              	dc.l	$00A2F61F					; atn(2^6)/2pi
 7964/    5CD8 : 0051 7C56              	dc.l	$00517C56					; atn(2^7)/2pi
 7965/    5CDC : 0028 BE54              	dc.l	$0028BE54					; atn(2^8)/2pi
 7966/    5CE0 : 0014 5F2F              	dc.l	$00145F2F					; atn(2^9)/2pi
 7967/    5CE4 : 000A 2F99              	dc.l	$000A2F99					; atn(2^10)/2pi
 7968/    5CE8 : 0005 17CD              	dc.l	$000517CD					; atn(2^11)/2pi
 7969/    5CEC : 0002 8BE7              	dc.l	$00028BE7					; atn(2^12)/2pi
 7970/    5CF0 : 0001 45F4              	dc.l	$000145F4					; atn(2^13)/2pi
 7971/    5CF4 : 0000 A2FA              	dc.l	$0000A2FA					; atn(2^14)/2pi
 7972/    5CF8 : 0000 517D              	dc.l	$0000517D					; atn(2^15)/2pi
 7973/    5CFC : 0000 28BF              	dc.l	$000028BF					; atn(2^16)/2pi
 7974/    5D00 : 0000 1460              	dc.l	$00001460					; atn(2^17)/2pi
 7975/    5D04 : 0000 0A30              	dc.l	$00000A30					; atn(2^18)/2pi
 7976/    5D08 : 0000 0518              	dc.l	$00000518					; atn(2^19)/2pi
 7977/    5D0C : 0000 028C              	dc.l	$0000028C					; atn(2^20)/2pi
 7978/    5D10 : 0000 0146              	dc.l	$00000146					; atn(2^21)/2pi
 7979/    5D14 : 0000 00A3              	dc.l	$000000A3					; atn(2^22)/2pi
 7980/    5D18 : 0000 0052              	dc.l	$00000052					; atn(2^23)/2pi
 7981/    5D1C : 0000 0029              	dc.l	$00000029					; atn(2^24)/2pi
 7982/    5D20 : 0000 0015              	dc.l	$00000015					; atn(2^25)/2pi
 7983/    5D24 : 0000 000B              	dc.l	$0000000B					; atn(2^26)/2pi
 7984/    5D28 : 0000 0006              	dc.l	$00000006					; atn(2^27)/2pi
 7985/    5D2C : 0000 0003              	dc.l	$00000003					; atn(2^28)/2pi
 7986/    5D30 : 0000 0002              	dc.l	$00000002					; atn(2^29)/2pi
 7987/    5D34 : 0000 0001              	dc.l	$00000001					; atn(2^30)/2pi
 7988/    5D38 : 0000 0001              	dc.l	$00000001					; atn(2^31)/2pi
 7989/    5D3C :                        
 7990/    5D3C :                        
 7991/    5D3C :                        ;************************************************************************************
 7992/    5D3C :                        ;
 7993/    5D3C :                        ; table of constants for cordic ATN calculation
 7994/    5D3C :                        ; constants are normalised to two integer bits and are atn(2^-i)
 7995/    5D3C :                        
 7996/    5D3C :                        TAB_ATNC
 7997/    5D3C : 1DAC 6705              	dc.l	$1DAC6705					; atn(2^-1)
 7998/    5D40 : 0FAD BAFD              	dc.l	$0FADBAFD					; atn(2^-2)
 7999/    5D44 : 07F5 6EA7              	dc.l	$07F56EA7					; atn(2^-3)
 8000/    5D48 : 03FE AB77              	dc.l	$03FEAB77					; atn(2^-4)
 8001/    5D4C : 01FF D55C              	dc.l	$01FFD55C					; atn(2^-5)
 8002/    5D50 : 00FF FAAB              	dc.l	$00FFFAAB					; atn(2^-6)
 8003/    5D54 : 007F FF55              	dc.l	$007FFF55					; atn(2^-7)
 8004/    5D58 : 003F FFEB              	dc.l	$003FFFEB					; atn(2^-8)
 8005/    5D5C : 001F FFFD              	dc.l	$001FFFFD					; atn(2^-9)
 8006/    5D60 : 0010 0000              	dc.l	$00100000					; atn(2^-10)
 8007/    5D64 : 0008 0000              	dc.l	$00080000					; atn(2^-11)
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 138 - 12/13/2023 15:59:9


 8008/    5D68 : 0004 0000              	dc.l	$00040000					; atn(2^-12)
 8009/    5D6C : 0002 0000              	dc.l	$00020000					; atn(2^-13)
 8010/    5D70 : 0001 0000              	dc.l	$00010000					; atn(2^-14)
 8011/    5D74 : 0000 8000              	dc.l	$00008000					; atn(2^-15)
 8012/    5D78 : 0000 4000              	dc.l	$00004000					; atn(2^-16)
 8013/    5D7C : 0000 2000              	dc.l	$00002000					; atn(2^-17)
 8014/    5D80 : 0000 1000              	dc.l	$00001000					; atn(2^-18)
 8015/    5D84 : 0000 0800              	dc.l	$00000800					; atn(2^-19)
 8016/    5D88 : 0000 0400              	dc.l	$00000400					; atn(2^-20)
 8017/    5D8C : 0000 0200              	dc.l	$00000200					; atn(2^-21)
 8018/    5D90 : 0000 0100              	dc.l	$00000100					; atn(2^-22)
 8019/    5D94 : 0000 0080              	dc.l	$00000080					; atn(2^-23)
 8020/    5D98 : 0000 0040              	dc.l	$00000040					; atn(2^-24)
 8021/    5D9C : 0000 0020              	dc.l	$00000020					; atn(2^-25)
 8022/    5DA0 : 0000 0010              	dc.l	$00000010					; atn(2^-26)
 8023/    5DA4 : 0000 0008              	dc.l	$00000008					; atn(2^-27)
 8024/    5DA8 : 0000 0004              	dc.l	$00000004					; atn(2^-28)
 8025/    5DAC : 0000 0002              	dc.l	$00000002					; atn(2^-29)
 8026/    5DB0 : 0000 0001              	dc.l	$00000001					; atn(2^-30)
 8027/    5DB4 :                        LAB_1D96
 8028/    5DB4 : 0000 0000              	dc.l	$00000000					; atn(2^-31)
 8029/    5DB8 : 0000 0000              	dc.l	$00000000					; atn(2^-32)
 8030/    5DBC :                        
 8031/    5DBC :                        ; constants are normalised to n integer bits and are tanh(2^-i)
 8032/    5DBC : =$2                    n	equ	2
 8033/    5DBC :                        TAB_HTHET
 8034/    5DBC : 2327 D4F4              	dc.l	$2327d4f4				; atnh(2^-1) .549306144
 8035/    5DC0 : 1058 AEFA              	dc.l	$1058aefa				; atnh(2^-2) .255412812
 8036/    5DC4 : 080A C48E              	dc.l	$080ac48e				; atnh(2^-3)
 8037/    5DC8 : 0401 5622              	dc.l	$04015622				; atnh(2^-4)
 8038/    5DCC : 0200 2AB0              	dc.l	$02002ab0				; atnh(2^-5)
 8039/    5DD0 : 0100 0554              	dc.l	$01000554				; atnh(2^-6)
 8040/    5DD4 : 0080 00AA              	dc.l	$008000aa				; atnh(2^-7)
 8041/    5DD8 : 0040 0014              	dc.l	$00400014				; atnh(2^-8)
 8042/    5DDC : 0020 0002              	dc.l	$00200002				; atnh(2^-9)
 8043/    5DE0 : 0010 0000              	dc.l	$00100000				; atnh(2^-10)
 8044/    5DE4 : 0008 0000              	dc.l	$00080000				; atnh(2^-11)
 8045/    5DE8 : 0004 0000              	dc.l	$00040000				; atnh(2^-12)
 8046/    5DEC : 0002 0000              	dc.l	$00020000				; atnh(2^-13)
 8047/    5DF0 : 0001 0000              	dc.l	$00010000				; atnh(2^-14)
 8048/    5DF4 : 0000 8000              	dc.l	$00008000				; atnh(2^-15)
 8049/    5DF8 : 0000 4000              	dc.l	$00004000				; atnh(2^-16)
 8050/    5DFC : 0000 2000              	dc.l	$00002000				; atnh(2^-17)
 8051/    5E00 : 0000 1000              	dc.l	$00001000				; atnh(2^-18)
 8052/    5E04 : 0000 0800              	dc.l	$00000800				; atnh(2^-19)
 8053/    5E08 : 0000 0400              	dc.l	$00000400				; atnh(2^-20)
 8054/    5E0C : 0000 0200              	dc.l	$00000200				; atnh(2^-21)
 8055/    5E10 : 0000 0100              	dc.l	$00000100				; atnh(2^-22)
 8056/    5E14 : 0000 0080              	dc.l	$00000080				; atnh(2^-23)
 8057/    5E18 : 0000 0040              	dc.l	$00000040				; atnh(2^-24)
 8058/    5E1C : 0000 0020              	dc.l	$00000020				; atnh(2^-25)
 8059/    5E20 : 0000 0010              	dc.l	$00000010				; atnh(2^-26)
 8060/    5E24 : 0000 0008              	dc.l	$00000008				; atnh(2^-27)
 8061/    5E28 : 0000 0004              	dc.l	$00000004				; atnh(2^-28)
 8062/    5E2C : 0000 0002              	dc.l	$00000002				; atnh(2^-29)
 8063/    5E30 : 0000 0001              	dc.l	$00000001				; atnh(2^-30)
 8064/    5E34 : 0000 0000              	dc.l	$00000000				; atnh(2^-31)
 8065/    5E38 : 0000 0000              	dc.l	$00000000				; atnh(2^-32)
 8066/    5E3C : =$26A3D110             KFCTSEED	equ	$26A3D110			; $26A3D110
 8067/    5E3C :                        
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 139 - 12/13/2023 15:59:9


 8068/    5E3C :                        
 8069/    5E3C :                        ;************************************************************************************
 8070/    5E3C :                        ;
 8071/    5E3C :                        ; command vector table
 8072/    5E3C :                        
 8073/    5E3C :                        LAB_CTBL
 8074/    5E3C : D79E                   	dc.w	LAB_END-LAB_CTBL				; END
 8075/    5E3E : D6D2                   	dc.w	LAB_FOR-LAB_CTBL				; FOR
 8076/    5E40 : DD44                   	dc.w	LAB_NEXT-LAB_CTBL				; NEXT
 8077/    5E42 : D8F2                   	dc.w	LAB_DATA-LAB_CTBL				; DATA
 8078/    5E44 : DC38                   	dc.w	LAB_INPUT-LAB_CTBL			; INPUT
 8079/    5E46 : E116                   	dc.w	LAB_DIM-LAB_CTBL				; DIM
 8080/    5E48 : DC5E                   	dc.w	LAB_READ-LAB_CTBL				; READ
 8081/    5E4A : DA6A                   	dc.w	LAB_LET-LAB_CTBL				; LET
 8082/    5E4C : DA06                   	dc.w	LAB_DEC-LAB_CTBL				; DEC	
 8083/    5E4E : D85A                   	dc.w	LAB_GOTO-LAB_CTBL				; GOTO
 8084/    5E50 : D822                   	dc.w	LAB_RUN-LAB_CTBL				; RUN
 8085/    5E52 : D91A                   	dc.w	LAB_IF-LAB_CTBL				; IF
 8086/    5E54 : D7CC                   	dc.w	LAB_RESTORE-LAB_CTBL			; RESTORE
 8087/    5E56 : D848                   	dc.w	LAB_GOSUB-LAB_CTBL			; GOSUB
 8088/    5E58 : D8DE                   	dc.w	LAB_RETURN-LAB_CTBL			; RETURN
 8089/    5E5A : D98C                   	dc.w	LAB_REM-LAB_CTBL				; REM
 8090/    5E5C : D7A6                   	dc.w	LAB_STOP-LAB_CTBL				; STOP
 8091/    5E5E : D994                   	dc.w	LAB_ON-LAB_CTBL				; ON
 8092/    5E60 : D7FA                   	dc.w	LAB_NULL-LAB_CTBL				; NULL
 8093/    5E62 : DA0C                   	dc.w	LAB_INC-LAB_CTBL				; INC	
 8094/    5E64 : EA1E                   	dc.w	LAB_WAIT-LAB_CTBL				; WAIT
 8095/    5E66 : EA0C                   	dc.w	LAB_LOAD-LAB_CTBL				; LOAD
 8096/    5E68 : EA10                   	dc.w	LAB_SAVE-LAB_CTBL				; SAVE
 8097/    5E6A : E4A6                   	dc.w	LAB_DEF-LAB_CTBL				; DEF
 8098/    5E6C : E98C                   	dc.w	LAB_POKE-LAB_CTBL				; POKE
 8099/    5E6E : E9BC                   	dc.w	LAB_DOKE-LAB_CTBL				; DOKE
 8100/    5E70 : E9C2                   	dc.w	LAB_LOKE-LAB_CTBL				; LOKE
 8101/    5E72 : EA14                   	dc.w	LAB_CALL-LAB_CTBL				; CALL
 8102/    5E74 : D836                   	dc.w	LAB_DO-LAB_CTBL				; DO	
 8103/    5E76 : D888                   	dc.w	LAB_LOOP-LAB_CTBL				; LOOP
 8104/    5E78 : DAFE                   	dc.w	LAB_PRINT-LAB_CTBL			; PRINT
 8105/    5E7A : D804                   	dc.w	LAB_CONT-LAB_CTBL				; CONT
 8106/    5E7C : D61C                   	dc.w	LAB_LIST-LAB_CTBL				; LIST
 8107/    5E7E : D618                   	dc.w	LAB_CLEAR-LAB_CTBL			; CLEAR
 8108/    5E80 : D5C6                   	dc.w	LAB_NEW-LAB_CTBL				; NEW
 8109/    5E82 : F954                   	dc.w	LAB_WDTH-LAB_CTBL				; WIDTH
 8110/    5E84 : DAC4                   	dc.w	LAB_GET-LAB_CTBL				; GET
 8111/    5E86 : E9D6                   	dc.w	LAB_SWAP-LAB_CTBL				; SWAP
 8112/    5E88 : F49E                   	dc.w	LAB_BITSET-LAB_CTBL			; BITSET
 8113/    5E8A : F4AE                   	dc.w	LAB_BITCLR-LAB_CTBL			; BITCLR
 8114/    5E8C :                        
 8115/    5E8C :                        
 8116/    5E8C :                        ;************************************************************************************
 8117/    5E8C :                        ;
 8118/    5E8C :                        ; function pre process routine table
 8119/    5E8C :                        
 8120/    5E8C :                        LAB_FTPP
 8121/    5E8C : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; SGN(n)	process numeric expression in ()
 8122/    5E8E : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; INT(n)		"
 8123/    5E90 : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; ABS(n)		"
 8124/    5E92 : DDC4                   	dc.w	LAB_EVEZ-LAB_FTPP				; USR(x)	process any expression
 8125/    5E94 : DF0C                   	dc.w	LAB_1BF7-LAB_FTPP				; FRE(x)	process any expression in ()
 8126/    5E96 : DF0C                   	dc.w	LAB_1BF7-LAB_FTPP				; POS(x)		"
 8127/    5E98 : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; SQR(n)	process numeric expression in ()
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 140 - 12/13/2023 15:59:9


 8128/    5E9A : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; RND(n)		"
 8129/    5E9C : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; LOG(n)		"
 8130/    5E9E : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; EXP(n)		"
 8131/    5EA0 : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; COS(n)		"
 8132/    5EA2 : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; SIN(n)		"
 8133/    5EA4 : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; TAN(n)		"
 8134/    5EA6 : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; ATN(n)		"
 8135/    5EA8 : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; PEEK(n)		"
 8136/    5EAA : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; DEEK(n)		"
 8137/    5EAC : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; LEEK(n)		"
 8138/    5EAE : DFB6                   	dc.w	LAB_PPFS-LAB_FTPP				; LEN($)	process string expression in ()
 8139/    5EB0 : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; STR$(n)	process numeric expression in ()
 8140/    5EB2 : DFB6                   	dc.w	LAB_PPFS-LAB_FTPP				; VAL($)	process string expression in ()
 8141/    5EB4 : DFB6                   	dc.w	LAB_PPFS-LAB_FTPP				; ASC($)		"
 8142/    5EB6 : DFB6                   	dc.w	LAB_PPFS-LAB_FTPP				; UCASE$($)		"
 8143/    5EB8 : DFB6                   	dc.w	LAB_PPFS-LAB_FTPP				; LCASE$($)		"
 8144/    5EBA : DFC4                   	dc.w	LAB_PPFN-LAB_FTPP				; CHR$(n)	process numeric expression in ()
 8145/    5EBC : DFFE                   	dc.w	LAB_BHSS-LAB_FTPP				; HEX$()	bin/hex pre process
 8146/    5EBE : DFFE                   	dc.w	LAB_BHSS-LAB_FTPP				; BIN$()		"
 8147/    5EC0 : 0000                   	dc.w	$0000						; BITTST()	none
 8148/    5EC2 : 0000                   	dc.w	$0000						; MAX()		"
 8149/    5EC4 : 0000                   	dc.w	$0000						; MIN()		"
 8150/    5EC6 : DFD2                   	dc.w	LAB_PPBI-LAB_FTPP				; RAMBASE	advance pointer
 8151/    5EC8 : DFD2                   	dc.w	LAB_PPBI-LAB_FTPP				; PI			"
 8152/    5ECA : DFD2                   	dc.w	LAB_PPBI-LAB_FTPP				; TWOPI		"
 8153/    5ECC : 0000                   	dc.w	$0000						; VARPTR()	none
 8154/    5ECE : 0000                   	dc.w	$0000						; SADD()		"
 8155/    5ED0 : DFDC                   	dc.w	LAB_LRMS-LAB_FTPP				; LEFT$()	process string expression
 8156/    5ED2 : DFDC                   	dc.w	LAB_LRMS-LAB_FTPP				; RIGHT$()		"
 8157/    5ED4 : DFDC                   	dc.w	LAB_LRMS-LAB_FTPP				; MID$()		"
 8158/    5ED6 : DDC4                   	dc.w	LAB_EVEZ-LAB_FTPP				; USING$(x)	process any expression
 8159/    5ED8 :                        
 8160/    5ED8 :                        
 8161/    5ED8 :                        ;************************************************************************************
 8162/    5ED8 :                        ;
 8163/    5ED8 :                        ; action addresses for functions
 8164/    5ED8 :                        
 8165/    5ED8 :                        LAB_FTBL
 8166/    5ED8 : ED4A                   	dc.w	LAB_SGN-LAB_FTBL				; SGN()
 8167/    5EDA : EDCE                   	dc.w	LAB_INT-LAB_FTBL				; INT()
 8168/    5EDC : ED5C                   	dc.w	LAB_ABS-LAB_FTBL				; ABS()
 8169/    5EDE : E968                   	dc.w	LAB_USR-LAB_FTBL				; USR()
 8170/    5EE0 : E3C2                   	dc.w	LAB_FRE-LAB_FTBL				; FRE()
 8171/    5EE2 : E3F4                   	dc.w	LAB_POS-LAB_FTBL				; POS()
 8172/    5EE4 : F938                   	dc.w	LAB_SQR-LAB_FTBL				; SQR()
 8173/    5EE6 : F21C                   	dc.w	LAB_RND-LAB_FTBL				; RND()
 8174/    5EE8 : EA6C                   	dc.w	LAB_LOG-LAB_FTBL				; LOG()
 8175/    5EEA : F102                   	dc.w	LAB_EXP-LAB_FTBL				; EXP()
 8176/    5EEC : F270                   	dc.w	LAB_COS-LAB_FTBL				; COS()
 8177/    5EEE : F288                   	dc.w	LAB_SIN-LAB_FTBL				; SIN()
 8178/    5EF0 : F24E                   	dc.w	LAB_TAN-LAB_FTBL				; TAN()
 8179/    5EF2 : F34E                   	dc.w	LAB_ATN-LAB_FTBL				; ATN()
 8180/    5EF4 : E8E4                   	dc.w	LAB_PEEK-LAB_FTBL				; PEEK()
 8181/    5EF6 : E8F6                   	dc.w	LAB_DEEK-LAB_FTBL				; DEEK()
 8182/    5EF8 : E90C                   	dc.w	LAB_LEEK-LAB_FTBL				; LEEK()
 8183/    5EFA : E826                   	dc.w	LAB_LENS-LAB_FTBL				; LEN()
 8184/    5EFC : E4EA                   	dc.w	LAB_STRS-LAB_FTBL				; STR$()
 8185/    5EFE : E86C                   	dc.w	LAB_VAL-LAB_FTBL				; VAL()
 8186/    5F00 : E82E                   	dc.w	LAB_ASC-LAB_FTBL				; ASC()
 8187/    5F02 : E7DC                   	dc.w	LAB_UCASE-LAB_FTBL			; UCASE$()
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 141 - 12/13/2023 15:59:9


 8188/    5F04 : E7AC                   	dc.w	LAB_LCASE-LAB_FTBL			; LCASE$()
 8189/    5F06 : E714                   	dc.w	LAB_CHRS-LAB_FTBL				; CHR$()
 8190/    5F08 : F7DA                   	dc.w	LAB_HEXS-LAB_FTBL				; HEX$()
 8191/    5F0A : F788                   	dc.w	LAB_BINS-LAB_FTBL				; BIN$()
 8192/    5F0C : F422                   	dc.w	LAB_BTST-LAB_FTBL				; BITTST()
 8193/    5F0E : F846                   	dc.w	LAB_MAX-LAB_FTBL				; MAX()
 8194/    5F10 : F85C                   	dc.w	LAB_MIN-LAB_FTBL				; MIN()
 8195/    5F12 : F9AA                   	dc.w	LAB_RAM-LAB_FTBL				; RAMBASE
 8196/    5F14 : F9B4                   	dc.w	LAB_PI-LAB_FTBL				; PI
 8197/    5F16 : F9C4                   	dc.w	LAB_TWOPI-LAB_FTBL			; TWOPI
 8198/    5F18 : F99A                   	dc.w	LAB_VARPTR-LAB_FTBL			; VARPTR()
 8199/    5F1A : E80E                   	dc.w	LAB_SADD-LAB_FTBL				; SADD()
 8200/    5F1C : E724                   	dc.w	LAB_LEFT-LAB_FTBL				; LEFT$()
 8201/    5F1E : E738                   	dc.w	LAB_RIGHT-LAB_FTBL			; RIGHT$()
 8202/    5F20 : E768                   	dc.w	LAB_MIDS-LAB_FTBL				; MID$()
 8203/    5F22 : F450                   	dc.w	LAB_USINGS-LAB_FTBL			; USING$()
 8204/    5F24 :                        
 8205/    5F24 :                        
 8206/    5F24 :                        ;************************************************************************************
 8207/    5F24 :                        ;
 8208/    5F24 :                        ; hierarchy and action addresses for operator
 8209/    5F24 :                        
 8210/    5F24 :                        LAB_OPPT
 8211/    5F24 : 0079                   	dc.w	$0079						; +
 8212/    5F26 : E96E                   	dc.w	LAB_ADD-LAB_OPPT
 8213/    5F28 : 0079                   	dc.w	$0079						; -
 8214/    5F2A : E95A                   	dc.w	LAB_SUBTRACT-LAB_OPPT
 8215/    5F2C : 007B                   	dc.w	$007B						; *
 8216/    5F2E : EB12                   	dc.w	LAB_MULTIPLY-LAB_OPPT
 8217/    5F30 : 007B                   	dc.w	$007B						; /
 8218/    5F32 : EB9E                   	dc.w	LAB_DIVIDE-LAB_OPPT
 8219/    5F34 : 007F                   	dc.w	$007F						; ^
 8220/    5F36 : F000                   	dc.w	LAB_POWER-LAB_OPPT
 8221/    5F38 : 0050                   	dc.w	$0050						; AND
 8222/    5F3A : DFA6                   	dc.w	LAB_AND-LAB_OPPT
 8223/    5F3C : 0046                   	dc.w	$0046						; EOR
 8224/    5F3E : DF96                   	dc.w	LAB_EOR-LAB_OPPT
 8225/    5F40 : 0046                   	dc.w	$0046						; OR
 8226/    5F42 : DF9E                   	dc.w	LAB_OR-LAB_OPPT
 8227/    5F44 : 0056                   	dc.w	$0056						; >>
 8228/    5F46 : E04A                   	dc.w	LAB_RSHIFT-LAB_OPPT
 8229/    5F48 : 0056                   	dc.w	$0056						; <<
 8230/    5F4A : E03A                   	dc.w	LAB_LSHIFT-LAB_OPPT
 8231/    5F4C : 007D                   	dc.w	$007D						; >
 8232/    5F4E : F064                   	dc.w	LAB_GTHAN-LAB_OPPT			; used to evaluate -n
 8233/    5F50 : 005A                   	dc.w	$005A						; =
 8234/    5F52 : DFBC                   	dc.w	LAB_EQUAL-LAB_OPPT			; used to evaluate NOT
 8235/    5F54 : 0064                   	dc.w	$0064						; <
 8236/    5F56 : DFC6                   	dc.w	LAB_LTHAN-LAB_OPPT
 8237/    5F58 :                        
 8238/    5F58 :                        
 8239/    5F58 :                        ;************************************************************************************
 8240/    5F58 :                        ;
 8241/    5F58 :                        ; misc constants
 8242/    5F58 :                        
 8243/    5F58 :                        ; This table is used in converting numbers to ASCII.
 8244/    5F58 :                        ; first four entries for expansion to 9.25 digits
 8245/    5F58 :                        
 8246/    5F58 :                        LAB_2A9A
 8247/    5F58 : FFF0 BDC0              	dc.l	$FFF0BDC0					; -1000000
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 142 - 12/13/2023 15:59:9


 8248/    5F5C : 0001 86A0              	dc.l	$000186A0					; 100000
 8249/    5F60 : FFFF D8F0              	dc.l	$FFFFD8F0					; -10000
 8250/    5F64 : 0000 03E8              	dc.l	$000003E8					; 1000
 8251/    5F68 : FFFF FF9C              	dc.l	$FFFFFF9C					; -100
 8252/    5F6C : 0000 000A              	dc.l	$0000000A					; 10
 8253/    5F70 : FFFF FFFF              	dc.l	$FFFFFFFF					; -1
 8254/    5F74 :                        LAB_2A9B
 8255/    5F74 :                        
 8256/    5F74 :                        
 8257/    5F74 :                        ;************************************************************************************
 8258/    5F74 :                        ;
 8259/    5F74 :                        ; new keyword tables
 8260/    5F74 :                        
 8261/    5F74 :                        ; offsets to keyword tables
 8262/    5F74 :                        
 8263/    5F74 :                        TAB_CHRT
 8264/    5F74 : 0000                   	dc.w	TAB_STAR-TAB_STAR				; "*"	$2A
 8265/    5F76 : 0002                   	dc.w	TAB_PLUS-TAB_STAR				; "+"	$2B
 8266/    5F78 : FFFF                   	dc.w	-1						; "," $2C no keywords
 8267/    5F7A : 0004                   	dc.w	TAB_MNUS-TAB_STAR				; "-"	$2D
 8268/    5F7C : FFFF                   	dc.w	-1						; "." $2E no keywords
 8269/    5F7E : 0006                   	dc.w	TAB_SLAS-TAB_STAR				; "/"	$2F
 8270/    5F80 : FFFF                   	dc.w	-1						; "0" $30 no keywords
 8271/    5F82 : FFFF                   	dc.w	-1						; "1" $31 no keywords
 8272/    5F84 : FFFF                   	dc.w	-1						; "2" $32 no keywords
 8273/    5F86 : FFFF                   	dc.w	-1						; "3" $33 no keywords
 8274/    5F88 : FFFF                   	dc.w	-1						; "4" $34 no keywords
 8275/    5F8A : FFFF                   	dc.w	-1						; "5" $35 no keywords
 8276/    5F8C : FFFF                   	dc.w	-1						; "6" $36 no keywords
 8277/    5F8E : FFFF                   	dc.w	-1						; "7" $37 no keywords
 8278/    5F90 : FFFF                   	dc.w	-1						; "8" $38 no keywords
 8279/    5F92 : FFFF                   	dc.w	-1						; "9" $39 no keywords
 8280/    5F94 : FFFF                   	dc.w	-1						; ";" $3A no keywords
 8281/    5F96 : FFFF                   	dc.w	-1						; ":" $3B no keywords
 8282/    5F98 : 0008                   	dc.w	TAB_LESS-TAB_STAR				; "<"	$3C
 8283/    5F9A : 000C                   	dc.w	TAB_EQUL-TAB_STAR				; "="	$3D
 8284/    5F9C : 000E                   	dc.w	TAB_MORE-TAB_STAR				; ">"	$3E
 8285/    5F9E : 0012                   	dc.w	TAB_QEST-TAB_STAR				; "?"	$3F
 8286/    5FA0 : FFFF                   	dc.w	-1						; "@" $40 no keywords
 8287/    5FA2 : 0014                   	dc.w	TAB_ASCA-TAB_STAR				; "A"	$41
 8288/    5FA4 : 0024                   	dc.w	TAB_ASCB-TAB_STAR				; "B"	$42
 8289/    5FA6 : 003D                   	dc.w	TAB_ASCC-TAB_STAR				; "C"	$43
 8290/    5FA8 : 0054                   	dc.w	TAB_ASCD-TAB_STAR				; "D"	$44
 8291/    5FAA : 006D                   	dc.w	TAB_ASCE-TAB_STAR				; "E"	$45
 8292/    5FAC : 007C                   	dc.w	TAB_ASCF-TAB_STAR				; "F"	$46
 8293/    5FAE : 0086                   	dc.w	TAB_ASCG-TAB_STAR				; "G"	$47
 8294/    5FB0 : 0093                   	dc.w	TAB_ASCH-TAB_STAR				; "H"	$48
 8295/    5FB2 : 0099                   	dc.w	TAB_ASCI-TAB_STAR				; "I"	$49
 8296/    5FB4 : FFFF                   	dc.w	-1						; "J" $4A no keywords
 8297/    5FB6 : FFFF                   	dc.w	-1						; "K" $4B no keywords
 8298/    5FB8 : 00A8                   	dc.w	TAB_ASCL-TAB_STAR				; "L"	$4C
 8299/    5FBA : 00D6                   	dc.w	TAB_ASCM-TAB_STAR				; "M"	$4D
 8300/    5FBC : 00E4                   	dc.w	TAB_ASCN-TAB_STAR				; "N"	$4E
 8301/    5FBE : 00F3                   	dc.w	TAB_ASCO-TAB_STAR				; "O"	$4F
 8302/    5FC0 : 00F8                   	dc.w	TAB_ASCP-TAB_STAR				; "P"	$50
 8303/    5FC2 : FFFF                   	dc.w	-1						; "Q" $51 no keywords
 8304/    5FC4 : 010D                   	dc.w	TAB_ASCR-TAB_STAR				; "R"	$52
 8305/    5FC6 : 0137                   	dc.w	TAB_ASCS-TAB_STAR				; "S"	$53
 8306/    5FC8 : 0162                   	dc.w	TAB_ASCT-TAB_STAR				; "T"	$54
 8307/    5FCA : 0176                   	dc.w	TAB_ASCU-TAB_STAR				; "U"	$55
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 143 - 12/13/2023 15:59:9


 8308/    5FCC : 018E                   	dc.w	TAB_ASCV-TAB_STAR				; "V"	$56
 8309/    5FCE : 019A                   	dc.w	TAB_ASCW-TAB_STAR				; "W"	$57
 8310/    5FD0 : FFFF                   	dc.w	-1						; "X" $58 no keywords
 8311/    5FD2 : FFFF                   	dc.w	-1						; "Y" $59 no keywords
 8312/    5FD4 : FFFF                   	dc.w	-1						; "Z" $5A no keywords
 8313/    5FD6 : FFFF                   	dc.w	-1						; "[" $5B no keywords
 8314/    5FD8 : FFFF                   	dc.w	-1						; "\" $5C no keywords
 8315/    5FDA : FFFF                   	dc.w	-1						; "]" $5D no keywords
 8316/    5FDC : 01A9                   	dc.w	TAB_POWR-TAB_STAR				; "^"	$5E
 8317/    5FDE :                        
 8318/    5FDE :                        
 8319/    5FDE :                        ;************************************************************************************
 8320/    5FDE :                        ;
 8321/    5FDE :                        ; Table of Basic keywords for LIST command
 8322/    5FDE :                        ; [byte]first character,[byte]remaining length -1
 8323/    5FDE :                        ; [word]offset from table start
 8324/    5FDE :                        
 8325/    5FDE :                        LAB_KEYT
 8326/    5FDE : 4501                   	dc.b	'E',1
 8327/    5FE0 : 0071                   	dc.w	KEY_END-TAB_STAR				; END
 8328/    5FE2 : 4601                   	dc.b	'F',1
 8329/    5FE4 : 007C                   	dc.w	KEY_FOR-TAB_STAR				; FOR
 8330/    5FE6 : 4E02                   	dc.b	'N',2
 8331/    5FE8 : 00E7                   	dc.w	KEY_NEXT-TAB_STAR				; NEXT
 8332/    5FEA : 4402                   	dc.b	'D',2
 8333/    5FEC : 0054                   	dc.w	KEY_DATA-TAB_STAR				; DATA
 8334/    5FEE : 4903                   	dc.b	'I',3
 8335/    5FF0 : 009E                   	dc.w	KEY_INPUT-TAB_STAR			; INPUT
 8336/    5FF2 : 4401                   	dc.b	'D',1
 8337/    5FF4 : 0063                   	dc.w	KEY_DIM-TAB_STAR				; DIM
 8338/    5FF6 : 5202                   	dc.b	'R',2
 8339/    5FF8 : 0114                   	dc.w	KEY_READ-TAB_STAR				; READ
 8340/    5FFA : 4C01                   	dc.b	'L',1
 8341/    5FFC : 00BE                   	dc.w	KEY_LET-TAB_STAR				; LET
 8342/    5FFE : 4401                   	dc.b	'D',1
 8343/    6000 : 0058                   	dc.w	KEY_DEC-TAB_STAR				; DEC
 8344/    6002 : 4702                   	dc.b	'G',2
 8345/    6004 : 0089                   	dc.w	KEY_GOTO-TAB_STAR				; GOTO
 8346/    6006 : 5201                   	dc.b	'R',1
 8347/    6008 : 0133                   	dc.w	KEY_RUN-TAB_STAR				; RUN
 8348/    600A : 4900                   	dc.b	'I',0
 8349/    600C : 0099                   	dc.w	KEY_IF-TAB_STAR				; IF
 8350/    600E : 5205                   	dc.b	'R',5
 8351/    6010 : 011B                   	dc.w	KEY_RESTORE-TAB_STAR			; RESTORE
 8352/    6012 : 4703                   	dc.b	'G',3
 8353/    6014 : 008D                   	dc.w	KEY_GOSUB-TAB_STAR			; GOSUB
 8354/    6016 : 5204                   	dc.b	'R',4
 8355/    6018 : 0122                   	dc.w	KEY_RETURN-TAB_STAR			; RETURN
 8356/    601A : 5201                   	dc.b	'R',1
 8357/    601C : 0118                   	dc.w	KEY_REM-TAB_STAR				; REM
 8358/    601E : 5302                   	dc.b	'S',2
 8359/    6020 : 0154                   	dc.w	KEY_STOP-TAB_STAR				; STOP
 8360/    6022 : 4F00                   	dc.b	'O',0
 8361/    6024 : 00F3                   	dc.w	KEY_ON-TAB_STAR				; ON
 8362/    6026 : 4E02                   	dc.b	'N',2
 8363/    6028 : 00EE                   	dc.w	KEY_NULL-TAB_STAR				; NULL
 8364/    602A : 4901                   	dc.b	'I',1
 8365/    602C : 009B                   	dc.w	KEY_INC-TAB_STAR				; INC
 8366/    602E : 5702                   	dc.b	'W',2
 8367/    6030 : 019A                   	dc.w	KEY_WAIT-TAB_STAR				; WAIT
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 144 - 12/13/2023 15:59:9


 8368/    6032 : 4C02                   	dc.b	'L',2
 8369/    6034 : 00C5                   	dc.w	KEY_LOAD-TAB_STAR				; LOAD
 8370/    6036 : 5302                   	dc.b	'S',2
 8371/    6038 : 013C                   	dc.w	KEY_SAVE-TAB_STAR				; SAVE
 8372/    603A : 4401                   	dc.b	'D',1
 8373/    603C : 0060                   	dc.w	KEY_DEF-TAB_STAR				; DEF
 8374/    603E : 5002                   	dc.b	'P',2
 8375/    6040 : 00FF                   	dc.w	KEY_POKE-TAB_STAR				; POKE
 8376/    6042 : 4402                   	dc.b	'D',2
 8377/    6044 : 0066                   	dc.w	KEY_DOKE-TAB_STAR				; DOKE
 8378/    6046 : 4C02                   	dc.b	'L',2
 8379/    6048 : 00CD                   	dc.w	KEY_LOKE-TAB_STAR				; LOKE
 8380/    604A : 4302                   	dc.b	'C',2
 8381/    604C : 003D                   	dc.w	KEY_CALL-TAB_STAR				; CALL
 8382/    604E : 4400                   	dc.b	'D',0
 8383/    6050 : 006A                   	dc.w	KEY_DO-TAB_STAR				; DO
 8384/    6052 : 4C02                   	dc.b	'L',2
 8385/    6054 : 00D1                   	dc.w	KEY_LOOP-TAB_STAR				; LOOP
 8386/    6056 : 5003                   	dc.b	'P',3
 8387/    6058 : 0107                   	dc.w	KEY_PRINT-TAB_STAR			; PRINT
 8388/    605A : 4302                   	dc.b	'C',2
 8389/    605C : 004B                   	dc.w	KEY_CONT-TAB_STAR				; CONT
 8390/    605E : 4C02                   	dc.b	'L',2
 8391/    6060 : 00C1                   	dc.w	KEY_LIST-TAB_STAR				; LIST
 8392/    6062 : 4303                   	dc.b	'C',3
 8393/    6064 : 0046                   	dc.w	KEY_CLEAR-TAB_STAR			; CLEAR
 8394/    6066 : 4E01                   	dc.b	'N',1
 8395/    6068 : 00E4                   	dc.w	KEY_NEW-TAB_STAR				; NEW
 8396/    606A : 5703                   	dc.b	'W',3
 8397/    606C : 01A3                   	dc.w	KEY_WIDTH-TAB_STAR			; WIDTH
 8398/    606E : 4701                   	dc.b	'G',1
 8399/    6070 : 0086                   	dc.w	KEY_GET-TAB_STAR				; GET
 8400/    6072 : 5302                   	dc.b	'S',2
 8401/    6074 : 015D                   	dc.w	KEY_SWAP-TAB_STAR				; SWAP
 8402/    6076 : 4204                   	dc.b	'B',4
 8403/    6078 : 002F                   	dc.w	KEY_BITSET-TAB_STAR			; BITSET
 8404/    607A : 4204                   	dc.b	'B',4
 8405/    607C : 0029                   	dc.w	KEY_BITCLR-TAB_STAR			; BITCLR
 8406/    607E : 5402                   	dc.b	'T',2
 8407/    6080 : 0162                   	dc.w	KEY_TAB-TAB_STAR				; TAB(
 8408/    6082 : 4502                   	dc.b	'E',2
 8409/    6084 : 006D                   	dc.w	KEY_ELSE-TAB_STAR				; ELSE
 8410/    6086 : 5400                   	dc.b	'T',0
 8411/    6088 : 016E                   	dc.w	KEY_TO-TAB_STAR				; TO
 8412/    608A : 4600                   	dc.b	'F',0
 8413/    608C : 007F                   	dc.w	KEY_FN-TAB_STAR				; FN
 8414/    608E : 5302                   	dc.b	'S',2
 8415/    6090 : 0148                   	dc.w	KEY_SPC-TAB_STAR				; SPC(
 8416/    6092 : 5402                   	dc.b	'T',2
 8417/    6094 : 016A                   	dc.w	KEY_THEN-TAB_STAR				; THEN
 8418/    6096 : 4E01                   	dc.b	'N',1
 8419/    6098 : 00EB                   	dc.w	KEY_NOT-TAB_STAR				; NOT
 8420/    609A : 5302                   	dc.b	'S',2
 8421/    609C : 0150                   	dc.w	KEY_STEP-TAB_STAR				; STEP
 8422/    609E : 5503                   	dc.b	'U',3
 8423/    60A0 : 017D                   	dc.w	KEY_UNTIL-TAB_STAR			; UNTIL
 8424/    60A2 : 5703                   	dc.b	'W',3
 8425/    60A4 : 019E                   	dc.w	KEY_WHILE-TAB_STAR			; WHILE
 8426/    60A6 :                        
 8427/    60A6 : 2BFF                   	dc.b	'+',-1
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 145 - 12/13/2023 15:59:9


 8428/    60A8 : 0002                   	dc.w	KEY_PLUS-TAB_STAR				; +
 8429/    60AA : 2DFF                   	dc.b	'-',-1
 8430/    60AC : 0004                   	dc.w	KEY_MINUS-TAB_STAR			; -
 8431/    60AE : 2AFF                   	dc.b	'*',-1
 8432/    60B0 : 0000                   	dc.w	KEY_MULT-TAB_STAR				; *
 8433/    60B2 : 2FFF                   	dc.b	'/',-1
 8434/    60B4 : 0006                   	dc.w	KEY_DIV-TAB_STAR				; /
 8435/    60B6 : 5EFF                   	dc.b	'^',-1
 8436/    60B8 : 01A9                   	dc.w	KEY_POWER-TAB_STAR			; ^
 8437/    60BA : 4101                   	dc.b	'A',1
 8438/    60BC : 0018                   	dc.w	KEY_AND-TAB_STAR				; AND
 8439/    60BE : 4501                   	dc.b	'E',1
 8440/    60C0 : 0074                   	dc.w	KEY_EOR-TAB_STAR				; EOR
 8441/    60C2 : 4F00                   	dc.b	'O',0
 8442/    60C4 : 00F5                   	dc.w	KEY_OR-TAB_STAR				; OR
 8443/    60C6 : 3E00                   	dc.b	'>',0
 8444/    60C8 : 000E                   	dc.w	KEY_RSHIFT-TAB_STAR			; >>
 8445/    60CA : 3C00                   	dc.b	'<',0
 8446/    60CC : 0008                   	dc.w	KEY_LSHIFT-TAB_STAR			; <<
 8447/    60CE : 3EFF                   	dc.b	'>',-1
 8448/    60D0 : 0010                   	dc.w	KEY_GT-TAB_STAR				; >
 8449/    60D2 : 3DFF                   	dc.b	'=',-1
 8450/    60D4 : 000C                   	dc.w	KEY_EQUAL-TAB_STAR			; =
 8451/    60D6 : 3CFF                   	dc.b	'<',-1
 8452/    60D8 : 000A                   	dc.w	KEY_LT-TAB_STAR				; <
 8453/    60DA :                        
 8454/    60DA : 5302                   	dc.b	'S',2
 8455/    60DC : 0140                   	dc.w	KEY_SGN-TAB_STAR				; SGN(
 8456/    60DE : 4902                   	dc.b	'I',2
 8457/    60E0 : 00A3                   	dc.w	KEY_INT-TAB_STAR				; INT(
 8458/    60E2 : 4102                   	dc.b	'A',2
 8459/    60E4 : 0014                   	dc.w	KEY_ABS-TAB_STAR				; ABS(
 8460/    60E6 : 5502                   	dc.b	'U',2
 8461/    60E8 : 0189                   	dc.w	KEY_USR-TAB_STAR				; USR(
 8462/    60EA : 4602                   	dc.b	'F',2
 8463/    60EC : 0081                   	dc.w	KEY_FRE-TAB_STAR				; FRE(
 8464/    60EE : 5002                   	dc.b	'P',2
 8465/    60F0 : 0103                   	dc.w	KEY_POS-TAB_STAR				; POS(
 8466/    60F2 : 5302                   	dc.b	'S',2
 8467/    60F4 : 014C                   	dc.w	KEY_SQR-TAB_STAR				; SQR(
 8468/    60F6 : 5202                   	dc.b	'R',2
 8469/    60F8 : 012F                   	dc.w	KEY_RND-TAB_STAR				; RND(
 8470/    60FA : 4C02                   	dc.b	'L',2
 8471/    60FC : 00C9                   	dc.w	KEY_LOG-TAB_STAR				; LOG(
 8472/    60FE : 4502                   	dc.b	'E',2
 8473/    6100 : 0077                   	dc.w	KEY_EXP-TAB_STAR				; EXP(
 8474/    6102 : 4302                   	dc.b	'C',2
 8475/    6104 : 004F                   	dc.w	KEY_COS-TAB_STAR				; COS(
 8476/    6106 : 5302                   	dc.b	'S',2
 8477/    6108 : 0144                   	dc.w	KEY_SIN-TAB_STAR				; SIN(
 8478/    610A : 5402                   	dc.b	'T',2
 8479/    610C : 0166                   	dc.w	KEY_TAN-TAB_STAR				; TAN(
 8480/    610E : 4102                   	dc.b	'A',2
 8481/    6110 : 001F                   	dc.w	KEY_ATN-TAB_STAR				; ATN(
 8482/    6112 : 5003                   	dc.b	'P',3
 8483/    6114 : 00F8                   	dc.w	KEY_PEEK-TAB_STAR				; PEEK(
 8484/    6116 : 4403                   	dc.b	'D',3
 8485/    6118 : 005B                   	dc.w	KEY_DEEK-TAB_STAR				; DEEK(
 8486/    611A : 4C03                   	dc.b	'L',3
 8487/    611C : 00AF                   	dc.w	KEY_LEEK-TAB_STAR				; LEEK(
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 146 - 12/13/2023 15:59:9


 8488/    611E : 4C02                   	dc.b	'L',2
 8489/    6120 : 00BA                   	dc.w	KEY_LEN-TAB_STAR				; LEN(
 8490/    6122 : 5303                   	dc.b	'S',3
 8491/    6124 : 0158                   	dc.w	KEY_STRS-TAB_STAR				; STR$(
 8492/    6126 : 5602                   	dc.b	'V',2
 8493/    6128 : 018E                   	dc.w	KEY_VAL-TAB_STAR				; VAL(
 8494/    612A : 4102                   	dc.b	'A',2
 8495/    612C : 001B                   	dc.w	KEY_ASC-TAB_STAR				; ASC(
 8496/    612E : 5505                   	dc.b	'U',5
 8497/    6130 : 0176                   	dc.w	KEY_UCASES-TAB_STAR			; UCASE$(
 8498/    6132 : 4C05                   	dc.b	'L',5
 8499/    6134 : 00A8                   	dc.w	KEY_LCASES-TAB_STAR			; LCASE$(
 8500/    6136 : 4303                   	dc.b	'C',3
 8501/    6138 : 0041                   	dc.w	KEY_CHRS-TAB_STAR				; CHR$(
 8502/    613A : 4803                   	dc.b	'H',3
 8503/    613C : 0093                   	dc.w	KEY_HEXS-TAB_STAR				; HEX$(
 8504/    613E : 4203                   	dc.b	'B',3
 8505/    6140 : 0024                   	dc.w	KEY_BINS-TAB_STAR				; BIN$(
 8506/    6142 : 4205                   	dc.b	'B',5
 8507/    6144 : 0035                   	dc.w	KEY_BITTST-TAB_STAR			; BITTST(
 8508/    6146 : 4D02                   	dc.b	'M',2
 8509/    6148 : 00D6                   	dc.w	KEY_MAX-TAB_STAR				; MAX(
 8510/    614A : 4D02                   	dc.b	'M',2
 8511/    614C : 00DF                   	dc.w	KEY_MIN-TAB_STAR				; MIN(
 8512/    614E : 5205                   	dc.b	'R',5
 8513/    6150 : 010D                   	dc.w	KEY_RAM-TAB_STAR				; RAMBASE
 8514/    6152 : 5000                   	dc.b	'P',0
 8515/    6154 : 00FD                   	dc.w	KEY_PI-TAB_STAR				; PI
 8516/    6156 : 5403                   	dc.b	'T',3
 8517/    6158 : 0170                   	dc.w	KEY_TWOPI-TAB_STAR			; TWOPI
 8518/    615A : 5605                   	dc.b	'V',5
 8519/    615C : 0192                   	dc.w	KEY_VPTR-TAB_STAR				; VARPTR(
 8520/    615E : 5303                   	dc.b	'S',3
 8521/    6160 : 0137                   	dc.w	KEY_SADD-TAB_STAR				; SADD(
 8522/    6162 : 4C04                   	dc.b	'L',4
 8523/    6164 : 00B4                   	dc.w	KEY_LEFTS-TAB_STAR			; LEFT$(
 8524/    6166 : 5205                   	dc.b	'R',5
 8525/    6168 : 0128                   	dc.w	KEY_RIGHTS-TAB_STAR			; RIGHT$(
 8526/    616A : 4D03                   	dc.b	'M',3
 8527/    616C : 00DA                   	dc.w	KEY_MIDS-TAB_STAR				; MID$(
 8528/    616E : 5505                   	dc.b	'U',5
 8529/    6170 : 0182                   	dc.w	KEY_USINGS-TAB_STAR			; USING$(
 8530/    6172 :                        
 8531/    6172 :                        
 8532/    6172 :                        ;************************************************************************************
 8533/    6172 :                        ;
 8534/    6172 :                        ; BASIC error messages
 8535/    6172 :                        
 8536/    6172 :                        LAB_BAER
 8537/    6172 : 0030                   	dc.w	LAB_NF-LAB_BAER				; $00 NEXT without FOR
 8538/    6174 : 0041                   	dc.w	LAB_SN-LAB_BAER				; $02 syntax
 8539/    6176 : 0048                   	dc.w	LAB_RG-LAB_BAER				; $04 RETURN without GOSUB
 8540/    6178 : 005D                   	dc.w	LAB_OD-LAB_BAER				; $06 out of data
 8541/    617A : 0069                   	dc.w	LAB_FC-LAB_BAER				; $08 function call
 8542/    617C : 0077                   	dc.w	LAB_OV-LAB_BAER				; $0A overflow
 8543/    617E : 0080                   	dc.w	LAB_OM-LAB_BAER				; $0C out of memory
 8544/    6180 : 008E                   	dc.w	LAB_US-LAB_BAER				; $0E undefined statement
 8545/    6182 : 00A2                   	dc.w	LAB_BS-LAB_BAER				; $10 array bounds
 8546/    6184 : 00AF                   	dc.w	LAB_DD-LAB_BAER				; $12 double dimension array
 8547/    6186 : 00C0                   	dc.w	LAB_D0-LAB_BAER				; $14 divide by 0
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 147 - 12/13/2023 15:59:9


 8548/    6188 : 00CF                   	dc.w	LAB_ID-LAB_BAER				; $16 illegal direct
 8549/    618A : 00DE                   	dc.w	LAB_TM-LAB_BAER				; $18 type mismatch
 8550/    618C : 00EC                   	dc.w	LAB_LS-LAB_BAER				; $1A long string
 8551/    618E : 00FC                   	dc.w	LAB_ST-LAB_BAER				; $1C string too complex
 8552/    6190 : 010F                   	dc.w	LAB_CN-LAB_BAER				; $1E continue error
 8553/    6192 : 011E                   	dc.w	LAB_UF-LAB_BAER				; $20 undefined function
 8554/    6194 : 0131                   	dc.w	LAB_LD-LAB_BAER				; $22 LOOP without DO
 8555/    6196 : 0141                   	dc.w	LAB_UV-LAB_BAER				; $24 undefined variable
 8556/    6198 : 0154                   	dc.w	LAB_UA-LAB_BAER				; $26 undimensioned array
 8557/    619A : 0168                   	dc.w	LAB_WD-LAB_BAER				; $28 wrong dimensions
 8558/    619C : 0179                   	dc.w	LAB_AD-LAB_BAER				; $2A address
 8559/    619E : 0181                   	dc.w	LAB_FO-LAB_BAER				; $2C format
 8560/    61A0 : 0188                   	dc.w	LAB_NI-LAB_BAER				; $2E not implemented
 8561/    61A2 :                        
 8562/    61A2 : 4E45 5854 2077 6974    LAB_NF	dc.b	'NEXT without FOR',$00
          61AA : 686F 7574 2046 4F52 00
 8563/    61B3 : 5379 6E74 6178 00      LAB_SN	dc.b	'Syntax',$00
 8564/    61BA : 5245 5455 524E 2077    LAB_RG	dc.b	'RETURN without GOSUB',$00
          61C2 : 6974 686F 7574 2047
          61CA : 4F53 5542 00         
 8565/    61CF : 4F75 7420 6F66 2044    LAB_OD	dc.b	'Out of DATA',$00
          61D7 : 4154 4100            
 8566/    61DB : 4675 6E63 7469 6F6E    LAB_FC	dc.b	'Function call',$00
          61E3 : 2063 616C 6C00      
 8567/    61E9 : 4F76 6572 666C 6F77 00 LAB_OV	dc.b	'Overflow',$00
 8568/    61F2 : 4F75 7420 6F66 206D    LAB_OM	dc.b	'Out of memory',$00
          61FA : 656D 6F72 7900      
 8569/    6200 : 556E 6465 6669 6E65    LAB_US	dc.b	'Undefined statement',$00
          6208 : 6420 7374 6174 656D
          6210 : 656E 7400            
 8570/    6214 : 4172 7261 7920 626F    LAB_BS	dc.b	'Array bounds',$00
          621C : 756E 6473 00         
 8571/    6221 : 446F 7562 6C65 2064    LAB_DD	dc.b	'Double dimension',$00
          6229 : 696D 656E 7369 6F6E 00
 8572/    6232 : 4469 7669 6465 2062    LAB_D0	dc.b	'Divide by zero',$00
          623A : 7920 7A65 726F 00   
 8573/    6241 : 496C 6C65 6761 6C20    LAB_ID	dc.b	'Illegal direct',$00
          6249 : 6469 7265 6374 00   
 8574/    6250 : 5479 7065 206D 6973    LAB_TM	dc.b	'Type mismatch',$00
          6258 : 6D61 7463 6800      
 8575/    625E : 5374 7269 6E67 2074    LAB_LS	dc.b	'String too long',$00
          6266 : 6F6F 206C 6F6E 6700   
 8576/    626E : 5374 7269 6E67 2074    LAB_ST	dc.b	'String too complex',$00
          6276 : 6F6F 2063 6F6D 706C
          627E : 6578 00               
 8577/    6281 : 4361 6E27 7420 636F    LAB_CN	dc.b	"Can't continue",$00
          6289 : 6E74 696E 7565 00   
 8578/    6290 : 556E 6465 6669 6E65    LAB_UF	dc.b	'Undefined function',$00
          6298 : 6420 6675 6E63 7469
          62A0 : 6F6E 00               
 8579/    62A3 : 4C4F 4F50 2077 6974    LAB_LD	dc.b	'LOOP without DO',$00
          62AB : 686F 7574 2044 4F00   
 8580/    62B3 : 556E 6465 6669 6E65    LAB_UV	dc.b	'Undefined variable',$00
          62BB : 6420 7661 7269 6162
          62C3 : 6C65 00               
 8581/    62C6 : 556E 6469 6D65 6E73    LAB_UA	dc.b	'Undimensioned array',$00
          62CE : 696F 6E65 6420 6172
          62D6 : 7261 7900            
 8582/    62DA : 5772 6F6E 6720 6469    LAB_WD	dc.b	'Wrong dimensions',$00
          62E2 : 6D65 6E73 696F 6E73 00
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 148 - 12/13/2023 15:59:9


 8583/    62EB : 4164 6472 6573 7300    LAB_AD	dc.b	'Address',$00
 8584/    62F3 : 466F 726D 6174 00      LAB_FO	dc.b	'Format',$00
 8585/    62FA : 4E6F 7420 696D 706C    LAB_NI  dc.b    'Not implemented',$00
          6302 : 656D 656E 7465 6400   
 8586/    630A :                        
 8587/    630A :                        
 8588/    630A :                        ;************************************************************************************
 8589/    630A :                        ;
 8590/    630A :                        ; keyword table for line (un)crunching
 8591/    630A :                        
 8592/    630A :                        ; [keyword,token
 8593/    630A :                        ; [keyword,token]]
 8594/    630A :                        ; end marker (#$00)
 8595/    630A :                        
 8596/    630A :                        TAB_STAR
 8597/    630A :                        KEY_MULT
 8598/    630A : B400                   	dc.b TK_MULT,$00					; *
 8599/    630C :                        TAB_PLUS
 8600/    630C :                        KEY_PLUS
 8601/    630C : B200                   	dc.b TK_PLUS,$00					; +
 8602/    630E :                        TAB_MNUS
 8603/    630E :                        KEY_MINUS
 8604/    630E : B300                   	dc.b TK_MINUS,$00					; -
 8605/    6310 :                        TAB_SLAS
 8606/    6310 :                        KEY_DIV
 8607/    6310 : B500                   	dc.b TK_DIV,$00					; /
 8608/    6312 :                        TAB_LESS
 8609/    6312 :                        KEY_LSHIFT
 8610/    6312 : 3CBB                   	dc.b	'<',TK_LSHIFT				; <<
 8611/    6314 :                        KEY_LT
 8612/    6314 : BE                     	dc.b TK_LT						; <
 8613/    6315 : 00                     	dc.b	$00
 8614/    6316 :                        TAB_EQUL
 8615/    6316 :                        KEY_EQUAL
 8616/    6316 : BD00                   	dc.b TK_EQUAL,$00					; =
 8617/    6318 :                        TAB_MORE
 8618/    6318 :                        KEY_RSHIFT
 8619/    6318 : 3EBA                   	dc.b	'>',TK_RSHIFT				; >>
 8620/    631A :                        KEY_GT
 8621/    631A : BC                     	dc.b TK_GT						; >
 8622/    631B : 00                     	dc.b	$00
 8623/    631C :                        TAB_QEST
 8624/    631C : 9E00                   	dc.b TK_PRINT,$00					; ?
 8625/    631E :                        TAB_ASCA
 8626/    631E :                        KEY_ABS
 8627/    631E : 4253 28C1              	dc.b	'BS(',TK_ABS				; ABS(
 8628/    6322 :                        KEY_AND
 8629/    6322 : 4E44 B7                	dc.b	'ND',TK_AND					; AND
 8630/    6325 :                        KEY_ASC
 8631/    6325 : 5343 28D3              	dc.b	'SC(',TK_ASC				; ASC(
 8632/    6329 :                        KEY_ATN
 8633/    6329 : 544E 28CC              	dc.b	'TN(',TK_ATN				; ATN(
 8634/    632D : 00                     	dc.b	$00
 8635/    632E :                        TAB_ASCB
 8636/    632E :                        KEY_BINS
 8637/    632E : 494E 2428 D8           	dc.b	'IN$(',TK_BINS				; BIN$(
 8638/    6333 :                        KEY_BITCLR
 8639/    6333 : 4954 434C 52A7         	dc.b	'ITCLR',TK_BITCLR				; BITCLR
 8640/    6339 :                        KEY_BITSET
 8641/    6339 : 4954 5345 54A6         	dc.b	'ITSET',TK_BITSET				; BITSET
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 149 - 12/13/2023 15:59:9


 8642/    633F :                        KEY_BITTST
 8643/    633F : 4954 5453 5428 D9      	dc.b	'ITTST(',TK_BITTST			; BITTST(
 8644/    6346 : 00                     	dc.b	$00
 8645/    6347 :                        TAB_ASCC
 8646/    6347 :                        KEY_CALL
 8647/    6347 : 414C 4C9B              	dc.b	'ALL',TK_CALL				; CALL
 8648/    634B :                        KEY_CHRS
 8649/    634B : 4852 2428 D6           	dc.b	'HR$(',TK_CHRS				; CHR$(
 8650/    6350 :                        KEY_CLEAR
 8651/    6350 : 4C45 4152 A1           	dc.b	'LEAR',TK_CLEAR				; CLEAR
 8652/    6355 :                        KEY_CONT
 8653/    6355 : 4F4E 549F              	dc.b	'ONT',TK_CONT				; CONT
 8654/    6359 :                        KEY_COS
 8655/    6359 : 4F53 28C9              	dc.b	'OS(',TK_COS				; COS(
 8656/    635D : 00                     	dc.b	$00
 8657/    635E :                        TAB_ASCD
 8658/    635E :                        KEY_DATA
 8659/    635E : 4154 4183              	dc.b	'ATA',TK_DATA				; DATA
 8660/    6362 :                        KEY_DEC
 8661/    6362 : 4543 88                	dc.b	'EC',TK_DEC					; DEC
 8662/    6365 :                        KEY_DEEK
 8663/    6365 : 4545 4B28 CE           	dc.b	'EEK(',TK_DEEK				; DEEK(
 8664/    636A :                        KEY_DEF
 8665/    636A : 4546 97                	dc.b	'EF',TK_DEF					; DEF
 8666/    636D :                        KEY_DIM
 8667/    636D : 494D 85                	dc.b	'IM',TK_DIM					; DIM
 8668/    6370 :                        KEY_DOKE
 8669/    6370 : 4F4B 4599              	dc.b	'OKE',TK_DOKE				; DOKE
 8670/    6374 :                        KEY_DO
 8671/    6374 : 4F9C                   	dc.b	'O',TK_DO					; DO
 8672/    6376 : 00                     	dc.b	$00
 8673/    6377 :                        TAB_ASCE
 8674/    6377 :                        KEY_ELSE
 8675/    6377 : 4C53 45A9              	dc.b	'LSE',TK_ELSE				; ELSE
 8676/    637B :                        KEY_END
 8677/    637B : 4E44 80                	dc.b	'ND',TK_END					; END
 8678/    637E :                        KEY_EOR
 8679/    637E : 4F52 B8                	dc.b	'OR',TK_EOR					; EOR
 8680/    6381 :                        KEY_EXP
 8681/    6381 : 5850 28C8              	dc.b	'XP(',TK_EXP				; EXP(
 8682/    6385 : 00                     	dc.b	$00
 8683/    6386 :                        TAB_ASCF
 8684/    6386 :                        KEY_FOR
 8685/    6386 : 4F52 81                	dc.b	'OR',TK_FOR					; FOR
 8686/    6389 :                        KEY_FN
 8687/    6389 : 4EAB                   	dc.b	'N',TK_FN					; FN
 8688/    638B :                        KEY_FRE
 8689/    638B : 5245 28C3              	dc.b	'RE(',TK_FRE				; FRE(
 8690/    638F : 00                     	dc.b	$00
 8691/    6390 :                        TAB_ASCG
 8692/    6390 :                        KEY_GET
 8693/    6390 : 4554 A4                	dc.b	'ET',TK_GET					; GET
 8694/    6393 :                        KEY_GOTO
 8695/    6393 : 4F54 4F89              	dc.b	'OTO',TK_GOTO				; GOTO
 8696/    6397 :                        KEY_GOSUB
 8697/    6397 : 4F53 5542 8D           	dc.b	'OSUB',TK_GOSUB				; GOSUB
 8698/    639C : 00                     	dc.b	$00
 8699/    639D :                        TAB_ASCH
 8700/    639D :                        KEY_HEXS
 8701/    639D : 4558 2428 D700         	dc.b	'EX$(',TK_HEXS,$00			; HEX$(
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 150 - 12/13/2023 15:59:9


 8702/    63A3 :                        TAB_ASCI
 8703/    63A3 :                        KEY_IF
 8704/    63A3 : 468B                   	dc.b	'F',TK_IF					; IF
 8705/    63A5 :                        KEY_INC
 8706/    63A5 : 4E43 93                	dc.b	'NC',TK_INC					; INC
 8707/    63A8 :                        KEY_INPUT
 8708/    63A8 : 4E50 5554 84           	dc.b	'NPUT',TK_INPUT				; INPUT
 8709/    63AD :                        KEY_INT
 8710/    63AD : 4E54 28C0              	dc.b	'NT(',TK_INT				; INT(
 8711/    63B1 : 00                     	dc.b	$00
 8712/    63B2 :                        TAB_ASCL
 8713/    63B2 :                        KEY_LCASES
 8714/    63B2 : 4341 5345 2428 D5      	dc.b	'CASE$(',TK_LCASES			; LCASE$(
 8715/    63B9 :                        KEY_LEEK
 8716/    63B9 : 4545 4B28 CF           	dc.b	'EEK(',TK_LEEK				; LEEK(
 8717/    63BE :                        KEY_LEFTS
 8718/    63BE : 4546 5424 28E1         	dc.b	'EFT$(',TK_LEFTS				; LEFT$(
 8719/    63C4 :                        KEY_LEN
 8720/    63C4 : 454E 28D0              	dc.b	'EN(',TK_LEN				; LEN(
 8721/    63C8 :                        KEY_LET
 8722/    63C8 : 4554 87                	dc.b	'ET',TK_LET					; LET
 8723/    63CB :                        KEY_LIST
 8724/    63CB : 4953 54A0              	dc.b	'IST',TK_LIST				; LIST
 8725/    63CF :                        KEY_LOAD
 8726/    63CF : 4F41 4495              	dc.b	'OAD',TK_LOAD				; LOAD
 8727/    63D3 :                        KEY_LOG
 8728/    63D3 : 4F47 28C7              	dc.b	'OG(',TK_LOG				; LOG(
 8729/    63D7 :                        KEY_LOKE
 8730/    63D7 : 4F4B 459A              	dc.b	'OKE',TK_LOKE				; LOKE
 8731/    63DB :                        KEY_LOOP
 8732/    63DB : 4F4F 509D              	dc.b	'OOP',TK_LOOP				; LOOP
 8733/    63DF : 00                     	dc.b	$00
 8734/    63E0 :                        TAB_ASCM
 8735/    63E0 :                        KEY_MAX
 8736/    63E0 : 4158 28DA              	dc.b	'AX(',TK_MAX				; MAX(
 8737/    63E4 :                        KEY_MIDS
 8738/    63E4 : 4944 2428 E3           	dc.b	'ID$(',TK_MIDS				; MID$(
 8739/    63E9 :                        KEY_MIN
 8740/    63E9 : 494E 28DB              	dc.b	'IN(',TK_MIN				; MIN(
 8741/    63ED : 00                     	dc.b	$00
 8742/    63EE :                        TAB_ASCN
 8743/    63EE :                        KEY_NEW
 8744/    63EE : 4557 A2                	dc.b	'EW',TK_NEW					; NEW
 8745/    63F1 :                        KEY_NEXT
 8746/    63F1 : 4558 5482              	dc.b	'EXT',TK_NEXT				; NEXT
 8747/    63F5 :                        KEY_NOT
 8748/    63F5 : 4F54 AE                	dc.b	'OT',TK_NOT					; NOT
 8749/    63F8 :                        KEY_NULL
 8750/    63F8 : 554C 4C92              	dc.b	'ULL',TK_NULL				; NULL
 8751/    63FC : 00                     	dc.b	$00
 8752/    63FD :                        TAB_ASCO
 8753/    63FD :                        KEY_ON
 8754/    63FD : 4E91                   	dc.b	'N',TK_ON					; ON
 8755/    63FF :                        KEY_OR
 8756/    63FF : 52B9                   	dc.b	'R',TK_OR					; OR
 8757/    6401 : 00                     	dc.b	$00
 8758/    6402 :                        TAB_ASCP
 8759/    6402 :                        KEY_PEEK
 8760/    6402 : 4545 4B28 CD           	dc.b	'EEK(',TK_PEEK				; PEEK(
 8761/    6407 :                        KEY_PI
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 151 - 12/13/2023 15:59:9


 8762/    6407 : 49DD                   	dc.b	'I',TK_PI					; PI
 8763/    6409 :                        KEY_POKE
 8764/    6409 : 4F4B 4598              	dc.b	'OKE',TK_POKE				; POKE
 8765/    640D :                        KEY_POS
 8766/    640D : 4F53 28C4              	dc.b	'OS(',TK_POS				; POS(
 8767/    6411 :                        KEY_PRINT
 8768/    6411 : 5249 4E54 9E           	dc.b	'RINT',TK_PRINT				; PRINT
 8769/    6416 : 00                     	dc.b	$00
 8770/    6417 :                        TAB_ASCR
 8771/    6417 :                        KEY_RAM
 8772/    6417 : 414D 4241 5345 DC      	dc.b	'AMBASE',TK_RAM				; RAMBASE
 8773/    641E :                        KEY_READ
 8774/    641E : 4541 4486              	dc.b	'EAD',TK_READ				; READ
 8775/    6422 :                        KEY_REM
 8776/    6422 : 454D 8F                	dc.b	'EM',TK_REM					; REM
 8777/    6425 :                        KEY_RESTORE
 8778/    6425 : 4553 544F 5245 8C      	dc.b	'ESTORE',TK_RESTORE			; RESTORE
 8779/    642C :                        KEY_RETURN
 8780/    642C : 4554 5552 4E8E         	dc.b	'ETURN',TK_RETURN				; RETURN
 8781/    6432 :                        KEY_RIGHTS
 8782/    6432 : 4947 4854 2428 E2      	dc.b	'IGHT$(',TK_RIGHTS			; RIGHT$(
 8783/    6439 :                        KEY_RND
 8784/    6439 : 4E44 28C6              	dc.b	'ND(',TK_RND				; RND(
 8785/    643D :                        KEY_RUN
 8786/    643D : 554E 8A                	dc.b	'UN',TK_RUN					; RUN
 8787/    6440 : 00                     	dc.b	$00
 8788/    6441 :                        TAB_ASCS
 8789/    6441 :                        KEY_SADD
 8790/    6441 : 4144 4428 E0           	dc.b	'ADD(',TK_SADD				; SADD(
 8791/    6446 :                        KEY_SAVE
 8792/    6446 : 4156 4596              	dc.b	'AVE',TK_SAVE				; SAVE
 8793/    644A :                        KEY_SGN
 8794/    644A : 474E 28BF              	dc.b	'GN(',TK_SGN				; SGN(
 8795/    644E :                        KEY_SIN
 8796/    644E : 494E 28CA              	dc.b	'IN(',TK_SIN				; SIN(
 8797/    6452 :                        KEY_SPC
 8798/    6452 : 5043 28AC              	dc.b	'PC(',TK_SPC				; SPC(
 8799/    6456 :                        KEY_SQR
 8800/    6456 : 5152 28C5              	dc.b	'QR(',TK_SQR				; SQR(
 8801/    645A :                        KEY_STEP
 8802/    645A : 5445 50AF              	dc.b	'TEP',TK_STEP				; STEP
 8803/    645E :                        KEY_STOP
 8804/    645E : 544F 5090              	dc.b	'TOP',TK_STOP				; STOP
 8805/    6462 :                        KEY_STRS
 8806/    6462 : 5452 2428 D1           	dc.b	'TR$(',TK_STRS				; STR$(
 8807/    6467 :                        KEY_SWAP
 8808/    6467 : 5741 50A5              	dc.b	'WAP',TK_SWAP				; SWAP
 8809/    646B : 00                     	dc.b	$00
 8810/    646C :                        TAB_ASCT
 8811/    646C :                        KEY_TAB
 8812/    646C : 4142 28A8              	dc.b	'AB(',TK_TAB				; TAB(
 8813/    6470 :                        KEY_TAN
 8814/    6470 : 414E 28CB              	dc.b	'AN(',TK_TAN				; TAN
 8815/    6474 :                        KEY_THEN
 8816/    6474 : 4845 4EAD              	dc.b	'HEN',TK_THEN				; THEN
 8817/    6478 :                        KEY_TO
 8818/    6478 : 4FAA                   	dc.b	'O',TK_TO					; TO
 8819/    647A :                        KEY_TWOPI
 8820/    647A : 574F 5049 DE           	dc.b	'WOPI',TK_TWOPI				; TWOPI
 8821/    647F : 00                     	dc.b	$00
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 152 - 12/13/2023 15:59:9


 8822/    6480 :                        TAB_ASCU
 8823/    6480 :                        KEY_UCASES
 8824/    6480 : 4341 5345 2428 D4      	dc.b	'CASE$(',TK_UCASES			; UCASE$(
 8825/    6487 :                        KEY_UNTIL
 8826/    6487 : 4E54 494C B0           	dc.b	'NTIL',TK_UNTIL				; UNTIL
 8827/    648C :                        KEY_USINGS
 8828/    648C : 5349 4E47 2428 E4      	dc.b	'SING$(',TK_USINGS			; USING$(
 8829/    6493 :                        KEY_USR
 8830/    6493 : 5352 28C2              	dc.b	'SR(',TK_USR				; USR(
 8831/    6497 : 00                     	dc.b	$00
 8832/    6498 :                        TAB_ASCV
 8833/    6498 :                        KEY_VAL
 8834/    6498 : 414C 28D2              	dc.b	'AL(',TK_VAL				; VAL(
 8835/    649C :                        KEY_VPTR
 8836/    649C : 4152 5054 5228 DF      	dc.b	'ARPTR(',TK_VPTR				; VARPTR(
 8837/    64A3 : 00                     	dc.b	$00
 8838/    64A4 :                        TAB_ASCW
 8839/    64A4 :                        KEY_WAIT
 8840/    64A4 : 4149 5494              	dc.b	'AIT',TK_WAIT				; WAIT
 8841/    64A8 :                        KEY_WHILE
 8842/    64A8 : 4849 4C45 B1           	dc.b	'HILE',TK_WHILE				; WHILE
 8843/    64AD :                        KEY_WIDTH
 8844/    64AD : 4944 5448 A3           	dc.b	'IDTH',TK_WIDTH				; WIDTH
 8845/    64B2 : 00                     	dc.b	$00
 8846/    64B3 :                        TAB_POWR
 8847/    64B3 :                        KEY_POWER
 8848/    64B3 : B600                   	dc.b	TK_POWER,$00				; ^
 8849/    64B5 :                        
 8850/    64B5 :                        
 8851/    64B5 :                        ;************************************************************************************
 8852/    64B5 :                        ;
 8853/    64B5 :                        ; just messages
 8854/    64B5 :                        
 8855/    64B5 :                        LAB_BMSG
 8856/    64B5 : 0D0A 4272 6561 6B00    	dc.b	$0D,$0A,'Break',$00
 8857/    64BD :                        LAB_EMSG
 8858/    64BD : 2045 7272 6F72 00      	dc.b	' Error',$00
 8859/    64C4 :                        LAB_LMSG
 8860/    64C4 : 2069 6E20 6C69 6E65    	dc.b	' in line ',$00
          64CC : 2000                  
 8861/    64CE :                        LAB_IMSG
 8862/    64CE : 4578 7472 6120 6967    	dc.b	'Extra ignored',$0D,$0A,$00
          64D6 : 6E6F 7265 640D 0A00   
 8863/    64DE :                        LAB_REDO
 8864/    64DE : 5265 646F 2066 726F    	dc.b	'Redo from start',$0D,$0A,$00
          64E6 : 6D20 7374 6172 740D
          64EE : 0A00                  
 8865/    64F0 :                        LAB_RMSG
 8866/    64F0 : 0D0A 5265 6164 790D    	dc.b	$0D,$0A,'Ready',$0D,$0A,$00
          64F8 : 0A00                  
 8867/    64FA :                        LAB_SMSG
 8868/    64FA : 2042 7974 6573 2066    	dc.b	' Bytes free',$0D,$0A,$0A
          6502 : 7265 650D 0A0A      
 8869/    6508 : 456E 6861 6E63 6564    	dc.b	'Enhanced 68k BASIC Version 3.54',$0D,$0A,$00
          6510 : 2036 386B 2042 4153
          6518 : 4943 2056 6572 7369
          6520 : 6F6E 2033 2E35 340D
          6528 : 0A00                  
 8870/    652A :                        
 8871/    652A : FFFF FFFF FFFF FFFF    	DC.B	[TBSC_CS-*]$FF
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 153 - 12/13/2023 15:59:9


          6532 : FFFF FFFF FFFF FFFF
          653A : FFFF FFFF FFFF FFFF
          6542 : FFFF FFFF FFFF FFFF
          654A : FFFF FFFF FFFF FFFF
          6552 : FFFF FFFF FFFF FFFF
          655A : FFFF FFFF FFFF FFFF
          6562 : FFFF FFFF FFFF FFFF
          656A : FFFF FFFF FFFF FFFF
          6572 : FFFF FFFF FFFF FFFF
          657A : FFFF FFFF FFFF FFFF
          6582 : FFFF FFFF FFFF FFFF
          658A : FFFF FFFF FFFF FFFF
          6592 : FFFF FFFF FFFF FFFF
          659A : FFFF FFFF FFFF FFFF
          65A2 : FFFF FFFF FFFF FFFF
          65AA : FFFF FFFF FFFF FFFF
          65B2 : FFFF FFFF FFFF FFFF
          65BA : FFFF FFFF FFFF FFFF
          65C2 : FFFF FFFF FFFF FFFF
          65CA : FFFF FFFF FFFF FFFF
          65D2 : FFFF FFFF FFFF FFFF
          65DA : FFFF FFFF FFFF FFFF
          65E2 : FFFF FFFF FFFF FFFF
          65EA : FFFF FFFF FFFF FFFF
          65F2 : FFFF FFFF FFFF FFFF
          65FA : FFFF FFFF FFFF      
 8872/    6600 :                        
 8873/    6600 :                        ;************************************************************************************
 8874/    6600 :                        ;
 8875/    6600 :                        ; This lot is in RAM
 8876/    6600 :                        
 8877/    6600 :                        ;    		ORG     ram_addr	; start of RAM
 8878/    6600 :                        ; 
 8879/    6600 :                        ;ram_strt	ds.l	$100		; allow 1K for the stack, this should be plenty
 8880/    6600 :                        ;								; for any BASIC program that doesn't do something
 8881/    6600 :                        ;								; silly, it could even be much less.
 8882/    6600 :                        ;ram_base
 8883/    6600 :                        ;LAB_WARM	ds.w	1			; BASIC warm start entry point
 8884/    6600 :                        ;Wrmjpv		ds.l	1			; BASIC warm start jump vector
 8885/    6600 :                        ;
 8886/    6600 :                        ;Usrjmp		ds.w	1			; USR function JMP address
 8887/    6600 :                        ;Usrjpv		ds.l	1			; USR function JMP vector
 8888/    6600 :                        ;
 8889/    6600 :                        ;; system dependant i/o vectors
 8890/    6600 :                        ;; these are in RAM and are set at start-up
 8891/    6600 :                        ;
 8892/    6600 :                        ;V_INPT		ds.w	1			; non halting scan input device entry point
 8893/    6600 :                        ;V_INPTv		ds.l	1			; non halting scan input device jump vector
 8894/    6600 :                        ;
 8895/    6600 :                        ;V_OUTP		ds.w	1			; send byte to output device entry point
 8896/    6600 :                        ;V_OUTPv		ds.l	1			; send byte to output device jump vector
 8897/    6600 :                        ;
 8898/    6600 :                        ;V_LOAD		ds.w	1			; load BASIC program entry point
 8899/    6600 :                        ;V_LOADv		ds.l	1			; load BASIC program jump vector
 8900/    6600 :                        ;
 8901/    6600 :                        ;V_SAVE		ds.w	1			; save BASIC program entry point
 8902/    6600 :                        ;V_SAVEv		ds.l	1			; save BASIC program jump vector
 8903/    6600 :                        ;
 8904/    6600 :                        ;V_CTLC		ds.w	1			; save CTRL-C check entry point
 8905/    6600 :                        ;V_CTLCv		ds.l	1			; save CTRL-C check jump vector
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 154 - 12/13/2023 15:59:9


 8906/    6600 :                        ;
 8907/    6600 :                        ;Itemp		ds.l	1			; temporary integer	(for GOTO etc)
 8908/    6600 :                        ;
 8909/    6600 :                        ;Smeml		ds.l	1			; start of memory		(start of program)
 8910/    6600 :                        ;
 8911/    6600 :                        ;; the program is stored as a series of lines each line having the following format
 8912/    6600 :                        ;;
 8913/    6600 :                        ;;		ds.l	1			; pointer to the next line or $00000000 if [EOT]
 8914/    6600 :                        ;;		ds.l	1			; line number
 8915/    6600 :                        ;;		ds.b	n			; program bytes
 8916/    6600 :                        ;;		dc.b	$00			; [EOL] marker, there will be a second $00 byte, if
 8917/    6600 :                        ;;						; needed, to pad the line to an even number of bytes
 8918/    6600 :                        ;
 8919/    6600 :                        ;Sfncl		ds.l	1			; start of functions	(end of Program)
 8920/    6600 :                        ;
 8921/    6600 :                        ;; the functions are stored as function name, function execute pointer and function
 8922/    6600 :                        ;; variable name
 8923/    6600 :                        ;;
 8924/    6600 :                        ;;		ds.l	1			; name
 8925/    6600 :                        ;;		ds.l	1			; execute pointer
 8926/    6600 :                        ;;		ds.l	1			; function variable
 8927/    6600 :                        ;
 8928/    6600 :                        ;Svarl		ds.l	1			; start of variables	(end of functions)
 8929/    6600 :                        ;
 8930/    6600 :                        ;; the variables are stored as variable name, variable value
 8931/    6600 :                        ;;
 8932/    6600 :                        ;;		ds.l	1			; name
 8933/    6600 :                        ;;		ds.l	1			; packed float or integer value
 8934/    6600 :                        ;
 8935/    6600 :                        ;Sstrl		ds.l	1			; start of strings	(end of variables)
 8936/    6600 :                        ;
 8937/    6600 :                        ;; the strings are stored as string name, string pointer and string length
 8938/    6600 :                        ;;
 8939/    6600 :                        ;;		ds.l	1			; name
 8940/    6600 :                        ;;		ds.l	1			; string pointer
 8941/    6600 :                        ;;		ds.w	1			; string length
 8942/    6600 :                        ;
 8943/    6600 :                        ;Sarryl		ds.l	1			; start of arrays		(end of strings)
 8944/    6600 :                        ;
 8945/    6600 :                        ;; the arrays are stored as array name, array size, array dimensions count, array
 8946/    6600 :                        ;; dimensions upper bounds and array elements
 8947/    6600 :                        ;;
 8948/    6600 :                        ;;		ds.l	1			; name
 8949/    6600 :                        ;;		ds.l	1			; size including this header
 8950/    6600 :                        ;;		ds.w	1			; dimensions count
 8951/    6600 :                        ;;		ds.w	1			; 1st dimension upper bound
 8952/    6600 :                        ;;		ds.w	1			; 2nd dimension upper bound
 8953/    6600 :                        ;;		...				; ...
 8954/    6600 :                        ;;		ds.w	1			; nth dimension upper bound
 8955/    6600 :                        ;;
 8956/    6600 :                        ;; then (i1+1)*(i2+1)...*(in+1) of either ..
 8957/    6600 :                        ;;
 8958/    6600 :                        ;;		ds.l	1			; packed float or integer value
 8959/    6600 :                        ;;
 8960/    6600 :                        ;; .. if float or integer, or ..
 8961/    6600 :                        ;;
 8962/    6600 :                        ;;		ds.l	1			; string pointer
 8963/    6600 :                        ;;		ds.w	1			; string length
 8964/    6600 :                        ;;
 8965/    6600 :                        ;; .. if string
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 155 - 12/13/2023 15:59:9


 8966/    6600 :                        ;
 8967/    6600 :                        ;Earryl		ds.l	1			; end of arrays		(start of free mem)
 8968/    6600 :                        ;Sstorl		ds.l	1			; string storage		(moving down)
 8969/    6600 :                        ;Ememl		ds.l	1			; end of memory		(upper bound of RAM)
 8970/    6600 :                        ;Sutill		ds.l	1			; string utility ptr
 8971/    6600 :                        ;Clinel		ds.l	1			; current line		(Basic line number)
 8972/    6600 :                        ;Blinel		ds.l	1			; break line		(Basic line number)
 8973/    6600 :                        ;
 8974/    6600 :                        ;Cpntrl		ds.l	1			; continue pointer
 8975/    6600 :                        ;Dlinel		ds.l	1			; current DATA line
 8976/    6600 :                        ;Dptrl		ds.l	1			; DATA pointer
 8977/    6600 :                        ;Rdptrl		ds.l	1			; read pointer
 8978/    6600 :                        ;Varname		ds.l	1			; current var name
 8979/    6600 :                        ;Cvaral		ds.l	1			; current var address
 8980/    6600 :                        ;Lvarpl		ds.l	1			; variable pointer for LET and FOR/NEXT
 8981/    6600 :                        ;
 8982/    6600 :                        ;des_sk_e	ds.l	6			; descriptor stack end address
 8983/    6600 :                        ;des_sk							; descriptor stack start address
 8984/    6600 :                        ;								; use a4 for the descriptor pointer
 8985/    6600 :                        ;			ds.w	1			
 8986/    6600 :                        ;Ibuffs		ds.l	$40			; start of input buffer
 8987/    6600 :                        ;Ibuffe
 8988/    6600 :                        ;								; end of input buffer
 8989/    6600 :                        ;
 8990/    6600 :                        ;FAC1_m		ds.l	1			; FAC1 mantissa1
 8991/    6600 :                        ;FAC1_e		ds.w	1			; FAC1 exponent
 8992/    6600 :                        ;FAC1_s		EQU	FAC1_e+1		; FAC1 sign (b7)
 8993/    6600 :                        ;			ds.w	1			
 8994/    6600 :                        ;
 8995/    6600 :                        ;FAC2_m		ds.l	1			; FAC2 mantissa1
 8996/    6600 :                        ;FAC2_e		ds.l	1			; FAC2 exponent
 8997/    6600 :                        ;FAC2_s		EQU	FAC2_e+1		; FAC2 sign (b7)
 8998/    6600 :                        ;FAC_sc		EQU	FAC2_e+2		; FAC sign comparison, Acc#1 vs #2
 8999/    6600 :                        ;flag		EQU	FAC2_e+3		; flag byte for divide routine
 9000/    6600 :                        ;
 9001/    6600 :                        ;PRNlword	ds.l	1			; PRNG seed long word
 9002/    6600 :                        ;
 9003/    6600 :                        ;ut1_pl		ds.l	1			; utility pointer 1
 9004/    6600 :                        ;
 9005/    6600 :                        ;Asptl		ds.l	1			; array size/pointer
 9006/    6600 :                        ;Astrtl		ds.l	1			; array start pointer
 9007/    6600 :                        ;
 9008/    6600 :                        ;numexp		EQU	Astrtl			; string to float number exponent count
 9009/    6600 :                        ;expcnt		EQU	Astrtl+1		; string to float exponent count
 9010/    6600 :                        ;
 9011/    6600 :                        ;expneg		EQU	Astrtl+3		; string to float eval exponent -ve flag
 9012/    6600 :                        ;
 9013/    6600 :                        ;func_l		ds.l	1			; function pointer
 9014/    6600 :                        ;
 9015/    6600 :                        ;
 9016/    6600 :                        ;								; these two need to be a word aligned pair !
 9017/    6600 :                        ;Defdim		ds.w	1			; default DIM flag
 9018/    6600 :                        ;cosout		EQU	Defdim			; flag which CORDIC output (re-use byte)
 9019/    6600 :                        ;Dtypef		EQU	Defdim+1		; data type flag, $80=string, $40=integer, $00=float
 9020/    6600 :                        ;
 9021/    6600 :                        ;
 9022/    6600 :                        ;Binss		ds.l	4			; number to bin string start (32 chrs)
 9023/    6600 :                        ;
 9024/    6600 :                        ;Decss		ds.l	1			; number to decimal string start (16 chrs)
 9025/    6600 :                        ;			ds.w	1
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 156 - 12/13/2023 15:59:9


 9026/    6600 :                        ;Usdss		ds.w	1			; unsigned decimal string start (10 chrs)
 9027/    6600 :                        ;
 9028/    6600 :                        ;Hexss		ds.l	2			; number to hex string start (8 chrs)
 9029/    6600 :                        ;
 9030/    6600 :                        ;BHsend		ds.w	1			; bin/decimal/hex string end
 9031/    6600 :                        ;
 9032/    6600 :                        ;
 9033/    6600 :                        ;prstk		ds.b	1			; stacked function index
 9034/    6600 :                        ;
 9035/    6600 :                        ;tpower		ds.b	1			; remember CORDIC power
 9036/    6600 :                        ;
 9037/    6600 :                        ;Asrch		ds.b	1			; scan-between-quotes flag, alt search character
 9038/    6600 :                        ;
 9039/    6600 :                        ;Dimcnt		ds.b	1			; # of dimensions
 9040/    6600 :                        ;
 9041/    6600 :                        ;Breakf		ds.b	1			; break flag, $00=END else=break
 9042/    6600 :                        ;Oquote		ds.b	1			; open quote flag (Flag: DATA; LIST; memory)
 9043/    6600 :                        ;Gclctd		ds.b	1			; garbage collected flag
 9044/    6600 :                        ;Sufnxf		ds.b	1			; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
 9045/    6600 :                        ;Imode		ds.b	1			; input mode flag, $00=INPUT, $98=READ
 9046/    6600 :                        ;
 9047/    6600 :                        ;Cflag		ds.b	1			; comparison evaluation flag
 9048/    6600 :                        ;
 9049/    6600 :                        ;TabSiz		ds.b	1			; TAB step size
 9050/    6600 :                        ;
 9051/    6600 :                        ;comp_f		ds.b	1			; compare function flag, bits 0,1 and 2 used
 9052/    6600 :                        ;								; bit 2 set if >
 9053/    6600 :                        ;								; bit 1 set if =
 9054/    6600 :                        ;								; bit 0 set if <
 9055/    6600 :                        ;
 9056/    6600 :                        ;Nullct		ds.b	1			; nulls output after each line
 9057/    6600 :                        ;TPos		ds.b	1			; BASIC terminal position byte
 9058/    6600 :                        ;TWidth		ds.b	1			; BASIC terminal width byte
 9059/    6600 :                        ;Iclim		ds.b	1			; input column limit
 9060/    6600 :                        ;ccflag		ds.b	1			; CTRL-C check flag
 9061/    6600 :                        ;ccbyte		ds.b	1			; CTRL-C last received byte
 9062/    6600 :                        ;ccnull		ds.b	1			; CTRL-C last received byte 'life' timer
 9063/    6600 :                        ;
 9064/    6600 :                        ;
 9065/    6600 :                        ;prg_strt
 9066/    6600 :                        
 9067/    6600 :                        ;************************************************************************************
 9068/    6600 :                        ; EhBASIC keywords quick reference list												*
 9069/    6600 :                        ;************************************************************************************
 9070/    6600 :                        
 9071/    6600 :                        ; glossary
 9072/    6600 :                        
 9073/    6600 :                        ;		<.>		  required
 9074/    6600 :                        ;		{.|.}		  one of required
 9075/    6600 :                        ;		[.]		  optional
 9076/    6600 :                        ;		...		  may repeat as last
 9077/    6600 :                        
 9078/    6600 :                        ;		any		= anything
 9079/    6600 :                        ;		num		= number
 9080/    6600 :                        ;		state		= statement
 9081/    6600 :                        ;		n		= positive integer
 9082/    6600 :                        ;		str		= string
 9083/    6600 :                        ;		var		= variable
 9084/    6600 :                        ;		nvar		= numeric variable
 9085/    6600 :                        ;		svar		= string variable
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 157 - 12/13/2023 15:59:9


 9086/    6600 :                        ;		expr		= expression
 9087/    6600 :                        ;		nexpr		= numeric expression
 9088/    6600 :                        ;		sexpr		= string expression
 9089/    6600 :                        
 9090/    6600 :                        ; statement separator
 9091/    6600 :                        
 9092/    6600 :                        ; :			. [<state>] : [<state>]							; done
 9093/    6600 :                        
 9094/    6600 :                        ; number bases
 9095/    6600 :                        
 9096/    6600 :                        ; %			. %<binary num>								; done
 9097/    6600 :                        ; $			. $<hex num>								; done
 9098/    6600 :                        
 9099/    6600 :                        ; commands
 9100/    6600 :                        
 9101/    6600 :                        ; END		. END										; done
 9102/    6600 :                        ; FOR		. FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]	; done
 9103/    6600 :                        ; NEXT		. NEXT [<nvar>[,<nvar>]...]						; done
 9104/    6600 :                        ; DATA		. DATA [{num|["]str["]}[,{num|["]str["]}]...]	; done
 9105/    6600 :                        ; INPUT		. INPUT [<">str<">;] <var>[,<var>[,<var>]...]	; done
 9106/    6600 :                        ; DIM		. DIM <var>(<nexpr>[,<nexpr>[,<nexpr>]])		; done
 9107/    6600 :                        ; READ		. READ <var>[,<var>[,<var>]...]				; done
 9108/    6600 :                        ; LET		. [LET] <var>=<expr>						; done
 9109/    6600 :                        ; DEC		. DEC <nvar>[,<nvar>[,<nvar>]...]			; done
 9110/    6600 :                        ; GOTO		. GOTO <n>									; done
 9111/    6600 :                        ; RUN		. RUN [<n>]									; done
 9112/    6600 :                        ; IF		. IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]	; done
 9113/    6600 :                        ; RESTORE	. RESTORE [<n>]								; done
 9114/    6600 :                        ; GOSUB		. GOSUB <n>									; done
 9115/    6600 :                        ; RETURN	. RETURN									; done
 9116/    6600 :                        ; REM		. REM [<any>]								; done
 9117/    6600 :                        ; STOP		. STOP										; done
 9118/    6600 :                        ; ON		. ON <nexpr>{GOTO|GOSUB}<n>[,<n>[,<n>]...]	; done
 9119/    6600 :                        ; NULL		. NULL <nexpr>								; done
 9120/    6600 :                        ; INC		. INC <nvar>[,<nvar>[,<nvar>]...]			; done
 9121/    6600 :                        ; WAIT		. WAIT <nexpr>,<nexpr>[,<nexpr>]			; done
 9122/    6600 :                        ; LOAD		. LOAD [<sexpr>]							; done for sim
 9123/    6600 :                        ; SAVE		. SAVE [<sexpr>][,[<n>][-<n>]]				; done for sim
 9124/    6600 :                        ; DEF		. DEF FN<var>(<var>)=<expr>					; done
 9125/    6600 :                        ; POKE		. POKE <nexpr>,<nexpr>						; done
 9126/    6600 :                        ; DOKE		. DOKE <nexpr>,<nexpr>						; done
 9127/    6600 :                        ; LOKE		. LOKE <nexpr>,<nexpr>						; done
 9128/    6600 :                        ; CALL		. CALL <nexpr>								; done
 9129/    6600 :                        ; DO		. DO										; done
 9130/    6600 :                        ; LOOP		. LOOP [{WHILE|UNTIL}<nexpr>]				; done
 9131/    6600 :                        ; PRINT		. PRINT [{;|,}][<expr>][{;|,}[<expr>]...]	; done
 9132/    6600 :                        ; CONT		. CONT										; done
 9133/    6600 :                        ; LIST		. LIST [<n>][-<n>]							; done
 9134/    6600 :                        ; CLEAR		. CLEAR										; done
 9135/    6600 :                        ; NEW		. NEW										; done
 9136/    6600 :                        ; WIDTH		. WIDTH [<n>][,<n>]							; done
 9137/    6600 :                        ; GET		. GET <var>									; done
 9138/    6600 :                        ; SWAP		. SWAP <var>,<var>							; done
 9139/    6600 :                        ; BITSET	. BITSET <nexpr>,<nexpr>					; done
 9140/    6600 :                        ; BITCLR	. BITCLR <nexpr>,<nexpr>					; done
 9141/    6600 :                        
 9142/    6600 :                        ; sub commands (may not start a statement)
 9143/    6600 :                        
 9144/    6600 :                        ; TAB		. TAB(<nexpr>)								; done
 9145/    6600 :                        ; ELSE		. IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]	; done
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 158 - 12/13/2023 15:59:9


 9146/    6600 :                        ; TO		. FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]			; done
 9147/    6600 :                        ; FN		. FN <var>(<expr>)							; done
 9148/    6600 :                        ; SPC		. SPC(<nexpr>)								; done
 9149/    6600 :                        ; THEN		. IF <nexpr> {THEN <{n|comm}>|GOTO <n>}		; done
 9150/    6600 :                        ; NOT		. NOT <nexpr>								; done
 9151/    6600 :                        ; STEP		. FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]			; done
 9152/    6600 :                        ; UNTIL		. LOOP [{WHILE|UNTIL}<nexpr>]				; done
 9153/    6600 :                        ; WHILE		. LOOP [{WHILE|UNTIL}<nexpr>]				; done
 9154/    6600 :                        
 9155/    6600 :                        ; operators
 9156/    6600 :                        
 9157/    6600 :                        ; +			. [expr] + <expr>							; done
 9158/    6600 :                        ; -			. [nexpr] - <nexpr>							; done
 9159/    6600 :                        ; *			. <nexpr>	; <nexpr>						; done fast hardware
 9160/    6600 :                        ; /			. <nexpr> / <nexpr>							; done fast hardware
 9161/    6600 :                        ; ^			. <nexpr> ^ <nexpr>							; done
 9162/    6600 :                        ; AND		. <nexpr> AND <nexpr>						; done
 9163/    6600 :                        ; EOR		. <nexpr> EOR <nexpr>						; done
 9164/    6600 :                        ; OR		. <nexpr> OR <nexpr>						; done
 9165/    6600 :                        ; >>		. <nexpr> >> <nexpr>						; done
 9166/    6600 :                        ; <<		. <nexpr> << <nexpr>						; done
 9167/    6600 :                        
 9168/    6600 :                        ; compare functions
 9169/    6600 :                        
 9170/    6600 :                        ; <			. <expr> < <expr>							; done
 9171/    6600 :                        ; =			. <expr> = <expr>							; done
 9172/    6600 :                        ; >			. <expr> > <expr>							; done
 9173/    6600 :                        
 9174/    6600 :                        ; functions
 9175/    6600 :                        
 9176/    6600 :                        ; SGN		. SGN(<nexpr>)								; done
 9177/    6600 :                        ; INT		. INT(<nexpr>)								; done
 9178/    6600 :                        ; ABS		. ABS(<nexpr>)								; done
 9179/    6600 :                        ; USR		. USR(<expr>)								; done
 9180/    6600 :                        ; FRE		. FRE(<expr>)								; done
 9181/    6600 :                        ; POS		. POS(<expr>)								; done
 9182/    6600 :                        ; SQR		. SQR(<nexpr>)								; done fast shift/sub
 9183/    6600 :                        ; RND		. RND(<nexpr>)								; done 32 bit PRNG
 9184/    6600 :                        ; LOG		. LOG(<nexpr>)								; done fast cordic
 9185/    6600 :                        ; EXP		. EXP(<nexpr>)								; done fast cordic
 9186/    6600 :                        ; COS		. COS(<nexpr>)								; done fast cordic
 9187/    6600 :                        ; SIN		. SIN(<nexpr>)								; done fast cordic
 9188/    6600 :                        ; TAN		. TAN(<nexpr>)								; done fast cordic
 9189/    6600 :                        ; ATN		. ATN(<nexpr>)								; done fast cordic
 9190/    6600 :                        ; PEEK		. PEEK(<nexpr>)								; done
 9191/    6600 :                        ; DEEK		. DEEK(<nexpr>)								; done
 9192/    6600 :                        ; LEEK		. LEEK(<nexpr>)								; done
 9193/    6600 :                        ; LEN		. LEN(<sexpr>)								; done
 9194/    6600 :                        ; STR$		. STR$(<nexpr>)								; done
 9195/    6600 :                        ; VAL		. VAL(<sexpr>)								; done
 9196/    6600 :                        ; ASC		. ASC(<sexpr>)								; done
 9197/    6600 :                        ; UCASE$	. UCASE$(<sexpr>)							; done
 9198/    6600 :                        ; LCASE$	. LCASE$(<sexpr>)							; done
 9199/    6600 :                        ; CHR$		. CHR$(<nexpr>)								; done
 9200/    6600 :                        ; HEX$		. HEX$(<nexpr>)								; done
 9201/    6600 :                        ; BIN$		. BIN$(<nexpr>)								; done
 9202/    6600 :                        ; BTST		. BTST(<nexpr>,<nexpr>)						; done
 9203/    6600 :                        ; MAX		. MAX(<nexpr>[,<nexpr>[,<nexpr>]...])		; done
 9204/    6600 :                        ; MIN		. MIN(<nexpr>[,<nexpr>[,<nexpr>]...])		; done
 9205/    6600 :                        ; PI		. PI										; done
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 159 - 12/13/2023 15:59:9


 9206/    6600 :                        ; TWOPI		. TWOPI										; done
 9207/    6600 :                        ; VARPTR	. VARPTR(<var>)								; done
 9208/    6600 :                        ; SADD		. SADD(<svar>)								; done
 9209/    6600 :                        ; LEFT$		. LEFT$(<sexpr>,<nexpr>)					; done
 9210/    6600 :                        ; RIGHT$	. RIGHT$(<sexpr>,<nexpr>)					; done
 9211/    6600 :                        ; MID$		. MID$(<sexpr>,<nexpr>[,<nexpr>])			; done
 9212/    6600 :                        ; USING$	. USING$(<sexpr>,<nexpr>[,<nexpr>]...])		; done
 9213/    6600 :                        
 9214/    6600 :                        
 9215/    6600 :                        ;************************************************************************************
 9216/    6600 :                        
 9217/    6600 :                        	END	code_start
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 160 - 12/13/2023 15:59:9


  Symbol Table (* = unused):
  --------------------------

 AC1GTAC2 :                    4AFA C |  ACIAC :                       E001 - |
 ACIAD :                       E000 - |
*ARCHITECTURE :                                        "i386-unknown-win32" - |
 ASPTL :                        5A8 C |  ASRCH :                        5DA C |
 ASTRTL :                       5AC C |  BHSEND :                       5D6 C |
 BIN2DEC :                     5ABE C |  BINPR :                       56A4 C |
 BINSS :                        5B6 C |  BLINEL :                       456 C |
 BREAKF :                       5DC C | *CASESENSITIVE :                  0 - |
 CCBYTE :                       5E9 C |  CCFLAG :                       5E8 C |
 CCNULL :                       5EA C |  CFLAG :                        5E1 C |
 CLINEL :                       452 C |  CO0 :                         3010 C |
 CODE_START :                  3054 C |  COMP_F :                       5E3 C |
*CONSTPI :        3.141592653589793 - |  COSOUT :                       5B4 - |
 CPNTRL :                       45A C | *CVARAL :                       46E C |
 D1X02 :                       5A98 C |  D1X10 :                       5AAE C |
 D1X16 :                       5A8A C | *DATE :                "12/13/2023" - |
 DECSS :                        5C6 C |  DEFDIM :                       5B4 C |
 DES_SK :                       48E C |  DES_SK_E :                     476 C |
 DIMCNT :                       5DB C |  DLINEL :                       45E C |
 DOCMP :                       36FA C |  DOREST :                      36E6 C |
 DPTRL :                        462 C |  DTYPEF :                       5B5 - |
 EARRYL :                       442 C |  EBSC_CS :                     3000 - |
 EMEML :                        44A C |  ENDBHS :                      567E C |
 EXPCNT :                       5AD - |  EXPNEG :                       5AF - |
 FAC1_E :                       594 C |  FAC1_M :                       590 C |
 FAC1_S :                       595 - |  FAC2_E :                       59C C |
 FAC2_M :                       598 C |  FAC2_S :                       59D - |
 FAC_SC :                       59E - | *FALSE :                          0 - |
 FEND :                           8 - |  FLAG :                         59F - |
*FLASH_SUPPORT :                  0 - |  FSD :                            0 - |
 FSDC :                           A - |  FSDPI :                          8 - |
 FSLI :                           6 - |  FSTI :                           4 - |
*FULLPMMU :                       1 - |  FUNC_L :                       5B0 C |
 GCLCTD :                       5DE C |  GETFIRST :                    3ED2 C |
 GETPAIR :                     3F8E C |  GOPR :                        56AE C |
*HAS64 :                          0 - | *HASFPU :                         0 - |
*HASPMMU :                        0 - |  HEXSS :                        5CE C |
 IBUFFE :                       590 C |  IBUFFS :                       490 C |
 ICLIM :                        5E7 C |  IMODE :                        5E0 C |
 INGET :                       5702 C | *INSUPMODE :                      1 - |
 ITEMP :                        42A C |  KEY_ABS :                     631E C |
 KEY_AND :                     6322 C |  KEY_ASC :                     6325 C |
 KEY_ATN :                     6329 C |  KEY_BINS :                    632E C |
 KEY_BITCLR :                  6333 C |  KEY_BITSET :                  6339 C |
 KEY_BITTST :                  633F C |  KEY_CALL :                    6347 C |
 KEY_CHRS :                    634B C |  KEY_CLEAR :                   6350 C |
 KEY_CONT :                    6355 C |  KEY_COS :                     6359 C |
 KEY_DATA :                    635E C |  KEY_DEC :                     6362 C |
 KEY_DEEK :                    6365 C |  KEY_DEF :                     636A C |
 KEY_DIM :                     636D C |  KEY_DIV :                     6310 C |
 KEY_DO :                      6374 C |  KEY_DOKE :                    6370 C |
 KEY_ELSE :                    6377 C |  KEY_END :                     637B C |
 KEY_EOR :                     637E C |  KEY_EQUAL :                   6316 C |
 KEY_EXP :                     6381 C |  KEY_FN :                      6389 C |
 KEY_FOR :                     6386 C |  KEY_FRE :                     638B C |
 KEY_GET :                     6390 C |  KEY_GOSUB :                   6397 C |
 KEY_GOTO :                    6393 C |  KEY_GT :                      631A C |
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 161 - 12/13/2023 15:59:9


 KEY_HEXS :                    639D C |  KEY_IF :                      63A3 C |
 KEY_INC :                     63A5 C |  KEY_INPUT :                   63A8 C |
 KEY_INT :                     63AD C |  KEY_LCASES :                  63B2 C |
 KEY_LEEK :                    63B9 C |  KEY_LEFTS :                   63BE C |
 KEY_LEN :                     63C4 C |  KEY_LET :                     63C8 C |
 KEY_LIST :                    63CB C |  KEY_LOAD :                    63CF C |
 KEY_LOG :                     63D3 C |  KEY_LOKE :                    63D7 C |
 KEY_LOOP :                    63DB C |  KEY_LSHIFT :                  6312 C |
 KEY_LT :                      6314 C |  KEY_MAX :                     63E0 C |
 KEY_MIDS :                    63E4 C |  KEY_MIN :                     63E9 C |
 KEY_MINUS :                   630E C |  KEY_MULT :                    630A C |
 KEY_NEW :                     63EE C |  KEY_NEXT :                    63F1 C |
 KEY_NOT :                     63F5 C |  KEY_NULL :                    63F8 C |
 KEY_ON :                      63FD C |  KEY_OR :                      63FF C |
 KEY_PEEK :                    6402 C |  KEY_PI :                      6407 C |
 KEY_PLUS :                    630C C |  KEY_POKE :                    6409 C |
 KEY_POS :                     640D C |  KEY_POWER :                   64B3 C |
 KEY_PRINT :                   6411 C |  KEY_RAM :                     6417 C |
 KEY_READ :                    641E C |  KEY_REM :                     6422 C |
 KEY_RESTORE :                 6425 C |  KEY_RETURN :                  642C C |
 KEY_RIGHTS :                  6432 C |  KEY_RND :                     6439 C |
 KEY_RSHIFT :                  6318 C |  KEY_RUN :                     643D C |
 KEY_SADD :                    6441 C |  KEY_SAVE :                    6446 C |
 KEY_SGN :                     644A C |  KEY_SIN :                     644E C |
 KEY_SPC :                     6452 C |  KEY_SQR :                     6456 C |
 KEY_STEP :                    645A C |  KEY_STOP :                    645E C |
 KEY_STRS :                    6462 C |  KEY_SWAP :                    6467 C |
 KEY_TAB :                     646C C |  KEY_TAN :                     6470 C |
 KEY_THEN :                    6474 C |  KEY_TO :                      6478 C |
 KEY_TWOPI :                   647A C |  KEY_UCASES :                  6480 C |
 KEY_UNTIL :                   6487 C |  KEY_USINGS :                  648C C |
 KEY_USR :                     6493 C |  KEY_VAL :                     6498 C |
 KEY_VPTR :                    649C C |  KEY_WAIT :                    64A4 C |
 KEY_WHILE :                   64A8 C |  KEY_WIDTH :                   64AD C |
 KFCTSEED :                26A3D110 - |  LAB_11A5 :                    3BA0 C |
 LAB_11A6 :                    3BA2 C |  LAB_11BD :                    3BAE C |
 LAB_1269 :                    318A C |  LAB_1274 :                    3198 C |
 LAB_127D :                    31A0 C |  LAB_127E :                    31AE C |
 LAB_1295 :                    31C2 C |  LAB_12AE :                    31E4 C |
 LAB_12B0 :                    31E6 C |  LAB_12E6 :                    3206 C |
 LAB_12FF :                    3238 C |  LAB_1301 :                    323A C |
 LAB_1303 :                    3258 C |  LAB_1325 :                    3270 C |
 LAB_132E :                    3260 C |  LAB_1330 :                    3262 C |
 LAB_134B :                    327E C |  LAB_1357 :                    329C C |
 LAB_1359 :                    32A2 C |  LAB_1374 :                    32C2 C |
 LAB_1378 :                    32C8 C |  LAB_137F :                    32D4 C |
 LAB_138E :                    32DA C |  LAB_1392 :                    32DE C |
 LAB_13A6 :                    3312 C |  LAB_13AC :                    331A C |
 LAB_13C6 :                    3344 C |  LAB_13CC :                    334A C |
 LAB_13D6 :                    336C C |  LAB_13D8 :                    3372 C |
 LAB_13EA :                    337E C |  LAB_13EC :                    3380 C |
 LAB_13FF :                    3398 C |  LAB_1401 :                    339C C |
 LAB_1408 :                    33A8 C |  LAB_1410 :                    33B4 C |
 LAB_1417 :                    33BE C |  LAB_141B :                    33C0 C |
 LAB_141F :                    33D0 C |  LAB_142A :                    33D6 C |
 LAB_142C :                    33E2 C |  LAB_145E :                    33FC C |
 LAB_145F :                    33EE C |  LAB_1463 :                    3404 C |
 LAB_1477 :                    3410 C |  LAB_147A :                    3416 C |
*LAB_1480 :                    3430 C |  LAB_1491 :                    343A C |
 LAB_14BD :                    346C C |  LAB_14C0 :                    3470 C |
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 162 - 12/13/2023 15:59:9


 LAB_14D4 :                    3490 C | *LAB_14E2 :                    34AC C |
 LAB_150C :                    34BA C |  LAB_1519 :                    34CA C |
 LAB_152E :                    34D6 C |  LAB_1540 :                    3502 C |
 LAB_15B3 :                    3562 C |  LAB_15C2 :                    358C C |
 LAB_15D1 :                    3598 C |  LAB_15DC :                    3574 C |
 LAB_15F6 :                    3586 C |  LAB_15FF :                    35A6 C |
 LAB_1602 :                    35AA C |  LAB_1624 :                    362E C |
 LAB_1629 :                    35CE C |  LAB_1636 :                    35D2 C |
 LAB_1639 :                    35D8 C |  LAB_163B :                    35E4 C |
 LAB_1647 :                    35F0 C |  LAB_164F :                    35F6 C |
 LAB_16B0 :                    368E C |  LAB_16D0 :                    36B2 C |
 LAB_1723 :                    374C C |  LAB_1725 :                    3750 C |
 LAB_172C :                    373C C |  LAB_172D :                    3744 C |
 LAB_174B :                    3778 C |  LAB_174E :                    379C C |
 LAB_1750 :                    37A8 C |  LAB_1752 :                    37B4 C |
 LAB_1754 :                    37CC C | *LAB_1756 :                    37B8 C |
 LAB_176C :                    37EA C |  LAB_1773 :                    37F4 C |
 LAB_1785 :                    3810 C |  LAB_1786 :                    383C C |
 LAB_17B7 :                    3852 C |  LAB_17B8 :                    384E C |
 LAB_17D5 :                    38CE C |  LAB_17D6 :                    38D2 C |
*LAB_1810 :                    38E4 C |  LAB_1811 :                    38F4 C |
 LAB_1813 :                    38FA C |  LAB_1829 :                    3932 C |
 LAB_182C :                    3936 C |  LAB_1831 :                    393C C |
 LAB_185E :                    397C C |  LAB_1866 :                    3980 C |
 LAB_1880 :                    3A42 C |  LAB_1886 :                    3A4C C |
 LAB_188A :                    3A50 C |  LAB_188B :                    398E C |
 LAB_1898 :                    399C C |  LAB_18A2 :                    39A6 C |
 LAB_18B7 :                    39C8 C |  LAB_18B8 :                    39D4 C |
 LAB_18BD :                    39DA C |  LAB_18C3 :                    39E4 C |
 LAB_18C6 :                    39E8 C |  LAB_18CD :                    39F2 C |
 LAB_18E3 :                    39FC C |  LAB_18F0 :                    3A1C C |
 LAB_18F7 :                    3A2A C |  LAB_18F9 :                    3A2E C |
 LAB_1904 :                    3A54 C |  LAB_1913 :                    3A66 C |
 LAB_1934 :                    3A8C C |  LAB_1953 :                    3AA0 C |
 LAB_195B :                    3AA8 C | *LAB_1961 :                    3AB2 C |
 LAB_1984 :                    3AD2 C |  LAB_1985 :                    3AD6 C |
 LAB_1986 :                    3ADA C |  LAB_1999 :                    3AEE C |
 LAB_19B0 :                    3B00 C |  LAB_19B6 :                    3B10 C |
 LAB_19C2 :                    3B20 C |  LAB_19DD :                    3B34 C |
 LAB_19F6 :                    3B54 C |  LAB_1A03 :                    3B62 C |
 LAB_1A0E :                    3B72 C |  LAB_1A1B :                    3B78 C |
 LAB_1A46 :                    3B92 C |  LAB_1A90 :                    3C10 C |
 LAB_1A9B :                    3C1E C |  LAB_1ABA :                    3C48 C |
 LAB_1ACD :                    3C74 C |  LAB_1ADB :                    3C80 C |
 LAB_1ADE :                    3C84 C |  LAB_1AE0 :                    3C9A C |
 LAB_1AFA :                    3CB4 C |  LAB_1B0B :                    3CCA C |
 LAB_1B13 :                    3CD2 C |  LAB_1B1C :                    3CE2 C |
 LAB_1B1D :                    3CE4 C |  LAB_1B2A :                    3CF6 C |
 LAB_1B3C :                    3D12 C |  LAB_1B43 :                    3C58 C |
 LAB_1B78 :                    3D1E C |  LAB_1B7B :                    3D22 C |
 LAB_1B7D :                    3D24 C |  LAB_1B84 :                    3D2E C |
 LAB_1B86 :                    3D32 C |  LAB_1B9D :                    3D56 C |
 LAB_1BC1 :                    3D86 C |  LAB_1BD0 :                    3DF6 C |
 LAB_1BE7 :                    3E10 C |  LAB_1BF3 :                    3D92 C |
 LAB_1BF7 :                    3D98 C |  LAB_1BFB :                    3D9C C |
 LAB_1C01 :                    3DA4 C |  LAB_1C11 :                    3DCE C |
 LAB_1C13 :                    3DD4 C |  LAB_1C18 :                    3DDC C |
 LAB_1C19 :                    3DE0 C |  LAB_1C1A :                    3DF0 C |
 LAB_1C2A :                    3E4E C |  LAB_1CAE :                    3EF6 C |
 LAB_1CB5 :                    3F14 C |  LAB_1CD4 :                    3F1E C |
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 163 - 12/13/2023 15:59:9


 LAB_1CD5 :                    3F24 C |  LAB_1CD6 :                    3F26 C |
 LAB_1CDB :                    3F36 C |  LAB_1CE6 :                    3F28 C |
 LAB_1CF2 :                    3F38 C |  LAB_1CFE :                    3F4E C |
 LAB_1D10 :                    3FC6 C |  LAB_1D12 :                    3FCA C |
 LAB_1D2D :                    3FDC C |  LAB_1D2E :                    3FE8 C |
 LAB_1D44 :                    4004 C |  LAB_1D45 :                    4014 C |
 LAB_1D48 :                    4028 C |  LAB_1D49 :                    4030 C |
 LAB_1D4A :                    4034 C |  LAB_1D4B :                    4044 C |
 LAB_1D5D :                    404C C |  LAB_1D5E :                    4052 C |
 LAB_1D83 :                    3FB6 C |  LAB_1D8A :                    3FB0 C |
 LAB_1D94 :                    4066 C | *LAB_1D96 :                    5DB4 C |
*LAB_1D98 :                    4070 C |  LAB_1DAC :                    408A C |
 LAB_1DAE :                    408C C |  LAB_1DAF :                    4098 C |
 LAB_1DB0 :                    40A6 C |  LAB_1DB1 :                    40AA C |
 LAB_1DB2 :                    40AE C |  LAB_1DD7 :                    40C6 C |
 LAB_1DE6 :                    40E0 C |  LAB_1E17 :                    4122 C |
 LAB_1E1F :                    4128 C |  LAB_1E5C :                    4162 C |
 LAB_1E8D :                    417E C |  LAB_1EA1 :                    419A C |
 LAB_1EC0 :                    41C2 C |  LAB_1ED6 :                    41EE C |
 LAB_1ED8 :                    41FC C |  LAB_1EDF :                    41B6 C |
 LAB_1F07 :                    420E C |  LAB_1F28 :                    4228 C |
 LAB_1F2C :                    422E C |  LAB_1F5A :                    423C C |
 LAB_1F6A :                    4264 C |  LAB_1F6B :                    4270 C |
 LAB_1F7C :                    4276 C |  LAB_1FB4 :                    42A4 C |
 LAB_1FD0 :                    42D0 C |  LAB_201E :                    432A C |
 LAB_2043 :                    4378 C |  LAB_2044 :                    43AA C |
 LAB_2045 :                    43B4 C |  LAB_204S :                    437A C |
 LAB_204T :                    43A8 C |  LAB_20AE :                    43C6 C |
 LAB_20B4 :                    43CA C |  LAB_20BE :                    43D0 C |
 LAB_20C9 :                    43F4 C |  LAB_20CB :                    43E0 C |
 LAB_20D0 :                    43E8 C |  LAB_20D8 :                    43FE C |
 LAB_20E0 :                    4406 C |  LAB_2115 :                    4426 C |
 LAB_2117 :                    443E C |  LAB_2128 :                    4458 C |
 LAB_2137 :                    445C C |  LAB_214B :                    447C C |
 LAB_2161 :                    4492 C |  LAB_2176 :                    449A C |
 LAB_217E :                    44A8 C |  LAB_2183 :                    44C2 C |
 LAB_218B :                    44CA C |  LAB_218F :                    44CC C |
 LAB_21C2 :                    44D8 C |  LAB_21C4 :                    44DE C |
 LAB_21D1 :                    4512 C |  LAB_2206 :                    4518 C |
 LAB_2212 :                    4540 C |  LAB_2216 :                    4502 C |
 LAB_2240 :                    450A C |  LAB_224D :                    4546 C |
 LAB_224E :                    455C C |  LAB_229E :                    45A0 C |
 LAB_22A0 :                    45AC C |  LAB_22B6 :                    45BA C |
 LAB_22BA :                    45BE C |  LAB_22BD :                    45C8 C |
 LAB_22E6 :                    45E2 C | *LAB_2316 :                    4622 C |
 LAB_2317 :                    4624 C |  LAB_231C :                    4628 C |
 LAB_2358 :                    465C C |  LAB_2368 :                    467C C |
 LAB_2441 :                    4870 C |  LAB_2445 :                    4874 C |
 LAB_2467 :                    48C4 C |  LAB_2468 :                    48C8 C |
 LAB_249C :                    48B6 C |  LAB_24A8 :                    48CC C |
 LAB_24B4 :                    48F6 C |  LAB_24D0 :                    4902 C |
 LAB_24D5 :                    490E C |  LAB_24D6 :                    4928 C |
 LAB_24D7 :                    4936 C |  LAB_24D8 :                    493C C |
 LAB_24D9 :                    491C C |  LAB_24DA :                    4942 C |
 LAB_24F7 :                    48E6 C |  LAB_24F8 :                    48EC C |
 LAB_2778 :                    4BAA C |  LAB_277C :                    4BAC C |
 LAB_279B :                    4BD0 C |  LAB_27BA :                    4BDE C |
 LAB_27C3 :                    4BFA C |  LAB_27C4 :                    4C04 C |
 LAB_27CA :                    4C0A C |  LAB_27CE :                    4C12 C |
 LAB_27D0 :                    4C16 C |  LAB_27DB :                    4C24 C |
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 164 - 12/13/2023 15:59:9


 LAB_27F0 :                    4EE8 C |  LAB_27F1 :                    4EFE C |
 LAB_27F2 :                    4F04 C |  LAB_27F3 :                    4F06 C |
 LAB_27FA :                    4C3C C |  LAB_2828 :                    4C5C C |
*LAB_282E :                    4C62 C |  LAB_282F :                    4C64 C |
 LAB_2831 :                    4C68 C |  LAB_284G :                    4C8C C |
 LAB_284H :                    4C9E C |  LAB_284J :                    4CA0 C |
 LAB_284L :                    4C94 C |  LAB_2887 :                    58AC C |
 LAB_289A :                    58D6 C |  LAB_289C :                    58DC C |
 LAB_289D :                    58E2 C |  LAB_28FD :                    58FE C |
 LAB_28FE :                    5904 C |  LAB_28FF :                    590A C |
 LAB_2900 :                    5918 C |  LAB_2901 :                    591E C |
 LAB_2902 :                    5970 C |  LAB_2903 :                    5978 C |
 LAB_2904 :                    597A C |  LAB_2953 :                    4CC2 C |
 LAB_295E :                    4CCE C |  LAB_2967 :                    4CDA C |
 LAB_2968 :                    4CE2 C |  LAB_2969 :                    4CF4 C |
 LAB_296A :                    4CFE C |  LAB_2970 :                    4D14 C |
 LAB_2978 :                    4D24 C |  LAB_2989 :                    4D34 C |
 LAB_299C :                    4D88 C |  LAB_29A7 :                    4DB0 C |
 LAB_29B7 :                    4DC8 C |  LAB_29B9 :                    4D60 C |
 LAB_29C0 :                    4DD6 C |  LAB_29C3 :                    4DEE C |
 LAB_29D9 :                    4E0A C |  LAB_29E4 :                    4E1C C |
 LAB_29F7 :                    4E30 C |  LAB_29FB :                    4E34 C |
 LAB_29FD :                    4E3C C |  LAB_2A18 :                    4E4C C |
 LAB_2A1A :                    4E4E C |  LAB_2A21 :                    4E56 C |
 LAB_2A3B :                    4E78 C |  LAB_2A4B :                    4E86 C |
 LAB_2A58 :                    4E9A C |  LAB_2A68 :                    4EB2 C |
 LAB_2A74 :                    4EBE C |  LAB_2A89 :                    4EDA C |
 LAB_2A8C :                    4EDE C |  LAB_2A91 :                    4EE4 C |
 LAB_2A9A :                    5F58 C |  LAB_2A9B :                    5F74 C |
 LAB_2X01 :                    5936 C |  LAB_2X02 :                    593E C |
 LAB_2X03 :                    594C C |  LAB_2X04 :                    5952 C |
 LAB_2X05 :                    5968 C |  LAB_2Y01 :                    5988 C |
 LAB_2Y02 :                    5990 C |  LAB_2Y03 :                    599C C |
 LAB_2Y04 :                    59A2 C |  LAB_3216 :                    4B44 C |
 LAB_32_16 :                   4B42 C |  LAB_ABER :                    314C C |
 LAB_ABS :                     4C34 C |  LAB_AD :                      62EB C |
 LAB_ADD :                     4892 C |  LAB_ADER :                    3118 C |
 LAB_AND :                     3ECA C |  LAB_ASC :                     4706 C |
 LAB_ATCD :                    5288 C |  LAB_ATGO :                    5244 C |
 LAB_ATLE :                    5262 C |  LAB_ATN :                     5226 C |
 LAB_ATNP :                    5282 C |  LAB_AYFC :                    42B0 C |
 LAB_BAER :                    6172 C |  LAB_BHCB :                    3EB0 C |
 LAB_BHSS :                    3E8A C |  LAB_BINS :                    5660 C |
 LAB_BITCLR :                  52EA C |  LAB_BITSET :                  52DA C |
 LAB_BMSG :                    64B5 C |  LAB_BS :                      6214 C |
 LAB_BTST :                    52FA C |  LAB_CALL :                    4850 C |
 LAB_CASC :                    3FA0 C |  LAB_CATN :                    528E C |
*LAB_CAUC :                    3FA6 C |  LAB_CBIN :                    5A5C C |
 LAB_CBX1 :                    5A76 C |  LAB_CBXN :                    5A64 C |
 LAB_CCER :                    3130 C |  LAB_CHEX :                    59FA C |
 LAB_CHRS :                    45EC C |  LAB_CHX1 :                    5A20 C |
 LAB_CHX2 :                    5A44 C |  LAB_CHX3 :                    5A3C C |
 LAB_CHXX :                    5A02 C |  LAB_CKRN :                    42D8 C |
 LAB_CKTM :                    3C3A C |  LAB_CLEAR :                   3454 C |
 LAB_CN :                      6281 C |  LAB_COLD :                    3060 C |
 LAB_CONT :                    3640 C |  LAB_CORD :                    51B8 C |
 LAB_COS :                     5148 C |  LAB_CRLF :                    3986 C |
 LAB_CTBL :                    5E3C C |  LAB_CTNM :                    3C38 C |
 LAB_D0 :                      6232 C |  LAB_D002 :                    55C4 C |
 LAB_D00A :                    55D4 C |  LAB_D00E :                    55E4 C |
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 165 - 12/13/2023 15:59:9


 LAB_DATA :                    372E C |  LAB_DD :                      6221 C |
 LAB_DDER :                    3148 C |  LAB_DEC :                     3842 C |
 LAB_DECI :                    38A2 C |  LAB_DEEK :                    47CE C |
 LAB_DEF :                     42E2 C |  LAB_DIM :                     3F52 C |
 LAB_DIV0 :                    4B3C C |  LAB_DIVIDE :                  4AC2 C |
 LAB_DIVX :                    4B12 C |  LAB_DO :                      3672 C |
 LAB_DOKE :                    47F8 C |  LAB_DUPFMT :                  55AC C |
 LAB_DZER :                    3144 C |  LAB_EMSG :                    64BD C |
 LAB_END :                     35DA C |  LAB_EOR :                     3EBA C |
 LAB_EQUAL :                   3EE0 C |  LAB_ESML :                    505E C |
 LAB_EVBY :                    471E C |  LAB_EVEX :                    3C4E C |
 LAB_EVEZ :                    3C50 C |  LAB_EVIN :                    40EC C |
 LAB_EVIR :                    40FC C |  LAB_EVNM :                    3C36 C |
 LAB_EVPI :                    40F4 C |  LAB_EX1 :                     4F96 C |
 LAB_EXAD :                    50E8 C |  LAB_EXCC :                    50CE C |
 LAB_EXCM :                    5000 C |  LAB_EXNN :                    50BA C |
 LAB_EXOF :                    4FBA C |  LAB_EXOL :                    4FD0 C |
 LAB_EXOU :                    4FA6 C |  LAB_EXP :                     4FDA C |
 LAB_EXPL :                    50B4 C |  LAB_EXPS :                    5012 C |
 LAB_EXRN :                    50C0 C |  LAB_EXXF :                    5A4A C |
 LAB_FB95 :                    5712 C |  LAB_FBA0 :                    56F6 C |
 LAB_FC :                      61DB C |  LAB_FCER :                    315C C |
 LAB_FO :                      62F3 C |  LAB_FOER :                    3114 C |
 LAB_FOR :                     350E C |  LAB_FRE :                     429A C |
 LAB_FTBL :                    5ED8 C |  LAB_FTPP :                    5E8C C |
 LAB_FVAR :                    3FBE C |  LAB_GADB :                    4772 C |
 LAB_GADW :                    4786 C |  LAB_GARB :                    4472 C |
 LAB_GBYT :                    3DB0 C |  LAB_GEAD :                    47A6 C |
 LAB_GET :                     3900 C |  LAB_GETS :                    391A C |
 LAB_GFPN :                    3804 C |  LAB_GOSUB :                   3684 C |
 LAB_GOTO :                    3696 C |  LAB_GOTS :                    36A6 C |
 LAB_GSCH :                    3626 C |  LAB_GTBY :                    471A C |
 LAB_GTHAN :                   4F88 C |  LAB_GTWO :                    4730 C |
 LAB_GVAL :                    3D5C C |  LAB_GVAR :                    3FC0 C |
 LAB_HEXS :                    56B2 C |  LAB_ID :                      6241 C |
 LAB_IDER :                    3140 C |  LAB_IF :                      3756 C |
 LAB_IGBY :                    3DAE C |  LAB_IMSG :                    64CE C |
 LAB_INC :                     3848 C |  LAB_INCI :                    3898 C |
 LAB_INCT :                    388A C |  LAB_INLN :                    3292 C |
 LAB_INPUT :                   3A74 C |  LAB_INT :                     4CA6 C |
 LAB_IRTS :                    4CC0 C |  LAB_ISHN :                    5A1C C |
 LAB_KEYT :                    5FDE C |  LAB_LAAD :                    49BC C |
 LAB_LCASE :                   4684 C |  LAB_LD :                      62A3 C |
 LAB_LDER :                    3128 C |  LAB_LEEK :                    47E4 C |
 LAB_LEFT :                    45FC C |  LAB_LENS :                    46FE C |
 LAB_LET :                     38A6 C |  LAB_LIST :                    3458 C |
 LAB_LMSG :                    64C4 C |  LAB_LOAD :                    4848 C |
 LAB_LOCC :                    49C2 C |  LAB_LOCX :                    49DE C |
 LAB_LOG :                     4944 C |  LAB_LOKE :                    47FE C |
 LAB_LOLP :                    49CC C |  LAB_LONE :                    49FA C |
 LAB_LONN :                    49E2 C |  LAB_LOOP :                    36C4 C |
 LAB_LOWZ :                    4A34 C |  LAB_LOXO :                    4A00 C |
 LAB_LOXP :                    49F0 C |  LAB_LRMS :                    3E68 C |
 LAB_LS :                      625E C |  LAB_LSHIFT :                  3F5E C |
 LAB_LTHAN :                   3EEA C |  LAB_LTPF :                    51C8 C |
 LAB_LTPT :                    51D8 C |  LAB_LT_1 :                    4B50 C |
 LAB_MADD :                    4A62 C |  LAB_MAN1 :                    4B36 C |
 LAB_MAX :                     571E C |  LAB_MAXN :                    572A C |
 LAB_MIDS :                    4640 C |  LAB_MIN :                     5734 C |
 LAB_MINN :                    5740 C | *LAB_MKCHR :                   45F0 C |
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 166 - 12/13/2023 15:59:9


 LAB_MMEC :                    574A C |  LAB_MNOC :                    4A5C C |
 LAB_MUEX :                    4AB0 C | *LAB_MUF1 :                    4A8C C |
 LAB_MUF2 :                    4A96 C |  LAB_MUF3 :                    4AAC C |
 LAB_MULTIPLY :                4A36 C |  LAB_MUUF :                    4AB6 C |
 LAB_NB1T :                    4B88 C |  LAB_NEW :                     3402 C |
 LAB_NEXT :                    3B80 C |  LAB_NF :                      61A2 C |
 LAB_NFER :                    316C C |  LAB_NI :                      62FA C |
 LAB_NOST :                    392C C |  LAB_NSTT :                    57B0 C |
 LAB_NULL :                    3636 C |  LAB_OD :                      61CF C |
 LAB_ODER :                    3160 C |  LAB_OFER :                    3158 C |
 LAB_OM :                      61F2 C |  LAB_OMER :                    3154 C |
 LAB_ON :                      37D0 C |  LAB_OPPT :                    5F24 C |
 LAB_OR :                      3EC2 C |  LAB_OV :                      61E9 C |
 LAB_P004 :                    5602 C |  LAB_P008 :                    5618 C |
 LAB_P00C :                    5620 C |  LAB_P00E :                    562C C |
 LAB_P010 :                    5630 C |  LAB_P018 :                    564A C |
 LAB_P01A :                    564E C |  LAB_P01E :                    5656 C |
 LAB_PEEK :                    47BC C |  LAB_PFAC :                    4B92 C |
 LAB_PHFA :                    575A C |  LAB_PI :                      588C C |
 LAB_POKE :                    47C8 C |  LAB_POON :                    4F08 C |
 LAB_POS :                     42CC C |  LAB_POWER :                   4F24 C |
 LAB_POWP :                    4F56 C |  LAB_POZE :                    4F18 C |
 LAB_PPBI :                    3E5E C |  LAB_PPFN :                    3E50 C |
 LAB_PPFS :                    3E42 C |  LAB_PRINT :                   393A C |
 LAB_PRNA :                    39FE C |  LAB_PROCFO :                  55EA C |
 LAB_P_10 :                    5BCE C |  LAB_RAM :                     5882 C |
 LAB_READ :                    3A9A C |  LAB_REDO :                    64DE C |
 LAB_REM :                     37C8 C |  LAB_REMM :                    4B68 C |
 LAB_RESS :                    361A C |  LAB_RESTORE :                 3608 C |
 LAB_RET0 :                    59E8 C |  LAB_RETURN :                  371A C |
 LAB_RG :                      61BA C |  LAB_RGER :                    3164 C |
 LAB_RIGHT :                   4610 C |  LAB_RMSG :                    64F0 C |
 LAB_RND :                     50F4 C |  LAB_RSED :                    5AE6 C |
 LAB_RSHIFT :                  3F6E C |  LAB_RTN0 :                    59EA C |
 LAB_RTST :                    440C C |  LAB_RUN :                     365E C |
 LAB_RUNN :                    366C C |  LAB_SADD :                    46E6 C |
 LAB_SAVE :                    484C C |  LAB_SCCA :                    3DA6 C |
 LAB_SCER :                    3134 C |  LAB_SCGB :                    3DA0 C |
 LAB_SCL0 :                    51AE C |  LAB_SCLN :                    33F0 C |
 LAB_SCZE :                    51A0 C |  LAB_SET1 :                    4B1A C |
 LAB_SGBY :                    4716 C |  LAB_SGN :                     4C22 C |
 LAB_SIN :                     5160 C |  LAB_SLER :                    3138 C |
 LAB_SMSG :                    64FA C |  LAB_SN :                      61B3 C |
 LAB_SNBS :                    3734 C |  LAB_SNER :                    3168 C |
 LAB_SQE1 :                    5834 C |  LAB_SQE2 :                    583A C |
 LAB_SQNA :                    5862 C |  LAB_SQNS :                    584C C |
 LAB_SQR :                     5810 C |  LAB_SSLN :                    33E8 C |
 LAB_ST :                      626E C |  LAB_STOP :                    35E2 C |
 LAB_STRS :                    43C2 C |  LAB_SUBTRACT :                487E C |
 LAB_SVAR :                    3FBC C |  LAB_SVTB :                    57E2 C |
 LAB_SWAP :                    4812 C |  LAB_TAN :                     5126 C |
 LAB_TBSZ :                    57C2 C |  LAB_TM :                      6250 C |
 LAB_TMER :                    313C C |  LAB_TWOPI :                   589C C |
 LAB_U002 :                    5352 C |  LAB_U004 :                    53A8 C |
 LAB_U005 :                    53B8 C |  LAB_U006 :                    53BA C |
 LAB_U008 :                    53CE C |  LAB_U009 :                    53F0 C |
 LAB_U00A :                    53F8 C |  LAB_U00B :                    5402 C |
 LAB_U00C :                    5416 C |  LAB_U00D :                    541A C |
 LAB_U00E :                    542C C |  LAB_U00F :                    5438 C |
 LAB_U010 :                    543C C |  LAB_U014 :                    5442 C |
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 167 - 12/13/2023 15:59:9


 LAB_U018 :                    544A C |  LAB_U01C :                    5460 C |
 LAB_U020 :                    546C C |  LAB_U022 :                    5472 C |
 LAB_U026 :                    5482 C |  LAB_U02A :                    548C C |
 LAB_U02B :                    54A4 C |  LAB_U02C :                    54AA C |
 LAB_U02E :                    54BC C |  LAB_U030 :                    54C0 C |
 LAB_U034 :                    54D6 C |  LAB_U036 :                    54DC C |
 LAB_U038 :                    54E4 C |  LAB_U03C :                    54EC C |
 LAB_U03E :                    54F2 C |  LAB_U040 :                    550A C |
 LAB_U044 :                    551A C |  LAB_U046 :                    5542 C |
 LAB_U048 :                    5544 C |  LAB_U04A :                    554E C |
 LAB_U04C :                    5580 C |  LAB_UA :                      62C6 C |
 LAB_UCASE :                   46B4 C |  LAB_UDER :                    3120 C |
 LAB_UF :                      6290 C |  LAB_UFAC :                    4B76 C |
 LAB_UFER :                    312C C |  LAB_US :                      6200 C |
 LAB_USER :                    3150 C |  LAB_USINGS :                  5328 C |
 LAB_USR :                     4840 C |  LAB_UV :                      62B3 C |
 LAB_UVER :                    3124 C |  LAB_VAL :                     4744 C |
 LAB_VALZ :                    476C C | *LAB_VARCALL :                 5874 C |
 LAB_VARPTR :                  5872 C |  LAB_WAIT :                    485A C |
 LAB_WARM :                     400 C |  LAB_WD :                      62DA C |
 LAB_WDER :                    311C C |  LAB_WDLP :                    57F6 C |
 LAB_WDTH :                    5790 C |  LAB_XDIV :                    4B2A C |
 LAB_XERR :                    316E C |  LAB_XGADW :                   47A0 C |
 LC_LOOP :                     469A C | *LISTON :                         1 - |
 LOOPALWAYS :                  3700 C |  LOOPDONE :                    3714 C |
 LVARPL :                       472 C |  L_DDIV :                      4B70 C |
 L_DIVRND :                    4B1E C | *MACEXP :                         7 - |
 MAINLOOP :                    51F0 C | *MOMCPU :                     68000 - |
*MOMCPUNAME :               "68000" - | *N :                              2 - |
*NESTMAX :                      100 - |  NEXTA :                       5202 C |
 NEXTB1 :                      5670 C |  NEXTB2 :                      5696 C |
 NEXTH1 :                      56C2 C |  NEXTPRN :                     5102 C |
 NINC0 :                       510A C |  NINC1 :                       5110 C |
*NOBRK :                          0 - |  NOCHR :                       3042 C |
 NOLCASE :                     46DC C |  NOSHIFT :                     3F6A C |
 NOSTRING :                    46E2 C |  NOT2BIG :                     3F82 C |
 NOUCASE :                     46AC C | *NOVAR :                          0 - |
 NULLCT :                       5E4 C |  NUMEXP :                       5AC - |
 OFCHR :                        '#' - |  OQUOTE :                       5DD C |
 OUTLOOP :                     5210 C | *PADDING :                        1 - |
 PRG_STRT :                     5EC C |  PRNLWORD :                     5A0 C |
 PRSTK :                        5D8 C |  RAM_ADDR :                    8000 - |
 RAM_BASE :                     400 C |  RAM_SIZE :                    2000 - |
*RAM_STRT :                       0 C |  RDPTRL :                       466 C |
*RELAXED :                        0 - |  RTS_001 :                     3DCC C |
 RTS_005 :                     3452 C |  RTS_006 :                     3634 C |
 RTS_007 :                     3732 C |  RTS_007A :                    3748 C |
*RTS_008 :                     38FE C |  RTS_009 :                     39FA C |
 RTS_011 :                     4274 C |  RTS_012 :                     4544 C |
 RTS_013 :                     45B8 C |  RTS_015 :                     4810 C |
 RTS_016 :                     48EA C |  RTS_017 :                     4C08 C |
 RTS_020 :                     4F94 C |  RTS_021 :                     52D8 C |
 RTS_022 :                     5700 C |  RTS_023 :                     580E C |
 RTS_024 :                     5A5A C |  RTS_025 :                     5ABC C |
 SARRYL :                       43E C |  SFNCL :                        432 C |
 SMEML :                        42E C |  SSTORL :                       446 C |
 SSTRL :                        43A C |  SUBEXIT :                     521A C |
 SUBLOOP :                     51E8 C |  SUFNXF :                       5DF C |
 SUTILL :                       44E C |  SVARL :                        436 C |
 TABSIZ :                       5E2 C |  TAB_ASCA :                    631E C |
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 168 - 12/13/2023 15:59:9


 TAB_ASCB :                    632E C |  TAB_ASCC :                    6347 C |
 TAB_ASCD :                    635E C |  TAB_ASCE :                    6377 C |
 TAB_ASCF :                    6386 C |  TAB_ASCG :                    6390 C |
 TAB_ASCH :                    639D C |  TAB_ASCI :                    63A3 C |
 TAB_ASCL :                    63B2 C |  TAB_ASCM :                    63E0 C |
 TAB_ASCN :                    63EE C |  TAB_ASCO :                    63FD C |
 TAB_ASCP :                    6402 C |  TAB_ASCR :                    6417 C |
 TAB_ASCS :                    6441 C |  TAB_ASCT :                    646C C |
 TAB_ASCU :                    6480 C |  TAB_ASCV :                    6498 C |
 TAB_ASCW :                    64A4 C |  TAB_ATNC :                    5D3C C |
 TAB_CHRT :                    5F74 C |  TAB_EQUL :                    6316 C |
 TAB_HTHET :                   5DBC C |  TAB_LESS :                    6312 C |
 TAB_MNUS :                    630E C |  TAB_MORE :                    6318 C |
 TAB_PLUS :                    630C C |  TAB_POWR :                    64B3 C |
 TAB_QEST :                    631C C |  TAB_SLAS :                    6310 C |
 TAB_SNCO :                    5CBC C |  TAB_STAR :                    630A C |
 TBSC_CS :                     6600 - | *TIME :                   "15:59:9" - |
 TK_ABS :                        C1 - |  TK_AND :                        B7 - |
 TK_ASC :                        D3 - |  TK_ATN :                        CC - |
 TK_BINS :                       D8 - |  TK_BITCLR :                     A7 - |
 TK_BITSET :                     A6 - |  TK_BITTST :                     D9 - |
 TK_CALL :                       9B - |  TK_CHRS :                       D6 - |
 TK_CLEAR :                      A1 - |  TK_CONT :                       9F - |
 TK_COS :                        C9 - |  TK_DATA :                       83 - |
 TK_DEC :                        88 - |  TK_DEEK :                       CE - |
 TK_DEF :                        97 - |  TK_DIM :                        85 - |
 TK_DIV :                        B5 - |  TK_DO :                         9C - |
 TK_DOKE :                       99 - |  TK_ELSE :                       A9 - |
 TK_END :                        80 - |  TK_EOR :                        B8 - |
 TK_EQUAL :                      BD - |  TK_EXP :                        C8 - |
 TK_FN :                         AB - |  TK_FOR :                        81 - |
 TK_FRE :                        C3 - |  TK_GET :                        A4 - |
 TK_GOSUB :                      8D - |  TK_GOTO :                       89 - |
 TK_GT :                         BC - |  TK_HEXS :                       D7 - |
 TK_IF :                         8B - |  TK_INC :                        93 - |
 TK_INPUT :                      84 - |  TK_INT :                        C0 - |
 TK_LCASES :                     D5 - |  TK_LEEK :                       CF - |
 TK_LEFTS :                      E1 - |  TK_LEN :                        D0 - |
 TK_LET :                        87 - |  TK_LIST :                       A0 - |
 TK_LOAD :                       95 - |  TK_LOG :                        C7 - |
 TK_LOKE :                       9A - |  TK_LOOP :                       9D - |
 TK_LSHIFT :                     BB - |  TK_LT :                         BE - |
 TK_MAX :                        DA - |  TK_MIDS :                       E3 - |
 TK_MIN :                        DB - |  TK_MINUS :                      B3 - |
 TK_MULT :                       B4 - |  TK_NEW :                        A2 - |
 TK_NEXT :                       82 - |  TK_NOT :                        AE - |
 TK_NULL :                       92 - |  TK_ON :                         91 - |
 TK_OR :                         B9 - |  TK_PEEK :                       CD - |
 TK_PI :                         DD - |  TK_PLUS :                       B2 - |
 TK_POKE :                       98 - |  TK_POS :                        C4 - |
 TK_POWER :                      B6 - |  TK_PRINT :                      9E - |
 TK_RAM :                        DC - |  TK_READ :                       86 - |
 TK_REM :                        8F - |  TK_RESTORE :                    8C - |
 TK_RETURN :                     8E - |  TK_RIGHTS :                     E2 - |
 TK_RND :                        C6 - |  TK_RSHIFT :                     BA - |
 TK_RUN :                        8A - |  TK_SADD :                       E0 - |
 TK_SAVE :                       96 - |  TK_SGN :                        BF - |
 TK_SIN :                        CA - |  TK_SPC :                        AC - |
 TK_SQR :                        C5 - |  TK_STEP :                       AF - |
 TK_STOP :                       90 - |  TK_STRS :                       D1 - |
 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 169 - 12/13/2023 15:59:9


 TK_SWAP :                       A5 - |  TK_TAB :                        A8 - |
 TK_TAN :                        CB - |  TK_THEN :                       AD - |
 TK_TO :                         AA - |  TK_TWOPI :                      DE - |
 TK_UCASES :                     D4 - |  TK_UNTIL :                      B0 - |
 TK_USINGS :                     E4 - |  TK_USR :                        C2 - |
 TK_VAL :                        D2 - |  TK_VPTR :                       DF - |
 TK_WAIT :                       94 - |  TK_WHILE :                      B1 - |
 TK_WIDTH :                      A3 - |  TOOBIG :                      3F88 C |
 TPOS :                         5E5 C |  TPOWER :                       5D9 C |
*TRUE :                           1 - |  TWIDTH :                       5E6 C |
 UC_LOOP :                     46CA C |  USDSS :                        5CC C |
 USRJMP :                       406 C | *USRJPV :                       408 C |
*UT1_PL :                       5A4 C |  VARNAME :                      46A C |
 VEC_CC :                      56DC C |  VEC_IN :                      3026 C |
 VEC_LD :                      3048 C |  VEC_OUT :                     300E C |
 VEC_SV :                      304E C | *VERSION :                     142F - |
 V_CTLC :                       424 C | *V_CTLCV :                      426 C |
 V_INPT :                       40C C | *V_INPTV :                      40E C |
 V_LOAD :                       418 C | *V_LOADV :                      41A C |
 V_OUTP :                       412 C | *V_OUTPV :                      414 C |
 V_SAVE :                       41E C | *V_SAVEV :                      420 C |
 WEXIT :                       57E6 C |  WRMJPV :                       402 C |

   1116 symbols
     47 unused symbols

 AS V1.42 Beta [Bld 254] - Source File basic68k.asm - Page 170 - 12/13/2023 15:59:9


  Code Pages:
  ----------

STANDARD (0 changed characters)

1 code page

0.35 seconds assembly time

   9433 lines source file
      6 passes
      0 errors
      0 warnings
