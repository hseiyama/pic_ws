 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 1 - 10/11/2023 16:23:32


       1/       0 :                     ;************************************************************************************
       2/       0 :                     ;										    										*
       3/       0 :                     ;	Enhanced BASIC for the Motorola MC680xx					    					*
       4/       0 :                     ;										    										*
       5/       0 :                     ;	This version is for the TS2 single board computer.		            			*
       6/       0 :                     ;	Jeff Tranter (tranter@pobox.com)					    						*
       7/       0 :                     ;										    										*
       8/       0 :                     ;************************************************************************************
       9/       0 :                     ;										    										*
      10/       0 :                     ;	Copyright(C) 2002-12 by Lee Davison. This program may be freely distributed 	*
      11/       0 :                     ;	for personal use only. All commercial rights are reserved.		    			*
      12/       0 :                     ;										    										*
      13/       0 :                     ;	More 68000 and other projects can be found on my website at ..		    		*
      14/       0 :                     ;										    										*
      15/       0 :                     ;	 http://mycorner.no-ip.org/index.html					    					*
      16/       0 :                     ;										    										*
      17/       0 :                     ;	mail : leeedavison@googlemail.com					    						*
      18/       0 :                     ;										    										*
      19/       0 :                     ;************************************************************************************
      20/       0 :                     
      21/       0 :                     ; Ver 3.54
      22/       0 :                     
      23/       0 :                     ; Ver 3.54 adds experimental support for LOAD/SAVE using Hobbytronics
      24/       0 :                     ; USB Flash Drive Host Board
      25/       0 :                     ; Ver 3.53 fixes math error that affected exponentiation ("^") and
      26/       0 :                     ;  EXP() function. Thanks to joelang for fix.
      27/       0 :                     ; Ver 3.52 stops USING$() from reading beyond the end of the format string
      28/       0 :                     ; Ver 3.51 fixes the UCASE$() and LCASE$() functions for null strings
      29/       0 :                     ; Ver 3.50 unary minus in concatenate generates a type mismatch error
      30/       0 :                     ; Ver 3.49 doesn't tokenise 'DEF' or 'DEC' within a hex value
      31/       0 :                     ; Ver 3.48 allows scientific notation underflow in the USING$() function
      32/       0 :                     ; Ver 3.47 traps the use of array elements as the FOR loop variable
      33/       0 :                     ; Ver 3.46 updates function and function variable handling
      34/       0 :                     
      35/       0 :                     ;************************************************************************************
      36/       0 :                     ;
      37/       0 :                     ; Ver 3.45 makes the handling of non existant variables consistent and gives the
      38/       0 :                     ; option of not returning an error for a non existant variable. If this is the
      39/       0 :                     ; behaviour you want just change novar to some non zero value
      40/       0 :                     
      41/       0 : =$0                 novar		EQU	0					; non existant variables cause errors
      42/       0 :                     
      43/       0 :                     ; Set the symbol FLASH_SUPPORT to 1 if you want to enable experimental
      44/       0 :                     ; support for LOAD/SAVE using a Hobbytronics USB Flash Drive Host
      45/       0 :                     ; Board.
      46/       0 :                     
      47/       0 : =$0                 FLASH_SUPPORT   EQU     0
      48/       0 :                     
      49/       0 :                     ;************************************************************************************
      50/       0 :                     
      51/       0 :                     ; Ver 3.44 adds overflow indication to the USING$() function
      52/       0 :                     ; Ver 3.43 removes an undocumented feature of concatenating null strings
      53/       0 :                     ; Ver 3.42 reimplements backspace so that characters are overwritten with [SPACE]
      54/       0 :                     ; Ver 3.41 removes undocumented features of the USING$() function
      55/       0 :                     ; Ver 3.40 adds the USING$() function
      56/       0 :                     ; Ver 3.33 adds the file requester to LOAD and SAVE
      57/       0 :                     ; Ver 3.32 adds the optional ELSE clause to IF .. THEN
      58/       0 :                     
      59/       0 :                     ;************************************************************************************
      60/       0 :                     ;
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 2 - 10/11/2023 16:23:32


      61/       0 :                     ; Version 3.25 adds the option to change the behaviour of INPUT so that a null
      62/       0 :                     ; response does not cause a program break. If this is the behaviour you want just
      63/       0 :                     ; change nobrk to some non zero value.
      64/       0 :                     
      65/       0 : =$0                 nobrk		EQU	0					; null response to INPUT causes a break
      66/       0 :                     
      67/       0 :                     
      68/       0 :                     ;************************************************************************************
      69/       0 :                     ;
      70/       0 :                     ; Version 3.xx replaces the fixed RAM addressing from previous versions with a RAM
      71/       0 :                     ; pointer in a3. this means that this could now be run as a task on a multitasking
      72/       0 :                     ; system where memory resources may change.
      73/       0 :                     
      74/       0 :                     
      75/       0 :                     ;************************************************************************************
      76/       0 :                     
      77/       0 :                     
      78/       0 :                     	CPU	68030
      79/       0 :                     	SUPMODE	ON
      80/       0 :                     
      81/       0 :                     	ORG	$00000000
      82/       0 :                     
      83/       0 :                     INIVEC:
      84/       0 :                     	;; 0-7
      85/       0 : 0000 4400           	DC.L	ram_addr+ram_base	; Reset: Initial SSP
      86/       4 : 0000 0106           	DC.L	code_start			; Reset: Initial PC
      87/       8 :                     
      88/       8 :                     
      89/       8 :                     	INCLUDE	"basic68k.inc"
(1)    1/       8 :                     
(1)    2/       8 :                     ; This lot is in RAM
(1)    3/       8 :                     
(1)    4/       0 :                         		ORG     $0000			; start of RAM
(1)    5/       0 :                      
(1)    6/       0 :                     ram_strt	ds.l	$100		; allow 1K for the stack, this should be plenty
(1)    7/     400 :                     								; for any BASIC program that doesn't do something
(1)    8/     400 :                     								; silly, it could even be much less.
(1)    9/     400 :                     ram_base
(1)   10/     400 :                     LAB_WARM	ds.w	1			; BASIC warm start entry point
(1)   11/     402 :                     Wrmjpv		ds.l	1			; BASIC warm start jump vector
(1)   12/     406 :                     
(1)   13/     406 :                     Usrjmp		ds.w	1			; USR function JMP address
(1)   14/     408 :                     Usrjpv		ds.l	1			; USR function JMP vector
(1)   15/     40C :                     
(1)   16/     40C :                     ; system dependant i/o vectors
(1)   17/     40C :                     ; these are in RAM and are set at start-up
(1)   18/     40C :                     
(1)   19/     40C :                     V_INPT		ds.w	1			; non halting scan input device entry point
(1)   20/     40E :                     V_INPTv		ds.l	1			; non halting scan input device jump vector
(1)   21/     412 :                     
(1)   22/     412 :                     V_OUTP		ds.w	1			; send byte to output device entry point
(1)   23/     414 :                     V_OUTPv		ds.l	1			; send byte to output device jump vector
(1)   24/     418 :                     
(1)   25/     418 :                     V_LOAD		ds.w	1			; load BASIC program entry point
(1)   26/     41A :                     V_LOADv		ds.l	1			; load BASIC program jump vector
(1)   27/     41E :                     
(1)   28/     41E :                     V_SAVE		ds.w	1			; save BASIC program entry point
(1)   29/     420 :                     V_SAVEv		ds.l	1			; save BASIC program jump vector
(1)   30/     424 :                     
(1)   31/     424 :                     V_CTLC		ds.w	1			; save CTRL-C check entry point
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm(basic68k.inc) - Page 3 - 10/11/2023 16:23:32


(1)   32/     426 :                     V_CTLCv		ds.l	1			; save CTRL-C check jump vector
(1)   33/     42A :                     
(1)   34/     42A :                     Itemp		ds.l	1			; temporary integer	(for GOTO etc)
(1)   35/     42E :                     
(1)   36/     42E :                     Smeml		ds.l	1			; start of memory		(start of program)
(1)   37/     432 :                     
(1)   38/     432 :                     ; the program is stored as a series of lines each line having the following format
(1)   39/     432 :                     ;
(1)   40/     432 :                     ;		ds.l	1			; pointer to the next line or $00000000 if [EOT]
(1)   41/     432 :                     ;		ds.l	1			; line number
(1)   42/     432 :                     ;		ds.b	n			; program bytes
(1)   43/     432 :                     ;		dc.b	$00			; [EOL] marker, there will be a second $00 byte, if
(1)   44/     432 :                     ;						; needed, to pad the line to an even number of bytes
(1)   45/     432 :                     
(1)   46/     432 :                     Sfncl		ds.l	1			; start of functions	(end of Program)
(1)   47/     436 :                     
(1)   48/     436 :                     ; the functions are stored as function name, function execute pointer and function
(1)   49/     436 :                     ; variable name
(1)   50/     436 :                     ;
(1)   51/     436 :                     ;		ds.l	1			; name
(1)   52/     436 :                     ;		ds.l	1			; execute pointer
(1)   53/     436 :                     ;		ds.l	1			; function variable
(1)   54/     436 :                     
(1)   55/     436 :                     Svarl		ds.l	1			; start of variables	(end of functions)
(1)   56/     43A :                     
(1)   57/     43A :                     ; the variables are stored as variable name, variable value
(1)   58/     43A :                     ;
(1)   59/     43A :                     ;		ds.l	1			; name
(1)   60/     43A :                     ;		ds.l	1			; packed float or integer value
(1)   61/     43A :                     
(1)   62/     43A :                     Sstrl		ds.l	1			; start of strings	(end of variables)
(1)   63/     43E :                     
(1)   64/     43E :                     ; the strings are stored as string name, string pointer and string length
(1)   65/     43E :                     ;
(1)   66/     43E :                     ;		ds.l	1			; name
(1)   67/     43E :                     ;		ds.l	1			; string pointer
(1)   68/     43E :                     ;		ds.w	1			; string length
(1)   69/     43E :                     
(1)   70/     43E :                     Sarryl		ds.l	1			; start of arrays		(end of strings)
(1)   71/     442 :                     
(1)   72/     442 :                     ; the arrays are stored as array name, array size, array dimensions count, array
(1)   73/     442 :                     ; dimensions upper bounds and array elements
(1)   74/     442 :                     ;
(1)   75/     442 :                     ;		ds.l	1			; name
(1)   76/     442 :                     ;		ds.l	1			; size including this header
(1)   77/     442 :                     ;		ds.w	1			; dimensions count
(1)   78/     442 :                     ;		ds.w	1			; 1st dimension upper bound
(1)   79/     442 :                     ;		ds.w	1			; 2nd dimension upper bound
(1)   80/     442 :                     ;		...				; ...
(1)   81/     442 :                     ;		ds.w	1			; nth dimension upper bound
(1)   82/     442 :                     ;
(1)   83/     442 :                     ; then (i1+1)*(i2+1)...*(in+1) of either ..
(1)   84/     442 :                     ;
(1)   85/     442 :                     ;		ds.l	1			; packed float or integer value
(1)   86/     442 :                     ;
(1)   87/     442 :                     ; .. if float or integer, or ..
(1)   88/     442 :                     ;
(1)   89/     442 :                     ;		ds.l	1			; string pointer
(1)   90/     442 :                     ;		ds.w	1			; string length
(1)   91/     442 :                     ;
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm(basic68k.inc) - Page 4 - 10/11/2023 16:23:32


(1)   92/     442 :                     ; .. if string
(1)   93/     442 :                     
(1)   94/     442 :                     Earryl		ds.l	1			; end of arrays		(start of free mem)
(1)   95/     446 :                     Sstorl		ds.l	1			; string storage		(moving down)
(1)   96/     44A :                     Ememl		ds.l	1			; end of memory		(upper bound of RAM)
(1)   97/     44E :                     Sutill		ds.l	1			; string utility ptr
(1)   98/     452 :                     Clinel		ds.l	1			; current line		(Basic line number)
(1)   99/     456 :                     Blinel		ds.l	1			; break line		(Basic line number)
(1)  100/     45A :                     
(1)  101/     45A :                     Cpntrl		ds.l	1			; continue pointer
(1)  102/     45E :                     Dlinel		ds.l	1			; current DATA line
(1)  103/     462 :                     Dptrl		ds.l	1			; DATA pointer
(1)  104/     466 :                     Rdptrl		ds.l	1			; read pointer
(1)  105/     46A :                     Varname		ds.l	1			; current var name
(1)  106/     46E :                     Cvaral		ds.l	1			; current var address
(1)  107/     472 :                     Lvarpl		ds.l	1			; variable pointer for LET and FOR/NEXT
(1)  108/     476 :                     
(1)  109/     476 :                     des_sk_e	ds.l	6			; descriptor stack end address
(1)  110/     48E :                     des_sk							; descriptor stack start address
(1)  111/     48E :                     								; use a4 for the descriptor pointer
(1)  112/     48E :                     			ds.w	1			
(1)  113/     490 :                     Ibuffs		ds.l	$40			; start of input buffer
(1)  114/     590 :                     Ibuffe
(1)  115/     590 :                     								; end of input buffer
(1)  116/     590 :                     
(1)  117/     590 :                     FAC1_m		ds.l	1			; FAC1 mantissa1
(1)  118/     594 :                     FAC1_e		ds.w	1			; FAC1 exponent
(1)  119/     596 : =$595               FAC1_s		EQU	FAC1_e+1		; FAC1 sign (b7)
(1)  120/     596 :                     			ds.w	1			
(1)  121/     598 :                     
(1)  122/     598 :                     FAC2_m		ds.l	1			; FAC2 mantissa1
(1)  123/     59C :                     FAC2_e		ds.l	1			; FAC2 exponent
(1)  124/     5A0 : =$59D               FAC2_s		EQU	FAC2_e+1		; FAC2 sign (b7)
(1)  125/     5A0 : =$59E               FAC_sc		EQU	FAC2_e+2		; FAC sign comparison, Acc#1 vs #2
(1)  126/     5A0 : =$59F               flag		EQU	FAC2_e+3		; flag byte for divide routine
(1)  127/     5A0 :                     
(1)  128/     5A0 :                     PRNlword	ds.l	1			; PRNG seed long word
(1)  129/     5A4 :                     
(1)  130/     5A4 :                     ut1_pl		ds.l	1			; utility pointer 1
(1)  131/     5A8 :                     
(1)  132/     5A8 :                     Asptl		ds.l	1			; array size/pointer
(1)  133/     5AC :                     Astrtl		ds.l	1			; array start pointer
(1)  134/     5B0 :                     
(1)  135/     5B0 : =$5AC               numexp		EQU	Astrtl			; string to float number exponent count
(1)  136/     5B0 : =$5AD               expcnt		EQU	Astrtl+1		; string to float exponent count
(1)  137/     5B0 :                     
(1)  138/     5B0 : =$5AF               expneg		EQU	Astrtl+3		; string to float eval exponent -ve flag
(1)  139/     5B0 :                     
(1)  140/     5B0 :                     func_l		ds.l	1			; function pointer
(1)  141/     5B4 :                     
(1)  142/     5B4 :                     
(1)  143/     5B4 :                     								; these two need to be a word aligned pair !
(1)  144/     5B4 :                     Defdim		ds.w	1			; default DIM flag
(1)  145/     5B6 : =$5B4               cosout		EQU	Defdim			; flag which CORDIC output (re-use byte)
(1)  146/     5B6 : =$5B5               Dtypef		EQU	Defdim+1		; data type flag, $80=string, $40=integer, $00=float
(1)  147/     5B6 :                     
(1)  148/     5B6 :                     
(1)  149/     5B6 :                     Binss		ds.l	4			; number to bin string start (32 chrs)
(1)  150/     5C6 :                     
(1)  151/     5C6 :                     Decss		ds.l	1			; number to decimal string start (16 chrs)
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm(basic68k.inc) - Page 5 - 10/11/2023 16:23:32


(1)  152/     5CA :                     			ds.w	1
(1)  153/     5CC :                     Usdss		ds.w	1			; unsigned decimal string start (10 chrs)
(1)  154/     5CE :                     
(1)  155/     5CE :                     Hexss		ds.l	2			; number to hex string start (8 chrs)
(1)  156/     5D6 :                     
(1)  157/     5D6 :                     BHsend		ds.w	1			; bin/decimal/hex string end
(1)  158/     5D8 :                     
(1)  159/     5D8 :                     
(1)  160/     5D8 :                     prstk		ds.b	1			; stacked function index
(1)  161/     5D9 :                     
(1)  162/     5D9 :                     tpower		ds.b	1			; remember CORDIC power
(1)  163/     5DA :                     
(1)  164/     5DA :                     Asrch		ds.b	1			; scan-between-quotes flag, alt search character
(1)  165/     5DB :                     
(1)  166/     5DB :                     Dimcnt		ds.b	1			; # of dimensions
(1)  167/     5DC :                     
(1)  168/     5DC :                     Breakf		ds.b	1			; break flag, $00=END else=break
(1)  169/     5DD :                     Oquote		ds.b	1			; open quote flag (Flag: DATA; LIST; memory)
(1)  170/     5DE :                     Gclctd		ds.b	1			; garbage collected flag
(1)  171/     5DF :                     Sufnxf		ds.b	1			; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
(1)  172/     5E0 :                     Imode		ds.b	1			; input mode flag, $00=INPUT, $98=READ
(1)  173/     5E1 :                     
(1)  174/     5E1 :                     Cflag		ds.b	1			; comparison evaluation flag
(1)  175/     5E2 :                     
(1)  176/     5E2 :                     TabSiz		ds.b	1			; TAB step size
(1)  177/     5E3 :                     
(1)  178/     5E3 :                     comp_f		ds.b	1			; compare function flag, bits 0,1 and 2 used
(1)  179/     5E4 :                     								; bit 2 set if >
(1)  180/     5E4 :                     								; bit 1 set if =
(1)  181/     5E4 :                     								; bit 0 set if <
(1)  182/     5E4 :                     
(1)  183/     5E4 :                     Nullct		ds.b	1			; nulls output after each line
(1)  184/     5E5 :                     TPos		ds.b	1			; BASIC terminal position byte
(1)  185/     5E6 :                     TWidth		ds.b	1			; BASIC terminal width byte
(1)  186/     5E7 :                     Iclim		ds.b	1			; input column limit
(1)  187/     5E8 :                     ccflag		ds.b	1			; CTRL-C check flag
(1)  188/     5E9 :                     ccbyte		ds.b	1			; CTRL-C last received byte
(1)  189/     5EA :                     ccnull		ds.b	1			; CTRL-C last received byte 'life' timer
(1)  190/     5EB :                     
(1)  191/     5EB :                     	ALIGN	2
(1)  192/     5EC :                     
(1)  193/     5EC :                     ; these variables for load/save routines
(1)  194/     5EC :                     
(1)  195/     5EC :                     ; ifne   FLASH_SUPPORT
(1)  196/     5EC :                     ;
(1)  197/     5EC :                     ;load_first      ds.b    1               ; Boolean indicating if first byte read
(1)  198/     5EC :                     ;load_filename   ds.b    13              ; Hold LOAD/SAVE filename (DOS 8.3 format plus terminating null)
(1)  199/     5EC :                     ;
(1)  200/     5EC :                     ; endc
(1)  201/     5EC :                     ;
(1)  202/     5EC :                     ;		even			; dummy even value and zero pad byte
(1)  203/     5EC :                     
(1)  204/     5EC :                     prg_strt
(1)  205/     5EC :                     
(1)  206/     5EC :                     ; Use these two lines when running from ROM
(1)  207/     5EC : =$4000              ram_addr	EQU	$04000		; RAM start address
(1)  208/     5EC : =$1C000             ram_size	EQU	$1C000		; RAM size
(1)  209/     5EC :                     
(1)  210/     5EC :                     ; Use these two lines when running from RAM
(1)  211/     5EC :                     ;ram_addr	EQU	$04000		; RAM start address
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm(basic68k.inc) - Page 6 - 10/11/2023 16:23:32


(1)  212/     5EC :                     ;ram_size	EQU	$04000		; RAM size
(1)  213/     5EC :                     
      90/     5EC :                     								; RAM offset definitions
      91/     5EC :                     
      92/     5EC :                     ; Use this value to run out of ROM
      93/     5EC :                     ;	ORG		$00C000				; past the vectors in a real system
      94/     5EC :                     ; Use this value to run out of RAM
      95/      C0 :                     	ORG		$0000c0				; past the vectors in a real system
      96/      C0 :                     
      97/      C0 : =$40000001          ACIAC:	EQU	$40000001
      98/      C0 : =$40000000          ACIAD:	EQU	$40000000
      99/      C0 :                     
     100/      C0 :                     ;************************************************************************************
     101/      C0 :                     ;
     102/      C0 :                     ; the following code is simulator specific, change to suit your system
     103/      C0 :                     ; Output character to the console from register d0.b
     104/      C0 :                     
     105/      C0 :                     VEC_OUT
     106/      C0 : 4840                	SWAP	D0
     107/      C2 :                     CO0:
     108/      C2 : 1039 4000 0001      	MOVE.B	ACIAC,D0
     109/      C8 : C03C 0002           	AND.B	#$02,D0
     110/      CC : 67F4                	BEQ	CO0
     111/      CE : 4840                	SWAP	D0
     112/      D0 : 13C0 4000 0000      	MOVE.B	D0,ACIAD
     113/      D6 : 4E75                	RTS
     114/      D8 :                     
     115/      D8 :                     ;************************************************************************************
     116/      D8 :                     ;
     117/      D8 :                     ; input a character from the console into register d0
     118/      D8 :                     ; else return Cb=0 if there's no character available
     119/      D8 :                     
     120/      D8 :                     VEC_IN
     121/      D8 : 1039 4000 0001      	MOVE.B	ACIAC,D0
     122/      DE : C03C 0001           	AND.B	#$01,D0
     123/      E2 : 6710                	BEQ     NOCHR
     124/      E4 : 1039 4000 0000      	MOVE.B	ACIAD,D0
     125/      EA : 0000 0000           	ORI.b	#$00,d0		; set z flag on received byte
     126/      EE : 003C 0001           	ORI.b	#1,CCR		; set carry, flag we got a byte
     127/      F2 : 4E75                	RTS
     128/      F4 :                     NOCHR
     129/      F4 : 0000 0000           	ORI.b   #$00,d0
     130/      F8 : 4E75                	RTS
     131/      FA :                     
     132/      FA :                     ;************************************************************************************
     133/      FA :                     ;
     134/      FA :                     ; LOAD routine for the TS2 computer (not implemented)
     135/      FA :                     
     136/      FA :                     VEC_LD
     137/      FA : 7E2E                       MOVEQ           #$2E,d7                        ; error code $2E "Not implemented" error
     138/      FC : 6000 012C                  BRA             LAB_XERR                       ; do error #d7, then warm start
     139/     100 :                     
     140/     100 :                     ;************************************************************************************
     141/     100 :                     ;
     142/     100 :                     ; SAVE routine for the TS2 computer (not implemented)
     143/     100 :                     
     144/     100 :                     VEC_SV
     145/     100 : 7E2E                       MOVEQ           #$2E,d7                        ; error code $2E "Not implemented" error
     146/     102 : 6000 0126                  BRA             LAB_XERR                       ; do error #d7, then warm start
     147/     106 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 7 - 10/11/2023 16:23:32


     148/     106 :                     
     149/     106 :                     ;************************************************************************************
     150/     106 :                     
     151/     106 :                     code_start
     152/     106 :                     ;                               ; Set up ACIA parameters
     153/     106 :                     ;        LEA.L   ACIA_1,A0      ; A0 points to console ACIA
     154/     106 :                     ;        MOVE.B  #$15,(A0)      ; Set up ACIA1 constants (no IRQ,
     155/     106 :                     ;                               ; RTS* low, 8 bit, no parity, 1 stop)
     156/     106 :                     ;        LEA.L   ACIA_2,A0      ; A0 points to aux. ACIA
     157/     106 :                     ;        MOVE.B  #$15,(A0)      ; Set up ACIA2 constants (no IRQ,
     158/     106 :                     ;                               ; RTS* low, 8 bit, no parity, 1 stop)
     159/     106 :                     
     160/     106 : 203C 0000 0001      	MOVE.l	#$00000001,d0	; [add] Set instruction cache enable
     161/     10C : 4E7B 0002           	MOVEC	d0,cacr		; [add] at cache control register
     162/     110 :                     
     163/     110 :                     ; to tell EhBASIC where and how much RAM it has pass the address in a0 and the size
     164/     110 :                     ; in d0. these values are at the end of the .inc file
     165/     110 :                     
     166/     110 : 207C 0000 4000      	MOVEA.l	#ram_addr,a0			; tell BASIC where RAM starts
     167/     116 : 203C 0001 C000      	MOVE.l	#ram_size,d0			; tell BASIC how big RAM is
     168/     11C :                     
     169/     11C :                     ; end of simulator specific code
     170/     11C :                     
     171/     11C :                     
     172/     11C :                     ;************************************************************************************
     173/     11C :                     ;************************************************************************************
     174/     11C :                     ;************************************************************************************
     175/     11C :                     ;************************************************************************************
     176/     11C :                     ;
     177/     11C :                     ; Register use :- (must improve this !!)
     178/     11C :                     ;
     179/     11C :                     ;	a6 -	temp Bpntr					; temporary BASIC execute pointer
     180/     11C :                     ;	a5 -	Bpntr						; BASIC execute (get byte) pointer
     181/     11C :                     ;	a4 -	des_sk				       ; descriptor stack pointer
     182/     11C :                     ;	a3 -	ram_strt					; start of RAM. all RAM references are offsets
     183/     11C :                     ;								; from this value
     184/     11C :                     ;
     185/     11C :                     
     186/     11C :                     ;************************************************************************************
     187/     11C :                     ;
     188/     11C :                     ; BASIC cold start entry point. assume entry with RAM address in a0 and RAM length
     189/     11C :                     ; in d0
     190/     11C :                     
     191/     11C :                     LAB_COLD
     192/     11C :                     ;	CMP.l		#$4000,d0			; compare size with 16k
     193/     11C :                     ;	BGE.s		LAB_sizok			; branch if >= 16k
     194/     11C :                     ;
     195/     11C :                     ;	MOVEQ	#5,d0					; error 5 - not enough RAM
     196/     11C :                     ;	move.b	#228,D7					; Go to TUTOR function
     197/     11C :                     ;	trap	#14						; Call TRAP14 handler
     198/     11C :                     ;
     199/     11C :                     ;LAB_sizok
     200/     11C : 2648                	MOVEA.l	a0,a3					; copy RAM base to a3
     201/     11E : D1C0                	ADDA.l	d0,a0					; a0 is top of RAM
     202/     120 : 2748 044A           	MOVE.l	a0,Ememl(a3)			; set end of mem
     203/     124 : 2E7C 0000 4400      	MOVE.l	#ram_addr+ram_base,sp	; set stack to RAM start + 1k
     204/     12A :                     
     205/     12A : 303C 4EF9           	MOVE.w	#$4EF9,d0				; JMP opcode
     206/     12E : 204F                	MOVEA.l	sp,a0					; point to start of vector table
     207/     130 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 8 - 10/11/2023 16:23:32


     208/     130 : 30C0                	MOVE.w	d0,(a0)+				; LAB_WARM
     209/     132 : 43FA FFE8           	LEA		LAB_COLD(pc),a1			; initial warm start vector
     210/     136 : 20C9                	MOVE.l	a1,(a0)+				; set vector
     211/     138 :                     
     212/     138 : 30C0                	MOVE.w	d0,(a0)+				; Usrjmp
     213/     13A : 43FA 00DC           	LEA		LAB_FCER(pc),a1			; initial user function vector
     214/     13E :                     									; "Function call" error
     215/     13E : 20C9                	MOVE.l	a1,(a0)+				; set vector
     216/     140 :                     
     217/     140 : 30C0                	MOVE.w	d0,(a0)+				; V_INPT JMP opcode
     218/     142 : 43FA FF94           	LEA		VEC_IN(pc),a1			; get byte from input device vector
     219/     146 : 20C9                	MOVE.l	a1,(a0)+				; set vector
     220/     148 :                     
     221/     148 : 30C0                	MOVE.w	d0,(a0)+				; V_OUTP JMP opcode
     222/     14A : 43FA FF74           	LEA		VEC_OUT(pc),a1			; send byte to output device vector
     223/     14E : 20C9                	MOVE.l	a1,(a0)+				; set vector
     224/     150 :                     
     225/     150 : 30C0                	MOVE.w	d0,(a0)+				; V_LOAD JMP opcode
     226/     152 : 43FA FFA6           	LEA		VEC_LD(pc),a1			; load BASIC program vector
     227/     156 : 20C9                	MOVE.l	a1,(a0)+				; set vector
     228/     158 :                     
     229/     158 : 30C0                	MOVE.w	d0,(a0)+				; V_SAVE JMP opcode
     230/     15A : 43FA FFA4           	LEA		VEC_SV(pc),a1			; save BASIC program vector
     231/     15E : 20C9                	MOVE.l	a1,(a0)+				; set vector
     232/     160 :                     
     233/     160 : 30C0                	MOVE.w	d0,(a0)+				; V_CTLC JMP opcode
     234/     162 : 43FA 2634           	LEA		VEC_CC(pc),a1			; save CTRL-C check vector
     235/     166 : 20C9                	MOVE.l	a1,(a0)+				; set vector
     236/     168 :                     
     237/     168 :                     ; set-up start values
     238/     168 :                     
     239/     168 :                     ;##LAB_GMEM
     240/     168 : 7000                	MOVEQ	#$00,d0					; clear d0
     241/     16A : 1740 05E4           	MOVE.b	d0,Nullct(a3)			; default NULL count
     242/     16E : 1740 05E5           	MOVE.b	d0,TPos(a3)				; clear terminal position
     243/     172 : 1740 05E8           	MOVE.b	d0,ccflag(a3)			; allow CTRL-C check
     244/     176 : 3740 05EA           	MOVE.w	d0,prg_strt-2(a3)			; clear start word
     245/     17A : 3740 05D6           	MOVE.w	d0,BHsend(a3)			; clear value to string end word
     246/     17E :                     
     247/     17E : 177C 0050 05E6      	MOVE.b	#$50,TWidth(a3)			; default terminal width byte for simulator
     248/     184 : 177C 000E 05E2      	MOVE.b	#$0E,TabSiz(a3)			; save default tab size = 14
     249/     18A :                     
     250/     18A : 177C 0038 05E7      	MOVE.b	#$38,Iclim(a3)			; default limit for TAB = 14 for simulator
     251/     190 :                     
     252/     190 : 49EB 048E           	LEA		des_sk(a3),a4			; set descriptor stack start
     253/     194 :                     
     254/     194 : 41EB 05EC           	LEA		prg_strt(a3),a0			; get start of mem
     255/     198 : 2748 042E           	MOVE.l	a0,Smeml(a3)			; save start of mem
     256/     19C :                     
     257/     19C : 6100 0322           	BSR		LAB_1463				; do "NEW" and "CLEAR"
     258/     1A0 : 6100 08A0           	BSR		LAB_CRLF				; print CR/LF
     259/     1A4 : 202B 044A           	MOVE.l	Ememl(a3),d0			; get end of mem
     260/     1A8 : 90AB 042E           	SUB.l		Smeml(a3),d0			; subtract start of mem
     261/     1AC :                     
     262/     1AC : 6100 1BDC           	BSR		LAB_295E				; print d0 as unsigned integer (bytes free)
     263/     1B0 : 41FA 3404           	LEA		LAB_SMSG(pc),a0			; point to start message
     264/     1B4 : 6100 08EA           	BSR		LAB_18C3				; print null terminated string from memory
     265/     1B8 :                     
     266/     1B8 : 41FA 29E8           	LEA		LAB_RSED(pc),a0			; get pointer to value
     267/     1BC : 6100 1A74           	BSR		LAB_UFAC				; unpack memory (a0) into FAC1
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 9 - 10/11/2023 16:23:32


     268/     1C0 :                     
     269/     1C0 : 41FA 0092           	LEA		LAB_1274(pc),a0			; get warm start vector
     270/     1C4 : 2748 0402           	MOVE.l	a0,Wrmjpv(a3)			; set warm start vector
     271/     1C8 : 6100 1FE6           	BSR		LAB_RND					; initialise
     272/     1CC : 4EEB 0400           	JMP		LAB_WARM(a3)			; go do warm start
     273/     1D0 :                     
     274/     1D0 :                     
     275/     1D0 :                     ;************************************************************************************
     276/     1D0 :                     ;
     277/     1D0 :                     ; do format error
     278/     1D0 :                     
     279/     1D0 :                     LAB_FOER
     280/     1D0 : 7E2C                	MOVEQ		#$2C,d7				; error code $2C "Format" error
     281/     1D2 : 6056                	BRA.s		LAB_XERR				; do error #d7, then warm start
     282/     1D4 :                     
     283/     1D4 :                     
     284/     1D4 :                     ;************************************************************************************
     285/     1D4 :                     ;
     286/     1D4 :                     ; do address error
     287/     1D4 :                     
     288/     1D4 :                     LAB_ADER
     289/     1D4 : 7E2A                	MOVEQ		#$2A,d7				; error code $2A "Address" error
     290/     1D6 : 6052                	BRA.s		LAB_XERR				; do error #d7, then warm start
     291/     1D8 :                     
     292/     1D8 :                     
     293/     1D8 :                     ;************************************************************************************
     294/     1D8 :                     ;
     295/     1D8 :                     ; do wrong dimensions error
     296/     1D8 :                     
     297/     1D8 :                     LAB_WDER
     298/     1D8 : 7E28                	MOVEQ		#$28,d7				; error code $28 "Wrong dimensions" error
     299/     1DA : 604E                	BRA.s		LAB_XERR				; do error #d7, then warm start
     300/     1DC :                     
     301/     1DC :                     
     302/     1DC :                     ;************************************************************************************
     303/     1DC :                     ;
     304/     1DC :                     ; do undimensioned array error
     305/     1DC :                     
     306/     1DC :                     LAB_UDER
     307/     1DC : 7E26                	MOVEQ		#$26,d7				; error code $26 "undimensioned array" error
     308/     1DE : 604A                	BRA.s		LAB_XERR				; do error #d7, then warm start
     309/     1E0 :                     
     310/     1E0 :                     
     311/     1E0 :                     ;************************************************************************************
     312/     1E0 :                     ;
     313/     1E0 :                     ; do undefined variable error
     314/     1E0 :                     
     315/     1E0 :                     LAB_UVER
     316/     1E0 :                     
     317/     1E0 : 7E24                	MOVEQ		#$24,d7				; error code $24 "undefined variable" error
     318/     1E2 : 6046                	BRA.s		LAB_XERR				; do error #d7, then warm start
     319/     1E4 :                     
     320/     1E4 :                     
     321/     1E4 :                     ;************************************************************************************
     322/     1E4 :                     ;
     323/     1E4 :                     ; do loop without do error
     324/     1E4 :                     
     325/     1E4 :                     LAB_LDER
     326/     1E4 : 7E22                	MOVEQ		#$22,d7				; error code $22 "LOOP without DO" error
     327/     1E6 : 6042                	BRA.s		LAB_XERR				; do error #d7, then warm start
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 10 - 10/11/2023 16:23:32


     328/     1E8 :                     
     329/     1E8 :                     
     330/     1E8 :                     ;************************************************************************************
     331/     1E8 :                     ;
     332/     1E8 :                     ; do undefined function error
     333/     1E8 :                     
     334/     1E8 :                     LAB_UFER
     335/     1E8 : 7E20                	MOVEQ		#$20,d7				; error code $20 "Undefined function" error
     336/     1EA : 603E                	BRA.s		LAB_XERR				; do error #d7, then warm start
     337/     1EC :                     
     338/     1EC :                     
     339/     1EC :                     ;************************************************************************************
     340/     1EC :                     ;
     341/     1EC :                     ; do can't continue error
     342/     1EC :                     
     343/     1EC :                     LAB_CCER
     344/     1EC : 7E1E                	MOVEQ		#$1E,d7				; error code $1E "Can't continue" error
     345/     1EE : 603A                	BRA.s		LAB_XERR				; do error #d7, then warm start
     346/     1F0 :                     
     347/     1F0 :                     
     348/     1F0 :                     ;************************************************************************************
     349/     1F0 :                     ;
     350/     1F0 :                     ; do string too complex error
     351/     1F0 :                     
     352/     1F0 :                     LAB_SCER
     353/     1F0 : 7E1C                	MOVEQ		#$1C,d7				; error code $1C "String too complex" error
     354/     1F2 : 6036                	BRA.s		LAB_XERR				; do error #d7, then warm start
     355/     1F4 :                     
     356/     1F4 :                     
     357/     1F4 :                     ;************************************************************************************
     358/     1F4 :                     ;
     359/     1F4 :                     ; do string too long error
     360/     1F4 :                     
     361/     1F4 :                     LAB_SLER
     362/     1F4 : 7E1A                	MOVEQ		#$1A,d7				; error code $1A "String too long" error
     363/     1F6 : 6032                	BRA.s		LAB_XERR				; do error #d7, then warm start
     364/     1F8 :                     
     365/     1F8 :                     
     366/     1F8 :                     ;************************************************************************************
     367/     1F8 :                     ;
     368/     1F8 :                     ; do type missmatch error
     369/     1F8 :                     
     370/     1F8 :                     LAB_TMER
     371/     1F8 : 7E18                	MOVEQ		#$18,d7				; error code $18 "Type mismatch" error
     372/     1FA : 602E                	BRA.s		LAB_XERR				; do error #d7, then warm start
     373/     1FC :                     
     374/     1FC :                     
     375/     1FC :                     ;************************************************************************************
     376/     1FC :                     ;
     377/     1FC :                     ; do illegal direct error
     378/     1FC :                     
     379/     1FC :                     LAB_IDER
     380/     1FC : 7E16                	MOVEQ		#$16,d7				; error code $16 "Illegal direct" error
     381/     1FE : 602A                	BRA.s		LAB_XERR				; do error #d7, then warm start
     382/     200 :                     
     383/     200 :                     
     384/     200 :                     ;************************************************************************************
     385/     200 :                     ;
     386/     200 :                     ; do divide by zero error
     387/     200 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 11 - 10/11/2023 16:23:32


     388/     200 :                     LAB_DZER
     389/     200 : 7E14                	MOVEQ		#$14,d7				; error code $14 "Divide by zero" error
     390/     202 : 6026                	BRA.s		LAB_XERR				; do error #d7, then warm start
     391/     204 :                     
     392/     204 :                     
     393/     204 :                     ;************************************************************************************
     394/     204 :                     ;
     395/     204 :                     ; do double dimension error
     396/     204 :                     
     397/     204 :                     LAB_DDER
     398/     204 : 7E12                	MOVEQ		#$12,d7				; error code $12 "Double dimension" error
     399/     206 : 6022                	BRA.s		LAB_XERR				; do error #d7, then warm start
     400/     208 :                     
     401/     208 :                     
     402/     208 :                     ;************************************************************************************
     403/     208 :                     ;
     404/     208 :                     ; do array bounds error
     405/     208 :                     
     406/     208 :                     LAB_ABER
     407/     208 : 7E10                	MOVEQ		#$10,d7				; error code $10 "Array bounds" error
     408/     20A : 601E                	BRA.s		LAB_XERR				; do error #d7, then warm start
     409/     20C :                     
     410/     20C :                     
     411/     20C :                     ;************************************************************************************
     412/     20C :                     ;
     413/     20C :                     ; do undefined satement error
     414/     20C :                     
     415/     20C :                     LAB_USER
     416/     20C : 7E0E                	MOVEQ		#$0E,d7				; error code $0E "Undefined statement" error
     417/     20E : 601A                	BRA.s		LAB_XERR				; do error #d7, then warm start
     418/     210 :                     
     419/     210 :                     
     420/     210 :                     ;************************************************************************************
     421/     210 :                     ;
     422/     210 :                     ; do out of memory error
     423/     210 :                     
     424/     210 :                     LAB_OMER
     425/     210 : 7E0C                	MOVEQ		#$0C,d7				; error code $0C "Out of memory" error
     426/     212 : 6016                	BRA.s		LAB_XERR				; do error #d7, then warm start
     427/     214 :                     
     428/     214 :                     
     429/     214 :                     ;************************************************************************************
     430/     214 :                     ;
     431/     214 :                     ; do overflow error
     432/     214 :                     
     433/     214 :                     LAB_OFER
     434/     214 : 7E0A                	MOVEQ		#$0A,d7				; error code $0A "Overflow" error
     435/     216 : 6012                	BRA.s		LAB_XERR				; do error #d7, then warm start
     436/     218 :                     
     437/     218 :                     
     438/     218 :                     ;************************************************************************************
     439/     218 :                     ;
     440/     218 :                     ; do function call error
     441/     218 :                     
     442/     218 :                     LAB_FCER
     443/     218 : 7E08                	MOVEQ		#$08,d7				; error code $08 "Function call" error
     444/     21A : 600E                	BRA.s		LAB_XERR				; do error #d7, then warm start
     445/     21C :                     
     446/     21C :                     
     447/     21C :                     ;************************************************************************************
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 12 - 10/11/2023 16:23:32


     448/     21C :                     ;
     449/     21C :                     ; do out of data error
     450/     21C :                     
     451/     21C :                     LAB_ODER
     452/     21C : 7E06                	MOVEQ		#$06,d7				; error code $06 "Out of DATA" error
     453/     21E : 600A                	BRA.s		LAB_XERR				; do error #d7, then warm start
     454/     220 :                     
     455/     220 :                     
     456/     220 :                     ;************************************************************************************
     457/     220 :                     ;
     458/     220 :                     ; do return without gosub error
     459/     220 :                     
     460/     220 :                     LAB_RGER
     461/     220 : 7E04                	MOVEQ		#$04,d7				; error code $04 "RETURN without GOSUB" error
     462/     222 : 6006                	BRA.s		LAB_XERR				; do error #d7, then warm start
     463/     224 :                     
     464/     224 :                     
     465/     224 :                     ;************************************************************************************
     466/     224 :                     ;
     467/     224 :                     ; do syntax error
     468/     224 :                     
     469/     224 :                     LAB_SNER
     470/     224 : 7E02                	MOVEQ		#$02,d7				; error code $02 "Syntax" error
     471/     226 : 6002                	BRA.s		LAB_XERR				; do error #d7, then warm start
     472/     228 :                     
     473/     228 :                     
     474/     228 :                     ;************************************************************************************
     475/     228 :                     ;
     476/     228 :                     ; do next without for error
     477/     228 :                     
     478/     228 :                     LAB_NFER
     479/     228 : 7E00                	MOVEQ		#$00,d7				; error code $00 "NEXT without FOR" error
     480/     22A :                     
     481/     22A :                     
     482/     22A :                     ;************************************************************************************
     483/     22A :                     ;
     484/     22A :                     ; do error #d7, then warm start
     485/     22A :                     
     486/     22A :                     LAB_XERR
     487/     22A : 6100 02CA           	BSR		LAB_1491				; flush stack & clear continue flag
     488/     22E : 6100 0812           	BSR		LAB_CRLF				; print CR/LF
     489/     232 : 43FA 2FFA           	LEA		LAB_BAER(pc),a1			; start of error message pointer table
     490/     236 : 3E31 7000           	MOVE.w	(a1,d7.w),d7			; get error message offset
     491/     23A : 41F1 7000           	LEA		(a1,d7.w),a0			; get error message address
     492/     23E : 6100 0860           	BSR		LAB_18C3				; print null terminated string from memory
     493/     242 : 41FA 3335           	LEA		LAB_EMSG(pc),a0			; point to " Error" message
     494/     246 :                     LAB_1269
     495/     246 : 6100 0858           	BSR		LAB_18C3				; print null terminated string from memory
     496/     24A : 202B 0452           	MOVE.l	Clinel(a3),d0			; get current line
     497/     24E : 6B04                	BMI.s	LAB_1274				; go do warm start if -ve # (was immediate mode)
     498/     250 :                     
     499/     250 :                     									; else print line number
     500/     250 : 6100 1B2C           	BSR		LAB_2953				; print " in line [LINE #]"
     501/     254 :                     
     502/     254 :                     ; BASIC warm start entry point, wait for Basic command
     503/     254 :                     
     504/     254 :                     LAB_1274
     505/     254 : 41FA 3356           	LEA		LAB_RMSG(pc),a0			; point to "Ready" message
     506/     258 : 6100 0846           	BSR		LAB_18C3				; go do print string
     507/     25C :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 13 - 10/11/2023 16:23:32


     508/     25C :                     ; wait for Basic command - no "Ready"
     509/     25C :                     
     510/     25C :                     LAB_127D
     511/     25C : 72FF                	MOVEQ	#-1,d1					; set to -1
     512/     25E : 2741 0452           	MOVE.l	d1,Clinel(a3)			; set current line #
     513/     262 : 1741 05DC           	MOVE.b	d1,Breakf(a3)			; set break flag
     514/     266 : 4BEB 0490           	LEA		Ibuffs(a3),a5			; set basic execute pointer ready for new line
     515/     26A :                     LAB_127E
     516/     26A : 6100 00EC           	BSR		LAB_1357				; call for BASIC input
     517/     26E : 6100 0BFC           	BSR		LAB_GBYT				; scan memory
     518/     272 : 67F6                	BEQ.s	LAB_127E				; loop while null
     519/     274 :                     
     520/     274 :                     ; got to interpret input line now ....
     521/     274 :                     
     522/     274 : 6508                	BCS.s	LAB_1295				; branch if numeric character, handle new
     523/     276 :                     								; BASIC line
     524/     276 :                     
     525/     276 :                     								; no line number so do immediate mode, a5
     526/     276 :                     								; points to the buffer start
     527/     276 : 6100 0156           	BSR		LAB_13A6				; crunch keywords into Basic tokens
     528/     27A :                     								; crunch from (a5), output to (a0)
     529/     27A :                     								; returns ..
     530/     27A :                     								; d2 is length, d1 trashed, d0 trashed,
     531/     27A :                     								; a1 trashed
     532/     27A : 6000 03C6           	BRA		LAB_15F6				; go scan & interpret code
     533/     27E :                     
     534/     27E :                     
     535/     27E :                     ;************************************************************************************
     536/     27E :                     ;
     537/     27E :                     ; handle a new BASIC line
     538/     27E :                     
     539/     27E :                     LAB_1295
     540/     27E : 6100 0640           	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
     541/     282 : 6100 014A           	BSR		LAB_13A6				; crunch keywords into Basic tokens
     542/     286 :                     								; crunch from (a5), output to (a0)
     543/     286 :                     								; returns .. d2 is length,
     544/     286 :                     								; d1 trashed, d0 trashed, a1 trashed
     545/     286 : 222B 042A           	MOVE.l	Itemp(a3),d1			; get required line #
     546/     28A : 6100 0218           	BSR		LAB_SSLN				; search BASIC for d1 line number
     547/     28E :                     								; returns pointer in a0
     548/     28E : 6532                	BCS.s		LAB_12E6				; branch if not found
     549/     290 :                     
     550/     290 :                     								; aroooogah! line # already exists! delete it
     551/     290 : 2250                	MOVEA.l	(a0),a1				; get start of block (next line pointer)
     552/     292 : 202B 0432           	MOVE.l	Sfncl(a3),d0			; get end of block (start of functions)
     553/     296 : 9089                	SUB.l		a1,d0					; subtract start of block ( = bytes to move)
     554/     298 : E288                	LSR.l		#1,d0					; /2 (word move)
     555/     29A : 5380                	SUBQ.l	#1,d0					; adjust for DBF loop
     556/     29C : 4840                	SWAP		d0					; swap high word to low word
     557/     29E : 2448                	MOVEA.l	a0,a2					; copy destination
     558/     2A0 :                     LAB_12AE
     559/     2A0 : 4840                	SWAP		d0					; swap high word to low word
     560/     2A2 :                     LAB_12B0
     561/     2A2 : 34D9                	MOVE.w	(a1)+,(a2)+				; copy word
     562/     2A4 : 51C8 FFFC           	DBF		d0,LAB_12B0				; decrement low count and loop until done
     563/     2A8 :                     
     564/     2A8 : 4840                	SWAP		d0					; swap high word to low word
     565/     2AA : 51C8 FFF4           	DBF		d0,LAB_12AE				; decrement high count and loop until done
     566/     2AE :                     
     567/     2AE : 274A 0432           	MOVE.l	a2,Sfncl(a3)			; start of functions
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 14 - 10/11/2023 16:23:32


     568/     2B2 : 274A 0436           	MOVE.l	a2,Svarl(a3)			; save start of variables
     569/     2B6 : 274A 043A           	MOVE.l	a2,Sstrl(a3)			; start of strings
     570/     2BA : 274A 043E           	MOVE.l	a2,Sarryl(a3)			; save start of arrays
     571/     2BE : 274A 0442           	MOVE.l	a2,Earryl(a3)			; save end of arrays
     572/     2C2 :                     
     573/     2C2 :                     								; got new line in buffer and no existing same #
     574/     2C2 :                     LAB_12E6
     575/     2C2 : 102B 0490           	MOVE.b	Ibuffs(a3),d0			; get byte from start of input buffer
     576/     2C6 : 6764                	BEQ.s		LAB_1325				; if null line go do line chaining
     577/     2C8 :                     
     578/     2C8 :                     								; got new line and it isn't empty line
     579/     2C8 : 226B 0432           	MOVEA.l	Sfncl(a3),a1			; get start of functions (end of block to move)
     580/     2CC : 45F1 2008           	LEA		8(a1,d2),a2				; copy it, add line length and add room for
     581/     2D0 :                     								; pointer and line number
     582/     2D0 :                     
     583/     2D0 : 274A 0432           	MOVE.l	a2,Sfncl(a3)			; start of functions
     584/     2D4 : 274A 0436           	MOVE.l	a2,Svarl(a3)			; save start of variables
     585/     2D8 : 274A 043A           	MOVE.l	a2,Sstrl(a3)			; start of strings
     586/     2DC : 274A 043E           	MOVE.l	a2,Sarryl(a3)			; save start of arrays
     587/     2E0 : 274A 0442           	MOVE.l	a2,Earryl(a3)			; save end of arrays
     588/     2E4 : 276B 044A 0446      	MOVE.l	Ememl(a3),Sstorl(a3)		; copy end of mem to start of strings, clear
     589/     2EA :                     								; strings
     590/     2EA :                     
     591/     2EA : 2209                	MOVE.l	a1,d1					; copy end of block to move
     592/     2EC : 9288                	SUB.l		a0,d1					; subtract start of block to move
     593/     2EE : E289                	LSR.l		#1,d1					; /2 (word copy)
     594/     2F0 : 5381                	SUBQ.l	#1,d1					; correct for loop end on -1
     595/     2F2 : 4841                	SWAP		d1					; swap high word to low word
     596/     2F4 :                     LAB_12FF
     597/     2F4 : 4841                	SWAP		d1					; swap high word to low word
     598/     2F6 :                     LAB_1301
     599/     2F6 : 3521                	MOVE.w	-(a1),-(a2)				; decrement pointers and copy word
     600/     2F8 : 51C9 FFFC           	DBF		d1,LAB_1301				; decrement & loop
     601/     2FC :                     
     602/     2FC : 4841                	SWAP		d1					; swap high word to low word
     603/     2FE : 51C9 FFF4           	DBF		d1,LAB_12FF				; decrement high count and loop until done
     604/     302 :                     
     605/     302 :                     ; space is opened up, now copy the crunched line from the input buffer into the space
     606/     302 :                     
     607/     302 : 43EB 0490           	LEA		Ibuffs(a3),a1			; source is input buffer
     608/     306 : 2448                	MOVEA.l	a0,a2					; copy destination
     609/     308 : 72FF                	MOVEQ		#-1,d1				; set to allow re-chaining
     610/     30A : 24C1                	MOVE.l	d1,(a2)+				; set next line pointer (allow re-chaining)
     611/     30C : 24EB 042A           	MOVE.l	Itemp(a3),(a2)+			; save line number
     612/     310 : E24A                	LSR.w		#1,d2					; /2 (word copy)
     613/     312 : 5342                	SUBQ.w	#1,d2					; correct for loop end on -1
     614/     314 :                     LAB_1303
     615/     314 : 34D9                	MOVE.w	(a1)+,(a2)+				; copy word
     616/     316 : 51CA FFFC           	DBF		d2,LAB_1303				; decrement & loop
     617/     31A :                     
     618/     31A : 6010                	BRA.s		LAB_1325				; go test for end of prog
     619/     31C :                     
     620/     31C :                     ; rebuild chaining of BASIC lines
     621/     31C :                     
     622/     31C :                     LAB_132E
     623/     31C : 5048                	ADDQ.w	#8,a0					; point to first code byte of line, there is
     624/     31E :                     								; always 1 byte + [EOL] as null entries are
     625/     31E :                     								; deleted
     626/     31E :                     LAB_1330
     627/     31E : 4A18                	TST.b		(a0)+					; test byte	
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 15 - 10/11/2023 16:23:32


     628/     320 : 66FC                	BNE.s		LAB_1330				; loop if not [EOL]
     629/     322 :                     
     630/     322 :                     								; was [EOL] so get next line start
     631/     322 : 3208                	MOVE.w	a0,d1					; past pad byte(s)
     632/     324 : 0241 0001           	ANDI.w	#1,d1					; mask odd bit
     633/     328 : D0C1                	ADD.w		d1,a0					; add back to ensure even
     634/     32A : 2288                	MOVE.l	a0,(a1)				; save next line pointer to current line
     635/     32C :                     LAB_1325
     636/     32C : 2248                	MOVEA.l	a0,a1					; copy pointer for this line
     637/     32E : 4A90                	TST.l		(a0)					; test pointer to next line
     638/     330 : 66EA                	BNE.s		LAB_132E				; not end of program yet so we must
     639/     332 :                     								; go and fix the pointers
     640/     332 :                     
     641/     332 : 6100 0198           	BSR		LAB_1477				; reset execution to start, clear variables
     642/     336 :                     								; and flush stack
     643/     336 : 6000 FF24           	BRA		LAB_127D				; now we just wait for Basic command, no "Ready"
     644/     33A :                     
     645/     33A :                     
     646/     33A :                     ;************************************************************************************
     647/     33A :                     ;
     648/     33A :                     ; receive a line from the keyboard
     649/     33A :                     								; character $08 as delete key, BACKSPACE on
     650/     33A :                     								; standard keyboard
     651/     33A :                     LAB_134B
     652/     33A : 6100 077E           	BSR		LAB_PRNA				; go print the character
     653/     33E : 7020                	MOVEQ		#' ',d0				; load [SPACE]
     654/     340 : 6100 0778           	BSR		LAB_PRNA				; go print
     655/     344 : 7008                	MOVEQ		#$08,d0				; load [BACKSPACE]
     656/     346 : 6100 0772           	BSR		LAB_PRNA				; go print
     657/     34A : 5341                	SUBQ.w	#$01,d1				; decrement the buffer index (delete)
     658/     34C : 6010                	BRA.s		LAB_1359				; re-enter loop
     659/     34E :                     
     660/     34E :                     ; print "? " and get BASIC input
     661/     34E :                     ; return a0 pointing to the buffer start
     662/     34E :                     
     663/     34E :                     LAB_INLN
     664/     34E : 6100 0768           	BSR		LAB_18E3				; print "?" character
     665/     352 : 7020                	MOVEQ		#' ',d0				; load " "
     666/     354 : 6100 0764           	BSR		LAB_PRNA				; go print
     667/     358 :                     
     668/     358 :                     ; call for BASIC input (main entry point)
     669/     358 :                     ; return a0 pointing to the buffer start
     670/     358 :                     
     671/     358 :                     LAB_1357
     672/     358 : 7200                	MOVEQ		#$00,d1				; clear buffer index
     673/     35A : 41EB 0490           	LEA		Ibuffs(a3),a0			; set buffer base pointer
     674/     35E :                     LAB_1359
     675/     35E : 4EAB 040C           	JSR		V_INPT(a3)				; call scan input device
     676/     362 : 64FA                	BCC.s		LAB_1359				; loop if no byte
     677/     364 :                     
     678/     364 : 67F8                	BEQ.s		LAB_1359				; loop if null byte
     679/     366 :                     
     680/     366 : B03C 0007           	CMP.b		#$07,d0				; compare with [BELL]
     681/     36A : 6718                	BEQ.s		LAB_1378				; branch if [BELL]
     682/     36C :                     
     683/     36C : B03C 000D           	CMP.b		#$0D,d0				; compare with [CR]
     684/     370 : 6700 06CA           	BEQ		LAB_1866				; do CR/LF exit if [CR]
     685/     374 :                     
     686/     374 : 4A41                	TST.w		d1					; set flags on buffer index
     687/     376 : 6606                	BNE.s		LAB_1374				; branch if not empty
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 16 - 10/11/2023 16:23:32


     688/     378 :                     
     689/     378 :                     ; the next two lines ignore any non printing character and [SPACE] if the input buffer
     690/     378 :                     ; is empty
     691/     378 :                     
     692/     378 : B03C 0020           	CMP.b		#' ',d0				; compare with [SP]+1
     693/     37C : 63E0                	BLS.s		LAB_1359				; if < ignore character
     694/     37E :                     
     695/     37E :                     ;##	CMP.b		#' '+1,d0				; compare with [SP]+1
     696/     37E :                     ;##	BCS.s		LAB_1359				; if < ignore character
     697/     37E :                     
     698/     37E :                     LAB_1374
     699/     37E : B03C 0008           	CMP.b		#$08,d0				; compare with [BACKSPACE]
     700/     382 : 67B6                	BEQ.s		LAB_134B				; go delete last character
     701/     384 :                     
     702/     384 :                     LAB_1378
     703/     384 : B27C 00FF           	CMP.w		#(Ibuffe-Ibuffs-1),d1		; compare character count with max-1
     704/     388 : 640C                	BCC.s		LAB_138E				; skip store & do [BELL] if buffer full
     705/     38A :                     
     706/     38A : 1180 1000           	MOVE.b	d0,(a0,d1.w)			; else store in buffer
     707/     38E : 5241                	ADDQ.w	#$01,d1				; increment index
     708/     390 :                     LAB_137F
     709/     390 : 6100 0728           	BSR		LAB_PRNA				; go print the character
     710/     394 : 60C8                	BRA.s		LAB_1359				; always loop for next character
     711/     396 :                     
     712/     396 :                     ; announce buffer full
     713/     396 :                     
     714/     396 :                     LAB_138E
     715/     396 : 7007                	MOVEQ		#$07,d0				; [BELL] character into d0
     716/     398 : 60F6                	BRA.s		LAB_137F				; go print the [BELL] but ignore input character
     717/     39A :                     
     718/     39A :                     
     719/     39A :                     ;************************************************************************************
     720/     39A :                     ;
     721/     39A :                     ; copy a hex value without crunching
     722/     39A :                     
     723/     39A :                     LAB_1392
     724/     39A : 1180 2000           	MOVE.b	d0,(a0,d2.w)			; save the byte to the output
     725/     39E : 5242                	ADDQ.w	#1,d2					; increment the buffer save index
     726/     3A0 :                     
     727/     3A0 : 5241                	ADDQ.w	#1,d1					; increment the buffer read index
     728/     3A2 : 1035 1000           	MOVE.b	(a5,d1.w),d0			; get a byte from the input buffer
     729/     3A6 : 6700 0094           	BEQ		LAB_13EC				; if [EOL] go save it without crunching
     730/     3AA :                     
     731/     3AA : B03C 0020           	CMP.b		#' ',d0				; compare the character with " "
     732/     3AE : 67EA                	BEQ.s		LAB_1392				; if [SPACE] just go save it and get another
     733/     3B0 :                     
     734/     3B0 : B03C 0030           	CMP.b		#'0',d0				; compare the character with "0"
     735/     3B4 : 654A                	BCS.s		LAB_13C6				; if < "0" quit the hex save loop
     736/     3B6 :                     
     737/     3B6 : B03C 0039           	CMP.b		#'9',d0				; compare with "9"
     738/     3BA : 63DE                	BLS.s		LAB_1392				; if it is "0" to "9" save it and get another
     739/     3BC :                     
     740/     3BC : 7ADF                	MOVEQ		#-33,d5				; mask xx0x xxxx, ASCII upper case
     741/     3BE : CA00                	AND.b		d0,d5					; mask the character
     742/     3C0 :                     
     743/     3C0 : BA3C 0041           	CMP.b		#'A',d5				; compare with "A"
     744/     3C4 : 6540                	BCS.s		LAB_13CC				; if < "A" quit the hex save loop
     745/     3C6 :                     
     746/     3C6 : BA3C 0046           	CMP.b		#'F',d5				; compare with "F"
     747/     3CA : 63CE                	BLS.s		LAB_1392				; if it is "A" to "F" save it and get another
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 17 - 10/11/2023 16:23:32


     748/     3CC :                     
     749/     3CC : 6038                	BRA.s		LAB_13CC				; else continue crunching
     750/     3CE :                     
     751/     3CE :                     ; crunch keywords into Basic tokens
     752/     3CE :                     ; crunch from (a5), output to (a0)
     753/     3CE :                     ; returns ..
     754/     3CE :                     ; d4 trashed
     755/     3CE :                     ; d3 trashed
     756/     3CE :                     ; d2 is length
     757/     3CE :                     ; d1 trashed
     758/     3CE :                     ; d0 trashed
     759/     3CE :                     ; a1 trashed
     760/     3CE :                     
     761/     3CE :                     ; this is the improved BASIC crunch routine and is 10 to 100 times faster than the
     762/     3CE :                     ; old list search
     763/     3CE :                     
     764/     3CE :                     LAB_13A6
     765/     3CE : 7200                	MOVEQ		#0,d1					; clear the read index
     766/     3D0 : 2401                	MOVE.l	d1,d2					; clear the save index
     767/     3D2 : 1741 05DD           	MOVE.b	d1,Oquote(a3)			; clear the open quote/DATA flag
     768/     3D6 :                     LAB_13AC
     769/     3D6 : 7000                	MOVEQ		#0,d0					; clear word
     770/     3D8 : 1035 1000           	MOVE.b	(a5,d1.w),d0			; get byte from input buffer
     771/     3DC : 675E                	BEQ.s		LAB_13EC				; if null save byte then continue crunching
     772/     3DE :                     
     773/     3DE : B03C 005F           	CMP.b		#'_',d0				; compare with "_"
     774/     3E2 : 6458                	BCC.s		LAB_13EC				; if >= "_" save byte then continue crunching
     775/     3E4 :                     
     776/     3E4 : B03C 003C           	CMP.b		#'<',d0				; compare with "<"
     777/     3E8 : 641C                	BCC.s		LAB_13CC				; if >= "<" go crunch
     778/     3EA :                     
     779/     3EA : B03C 0030           	CMP.b		#'0',d0				; compare with "0"
     780/     3EE : 644C                	BCC.s		LAB_13EC				; if >= "0" save byte then continue crunching
     781/     3F0 :                     
     782/     3F0 : 1740 05DA           	MOVE.b	d0,Asrch(a3)			; save buffer byte as search character
     783/     3F4 : B03C 0022           	CMP.b		#$22,d0				; is it quote character?
     784/     3F8 : 6776                	BEQ.s		LAB_1410				; branch if so (copy quoted string)
     785/     3FA :                     
     786/     3FA : B03C 0024           	CMP.b		#'$',d0				; is it the hex value character?
     787/     3FE : 679A                	BEQ.s		LAB_1392				; if so go copy a hex value
     788/     400 :                     
     789/     400 :                     LAB_13C6
     790/     400 : B03C 002A           	CMP.b		#'*',d0				; compare with "*"
     791/     404 : 6536                	BCS.s		LAB_13EC				; if <= "*" save byte then continue crunching
     792/     406 :                     
     793/     406 :                     								; crunch rest
     794/     406 :                     LAB_13CC
     795/     406 : 082B 0006 05DD      	BTST.b	#6,Oquote(a3)			; test open quote/DATA token flag
     796/     40C : 662E                	BNE.s		LAB_13EC				; branch if b6 of Oquote set (was DATA)
     797/     40E :                     								; go save byte then continue crunching
     798/     40E :                     
     799/     40E : 903C 002A           	SUB.b		#$2A,d0				; normalise byte
     800/     412 : D040                	ADD.w		d0,d0					; *2 makes word offset (high byte=$00)
     801/     414 : 43FA 2C1A           	LEA		TAB_CHRT(pc),a1			; get keyword offset table address
     802/     418 : 3031 0000           	MOVE.w	(a1,d0.w),d0			; get offset into keyword table
     803/     41C : 6B6E                	BMI.s		LAB_141F				; branch if no keywords for character
     804/     41E :                     
     805/     41E : 43FA 2FA6           	LEA		TAB_STAR(pc),a1			; get keyword table address
     806/     422 : D2C0                	ADDA.w	d0,a1					; add keyword offset
     807/     424 : 76FF                	MOVEQ		#-1,d3				; clear index
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 18 - 10/11/2023 16:23:32


     808/     426 : 3801                	MOVE.w	d1,d4					; copy read index
     809/     428 :                     LAB_13D6
     810/     428 : 5243                	ADDQ.w	#1,d3					; increment table index
     811/     42A : 1031 3000           	MOVE.b	(a1,d3.w),d0			; get byte from table
     812/     42E :                     LAB_13D8
     813/     42E : 6B0A                	BMI.s		LAB_13EA				; branch if token, save token and continue
     814/     430 :                     								; crunching
     815/     430 :                     
     816/     430 : 5244                	ADDQ.w	#1,d4					; increment read index
     817/     432 : B035 4000           	CMP.b		(a5,d4.w),d0			; compare byte from input buffer
     818/     436 : 67F0                	BEQ.s		LAB_13D6				; loop if character match
     819/     438 :                     
     820/     438 : 6040                	BRA.s		LAB_1417				; branch if no match
     821/     43A :                     
     822/     43A :                     LAB_13EA
     823/     43A : 3204                	MOVE.w	d4,d1					; update read index
     824/     43C :                     LAB_13EC
     825/     43C : 1180 2000           	MOVE.b	d0,(a0,d2.w)			; save byte to output
     826/     440 : 5242                	ADDQ.w	#1,d2					; increment buffer save index
     827/     442 : 5241                	ADDQ.w	#1,d1					; increment buffer read index
     828/     444 : 4A00                	TST.b		d0					; set flags
     829/     446 : 674A                	BEQ.s		LAB_142A				; branch if was null [EOL]
     830/     448 :                     
     831/     448 :                     								; d0 holds token or byte here
     832/     448 : 903C 003A           	SUB.b		#$3A,d0				; subtract ":"
     833/     44C : 6706                	BEQ.s		LAB_13FF				; branch if it was ":" (is now $00)
     834/     44E :                     
     835/     44E :                     								; d0 now holds token-$3A
     836/     44E : B03C 0049           	CMP.b		#(TK_DATA-$3A),d0			; compare with DATA token - $3A
     837/     452 : 6604                	BNE.s		LAB_1401				; branch if not DATA
     838/     454 :                     
     839/     454 :                     								; token was : or DATA
     840/     454 :                     LAB_13FF
     841/     454 : 1740 05DD           	MOVE.b	d0,Oquote(a3)			; save token-$3A ($00 for ":", TK_DATA-$3A for
     842/     458 :                     								; DATA)
     843/     458 :                     LAB_1401
     844/     458 : 903C 0055           	SUB.b		#(TK_REM-$3A),d0			; subtract REM token offset
     845/     45C : 6600 FF78           	BNE		LAB_13AC				; If wasn't REM then go crunch rest of line
     846/     460 :                     
     847/     460 : 1740 05DA           	MOVE.b	d0,Asrch(a3)			; else was REM so set search for [EOL]
     848/     464 :                     
     849/     464 :                     								; loop for REM, "..." etc.
     850/     464 :                     LAB_1408
     851/     464 : 1035 1000           	MOVE.b	(a5,d1.w),d0			; get byte from input buffer
     852/     468 : 67D2                	BEQ.s		LAB_13EC				; branch if null [EOL]
     853/     46A :                     
     854/     46A : B02B 05DA           	CMP.b		Asrch(a3),d0			; compare with stored character
     855/     46E : 67CC                	BEQ.s		LAB_13EC				; branch if match (end quote, REM, :, or DATA)
     856/     470 :                     
     857/     470 :                     								; entry for copy string in quotes, don't crunch
     858/     470 :                     LAB_1410
     859/     470 : 1180 2000           	MOVE.b	d0,(a0,d2.w)			; save byte to output
     860/     474 : 5242                	ADDQ.w	#1,d2					; increment buffer save index
     861/     476 : 5241                	ADDQ.w	#1,d1					; increment buffer read index
     862/     478 : 60EA                	BRA.s		LAB_1408				; loop
     863/     47A :                     
     864/     47A :                     ; not found keyword this go so find the end of this word in the table
     865/     47A :                     
     866/     47A :                     LAB_1417
     867/     47A : 3801                	MOVE.w	d1,d4					; reset read pointer
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 19 - 10/11/2023 16:23:32


     868/     47C :                     LAB_141B
     869/     47C : 5243                	ADDQ.w	#1,d3					; increment keyword table pointer, flag
     870/     47E :                     								; unchanged
     871/     47E : 1031 3000           	MOVE.b	(a1,d3.w),d0			; get keyword table byte
     872/     482 : 6AF8                	BPL.s		LAB_141B				; if not end of keyword go do next byte
     873/     484 :                     
     874/     484 : 5243                	ADDQ.w	#1,d3					; increment keyword table pointer flag
     875/     486 :                     								; unchanged
     876/     486 : 1031 3000           	MOVE.b	(a1,d3.w),d0			; get keyword table byte
     877/     48A : 66A2                	BNE.s		LAB_13D8				; go test next word if not zero byte (table end)
     878/     48C :                     
     879/     48C :                     								; reached end of table with no match
     880/     48C :                     LAB_141F
     881/     48C : 1035 1000           	MOVE.b	(a5,d1.w),d0			; restore byte from input buffer
     882/     490 : 60AA                	BRA.s		LAB_13EC				; go save byte in output and continue crunching
     883/     492 :                     
     884/     492 :                     								; reached [EOL]
     885/     492 :                     LAB_142A
     886/     492 : 7000                	MOVEQ		#0,d0					; ensure longword clear
     887/     494 : 0102                	BTST		d0,d2					; test odd bit (fastest)
     888/     496 : 6706                	BEQ.s		LAB_142C				; branch if no bytes to fill
     889/     498 :                     
     890/     498 : 1180 2000           	MOVE.b	d0,(a0,d2.w)			; clear next byte
     891/     49C : 5242                	ADDQ.w	#1,d2					; increment buffer save index
     892/     49E :                     LAB_142C
     893/     49E : 2180 2000           	MOVE.l	d0,(a0,d2.w)			; clear next line pointer, EOT in immediate mode
     894/     4A2 : 4E75                	RTS
     895/     4A4 :                     
     896/     4A4 :                     
     897/     4A4 :                     ;************************************************************************************
     898/     4A4 :                     ;
     899/     4A4 :                     ; search Basic for d1 line number from start of mem
     900/     4A4 :                     
     901/     4A4 :                     LAB_SSLN
     902/     4A4 : 206B 042E           	MOVEA.l	Smeml(a3),a0			; get start of program mem
     903/     4A8 : 6002                	BRA.s		LAB_SCLN				; go search for required line from a0
     904/     4AA :                     
     905/     4AA :                     LAB_145F
     906/     4AA : 2040                	MOVEA.l	d0,a0					; copy next line pointer
     907/     4AC :                     
     908/     4AC :                     ; search Basic for d1 line number from a0
     909/     4AC :                     ; returns Cb=0 if found
     910/     4AC :                     ; returns a0 pointer to found or next higher (not found) line
     911/     4AC :                     
     912/     4AC :                     LAB_SCLN
     913/     4AC : 2018                	MOVE.l	(a0)+,d0				; get next line pointer and point to line #
     914/     4AE : 6708                	BEQ.s		LAB_145E				; is end marker so we're done, do 'no line' exit
     915/     4B0 :                     
     916/     4B0 : B290                	CMP.l		(a0),d1				; compare this line # with required line #
     917/     4B2 : 6EF6                	BGT.s		LAB_145F				; loop if required # > this #
     918/     4B4 :                     
     919/     4B4 : 5948                	SUBQ.w	#4,a0					; adjust pointer, flags not changed
     920/     4B6 : 4E75                	RTS
     921/     4B8 :                     
     922/     4B8 :                     LAB_145E
     923/     4B8 : 5948                	SUBQ.w	#4,a0					; adjust pointer, flags not changed
     924/     4BA : 5380                	SUBQ.l	#1,d0					; make end program found = -1, set carry
     925/     4BC : 4E75                	RTS
     926/     4BE :                     
     927/     4BE :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 20 - 10/11/2023 16:23:32


     928/     4BE :                     ;************************************************************************************
     929/     4BE :                     ;
     930/     4BE :                     ; perform NEW
     931/     4BE :                     
     932/     4BE :                     LAB_NEW
     933/     4BE : 664E                	BNE.s		RTS_005				; exit if not end of statement (do syntax error)
     934/     4C0 :                     
     935/     4C0 :                     LAB_1463
     936/     4C0 : 206B 042E           	MOVEA.l	Smeml(a3),a0			; point to start of program memory
     937/     4C4 : 7000                	MOVEQ		#0,d0					; clear longword
     938/     4C6 : 20C0                	MOVE.l	d0,(a0)+				; clear first line, next line pointer
     939/     4C8 : 2748 0432           	MOVE.l	a0,Sfncl(a3)			; set start of functions
     940/     4CC :                     
     941/     4CC :                     ; reset execution to start, clear variables and flush stack
     942/     4CC :                     
     943/     4CC :                     LAB_1477
     944/     4CC : 2A6B 042E           	MOVEA.l	Smeml(a3),a5			; reset BASIC execute pointer
     945/     4D0 : 534D                	SUBQ.w	#1,a5					; -1 (as end of previous line)
     946/     4D2 :                     
     947/     4D2 :                     ; "CLEAR" command gets here
     948/     4D2 :                     
     949/     4D2 :                     LAB_147A
     950/     4D2 : 276B 044A 0446      	MOVE.l	Ememl(a3),Sstorl(a3)		; save end of mem as bottom of string space
     951/     4D8 : 202B 0432           	MOVE.l	Sfncl(a3),d0			; get start of functions
     952/     4DC : 2740 0436           	MOVE.l	d0,Svarl(a3)			; start of variables
     953/     4E0 : 2740 043A           	MOVE.l	d0,Sstrl(a3)			; start of strings
     954/     4E4 : 2740 043E           	MOVE.l	d0,Sarryl(a3)			; set start of arrays
     955/     4E8 : 2740 0442           	MOVE.l	d0,Earryl(a3)			; set end of arrays
     956/     4EC :                     LAB_1480
     957/     4EC : 7000                	MOVEQ		#0,d0					; set Zb
     958/     4EE : 1740 05EA           	MOVE.b	d0,ccnull(a3)			; clear get byte countdown
     959/     4F2 : 6100 01D0           	BSR		LAB_RESTORE				; perform RESTORE command
     960/     4F6 :                     
     961/     4F6 :                     ; flush stack & clear continue flag
     962/     4F6 :                     
     963/     4F6 :                     LAB_1491
     964/     4F6 : 49EB 048E           	LEA		des_sk(a3),a4			; reset descriptor stack pointer
     965/     4FA :                     
     966/     4FA : 201F                	MOVE.l	(sp)+,d0				; pull return address
     967/     4FC : 2E7C 0000 4400      	MOVE.l	#ram_addr+ram_base,sp	; set stack to RAM start + 1k, flush stack
     968/     502 : 2F00                	MOVE.l	d0,-(sp)				; restore return address
     969/     504 :                     
     970/     504 : 7000                	MOVEQ		#0,d0					; clear longword
     971/     506 : 2740 045A           	MOVE.l	d0,Cpntrl(a3)			; clear continue pointer
     972/     50A : 1740 05DF           	MOVE.b	d0,Sufnxf(a3)			; clear subscript/FNX flag
     973/     50E :                     RTS_005
     974/     50E : 4E75                	RTS
     975/     510 :                     
     976/     510 :                     
     977/     510 :                     ;************************************************************************************
     978/     510 :                     ;
     979/     510 :                     ; perform CLEAR
     980/     510 :                     
     981/     510 :                     LAB_CLEAR
     982/     510 : 67C0                	BEQ.s		LAB_147A				; if no following byte go do "CLEAR"
     983/     512 :                     
     984/     512 : 4E75                	RTS							; was following byte (go do syntax error)
     985/     514 :                     
     986/     514 :                     
     987/     514 :                     ;************************************************************************************
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 21 - 10/11/2023 16:23:32


     988/     514 :                     ;
     989/     514 :                     ; perform LIST [n][-m]
     990/     514 :                     
     991/     514 :                     LAB_LIST
     992/     514 : 6512                	BCS.s		LAB_14BD				; branch if next character numeric (LIST n...)
     993/     516 :                     
     994/     516 : 72FF                	MOVEQ		#-1,d1				; set end to $FFFFFFFF
     995/     518 : 2741 042A           	MOVE.l	d1,Itemp(a3)			; save to Itemp
     996/     51C :                     
     997/     51C : 7200                	MOVEQ		#0,d1					; set start to $00000000
     998/     51E : 4A00                	TST.b		d0					; test next byte
     999/     520 : 670A                	BEQ.s		LAB_14C0				; branch if next character [NULL] (LIST)
    1000/     522 :                     
    1001/     522 : B03C 00B3           	CMP.b		#TK_MINUS,d0			; compare with token for -
    1002/     526 : 66E6                	BNE.s		RTS_005				; exit if not - (LIST -m)
    1003/     528 :                     
    1004/     528 :                     								; LIST [[n]-[m]] this sets the n, if present,
    1005/     528 :                     								; as the start and end
    1006/     528 :                     LAB_14BD
    1007/     528 : 6100 0396           	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
    1008/     52C :                     LAB_14C0
    1009/     52C : 6100 FF76           	BSR		LAB_SSLN				; search BASIC for d1 line number
    1010/     530 :                     								; (pointer in a0)
    1011/     530 : 6100 093A           	BSR		LAB_GBYT				; scan memory
    1012/     534 : 6716                	BEQ.s		LAB_14D4				; branch if no more characters
    1013/     536 :                     
    1014/     536 :                     								; this bit checks the - is present
    1015/     536 : B03C 00B3           	CMP.b		#TK_MINUS,d0			; compare with token for -
    1016/     53A : 66D2                	BNE.s		RTS_005				; return if not "-" (will be Syntax error)
    1017/     53C :                     
    1018/     53C : 72FF                	MOVEQ		#-1,d1				; set end to $FFFFFFFF
    1019/     53E : 2741 042A           	MOVE.l	d1,Itemp(a3)			; save Itemp
    1020/     542 :                     
    1021/     542 :                     								; LIST [n]-[m] the - was there so see if
    1022/     542 :                     								; there is an m to set as the end value
    1023/     542 : 6100 0926           	BSR		LAB_IGBY				; increment & scan memory
    1024/     546 : 6704                	BEQ.s		LAB_14D4				; branch if was [NULL] (LIST n-)
    1025/     548 :                     
    1026/     548 : 6100 0376           	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
    1027/     54C :                     LAB_14D4
    1028/     54C : 177C 0000 05DD      	MOVE.b	#$00,Oquote(a3)			; clear open quote flag
    1029/     552 : 6100 04EE           	BSR		LAB_CRLF				; print CR/LF
    1030/     556 : 2018                	MOVE.l	(a0)+,d0				; get next line pointer
    1031/     558 : 67B4                	BEQ.s		RTS_005				; if null all done so exit
    1032/     55A :                     
    1033/     55A : 2240                	MOVEA.l	d0,a1					; copy next line pointer
    1034/     55C : 6100 012C           	BSR		LAB_1629				; do CRTL-C check vector
    1035/     560 :                     
    1036/     560 : 2018                	MOVE.l	(a0)+,d0				; get this line #
    1037/     562 : B0AB 042A           	CMP.l		Itemp(a3),d0			; compare end line # with this line #
    1038/     566 : 62A6                	BHI.s		RTS_005				; if this line greater all done so exit
    1039/     568 :                     
    1040/     568 :                     LAB_14E2
    1041/     568 : 48E7 00C0           	MOVEM.l	a0-a1,-(sp)				; save registers
    1042/     56C : 6100 181C           	BSR		LAB_295E				; print d0 as unsigned integer
    1043/     570 : 4CDF 0300           	MOVEM.l	(sp)+,a0-a1				; restore registers
    1044/     574 : 7020                	MOVEQ		#$20,d0				; space is the next character
    1045/     576 :                     LAB_150C
    1046/     576 : 6100 0542           	BSR		LAB_PRNA				; go print the character
    1047/     57A : B03C 0022           	CMP.b		#$22,d0				; was it " character
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 22 - 10/11/2023 16:23:32


    1048/     57E : 6606                	BNE.s		LAB_1519				; branch if not
    1049/     580 :                     
    1050/     580 :                     								; we're either entering or leaving quotes
    1051/     580 : 0A2B 00FF 05DD      	EOR.b		#$FF,Oquote(a3)			; toggle open quote flag
    1052/     586 :                     LAB_1519
    1053/     586 : 1018                	MOVE.b	(a0)+,d0				; get byte and increment pointer
    1054/     588 : 6608                	BNE.s		LAB_152E				; branch if not [EOL] (go print)
    1055/     58A :                     
    1056/     58A :                     								; was [EOL]
    1057/     58A : 2049                	MOVEA.l	a1,a0					; copy next line pointer
    1058/     58C : 2008                	MOVE.l	a0,d0					; copy to set flags
    1059/     58E : 66BC                	BNE.s		LAB_14D4				; go do next line if not [EOT]
    1060/     590 :                     
    1061/     590 : 4E75                	RTS
    1062/     592 :                     
    1063/     592 :                     LAB_152E
    1064/     592 : 6AE2                	BPL.s		LAB_150C				; just go print it if not token byte
    1065/     594 :                     
    1066/     594 :                     								; else it was a token byte so maybe uncrunch it
    1067/     594 : 4A2B 05DD           	TST.b		Oquote(a3)				; test the open quote flag
    1068/     598 : 6BDC                	BMI.s		LAB_150C				; just go print character if open quote set
    1069/     59A :                     
    1070/     59A :                     								; else uncrunch BASIC token
    1071/     59A : 45FA 2AFE           	LEA		LAB_KEYT(pc),a2			; get keyword table address
    1072/     59E : 727F                	MOVEQ		#$7F,d1				; mask into d1
    1073/     5A0 : C200                	AND.b		d0,d1					; copy and mask token
    1074/     5A2 : E549                	LSL.w		#2,d1					; *4
    1075/     5A4 : 45F2 1000           	LEA		(a2,d1.w),a2			; get keyword entry address
    1076/     5A8 : 101A                	MOVE.b	(a2)+,d0				; get byte from keyword table
    1077/     5AA : 6100 050E           	BSR		LAB_PRNA				; go print the first character
    1078/     5AE : 7200                	MOVEQ		#0,d1					; clear d1
    1079/     5B0 : 121A                	MOVE.b	(a2)+,d1				; get remaining length byte from keyword table
    1080/     5B2 : 6BD2                	BMI.s		LAB_1519				; if -ve done so go get next byte
    1081/     5B4 :                     
    1082/     5B4 : 3012                	MOVE.w	(a2),d0				; get offset to rest
    1083/     5B6 : 45FA 2E0E           	LEA		TAB_STAR(pc),a2			; get keyword table address
    1084/     5BA : 45F2 0000           	LEA		(a2,d0.w),a2			; get address of rest
    1085/     5BE :                     LAB_1540
    1086/     5BE : 101A                	MOVE.b	(a2)+,d0				; get byte from keyword table
    1087/     5C0 : 6100 04F8           	BSR		LAB_PRNA				; go print the character
    1088/     5C4 : 51C9 FFF8           	DBF		d1,LAB_1540				; decrement and loop if more to do
    1089/     5C8 :                     
    1090/     5C8 : 60BC                	BRA.s		LAB_1519				; go get next byte
    1091/     5CA :                     
    1092/     5CA :                     
    1093/     5CA :                     ;************************************************************************************
    1094/     5CA :                     ;
    1095/     5CA :                     ; perform FOR
    1096/     5CA :                     
    1097/     5CA :                     LAB_FOR
    1098/     5CA : 6100 0396           	BSR		LAB_LET				; go do LET
    1099/     5CE :                     
    1100/     5CE : 202B 0472           	MOVE.l	Lvarpl(a3),d0			; get the loop variable pointer
    1101/     5D2 : B0AB 043A           	CMP.l		Sstrl(a3),d0			; compare it with the end of vars memory
    1102/     5D6 : 6C00 FC20           	BGE		LAB_TMER				; if greater go do type mismatch error
    1103/     5DA :                     
    1104/     5DA :                     ; test for not less than the start of variables memory if needed
    1105/     5DA :                     ;
    1106/     5DA :                     ;	CMP.l		Svarl(a3),d0			; compare it with the start of variables memory
    1107/     5DA :                     ;	BLT		LAB_TMER				; if not variables memory do type mismatch error
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 23 - 10/11/2023 16:23:32


    1108/     5DA :                     
    1109/     5DA :                     ;	MOVEQ		#28,d0				; we need 28 bytes !
    1110/     5DA :                     ;	BSR.s		LAB_1212				; check room on stack for d0 bytes
    1111/     5DA :                     
    1112/     5DA : 6100 0214           	BSR		LAB_SNBS				; scan for next BASIC statement ([:] or [EOL])
    1113/     5DE :                     								; returns a0 as pointer to [:] or [EOL]
    1114/     5DE : 2E88                	MOVE.l	a0,(sp)				; push onto stack (and dump the return address)
    1115/     5E0 : 2F2B 0452           	MOVE.l	Clinel(a3),-(sp)			; push current line onto stack
    1116/     5E4 :                     
    1117/     5E4 : 70AA                	MOVEQ		#TK_TO-$100,d0			; set "TO" token
    1118/     5E6 : 6100 087A           	BSR		LAB_SCCA				; scan for CHR$(d0) else syntax error/warm start
    1119/     5EA : 6100 0708           	BSR		LAB_CTNM				; check if source is numeric, else type mismatch
    1120/     5EE : 1F2B 05B5           	MOVE.b	Dtypef(a3),-(sp)			; push the FOR variable data type onto stack
    1121/     5F2 : 6100 06FE           	BSR		LAB_EVNM				; evaluate expression and check is numeric else
    1122/     5F6 :                     								; do type mismatch
    1123/     5F6 :                     
    1124/     5F6 : 2F2B 0590           	MOVE.l	FAC1_m(a3),-(sp)			; push TO value mantissa
    1125/     5FA : 3F2B 0594           	MOVE.w	FAC1_e(a3),-(sp)			; push TO value exponent and sign
    1126/     5FE :                     
    1127/     5FE : 277C 8000 0000      	MOVE.l	#$80000000,FAC1_m(a3)		; set default STEP size mantissa
              604 : 0590             
    1128/     606 : 377C 8100 0594      	MOVE.w	#$8100,FAC1_e(a3)			; set default STEP size exponent and sign
    1129/     60C :                     
    1130/     60C : 6100 085E           	BSR		LAB_GBYT				; scan memory
    1131/     610 : B03C 00AF           	CMP.b		#TK_STEP,d0				; compare with STEP token
    1132/     614 : 6608                	BNE.s		LAB_15B3				; jump if not "STEP"
    1133/     616 :                     
    1134/     616 :                     								; was STEP token so ....
    1135/     616 : 6100 0852           	BSR		LAB_IGBY				; increment & scan memory
    1136/     61A : 6100 06D6           	BSR		LAB_EVNM				; evaluate expression & check is numeric
    1137/     61E :                     								; else do type mismatch
    1138/     61E :                     LAB_15B3
    1139/     61E : 2F2B 0590           	MOVE.l	FAC1_m(a3),-(sp)			; push STEP value mantissa
    1140/     622 : 3F2B 0594           	MOVE.w	FAC1_e(a3),-(sp)			; push STEP value exponent and sign
    1141/     626 :                     
    1142/     626 : 2F2B 0472           	MOVE.l	Lvarpl(a3),-(sp)			; push variable pointer for FOR/NEXT
    1143/     62A : 3F3C 0081           	MOVE.w	#TK_FOR,-(sp)			; push FOR token on stack
    1144/     62E :                     
    1145/     62E : 6018                	BRA.s		LAB_15C2				; go do interpreter inner loop
    1146/     630 :                     
    1147/     630 :                     LAB_15DC							; have reached [EOL]+1
    1148/     630 : 300D                	MOVE.w	a5,d0					; copy BASIC execute pointer
    1149/     632 : C07C 0001           	AND.w		#1,d0					; and make line start address even
    1150/     636 : DAC0                	ADD.w		d0,a5					; add to BASIC execute pointer
    1151/     638 : 201D                	MOVE.l	(a5)+,d0				; get next line pointer
    1152/     63A : 6700 FC18           	BEQ		LAB_1274				; if null go to immediate mode, no "BREAK"
    1153/     63E :                     								; message (was immediate or [EOT] marker)
    1154/     63E :                     
    1155/     63E : 275D 0452           	MOVE.l	(a5)+,Clinel(a3)			; save (new) current line #
    1156/     642 :                     LAB_15F6
    1157/     642 : 6100 0828           	BSR		LAB_GBYT				; get BASIC byte
    1158/     646 : 611A                	BSR.s		LAB_15FF				; go interpret BASIC code from (a5)
    1159/     648 :                     
    1160/     648 :                     ; interpreter inner loop (re)entry point
    1161/     648 :                     
    1162/     648 :                     LAB_15C2
    1163/     648 : 6140                	BSR.s		LAB_1629				; do CRTL-C check vector
    1164/     64A : 4A2B 0452           	TST.b		Clinel(a3)				; test current line #, is -ve for immediate mode
    1165/     64E : 6B04                	BMI.s		LAB_15D1				; branch if immediate mode
    1166/     650 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 24 - 10/11/2023 16:23:32


    1167/     650 : 274D 045A           	MOVE.l	a5,Cpntrl(a3)			; save BASIC execute pointer as continue pointer
    1168/     654 :                     LAB_15D1
    1169/     654 : 101D                	MOVE.b	(a5)+,d0				; get this byte & increment pointer
    1170/     656 : 67D8                	BEQ.s		LAB_15DC				; loop if [EOL]
    1171/     658 :                     
    1172/     658 : B03C 003A           	CMP.b		#$3A,d0				; compare with ":"
    1173/     65C : 67E4                	BEQ.s		LAB_15F6				; loop if was statement separator
    1174/     65E :                     
    1175/     65E : 6000 FBC4           	BRA		LAB_SNER				; else syntax error, then warm start
    1176/     662 :                     
    1177/     662 :                     
    1178/     662 :                     ;************************************************************************************
    1179/     662 :                     ;
    1180/     662 :                     ; interpret BASIC code from (a5)
    1181/     662 :                     
    1182/     662 :                     LAB_15FF
    1183/     662 : 6700 008C           	BEQ		RTS_006				; exit if zero [EOL]
    1184/     666 :                     
    1185/     666 :                     LAB_1602
    1186/     666 : 0A00 0080           	EORI.b	#$80,d0				; normalise token
    1187/     66A : 6B00 02F6           	BMI		LAB_LET				; if not token, go do implied LET
    1188/     66E :                     
    1189/     66E : B03C 0028           	CMP.b		#(TK_TAB-$80),d0			; compare normalised token with TAB
    1190/     672 : 6400 FBB0           	BCC		LAB_SNER				; branch if d0>=TAB, syntax error/warm start
    1191/     676 :                     								; only tokens before TAB can start a statement
    1192/     676 :                     
    1193/     676 : 4880                	EXT.w		d0					; byte to word (clear high byte)
    1194/     678 : D040                	ADD.w		d0,d0					; *2
    1195/     67A : 41FA 287C           	LEA		LAB_CTBL(pc),a0			; get vector table base address
    1196/     67E : 3030 0000           	MOVE.w	(a0,d0.w),d0			; get offset to vector
    1197/     682 : 4870 0000           	PEA		(a0,d0.w)				; push vector
    1198/     686 : 6000 07E2           	BRA		LAB_IGBY				; get following byte & execute vector
    1199/     68A :                     
    1200/     68A :                     
    1201/     68A :                     ;************************************************************************************
    1202/     68A :                     ;
    1203/     68A :                     ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
    1204/     68A :                     ; key press is detected.
    1205/     68A :                     
    1206/     68A :                     LAB_1629
    1207/     68A : 4EEB 0424           	JMP		V_CTLC(a3)				; ctrl c check vector
    1208/     68E :                     
    1209/     68E :                     ; if there was a key press it gets back here .....
    1210/     68E :                     
    1211/     68E :                     LAB_1636
    1212/     68E : B03C 0003           	CMP.b		#$03,d0				; compare with CTRL-C
    1213/     692 : 670C                	BEQ.s		LAB_163B				; STOP if was CTRL-C
    1214/     694 :                     
    1215/     694 :                     LAB_1639
    1216/     694 : 4E75                	RTS
    1217/     696 :                     
    1218/     696 :                     
    1219/     696 :                     ;************************************************************************************
    1220/     696 :                     ;
    1221/     696 :                     ; perform END
    1222/     696 :                     
    1223/     696 :                     LAB_END
    1224/     696 : 66FC                	BNE.s		LAB_1639				; exit if something follows STOP
    1225/     698 : 177C 0000 05DC      	MOVE.b	#0,Breakf(a3)			; clear break flag, indicate program end
    1226/     69E :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 25 - 10/11/2023 16:23:32


    1227/     69E :                     
    1228/     69E :                     ;************************************************************************************
    1229/     69E :                     ;
    1230/     69E :                     ; perform STOP
    1231/     69E :                     
    1232/     69E :                     LAB_STOP
    1233/     69E : 66F4                	BNE.s		LAB_1639				; exit if something follows STOP
    1234/     6A0 :                     
    1235/     6A0 :                     LAB_163B
    1236/     6A0 : 43EB 0590           	LEA		Ibuffe(a3),a1			; get buffer end
    1237/     6A4 : BBC9                	CMPA.l	a1,a5					; compare execute address with buffer end
    1238/     6A6 : 650A                	BCS.s		LAB_164F				; branch if BASIC pointer is in buffer
    1239/     6A8 :                     								; can't continue in immediate mode
    1240/     6A8 :                     
    1241/     6A8 :                     								; else...
    1242/     6A8 : 274D 045A           	MOVE.l	a5,Cpntrl(a3)			; save BASIC execute pointer as continue pointer
    1243/     6AC :                     LAB_1647
    1244/     6AC : 276B 0452 0456      	MOVE.l	Clinel(a3),Blinel(a3)		; save break line
    1245/     6B2 :                     LAB_164F
    1246/     6B2 : 584F                	ADDQ.w	#4,sp					; dump return address, don't return to execute
    1247/     6B4 :                     								; loop
    1248/     6B4 : 102B 05DC           	MOVE.b	Breakf(a3),d0			; get break flag
    1249/     6B8 : 6700 FB9A           	BEQ		LAB_1274				; go do warm start if was program end
    1250/     6BC :                     
    1251/     6BC : 41FA 2EB3           	LEA		LAB_BMSG(pc),a0			; point to "Break"
    1252/     6C0 : 6000 FB84           	BRA		LAB_1269				; print "Break" and do warm start
    1253/     6C4 :                     
    1254/     6C4 :                     
    1255/     6C4 :                     ;************************************************************************************
    1256/     6C4 :                     ;
    1257/     6C4 :                     ; perform RESTORE
    1258/     6C4 :                     
    1259/     6C4 :                     LAB_RESTORE
    1260/     6C4 : 206B 042E           	MOVEA.l	Smeml(a3),a0			; copy start of memory
    1261/     6C8 : 6720                	BEQ.s		LAB_1624				; branch if next character null (RESTORE)
    1262/     6CA :                     
    1263/     6CA : 6100 01F4           	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
    1264/     6CE : B2AB 0452           	CMP.l		Clinel(a3),d1			; compare current line # with required line #
    1265/     6D2 : 630E                	BLS.s		LAB_GSCH				; branch if >= (start search from beginning)
    1266/     6D4 :                     
    1267/     6D4 : 204D                	MOVEA.l	a5,a0					; copy BASIC execute pointer
    1268/     6D6 :                     LAB_RESs
    1269/     6D6 : 4A18                	TST.b		(a0)+					; test next byte & increment pointer
    1270/     6D8 : 66FC                	BNE.s		LAB_RESs				; loop if not EOL
    1271/     6DA :                     
    1272/     6DA : 3008                	MOVE.w	a0,d0					; copy pointer
    1273/     6DC : C07C 0001           	AND.w		#1,d0					; mask odd bit
    1274/     6E0 : D0C0                	ADD.w		d0,a0					; add pointer
    1275/     6E2 :                     								; search for line in Itemp from (a0)
    1276/     6E2 :                     LAB_GSCH
    1277/     6E2 : 6100 FDC8           	BSR		LAB_SCLN				; search for d1 line number from a0
    1278/     6E6 :                     								; returns Cb=0 if found
    1279/     6E6 : 6500 FB24           	BCS		LAB_USER				; go do "Undefined statement" error if not found
    1280/     6EA :                     
    1281/     6EA :                     LAB_1624
    1282/     6EA : 4A20                	TST.b		-(a0)					; decrement pointer (faster)
    1283/     6EC : 2748 0462           	MOVE.l	a0,Dptrl(a3)			; save DATA pointer
    1284/     6F0 :                     RTS_006
    1285/     6F0 : 4E75                	RTS
    1286/     6F2 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 26 - 10/11/2023 16:23:32


    1287/     6F2 :                     
    1288/     6F2 :                     ;************************************************************************************
    1289/     6F2 :                     ;
    1290/     6F2 :                     ; perform NULL
    1291/     6F2 :                     
    1292/     6F2 :                     LAB_NULL
    1293/     6F2 : 6100 10E2           	BSR		LAB_GTBY				; get byte parameter, result in d0 and Itemp
    1294/     6F6 : 1740 05E4           	MOVE.b	d0,Nullct(a3)			; save new NULL count
    1295/     6FA : 4E75                	RTS
    1296/     6FC :                     
    1297/     6FC :                     
    1298/     6FC :                     ;************************************************************************************
    1299/     6FC :                     ;
    1300/     6FC :                     ; perform CONT
    1301/     6FC :                     
    1302/     6FC :                     LAB_CONT
    1303/     6FC : 6600 FB26           	BNE		LAB_SNER				; if following byte exit to do syntax error
    1304/     700 :                     
    1305/     700 : 4A2B 0452           	TST.b		Clinel(a3)				; test current line #, is -ve for immediate mode
    1306/     704 : 6A00 FAE6           	BPL		LAB_CCER				; if running go do can't continue error
    1307/     708 :                     
    1308/     708 : 202B 045A           	MOVE.l	Cpntrl(a3),d0			; get continue pointer
    1309/     70C : 6700 FADE           	BEQ		LAB_CCER				; go do can't continue error if we can't
    1310/     710 :                     
    1311/     710 :                     								; we can continue so ...
    1312/     710 : 2A40                	MOVEA.l	d0,a5					; save continue pointer as BASIC execute pointer
    1313/     712 : 276B 0456 0452      	MOVE.l	Blinel(a3),Clinel(a3)		; set break line as current line
    1314/     718 : 4E75                	RTS
    1315/     71A :                     
    1316/     71A :                     
    1317/     71A :                     ;************************************************************************************
    1318/     71A :                     ;
    1319/     71A :                     ; perform RUN
    1320/     71A :                     
    1321/     71A :                     LAB_RUN
    1322/     71A : 660C                	BNE.s		LAB_RUNn				; if following byte do RUN n
    1323/     71C :                     
    1324/     71C : 6100 FDAE           	BSR		LAB_1477				; execution to start, clear vars & flush stack
    1325/     720 : 274D 045A           	MOVE.l	a5,Cpntrl(a3)			; save as continue pointer
    1326/     724 : 6000 FF22           	BRA		LAB_15C2				; go do interpreter inner loop
    1327/     728 :                     								; (can't RTS, we flushed the stack!)
    1328/     728 :                     
    1329/     728 :                     LAB_RUNn
    1330/     728 : 6100 FDA8           	BSR		LAB_147A				; go do "CLEAR"
    1331/     72C : 601C                	BRA.s		LAB_16B0				; get n and do GOTO n
    1332/     72E :                     
    1333/     72E :                     
    1334/     72E :                     ;************************************************************************************
    1335/     72E :                     ;
    1336/     72E :                     ; perform DO
    1337/     72E :                     
    1338/     72E :                     LAB_DO
    1339/     72E :                     ;	MOVE.l	#$05,d0				; need 5 bytes for DO
    1340/     72E :                     ;	BSR.s		LAB_1212				; check room on stack for A bytes
    1341/     72E : 2F0D                	MOVE.l	a5,-(sp)				; push BASIC execute pointer on stack
    1342/     730 : 2F2B 0452           	MOVE.l	Clinel(a3),-(sp)			; push current line on stack
    1343/     734 : 3F3C 009C           	MOVE.w	#TK_DO,-(sp)			; push token for DO on stack
    1344/     738 : 487A FF0E           	PEA		LAB_15C2(pc)			; set return address
    1345/     73C : 6000 072E           	BRA		LAB_GBYT				; scan memory & return to interpreter inner loop
    1346/     740 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 27 - 10/11/2023 16:23:32


    1347/     740 :                     
    1348/     740 :                     ;************************************************************************************
    1349/     740 :                     ;
    1350/     740 :                     ; perform GOSUB
    1351/     740 :                     
    1352/     740 :                     LAB_GOSUB
    1353/     740 :                     ;	MOVE.l	#10,d0				; need 10 bytes for GOSUB
    1354/     740 :                     ;	BSR.s		LAB_1212				; check room on stack for d0 bytes
    1355/     740 : 2F0D                	MOVE.l	a5,-(sp)				; push BASIC execute pointer
    1356/     742 : 2F2B 0452           	MOVE.l	Clinel(a3),-(sp)			; push current line
    1357/     746 : 3F3C 008D           	MOVE.w	#TK_GOSUB,-(sp)			; push token for GOSUB
    1358/     74A :                     LAB_16B0
    1359/     74A : 6100 0720           	BSR		LAB_GBYT				; scan memory
    1360/     74E : 487A FEF8           	PEA		LAB_15C2(pc)			; return to interpreter inner loop after GOTO n
    1361/     752 :                     
    1362/     752 :                     ; this PEA is needed because either we just cleared the stack and have nowhere to return
    1363/     752 :                     ; to or, in the case of GOSUB, we have just dropped a load on the stack and the address
    1364/     752 :                     ; we whould have returned to is buried. This burried return address will be unstacked by
    1365/     752 :                     ; the corresponding RETURN command
    1366/     752 :                     
    1367/     752 :                     
    1368/     752 :                     ;************************************************************************************
    1369/     752 :                     ;
    1370/     752 :                     ; perform GOTO
    1371/     752 :                     
    1372/     752 :                     LAB_GOTO
    1373/     752 : 6100 016C           	BSR		LAB_GFPN				; get fixed-point number into temp integer & d1
    1374/     756 : 206B 042E           	MOVEA.l	Smeml(a3),a0			; get start of memory
    1375/     75A : B2AB 0452           	CMP.l		Clinel(a3),d1			; compare current line with wanted #
    1376/     75E : 630E                	BLS.s		LAB_16D0				; branch if current # => wanted #
    1377/     760 :                     
    1378/     760 : 204D                	MOVEA.l	a5,a0					; copy BASIC execute pointer
    1379/     762 :                     LAB_GOTs
    1380/     762 : 4A18                	TST.b		(a0)+					; test next byte & increment pointer
    1381/     764 : 66FC                	BNE.s		LAB_GOTs				; loop if not EOL
    1382/     766 :                     
    1383/     766 : 3008                	MOVE.w	a0,d0					; past pad byte(s)
    1384/     768 : C07C 0001           	AND.w		#1,d0					; mask odd bit
    1385/     76C : D0C0                	ADD.w		d0,a0					; add to pointer
    1386/     76E :                     
    1387/     76E :                     LAB_16D0
    1388/     76E : 6100 FD3C           	BSR		LAB_SCLN				; search for d1 line number from a0
    1389/     772 :                     								; returns Cb=0 if found
    1390/     772 : 6500 FA98           	BCS		LAB_USER				; if carry set go do "Undefined statement" error
    1391/     776 :                     
    1392/     776 : 2A48                	MOVEA.l	a0,a5					; copy to basic execute pointer
    1393/     778 : 534D                	SUBQ.w	#1,a5					; decrement pointer
    1394/     77A : 274D 045A           	MOVE.l	a5,Cpntrl(a3)			; save as continue pointer
    1395/     77E : 4E75                	RTS
    1396/     780 :                     
    1397/     780 :                     
    1398/     780 :                     ;************************************************************************************
    1399/     780 :                     ;
    1400/     780 :                     ; perform LOOP
    1401/     780 :                     
    1402/     780 :                     LAB_LOOP
    1403/     780 : 0C6F 009C 0004      	CMP.w		#TK_DO,4(sp)			; compare token on stack with DO token
    1404/     786 : 6600 FA5C           	BNE		LAB_LDER				; branch if no matching DO
    1405/     78A :                     
    1406/     78A : 1E00                	MOVE.b	d0,d7					; copy following token (byte)
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 28 - 10/11/2023 16:23:32


    1407/     78C : 672E                	BEQ.s		LoopAlways				; if no following token loop forever
    1408/     78E :                     
    1409/     78E : BE3C 003A           	CMP.b		#':',d7				; compare with ":"
    1410/     792 : 6728                	BEQ.s		LoopAlways				; if no following token loop forever
    1411/     794 :                     
    1412/     794 : 9E3C 00B0           	SUB.b		#TK_UNTIL,d7			; subtract token for UNTIL
    1413/     798 : 6708                	BEQ.s		DoRest				; branch if was UNTIL
    1414/     79A :                     
    1415/     79A : 5307                	SUBQ.b	#1,d7					; decrement result
    1416/     79C : 6600 FA86           	BNE		LAB_SNER				; if not WHILE go do syntax error & warm start
    1417/     7A0 :                     								; only if the token was WHILE will this fail
    1418/     7A0 :                     
    1419/     7A0 : 7EFF                	MOVEQ		#-1,d7				; set invert result longword
    1420/     7A2 :                     DoRest
    1421/     7A2 : 6100 06C6           	BSR		LAB_IGBY				; increment & scan memory
    1422/     7A6 : 6100 0562           	BSR		LAB_EVEX				; evaluate expression
    1423/     7AA : 4A2B 0594           	TST.b		FAC1_e(a3)				; test FAC1 exponent
    1424/     7AE : 6706                	BEQ.s		DoCmp					; if = 0 go do straight compare
    1425/     7B0 :                     
    1426/     7B0 : 177C 00FF 0594      	MOVE.b	#$FF,FAC1_e(a3)			; else set all bits
    1427/     7B6 :                     DoCmp
    1428/     7B6 : BF2B 0594           	EOR.b		d7,FAC1_e(a3)			; EOR with invert byte
    1429/     7BA : 6614                	BNE.s		LoopDone				; if <> 0 clear stack & back to interpreter loop
    1430/     7BC :                     
    1431/     7BC :                     								; loop condition wasn't met so do it again
    1432/     7BC :                     LoopAlways
    1433/     7BC : 276F 0006 0452      	MOVE.l	6(sp),Clinel(a3)			; copy DO current line
    1434/     7C2 : 2A6F 000A           	MOVE.l	10(sp),a5				; save BASIC execute pointer
    1435/     7C6 :                     
    1436/     7C6 : 41FA FE80           	LEA		LAB_15C2(pc),a0			; get return address
    1437/     7CA : 2E88                	MOVE.l	a0,(sp)				; dump the call to this routine and set the
    1438/     7CC :                     								; return address
    1439/     7CC : 6000 069E           	BRA		LAB_GBYT				; scan memory and return to interpreter inner
    1440/     7D0 :                     								; loop
    1441/     7D0 :                     
    1442/     7D0 :                     								; clear stack & back to interpreter loop
    1443/     7D0 :                     LoopDone
    1444/     7D0 : 4FEF 000E           	LEA		14(sp),sp				; dump structure and call from stack
    1445/     7D4 : 6014                	BRA.s		LAB_DATA				; go perform DATA (find : or [EOL])
    1446/     7D6 :                     
    1447/     7D6 :                     
    1448/     7D6 :                     ;************************************************************************************
    1449/     7D6 :                     ;
    1450/     7D6 :                     ; perform RETURN
    1451/     7D6 :                     
    1452/     7D6 :                     LAB_RETURN
    1453/     7D6 : 6616                	BNE.s		RTS_007				; exit if following token to allow syntax error
    1454/     7D8 :                     
    1455/     7D8 : 0C6F 008D 0004      	CMP.w		#TK_GOSUB,4(sp)			; compare token from stack with GOSUB
    1456/     7DE : 6600 FA40           	BNE		LAB_RGER				; do RETURN without GOSUB error if no matching
    1457/     7E2 :                     								; GOSUB
    1458/     7E2 :                     
    1459/     7E2 : 5C4F                	ADDQ.w	#6,sp					; dump calling address & token
    1460/     7E4 : 275F 0452           	MOVE.l	(sp)+,Clinel(a3)			; pull current line
    1461/     7E8 : 2A5F                	MOVE.l	(sp)+,a5				; pull BASIC execute pointer
    1462/     7EA :                     								; now do perform "DATA" statement as we could be
    1463/     7EA :                     								; returning into the middle of an ON <var> GOSUB
    1464/     7EA :                     								; n,m,p,q line (the return address used by the
    1465/     7EA :                     								; DATA statement is the one pushed before the
    1466/     7EA :                     								; GOSUB was executed!)
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 29 - 10/11/2023 16:23:32


    1467/     7EA :                     
    1468/     7EA :                     
    1469/     7EA :                     ;************************************************************************************
    1470/     7EA :                     ;
    1471/     7EA :                     ; perform DATA
    1472/     7EA :                     
    1473/     7EA :                     LAB_DATA
    1474/     7EA : 6104                	BSR.s		LAB_SNBS				; scan for next BASIC statement ([:] or [EOL])
    1475/     7EC :                     								; returns a0 as pointer to [:] or [EOL]
    1476/     7EC : 2A48                	MOVEA.l	a0,a5					; skip rest of statement
    1477/     7EE :                     RTS_007
    1478/     7EE : 4E75                	RTS
    1479/     7F0 :                     
    1480/     7F0 :                     
    1481/     7F0 :                     ;************************************************************************************
    1482/     7F0 :                     ;
    1483/     7F0 :                     ; scan for next BASIC statement ([:] or [EOL])
    1484/     7F0 :                     ; returns a0 as pointer to [:] or [EOL]
    1485/     7F0 :                     
    1486/     7F0 :                     LAB_SNBS
    1487/     7F0 : 204D                	MOVEA.l	a5,a0					; copy BASIC execute pointer
    1488/     7F2 : 7222                	MOVEQ		#$22,d1				; set string quote character
    1489/     7F4 : 743A                	MOVEQ		#$3A,d2				; set look for character = ":"
    1490/     7F6 : 6008                	BRA.s		LAB_172D				; go do search
    1491/     7F8 :                     
    1492/     7F8 :                     LAB_172C
    1493/     7F8 : B400                	CMP.b		d0,d2					; compare with ":"
    1494/     7FA : 6708                	BEQ.s		RTS_007a				; exit if found
    1495/     7FC :                     
    1496/     7FC : B200                	CMP.b		d0,d1					; compare with '"'
    1497/     7FE : 670C                	BEQ.s		LAB_1725				; if found go search for [EOL]
    1498/     800 :                     
    1499/     800 :                     LAB_172D
    1500/     800 : 1018                	MOVE.b	(a0)+,d0				; get next byte
    1501/     802 : 66F4                	BNE.s		LAB_172C				; loop if not null [EOL]
    1502/     804 :                     
    1503/     804 :                     RTS_007a
    1504/     804 : 5348                	SUBQ.w	#1,a0					; correct pointer
    1505/     806 : 4E75                	RTS
    1506/     808 :                     
    1507/     808 :                     LAB_1723
    1508/     808 : B200                	CMP.b		d0,d1					; compare with '"'
    1509/     80A : 67F4                	BEQ.s		LAB_172D				; if found go search for ":" or [EOL]
    1510/     80C :                     
    1511/     80C :                     LAB_1725
    1512/     80C : 1018                	MOVE.b	(a0)+,d0				; get next byte
    1513/     80E : 66F8                	BNE.s		LAB_1723				; loop if not null [EOL]
    1514/     810 :                     
    1515/     810 : 60F2                	BRA.s		RTS_007a				; correct pointer & return
    1516/     812 :                     
    1517/     812 :                     
    1518/     812 :                     ;************************************************************************************
    1519/     812 :                     ;
    1520/     812 :                     ; perform IF
    1521/     812 :                     
    1522/     812 :                     LAB_IF
    1523/     812 : 6100 04F6           	BSR		LAB_EVEX				; evaluate expression
    1524/     816 : 6100 0654           	BSR		LAB_GBYT				; scan memory
    1525/     81A : B03C 00AD           	CMP.b		#TK_THEN,d0				; compare with THEN token
    1526/     81E : 6714                	BEQ.s		LAB_174B				; if it was THEN then continue
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 30 - 10/11/2023 16:23:32


    1527/     820 :                     
    1528/     820 :                     								; wasn't IF .. THEN so must be IF .. GOTO
    1529/     820 : B03C 0089           	CMP.b		#TK_GOTO,d0				; compare with GOTO token
    1530/     824 : 6600 F9FE           	BNE		LAB_SNER				; if not GOTO token do syntax error/warm start
    1531/     828 :                     
    1532/     828 :                     								; was GOTO so check for GOTO <n>
    1533/     828 : 204D                	MOVE.l	a5,a0					; save the execute pointer
    1534/     82A : 6100 063E           	BSR		LAB_IGBY				; scan memory, test for a numeric character
    1535/     82E : 2A48                	MOVE.l	a0,a5					; restore the execute pointer
    1536/     830 : 6400 F9F2           	BCC		LAB_SNER				; if not numeric do syntax error/warm start
    1537/     834 :                     
    1538/     834 :                     LAB_174B
    1539/     834 : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
    1540/     838 : 671E                	BEQ.s		LAB_174E				; if result was zero go look for an ELSE
    1541/     83A :                     
    1542/     83A : 6100 062E           	BSR		LAB_IGBY				; increment & scan memory
    1543/     83E : 6500 FF12           	BCS		LAB_GOTO				; if numeric do GOTO n
    1544/     842 :                     								; a GOTO <n> will never return to the IF
    1545/     842 :                     								; statement so there is no need to return
    1546/     842 :                     								; to this code
    1547/     842 :                     
    1548/     842 : B03C 008E           	CMP.b		#TK_RETURN,d0			; compare with RETURN token
    1549/     846 : 6700 FE1E           	BEQ		LAB_1602				; if RETURN then interpret BASIC code from (a5)
    1550/     84A :                     								; and don't return here
    1551/     84A :                     
    1552/     84A : 6100 FE16           	BSR		LAB_15FF				; else interpret BASIC code from (a5)
    1553/     84E :                     
    1554/     84E :                     ; the IF was executed and there may be a following ELSE so the code needs to return
    1555/     84E :                     ; here to check and ignore the ELSE if present
    1556/     84E :                     
    1557/     84E : 1015                	MOVE.b	(a5),d0				; get the next basic byte
    1558/     850 : B03C 00A9           	CMP.b		#TK_ELSE,d0				; compare it with the token for ELSE
    1559/     854 : 6794                	BEQ		LAB_DATA				; if ELSE ignore the following statement
    1560/     856 :                     
    1561/     856 :                     ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
    1562/     856 :                     ; following ELSE will, correctly, cause a syntax error
    1563/     856 :                     
    1564/     856 : 4E75                	RTS							; else return to interpreter inner loop
    1565/     858 :                     
    1566/     858 :                     ; perform ELSE after IF
    1567/     858 :                     
    1568/     858 :                     LAB_174E
    1569/     858 : 101D                	MOVE.b	(a5)+,d0				; faster increment past THEN
    1570/     85A : 163C 00A9           	MOVE.b		#TK_ELSE,d3				; set search for ELSE token
    1571/     85E : 183C 008B           	MOVE.b		#TK_IF,d4				; set search for IF token
    1572/     862 : 7A00                	MOVEQ		#0,d5					; clear the nesting depth
    1573/     864 :                     LAB_1750
    1574/     864 : 101D                	MOVE.b	(a5)+,d0				; get next BASIC byte & increment ptr
    1575/     866 : 6720                	BEQ.s		LAB_1754				; if EOL correct the pointer and return
    1576/     868 :                     
    1577/     868 : B004                	CMP.b		d4,d0					; compare with "IF" token
    1578/     86A : 6604                	BNE.s		LAB_1752				; skip if not nested IF
    1579/     86C :                     
    1580/     86C : 5245                	ADDQ.w	#1,d5					; else increment the nesting depth ..
    1581/     86E : 60F4                	BRA.s		LAB_1750				; .. and continue looking
    1582/     870 :                     
    1583/     870 :                     LAB_1752
    1584/     870 : B003                	CMP.b		d3,d0					; compare with ELSE token
    1585/     872 : 66F0                	BNE.s		LAB_1750				; if not ELSE continue looking
    1586/     874 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 31 - 10/11/2023 16:23:32


    1587/     874 :                     LAB_1756
    1588/     874 : 51CD FFEE           	DBF		d5,LAB_1750				; loop if still nested
    1589/     878 :                     
    1590/     878 :                     ; found the matching ELSE, now do <{n|statement}>
    1591/     878 :                     
    1592/     878 : 6100 05F2           	BSR		LAB_GBYT				; scan memory
    1593/     87C : 6500 FED4           	BCS		LAB_GOTO				; if numeric do GOTO n
    1594/     880 :                     								; code will return to the interpreter loop
    1595/     880 :                     								; at the tail end of the GOTO <n>
    1596/     880 :                     
    1597/     880 : 6000 FDE0           	BRA		LAB_15FF				; else interpret BASIC code from (a5)
    1598/     884 :                     								; code will return to the interpreter loop
    1599/     884 :                     								; at the tail end of the <statement>
    1600/     884 :                     
    1601/     884 :                     
    1602/     884 :                     ;************************************************************************************
    1603/     884 :                     ;
    1604/     884 :                     ; perform REM, skip (rest of) line
    1605/     884 :                     
    1606/     884 :                     LAB_REM
    1607/     884 : 4A1D                	TST.b		(a5)+					; test byte & increment pointer
    1608/     886 : 66FC                	BNE.s		LAB_REM				; loop if not EOL
    1609/     888 :                     
    1610/     888 :                     LAB_1754
    1611/     888 : 534D                	SUBQ.w	#1,a5					; correct the execute pointer
    1612/     88A : 4E75                	RTS
    1613/     88C :                     
    1614/     88C :                     
    1615/     88C :                     ;************************************************************************************
    1616/     88C :                     ;
    1617/     88C :                     ; perform ON
    1618/     88C :                     
    1619/     88C :                     LAB_ON
    1620/     88C : 6100 0F48           	BSR		LAB_GTBY				; get byte parameter, result in d0 and Itemp
    1621/     890 : 1400                	MOVE.b	d0,d2					; copy byte
    1622/     892 : 6100 05D8           	BSR		LAB_GBYT				; restore BASIC byte
    1623/     896 : 3F00                	MOVE.w	d0,-(sp)				; push GOTO/GOSUB token
    1624/     898 : B03C 008D           	CMP.b		#TK_GOSUB,d0			; compare with GOSUB token
    1625/     89C : 6708                	BEQ.s		LAB_176C				; branch if GOSUB
    1626/     89E :                     
    1627/     89E : B03C 0089           	CMP.b		#TK_GOTO,d0				; compare with GOTO token
    1628/     8A2 : 6600 F980           	BNE		LAB_SNER				; if not GOTO do syntax error, then warm start
    1629/     8A6 :                     
    1630/     8A6 :                     ; next character was GOTO or GOSUB
    1631/     8A6 :                     
    1632/     8A6 :                     LAB_176C
    1633/     8A6 : 5302                	SUBQ.b	#1,d2					; decrement index (byte value)
    1634/     8A8 : 6606                	BNE.s		LAB_1773				; branch if not zero
    1635/     8AA :                     
    1636/     8AA : 301F                	MOVE.w	(sp)+,d0				; pull GOTO/GOSUB token
    1637/     8AC : 6000 FDB8           	BRA		LAB_1602				; go execute it
    1638/     8B0 :                     
    1639/     8B0 :                     LAB_1773
    1640/     8B0 : 6100 05B8           	BSR		LAB_IGBY				; increment & scan memory
    1641/     8B4 : 610A                	BSR.s		LAB_GFPN				; get fixed-point number into temp integer & d1
    1642/     8B6 :                     								; (skip this n)
    1643/     8B6 : B03C 002C           	CMP.b		#$2C,d0				; compare next character with ","
    1644/     8BA : 67EA                	BEQ.s		LAB_176C				; loop if ","
    1645/     8BC :                     
    1646/     8BC : 301F                	MOVE.w	(sp)+,d0				; pull GOTO/GOSUB token (run out of options)
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 32 - 10/11/2023 16:23:32


    1647/     8BE : 4E75                	RTS							; and exit
    1648/     8C0 :                     
    1649/     8C0 :                     
    1650/     8C0 :                     ;************************************************************************************
    1651/     8C0 :                     ;
    1652/     8C0 :                     ; get fixed-point number into temp integer & d1
    1653/     8C0 :                     ; interpret number from (a5), leave (a5) pointing to byte after #
    1654/     8C0 :                     
    1655/     8C0 :                     LAB_GFPN
    1656/     8C0 : 7200                	MOVEQ		#$00,d1				; clear integer register
    1657/     8C2 : 2001                	MOVE.l	d1,d0					; clear d0
    1658/     8C4 : 6100 05A6           	BSR		LAB_GBYT				; scan memory, Cb=1 if "0"-"9", & get byte
    1659/     8C8 : 642E                	BCC.s		LAB_1786				; return if carry clear, chr was not "0"-"9"
    1660/     8CA :                     
    1661/     8CA : 2F02                	MOVE.l	d2,-(sp)				; save d2
    1662/     8CC :                     LAB_1785
    1663/     8CC : 2401                	MOVE.l	d1,d2					; copy integer register
    1664/     8CE : D281                	ADD.l		d1,d1					; *2
    1665/     8D0 : 6500 F952           	BCS		LAB_SNER				; if overflow do syntax error, then warm start
    1666/     8D4 :                     
    1667/     8D4 : D281                	ADD.l		d1,d1					; *4
    1668/     8D6 : 6500 F94C           	BCS		LAB_SNER				; if overflow do syntax error, then warm start
    1669/     8DA :                     
    1670/     8DA : D282                	ADD.l		d2,d1					; *1 + *4
    1671/     8DC : 6500 F946           	BCS		LAB_SNER				; if overflow do syntax error, then warm start
    1672/     8E0 :                     
    1673/     8E0 : D281                	ADD.l		d1,d1					; *10
    1674/     8E2 : 6500 F940           	BCS		LAB_SNER				; if overflow do syntax error, then warm start
    1675/     8E6 :                     
    1676/     8E6 : 903C 0030           	SUB.b		#$30,d0				; subtract $30 from byte
    1677/     8EA : D280                	ADD.l		d0,d1					; add to integer register, the top 24 bits are
    1678/     8EC :                     								; always clear
    1679/     8EC : 6900 F936           	BVS		LAB_SNER				; if overflow do syntax error, then warm start
    1680/     8F0 :                     								; this makes the maximum line number 2147483647
    1681/     8F0 : 6100 0578           	BSR		LAB_IGBY				; increment & scan memory
    1682/     8F4 : 65D6                	BCS.s		LAB_1785				; loop for next character if "0"-"9"
    1683/     8F6 :                     
    1684/     8F6 : 241F                	MOVE.l	(sp)+,d2				; restore d2
    1685/     8F8 :                     LAB_1786
    1686/     8F8 : 2741 042A           	MOVE.l	d1,Itemp(a3)			; save Itemp
    1687/     8FC : 4E75                	RTS
    1688/     8FE :                     
    1689/     8FE :                     
    1690/     8FE :                     ;************************************************************************************
    1691/     8FE :                     ;
    1692/     8FE :                     ; perform DEC
    1693/     8FE :                     
    1694/     8FE :                     LAB_DEC
    1695/     8FE : 3F3C 8180           	MOVE.w	#$8180,-(sp)			; set -1 sign/exponent
    1696/     902 : 600A                	BRA.s		LAB_17B7				; go do DEC
    1697/     904 :                     
    1698/     904 :                     
    1699/     904 :                     ;************************************************************************************
    1700/     904 :                     ;
    1701/     904 :                     ; perform INC
    1702/     904 :                     
    1703/     904 :                     LAB_INC
    1704/     904 : 3F3C 8100           	MOVE.w	#$8100,-(sp)			; set 1 sign/exponent
    1705/     908 : 6004                	BRA.s		LAB_17B7				; go do INC
    1706/     90A :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 33 - 10/11/2023 16:23:32


    1707/     90A :                     								; was "," so another INCR variable to do
    1708/     90A :                     LAB_17B8
    1709/     90A : 6100 055E           	BSR		LAB_IGBY				; increment and scan memory
    1710/     90E :                     LAB_17B7
    1711/     90E : 6100 076C           	BSR		LAB_GVAR				; get variable address in a0
    1712/     912 :                     
    1713/     912 : 6732                	BEQ.s		LAB_INCT				; if variable not found skip the inc/dec
    1714/     914 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
    1715/     918 :                     								; $00=float
    1716/     918 : 6B00 F8DE           	BMI		LAB_TMER				; if string do "Type mismatch" error/warm start
    1717/     91C :                     
    1718/     91C : 6636                	BNE.s		LAB_INCI				; go do integer INC/DEC
    1719/     91E :                     
    1720/     91E : 2748 0472           	MOVE.l	a0,Lvarpl(a3)			; save var address
    1721/     922 : 6100 130E           	BSR		LAB_UFAC				; unpack memory (a0) into FAC1
    1722/     926 : 277C 8000 0000      	MOVE.l	#$80000000,FAC2_m(a3)		; set FAC2 mantissa for 1
              92C : 0598             
    1723/     92E : 3017                	MOVE.w	(sp),d0				; move exponent & sign to d0
    1724/     930 : 3740 059C           	MOVE.w	d0,FAC2_e(a3)			; move exponent & sign to FAC2
    1725/     934 : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; make sign compare = FAC1 sign
    1726/     93A : B12B 059E           	EOR.b		d0,FAC_sc(a3)			; make sign compare (FAC1_s EOR FAC2_s)
    1727/     93E : 6100 100E           	BSR		LAB_ADD				; add FAC2 to FAC1
    1728/     942 : 6100 130A           	BSR		LAB_PFAC				; pack FAC1 into variable (Lvarpl)
    1729/     946 :                     LAB_INCT
    1730/     946 : 6100 0524           	BSR		LAB_GBYT				; scan memory
    1731/     94A : 0C00 002C           	CMPI.b	#$2C,d0				; compare with ","
    1732/     94E : 67BA                	BEQ.s		LAB_17B8				; continue if "," (another variable to do)
    1733/     950 :                     
    1734/     950 : 544F                	ADDQ.w	#2,sp					; else dump sign & exponent
    1735/     952 : 4E75                	RTS
    1736/     954 :                     
    1737/     954 :                     LAB_INCI
    1738/     954 : 4A2F 0001           	TST.b		1(sp)					; test sign
    1739/     958 : 6604                	BNE.s		LAB_DECI				; branch if DEC
    1740/     95A :                     
    1741/     95A : 5290                	ADDQ.l	#1,(a0)				; increment variable
    1742/     95C : 60E8                	BRA.s		LAB_INCT				; go scan for more
    1743/     95E :                     
    1744/     95E :                     LAB_DECI
    1745/     95E : 5390                	SUBQ.l	#1,(a0)				; decrement variable
    1746/     960 : 60E4                	BRA.s		LAB_INCT				; go scan for more
    1747/     962 :                     
    1748/     962 :                     
    1749/     962 :                     ;************************************************************************************
    1750/     962 :                     ;
    1751/     962 :                     ; perform LET
    1752/     962 :                     
    1753/     962 :                     LAB_LET
    1754/     962 : 6100 0714           	BSR		LAB_SVAR				; search for or create a variable
    1755/     966 :                     								; return the variable address in a0
    1756/     966 : 2748 0472           	MOVE.l	a0,Lvarpl(a3)			; save variable address
    1757/     96A : 1F2B 05B5           	MOVE.b	Dtypef(a3),-(sp)			; push var data type, $80=string, $40=integer,
    1758/     96E :                     								; $00=float
    1759/     96E : 70BD                	MOVEQ		#TK_EQUAL-$100,d0			; get = token
    1760/     970 : 6100 04F0           	BSR		LAB_SCCA				; scan for CHR$(d0), else do syntax error/warm
    1761/     974 :                     								; start
    1762/     974 : 6100 0394           	BSR		LAB_EVEX				; evaluate expression
    1763/     978 : 102B 05B5           	MOVE.b	Dtypef(a3),d0			; copy expression data type
    1764/     97C : 175F 05B5           	MOVE.b	(sp)+,Dtypef(a3)			; pop variable data type
    1765/     980 : E318                	ROL.b		#1,d0					; set carry if expression type = string
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 34 - 10/11/2023 16:23:32


    1766/     982 : 6100 0372           	BSR		LAB_CKTM				; type match check, set C for string
    1767/     986 : 6700 12C6           	BEQ		LAB_PFAC				; if number pack FAC1 into variable Lvarpl & RET
    1768/     98A :                     
    1769/     98A :                     ; string LET
    1770/     98A :                     
    1771/     98A :                     LAB_17D5
    1772/     98A : 246B 0472           	MOVEA.l	Lvarpl(a3),a2			; get pointer to variable
    1773/     98E :                     LAB_17D6
    1774/     98E : 206B 0590           	MOVEA.l	FAC1_m(a3),a0			; get descriptor pointer
    1775/     992 : 2250                	MOVEA.l	(a0),a1				; get string pointer
    1776/     994 : B3EB 0446           	CMP.l		Sstorl(a3),a1			; compare string memory start with string
    1777/     998 :                     								; pointer
    1778/     998 : 6516                	BCS.s		LAB_1811				; if it was in program memory assign the value
    1779/     99A :                     								; and exit
    1780/     99A :                     
    1781/     99A : B1EB 0432           	CMPA.l	Sfncl(a3),a0			; compare functions start with descriptor
    1782/     99E :                     								; pointer
    1783/     99E : 6510                	BCS.s		LAB_1811				; branch if >= (string is on stack)
    1784/     9A0 :                     
    1785/     9A0 :                     								; string is variable$ make space and copy string
    1786/     9A0 :                     LAB_1810
    1787/     9A0 : 7200                	MOVEQ		#0,d1					; clear length
    1788/     9A2 : 3228 0004           	MOVE.w	4(a0),d1				; get string length
    1789/     9A6 : 2050                	MOVEA.l	(a0),a0				; get string pointer
    1790/     9A8 : 6100 0B06           	BSR		LAB_20C9				; copy string
    1791/     9AC : 206B 0590           	MOVEA.l	FAC1_m(a3),a0			; get descriptor pointer back
    1792/     9B0 :                     								; clean stack & assign value to string variable
    1793/     9B0 :                     LAB_1811
    1794/     9B0 : B9C8                	CMPA.l	a0,a4					; is string on the descriptor stack
    1795/     9B2 : 6602                	BNE.s		LAB_1813				; skip pop if not
    1796/     9B4 :                     
    1797/     9B4 : 5C4C                	ADDQ.w	#$06,a4				; else update stack pointer
    1798/     9B6 :                     LAB_1813
    1799/     9B6 : 24D8                	MOVE.l	(a0)+,(a2)+				; save pointer to variable
    1800/     9B8 : 3490                	MOVE.w	(a0),(a2)				; save length to variable
    1801/     9BA :                     RTS_008
    1802/     9BA : 4E75                	RTS
    1803/     9BC :                     
    1804/     9BC :                     
    1805/     9BC :                     ;************************************************************************************
    1806/     9BC :                     ;
    1807/     9BC :                     ; perform GET
    1808/     9BC :                     
    1809/     9BC :                     LAB_GET
    1810/     9BC : 6100 06BA           	BSR		LAB_SVAR				; search for or create a variable
    1811/     9C0 :                     								; return the variable address in a0
    1812/     9C0 : 2748 0472           	MOVE.l	a0,Lvarpl(a3)			; save variable address as GET variable
    1813/     9C4 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
    1814/     9C8 :                     								; $00=float
    1815/     9C8 : 6B0C                	BMI.s		LAB_GETS				; go get string character
    1816/     9CA :                     
    1817/     9CA :                     								; was numeric get
    1818/     9CA : 6100 1DF2           	BSR		INGET					; get input byte
    1819/     9CE : 6100 09BC           	BSR		LAB_1FD0				; convert d0 to unsigned byte in FAC1
    1820/     9D2 : 6000 127A           	BRA		LAB_PFAC				; pack FAC1 into variable (Lvarpl) & return
    1821/     9D6 :                     
    1822/     9D6 :                     LAB_GETS
    1823/     9D6 : 7200                	MOVEQ		#$00,d1				; assume no byte
    1824/     9D8 : 2041                	MOVE.l	d1,a0					; assume null string
    1825/     9DA : 6100 1DE2           	BSR		INGET					; get input byte
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 35 - 10/11/2023 16:23:32


    1826/     9DE : 6408                	BCC.s		LAB_NoSt				; branch if no byte received
    1827/     9E0 :                     
    1828/     9E0 : 7201                	MOVEQ		#$01,d1				; string is single byte
    1829/     9E2 : 6100 0AFE           	BSR		LAB_2115				; make string space d1 bytes long
    1830/     9E6 :                     								; return a0 = pointer, other registers unchanged
    1831/     9E6 :                     
    1832/     9E6 : 1080                	MOVE.b	d0,(a0)				; save byte in string (byte IS string!)
    1833/     9E8 :                     LAB_NoSt
    1834/     9E8 : 6100 0ADE           	BSR		LAB_RTST				; push string on descriptor stack
    1835/     9EC :                     								; a0 = pointer, d1 = length
    1836/     9EC :                     
    1837/     9EC : 609C                	BRA.s		LAB_17D5				; do string LET & return
    1838/     9EE :                     
    1839/     9EE :                     
    1840/     9EE :                     ;************************************************************************************
    1841/     9EE :                     ;
    1842/     9EE :                     ; PRINT
    1843/     9EE :                     
    1844/     9EE :                     LAB_1829
    1845/     9EE : 6100 00B4           	BSR		LAB_18C6				; print string from stack
    1846/     9F2 :                     LAB_182C
    1847/     9F2 : 6100 0478           	BSR		LAB_GBYT				; scan memory
    1848/     9F6 :                     
    1849/     9F6 :                     ; perform PRINT
    1850/     9F6 :                     
    1851/     9F6 :                     LAB_PRINT
    1852/     9F6 : 674A                	BEQ.s		LAB_CRLF				; if nothing following just print CR/LF
    1853/     9F8 :                     
    1854/     9F8 :                     LAB_1831
    1855/     9F8 : B03C 00A8           	CMP.b		#TK_TAB,d0				; compare with TAB( token
    1856/     9FC : 6764                	BEQ.s		LAB_18A2				; go do TAB/SPC
    1857/     9FE :                     
    1858/     9FE : B03C 00AC           	CMP.b		#TK_SPC,d0				; compare with SPC( token
    1859/     A02 : 675E                	BEQ.s		LAB_18A2				; go do TAB/SPC
    1860/     A04 :                     
    1861/     A04 : B03C 002C           	CMP.b		#',',d0				; compare with ","
    1862/     A08 : 6740                	BEQ.s		LAB_188B				; go do move to next TAB mark
    1863/     A0A :                     
    1864/     A0A : B03C 003B           	CMP.b		#';',d0				; compare with ";"
    1865/     A0E : 6700 0086           	BEQ		LAB_18BD				; if ";" continue with PRINT processing
    1866/     A12 :                     
    1867/     A12 : 6100 02F6           	BSR		LAB_EVEX				; evaluate expression
    1868/     A16 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
    1869/     A1A :                     								; $00=float
    1870/     A1A : 6BD2                	BMI.s		LAB_1829				; branch if string
    1871/     A1C :                     
    1872/     A1C :                     ; replace the two lines above with this code
    1873/     A1C :                     
    1874/     A1C :                     ;	MOVE.b	Dtypef(a3),d0			; get data type flag, $80=string, $00=numeric
    1875/     A1C :                     ;	BMI.s		LAB_1829				; branch if string
    1876/     A1C :                     
    1877/     A1C : 6100 13B2           	BSR		LAB_2970				; convert FAC1 to string
    1878/     A20 : 6100 0A60           	BSR		LAB_20AE				; print " terminated string to FAC1 stack
    1879/     A24 :                     
    1880/     A24 :                     ; don't check fit if terminal width byte is zero
    1881/     A24 :                     
    1882/     A24 : 7000                	MOVEQ		#0,d0					; clear d0
    1883/     A26 : 102B 05E6           	MOVE.b	TWidth(a3),d0			; get terminal width byte
    1884/     A2A : 670C                	BEQ.s		LAB_185E				; skip check if zero
    1885/     A2C :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 36 - 10/11/2023 16:23:32


    1886/     A2C : 902C 0007           	SUB.b		7(a4),d0				; subtract string length
    1887/     A30 : 902B 05E5           	SUB.b		TPos(a3),d0				; subtract terminal position
    1888/     A34 : 6402                	BCC		LAB_185E				; branch if less than terminal width
    1889/     A36 :                     
    1890/     A36 : 610A                	BSR.s		LAB_CRLF				; else print CR/LF
    1891/     A38 :                     LAB_185E
    1892/     A38 : 616A                	BSR.s		LAB_18C6				; print string from stack
    1893/     A3A : 60B6                	BRA.s		LAB_182C				; always go continue processing line
    1894/     A3C :                     
    1895/     A3C :                     
    1896/     A3C :                     ;************************************************************************************
    1897/     A3C :                     ;
    1898/     A3C :                     ; CR/LF return to BASIC from BASIC input handler
    1899/     A3C :                     ; leaves a0 pointing to the buffer start
    1900/     A3C :                     
    1901/     A3C :                     LAB_1866
    1902/     A3C : 11BC 0000 1000      	MOVE.b	#$00,(a0,d1.w)			; null terminate input
    1903/     A42 :                     
    1904/     A42 :                     ; print CR/LF
    1905/     A42 :                     
    1906/     A42 :                     LAB_CRLF
    1907/     A42 : 700D                	MOVEQ		#$0D,d0				; load [CR]
    1908/     A44 : 6174                	BSR.s		LAB_PRNA				; go print the character
    1909/     A46 : 700A                	MOVEQ		#$0A,d0				; load [LF]
    1910/     A48 : 6070                	BRA.s		LAB_PRNA				; go print the character & return
    1911/     A4A :                     
    1912/     A4A :                     LAB_188B
    1913/     A4A : 142B 05E5           	MOVE.b	TPos(a3),d2				; get terminal position
    1914/     A4E : B42B 05E7           	CMP.b		Iclim(a3),d2			; compare with input column limit
    1915/     A52 : 6504                	BCS.s		LAB_1898				; branch if less than Iclim
    1916/     A54 :                     
    1917/     A54 : 61EC                	BSR.s		LAB_CRLF				; else print CR/LF (next line)
    1918/     A56 : 603E                	BRA.s		LAB_18BD				; continue with PRINT processing
    1919/     A58 :                     
    1920/     A58 :                     LAB_1898
    1921/     A58 : 942B 05E2           	SUB.b		TabSiz(a3),d2			; subtract TAB size
    1922/     A5C : 64FA                	BCC.s		LAB_1898				; loop if result was >= 0
    1923/     A5E :                     
    1924/     A5E : 4402                	NEG.b		d2					; twos complement it
    1925/     A60 : 6022                	BRA.s		LAB_18B7				; print d2 spaces
    1926/     A62 :                     
    1927/     A62 :                     								; do TAB/SPC
    1928/     A62 :                     LAB_18A2
    1929/     A62 : 3F00                	MOVE.w	d0,-(sp)				; save token
    1930/     A64 : 6100 0D6C           	BSR		LAB_SGBY				; increment and get byte, result in d0 and Itemp
    1931/     A68 : 3400                	MOVE.w	d0,d2					; copy byte
    1932/     A6A : 6100 0400           	BSR		LAB_GBYT				; get basic byte back
    1933/     A6E : B03C 0029           	CMP.b		#$29,d0				; is next character ")"
    1934/     A72 : 6600 F7B0           	BNE		LAB_SNER				; if not do syntax error, then warm start
    1935/     A76 :                     
    1936/     A76 : 301F                	MOVE.w	(sp)+,d0				; get token back
    1937/     A78 : B03C 00A8           	CMP.b		#TK_TAB,d0				; was it TAB ?
    1938/     A7C : 6606                	BNE.s		LAB_18B7				; branch if not (was SPC)
    1939/     A7E :                     
    1940/     A7E :                     								; calculate TAB offset
    1941/     A7E : 942B 05E5           	SUB.b		TPos(a3),d2				; subtract terminal position
    1942/     A82 : 6312                	BLS.s		LAB_18BD				; branch if result was <= 0
    1943/     A84 :                     								; can't TAB backwards or already there
    1944/     A84 :                     
    1945/     A84 :                     								; print d2.b spaces
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 37 - 10/11/2023 16:23:32


    1946/     A84 :                     LAB_18B7
    1947/     A84 : 7000                	MOVEQ		#0,d0					; clear longword
    1948/     A86 : 5300                	SUBQ.b	#1,d0					; make d0 = $FF
    1949/     A88 : C480                	AND.l		d0,d2					; mask for byte only
    1950/     A8A : 670A                	BEQ.s		LAB_18BD				; branch if zero
    1951/     A8C :                     
    1952/     A8C : 7020                	MOVEQ		#$20,d0				; load " "
    1953/     A8E : 5302                	SUBQ.b	#1,d2					; adjust for DBF loop
    1954/     A90 :                     LAB_18B8
    1955/     A90 : 6128                	BSR.s		LAB_PRNA				; go print
    1956/     A92 : 51CA FFFC           	DBF		d2,LAB_18B8				; decrement count and loop if not all done
    1957/     A96 :                     
    1958/     A96 :                     								; continue with PRINT processing
    1959/     A96 :                     LAB_18BD
    1960/     A96 : 6100 03D2           	BSR		LAB_IGBY				; increment & scan memory
    1961/     A9A : 6600 FF5C           	BNE		LAB_1831				; if byte continue executing PRINT
    1962/     A9E :                     
    1963/     A9E : 4E75                	RTS							; exit if nothing more to print
    1964/     AA0 :                     
    1965/     AA0 :                     
    1966/     AA0 :                     ;************************************************************************************
    1967/     AA0 :                     ;
    1968/     AA0 :                     ; print null terminated string from a0
    1969/     AA0 :                     
    1970/     AA0 :                     LAB_18C3
    1971/     AA0 : 6100 09E0           	BSR		LAB_20AE				; print terminated string to FAC1/stack
    1972/     AA4 :                     
    1973/     AA4 :                     ; print string from stack
    1974/     AA4 :                     
    1975/     AA4 :                     LAB_18C6
    1976/     AA4 : 6100 0BD0           	BSR		LAB_22B6				; pop string off descriptor stack or from memory
    1977/     AA8 :                     								; returns with d0 = length, a0 = pointer
    1978/     AA8 : 670C                	BEQ.s		RTS_009				; exit (RTS) if null string
    1979/     AAA :                     
    1980/     AAA : 3200                	MOVE.w	d0,d1					; copy length & set Z flag
    1981/     AAC : 5341                	SUBQ.w	#1,d1					; -1 for BF loop
    1982/     AAE :                     LAB_18CD
    1983/     AAE : 1018                	MOVE.b	(a0)+,d0				; get byte from string
    1984/     AB0 : 6108                	BSR.s		LAB_PRNA				; go print the character
    1985/     AB2 : 51C9 FFFA           	DBF		d1,LAB_18CD				; decrement count and loop if not done yet
    1986/     AB6 :                     
    1987/     AB6 :                     RTS_009
    1988/     AB6 : 4E75                	RTS
    1989/     AB8 :                     
    1990/     AB8 :                     
    1991/     AB8 :                     ;************************************************************************************
    1992/     AB8 :                     ;
    1993/     AB8 :                     ; print "?" character
    1994/     AB8 :                     
    1995/     AB8 :                     LAB_18E3
    1996/     AB8 : 703F                	MOVEQ		#$3F,d0				; load "?" character
    1997/     ABA :                     
    1998/     ABA :                     
    1999/     ABA :                     ;************************************************************************************
    2000/     ABA :                     ;
    2001/     ABA :                     ; print character in d0, includes the null handler and infinite line length code
    2002/     ABA :                     ; changes no registers
    2003/     ABA :                     
    2004/     ABA :                     LAB_PRNA
    2005/     ABA : 2F01                	MOVE.l	d1,-(sp)				; save d1
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 38 - 10/11/2023 16:23:32


    2006/     ABC : B03C 0020           	CMP.b		#$20,d0				; compare with " "
    2007/     AC0 : 6528                	BCS.s		LAB_18F9				; branch if less, non printing character
    2008/     AC2 :                     
    2009/     AC2 :                     								; don't check fit if terminal width byte is zero
    2010/     AC2 : 122B 05E6           	MOVE.b	TWidth(a3),d1			; get terminal width
    2011/     AC6 : 6610                	BNE.s		LAB_18F0				; branch if not zero (not infinite length)
    2012/     AC8 :                     
    2013/     AC8 :                     								; is "infinite line" so check TAB position
    2014/     AC8 : 122B 05E5           	MOVE.b	TPos(a3),d1				; get position
    2015/     ACC : 922B 05E2           	SUB.b		TabSiz(a3),d1			; subtract TAB size
    2016/     AD0 : 6614                	BNE.s		LAB_18F7				; skip reset if different
    2017/     AD2 :                     
    2018/     AD2 : 1741 05E5           	MOVE.b	d1,TPos(a3)				; else reset position
    2019/     AD6 : 600E                	BRA.s		LAB_18F7				; go print character
    2020/     AD8 :                     
    2021/     AD8 :                     LAB_18F0
    2022/     AD8 : B22B 05E5           	CMP.b		TPos(a3),d1				; compare with terminal character position
    2023/     ADC : 6608                	BNE.s		LAB_18F7				; branch if not at end of line
    2024/     ADE :                     
    2025/     ADE : 2F00                	MOVE.l	d0,-(sp)				; save d0
    2026/     AE0 : 6100 FF60           	BSR		LAB_CRLF				; else print CR/LF
    2027/     AE4 : 201F                	MOVE.l	(sp)+,d0				; restore d0
    2028/     AE6 :                     LAB_18F7
    2029/     AE6 : 522B 05E5           	ADDQ.b	#$01,TPos(a3)			; increment terminal position
    2030/     AEA :                     LAB_18F9
    2031/     AEA : 4EAB 0412           	JSR		V_OUTP(a3)				; output byte via output vector
    2032/     AEE : B03C 000D           	CMP.b		#$0D,d0				; compare with [CR]
    2033/     AF2 : 6618                	BNE.s		LAB_188A				; branch if not [CR]
    2034/     AF4 :                     
    2035/     AF4 :                     								; else print nullct nulls after the [CR]
    2036/     AF4 : 7200                	MOVEQ		#$00,d1				; clear d1
    2037/     AF6 : 122B 05E4           	MOVE.b	Nullct(a3),d1			; get null count
    2038/     AFA : 670C                	BEQ.s		LAB_1886				; branch if no nulls
    2039/     AFC :                     
    2040/     AFC : 7000                	MOVEQ		#$00,d0				; load [NULL]
    2041/     AFE :                     LAB_1880
    2042/     AFE : 4EAB 0412           	JSR		V_OUTP(a3)				; go print the character
    2043/     B02 : 51C9 FFFA           	DBF		d1,LAB_1880				; decrement count and loop if not all done
    2044/     B06 :                     
    2045/     B06 : 700D                	MOVEQ		#$0D,d0				; restore the character
    2046/     B08 :                     LAB_1886
    2047/     B08 : 1741 05E5           	MOVE.b	d1,TPos(a3)				; clear terminal position
    2048/     B0C :                     LAB_188A
    2049/     B0C : 221F                	MOVE.l	(sp)+,d1				; restore d1
    2050/     B0E : 4E75                	RTS
    2051/     B10 :                     
    2052/     B10 :                     
    2053/     B10 :                     ;************************************************************************************
    2054/     B10 :                     ;
    2055/     B10 :                     ; handle bad input data
    2056/     B10 :                     
    2057/     B10 :                     LAB_1904
    2058/     B10 : 2A5F                	MOVEA.l	(sp)+,a5				; restore execute pointer
    2059/     B12 : 4A2B 05E0           	TST.b		Imode(a3)				; test input mode flag, $00=INPUT, $98=READ
    2060/     B16 : 6A0A                	BPL.s		LAB_1913				; branch if INPUT (go do redo)
    2061/     B18 :                     
    2062/     B18 : 276B 045E 0452      	MOVE.l	Dlinel(a3),Clinel(a3)		; save DATA line as current line
    2063/     B1E : 6000 F6D8           	BRA		LAB_TMER				; do type mismatch error, then warm start
    2064/     B22 :                     
    2065/     B22 :                     								; mode was INPUT
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 39 - 10/11/2023 16:23:32


    2066/     B22 :                     LAB_1913
    2067/     B22 : 41FA 2A76           	LEA		LAB_REDO(pc),a0			; point to redo message
    2068/     B26 : 6100 FF78           	BSR		LAB_18C3				; print null terminated string from memory
    2069/     B2A : 2A6B 045A           	MOVEA.l	Cpntrl(a3),a5			; save continue pointer as BASIC execute pointer
    2070/     B2E : 4E75                	RTS
    2071/     B30 :                     
    2072/     B30 :                     
    2073/     B30 :                     ;************************************************************************************
    2074/     B30 :                     ;
    2075/     B30 :                     ; perform INPUT
    2076/     B30 :                     
    2077/     B30 :                     LAB_INPUT
    2078/     B30 : 6100 0862           	BSR		LAB_CKRN				; check not direct (back here if ok)
    2079/     B34 : B03C 0022           	CMP.b		#'"',d0				; compare the next byte with open quote
    2080/     B38 : 660E                	BNE.s		LAB_1934				; if no prompt string just go get the input
    2081/     B3A :                     
    2082/     B3A : 6100 0306           	BSR		LAB_1BC1				; print "..." string
    2083/     B3E : 703B                	MOVEQ		#';',d0				; set the search character to ";"
    2084/     B40 : 6100 0320           	BSR		LAB_SCCA				; scan for CHR$(d0), else do syntax error/warm
    2085/     B44 :                     								; start
    2086/     B44 : 6100 FF5E           	BSR		LAB_18C6				; print string from Sutill/Sutilh
    2087/     B48 :                     								; finished the prompt, now read the data
    2088/     B48 :                     LAB_1934
    2089/     B48 : 6100 F804           	BSR		LAB_INLN				; print "? " and get BASIC input
    2090/     B4C :                     								; return a0 pointing to the buffer start
    2091/     B4C : 7000                	MOVEQ		#0,d0					; flag INPUT
    2092/     B4E : 4A10                	TST.b		(a0)					; test first byte from buffer
    2093/     B50 : 660A                	BNE.s		LAB_1953				; branch if not null input
    2094/     B52 :                     
    2095/     B52 : 6000 FB58           	BRA		LAB_1647				; go do BREAK exit
    2096/     B56 :                     
    2097/     B56 :                     
    2098/     B56 :                     ;************************************************************************************
    2099/     B56 :                     ;
    2100/     B56 :                     ; perform READ
    2101/     B56 :                     
    2102/     B56 :                     LAB_READ
    2103/     B56 : 206B 0462           	MOVEA.l	Dptrl(a3),a0			; get the DATA pointer
    2104/     B5A : 7098                	MOVEQ		#$98-$100,d0			; flag READ
    2105/     B5C :                     LAB_1953
    2106/     B5C : 1740 05E0           	MOVE.b	d0,Imode(a3)			; set input mode flag, $00=INPUT, $98=READ
    2107/     B60 : 2748 0466           	MOVE.l	a0,Rdptrl(a3)			; save READ pointer
    2108/     B64 :                     
    2109/     B64 :                     								; READ or INPUT the next variable from list
    2110/     B64 :                     LAB_195B
    2111/     B64 : 6100 0512           	BSR		LAB_SVAR				; search for or create a variable
    2112/     B68 :                     								; return the variable address in a0
    2113/     B68 : 2748 0472           	MOVE.l	a0,Lvarpl(a3)			; save variable address as LET variable
    2114/     B6C : 2F0D                	MOVE.l	a5,-(sp)				; save BASIC execute pointer
    2115/     B6E :                     LAB_1961
    2116/     B6E : 2A6B 0466           	MOVEA.l	Rdptrl(a3),a5			; set READ pointer as BASIC execute pointer
    2117/     B72 : 6100 02F8           	BSR		LAB_GBYT				; scan memory
    2118/     B76 : 661E                	BNE.s		LAB_1986				; if not null go get the value
    2119/     B78 :                     
    2120/     B78 :                     								; the pointer was to a null entry
    2121/     B78 : 4A2B 05E0           	TST.b		Imode(a3)				; test input mode flag, $00=INPUT, $98=READ
    2122/     B7C : 6B72                	BMI.s		LAB_19DD				; branch if READ (go find the next statement)
    2123/     B7E :                     
    2124/     B7E :                     								; else the mode was INPUT so get more
    2125/     B7E : 6100 FF38           	BSR		LAB_18E3				; print a "?" character
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 40 - 10/11/2023 16:23:32


    2126/     B82 : 6100 F7CA           	BSR		LAB_INLN				; print "? " and get BASIC input
    2127/     B86 :                     								; return a0 pointing to the buffer start
    2128/     B86 : 4A10                	TST.b		(a0)					; test the first byte from the buffer
    2129/     B88 : 6604                	BNE.s		LAB_1984				; if not null input go handle it
    2130/     B8A :                     
    2131/     B8A : 6000 FB20           	BRA		LAB_1647				; else go do the BREAK exit
    2132/     B8E :                     
    2133/     B8E :                     LAB_1984
    2134/     B8E : 2A48                	MOVEA.l	a0,a5					; set the execute pointer to the buffer
    2135/     B90 : 534D                	SUBQ.w	#1,a5					; decrement the execute pointer
    2136/     B92 :                     
    2137/     B92 :                     LAB_1985
    2138/     B92 : 6100 02D6           	BSR		LAB_IGBY				; increment & scan memory
    2139/     B96 :                     LAB_1986
    2140/     B96 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
    2141/     B9A :                     								; $00=float
    2142/     B9A : 6A20                	BPL.s		LAB_19B0				; branch if numeric
    2143/     B9C :                     
    2144/     B9C :                     								; else get string
    2145/     B9C : 1400                	MOVE.b	d0,d2					; save search character
    2146/     B9E : B03C 0022           	CMP.b		#$22,d0				; was it " ?
    2147/     BA2 : 6706                	BEQ.s		LAB_1999				; branch if so
    2148/     BA4 :                     
    2149/     BA4 : 743A                	MOVEQ		#':',d2				; set new search character
    2150/     BA6 : 702C                	MOVEQ		#',',d0				; other search character is ","
    2151/     BA8 : 534D                	SUBQ.w	#1,a5					; decrement BASIC execute pointer
    2152/     BAA :                     LAB_1999
    2153/     BAA : 524D                	ADDQ.w	#1,a5					; increment BASIC execute pointer
    2154/     BAC : 1600                	MOVE.b	d0,d3					; set second search character
    2155/     BAE : 204D                	MOVEA.l	a5,a0					; BASIC execute pointer is source
    2156/     BB0 :                     
    2157/     BB0 : 6100 08D4           	BSR		LAB_20B4				; print d2/d3 terminated string to FAC1 stack
    2158/     BB4 :                     								; d2 = Srchc, d3 = Asrch, a0 is source
    2159/     BB4 : 2A4A                	MOVEA.l	a2,a5					; copy end of string to BASIC execute pointer
    2160/     BB6 : 6100 FDD2           	BSR		LAB_17D5				; go do string LET
    2161/     BBA : 6010                	BRA.s		LAB_19B6				; go check string terminator
    2162/     BBC :                     
    2163/     BBC :                     								; get numeric INPUT
    2164/     BBC :                     LAB_19B0
    2165/     BBC : 1F2B 05B5           	MOVE.b	Dtypef(a3),-(sp)			; save variable data type
    2166/     BC0 : 6100 1DA6           	BSR		LAB_2887				; get FAC1 from string
    2167/     BC4 : 175F 05B5           	MOVE.b	(sp)+,Dtypef(a3)			; restore variable data type
    2168/     BC8 : 6100 1084           	BSR		LAB_PFAC				; pack FAC1 into (Lvarpl)
    2169/     BCC :                     LAB_19B6
    2170/     BCC : 6100 029E           	BSR		LAB_GBYT				; scan memory
    2171/     BD0 : 670A                	BEQ.s		LAB_19C2				; branch if null (last entry)
    2172/     BD2 :                     
    2173/     BD2 : B03C 002C           	CMP.b		#',',d0				; else compare with ","
    2174/     BD6 : 6600 FF38           	BNE		LAB_1904				; if not "," go handle bad input data
    2175/     BDA :                     
    2176/     BDA : 524D                	ADDQ.w	#1,a5					; else was "," so point to next chr
    2177/     BDC :                     								; got good input data
    2178/     BDC :                     LAB_19C2
    2179/     BDC : 274D 0466           	MOVE.l	a5,Rdptrl(a3)			; save the read pointer for now
    2180/     BE0 : 2A5F                	MOVEA.l	(sp)+,a5				; restore the execute pointer
    2181/     BE2 : 6100 0288           	BSR		LAB_GBYT				; scan the memory
    2182/     BE6 : 6736                	BEQ.s		LAB_1A03				; if null go do extra ignored message
    2183/     BE8 :                     
    2184/     BE8 : 487A FF7A           	PEA		LAB_195B(pc)			; set return address
    2185/     BEC : 6000 0272           	BRA		LAB_1C01				; scan for "," else do syntax error/warm start
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 41 - 10/11/2023 16:23:32


    2186/     BF0 :                     								; then go INPUT next variable from list
    2187/     BF0 :                     
    2188/     BF0 :                     								; find next DATA statement or do "Out of Data"
    2189/     BF0 :                     								; error
    2190/     BF0 :                     LAB_19DD
    2191/     BF0 : 6100 FBFE           	BSR		LAB_SNBS				; scan for next BASIC statement ([:] or [EOL])
    2192/     BF4 :                     								; returns a0 as pointer to [:] or [EOL]
    2193/     BF4 : 2A48                	MOVEA.l	a0,a5					; add index, now = pointer to [EOL]/[EOS]
    2194/     BF6 : 524D                	ADDQ.w	#1,a5					; pointer to next character
    2195/     BF8 : B03C 003A           	CMP.b		#':',d0				; was it statement end?
    2196/     BFC : 6712                	BEQ.s		LAB_19F6				; branch if [:]
    2197/     BFE :                     
    2198/     BFE :                     								; was [EOL] so find next line
    2199/     BFE :                     
    2200/     BFE : 320D                	MOVE.w	a5,d1					; past pad byte(s)
    2201/     C00 : C27C 0001           	AND.w		#1,d1					; mask odd bit
    2202/     C04 : DAC1                	ADD.w		d1,a5					; add pointer
    2203/     C06 : 241D                	MOVE.l	(a5)+,d2				; get next line pointer
    2204/     C08 : 6700 F612           	BEQ		LAB_ODER				; branch if end of program
    2205/     C0C :                     
    2206/     C0C : 275D 045E           	MOVE.l	(a5)+,Dlinel(a3)			; save current DATA line
    2207/     C10 :                     LAB_19F6
    2208/     C10 : 6100 025A           	BSR		LAB_GBYT				; scan memory
    2209/     C14 : B03C 0083           	CMP.b		#TK_DATA,d0				; compare with "DATA" token
    2210/     C18 : 6700 FF78           	BEQ		LAB_1985				; was "DATA" so go do next READ
    2211/     C1C :                     
    2212/     C1C : 60D2                	BRA.s		LAB_19DD				; go find next statement if not "DATA"
    2213/     C1E :                     
    2214/     C1E :                     ; end of INPUT/READ routine
    2215/     C1E :                     
    2216/     C1E :                     LAB_1A03
    2217/     C1E : 206B 0466           	MOVEA.l	Rdptrl(a3),a0			; get temp READ pointer
    2218/     C22 : 4A2B 05E0           	TST.b		Imode(a3)				; get input mode flag, $00=INPUT, $98=READ
    2219/     C26 : 6A06                	BPL.s		LAB_1A0E				; branch if INPUT
    2220/     C28 :                     
    2221/     C28 : 2748 0462           	MOVE.l	a0,Dptrl(a3)			; else save temp READ pointer as DATA pointer
    2222/     C2C : 4E75                	RTS
    2223/     C2E :                     
    2224/     C2E :                     								; we were getting INPUT
    2225/     C2E :                     LAB_1A0E
    2226/     C2E : 4A10                	TST.b		(a0)					; test next byte
    2227/     C30 : 6602                	BNE.s		LAB_1A1B				; error if not end of INPUT
    2228/     C32 :                     
    2229/     C32 : 4E75                	RTS
    2230/     C34 :                     								; user typed too much
    2231/     C34 :                     LAB_1A1B
    2232/     C34 : 41FA 2954           	LEA		LAB_IMSG(pc),a0			; point to extra ignored message
    2233/     C38 : 6000 FE66           	BRA		LAB_18C3				; print null terminated string from memory & RTS
    2234/     C3C :                     
    2235/     C3C :                     
    2236/     C3C :                     ;************************************************************************************
    2237/     C3C :                     ;
    2238/     C3C :                     ; perform NEXT
    2239/     C3C :                     
    2240/     C3C :                     LAB_NEXT
    2241/     C3C : 6610                	BNE.s		LAB_1A46				; branch if NEXT var
    2242/     C3E :                     
    2243/     C3E : 584F                	ADDQ.w	#4,sp					; back past return address
    2244/     C40 : 0C57 0081           	CMP.w		#TK_FOR,(sp)			; is FOR token on stack?
    2245/     C44 : 6600 F5E2           	BNE		LAB_NFER				; if not do NEXT without FOR err/warm start
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 42 - 10/11/2023 16:23:32


    2246/     C48 :                     
    2247/     C48 : 206F 0002           	MOVEA.l	2(sp),a0				; get stacked FOR variable pointer
    2248/     C4C : 601C                	BRA.s		LAB_11BD				; branch always (no variable to search for)
    2249/     C4E :                     
    2250/     C4E :                     ; NEXT var
    2251/     C4E :                     
    2252/     C4E :                     LAB_1A46
    2253/     C4E : 6100 042C           	BSR		LAB_GVAR				; get variable address in a0
    2254/     C52 : 584F                	ADDQ.w	#4,sp					; back past return address
    2255/     C54 : 303C 0081           	MOVE.w	#TK_FOR,d0				; set for FOR token
    2256/     C58 : 721C                	MOVEQ		#$1C,d1				; set for FOR use size
    2257/     C5A : 6002                	BRA.s		LAB_11A6				; enter loop for next variable search
    2258/     C5C :                     
    2259/     C5C :                     LAB_11A5
    2260/     C5C : DFC1                	ADDA.l	d1,sp					; add FOR stack use size
    2261/     C5E :                     LAB_11A6
    2262/     C5E : B057                	CMP.w		(sp),d0				; is FOR token on stack?
    2263/     C60 : 6600 F5C6           	BNE		LAB_NFER				; if not found do NEXT without FOR error and
    2264/     C64 :                     								; warm start
    2265/     C64 :                     
    2266/     C64 :                     								; was FOR token
    2267/     C64 : B1EF 0002           	CMPA.l	2(sp),a0				; compare var pointer with stacked var pointer
    2268/     C68 : 66F2                	BNE.s		LAB_11A5				; loop if no match found
    2269/     C6A :                     
    2270/     C6A :                     LAB_11BD
    2271/     C6A : 376F 0006 059C      	MOVE.w	6(sp),FAC2_e(a3)			; get STEP value exponent and sign
    2272/     C70 : 276F 0008 0598      	MOVE.l	8(sp),FAC2_m(a3)			; get STEP value mantissa
    2273/     C76 :                     
    2274/     C76 : 176F 0012 05B5      	MOVE.b	18(sp),Dtypef(a3)			; restore FOR variable data type
    2275/     C7C : 6100 021E           	BSR		LAB_1C19				; check type and unpack (a0)
    2276/     C80 :                     
    2277/     C80 : 176B 059D 059E      	MOVE.b	FAC2_s(a3),FAC_sc(a3)		; save FAC2 sign as sign compare
    2278/     C86 : 102B 0595           	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
    2279/     C8A : B12B 059E           	EOR.b		d0,FAC_sc(a3)			; EOR to create sign compare
    2280/     C8E :                     
    2281/     C8E : 2748 0472           	MOVE.l	a0,Lvarpl(a3)			; save variable pointer
    2282/     C92 : 6100 0CBA           	BSR		LAB_ADD				; add STEP value to FOR variable
    2283/     C96 : 176F 0012 05B5      	MOVE.b	18(sp),Dtypef(a3)			; restore FOR variable data type (again)
    2284/     C9C : 6100 0FB0           	BSR		LAB_PFAC				; pack FAC1 into FOR variable (Lvarpl)
    2285/     CA0 :                     
    2286/     CA0 : 376F 000C 059C      	MOVE.w	12(sp),FAC2_e(a3)			; get TO value exponent and sign
    2287/     CA6 : 276F 000E 0598      	MOVE.l	14(sp),FAC2_m(a3)			; get TO value mantissa
    2288/     CAC :                     
    2289/     CAC : 176B 059D 059E      	MOVE.b	FAC2_s(a3),FAC_sc(a3)		; save FAC2 sign as sign compare
    2290/     CB2 : 102B 0595           	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
    2291/     CB6 : B12B 059E           	EOR.b		d0,FAC_sc(a3)			; EOR to create sign compare
    2292/     CBA :                     
    2293/     CBA : 6100 103C           	BSR		LAB_27FA				; compare FAC1 with FAC2 (TO value)
    2294/     CBE :                     								; returns d0=+1 if FAC1 > FAC2
    2295/     CBE :                     								; returns d0= 0 if FAC1 = FAC2
    2296/     CBE :                     								; returns d0=-1 if FAC1 < FAC2
    2297/     CBE :                     
    2298/     CBE : 322F 0006           	MOVE.w	6(sp),d1				; get STEP value exponent and sign
    2299/     CC2 : B141                	EOR.w		d0,d1					; EOR compare result with STEP exponent and sign
    2300/     CC4 :                     
    2301/     CC4 : 4A00                	TST.b		d0					; test for =
    2302/     CC6 : 6704                	BEQ.s		LAB_1A90				; branch if = (loop INcomplete)
    2303/     CC8 :                     
    2304/     CC8 : 4A01                	TST.b		d1					; test result
    2305/     CCA : 6A0E                	BPL.s		LAB_1A9B				; branch if > (loop complete)
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 43 - 10/11/2023 16:23:32


    2306/     CCC :                     
    2307/     CCC :                     								; loop back and do it all again
    2308/     CCC :                     LAB_1A90
    2309/     CCC : 276F 0014 0452      	MOVE.l	20(sp),Clinel(a3)			; reset current line
    2310/     CD2 : 2A6F 0018           	MOVE.l	24(sp),a5				; reset BASIC execute pointer
    2311/     CD6 : 6000 F970           	BRA		LAB_15C2				; go do interpreter inner loop
    2312/     CDA :                     
    2313/     CDA :                     								; loop complete so carry on
    2314/     CDA :                     LAB_1A9B
    2315/     CDA : DEFC 001C           	ADDA.w	#28,sp				; add 28 to dump FOR structure
    2316/     CDE : 6100 018C           	BSR		LAB_GBYT				; scan memory
    2317/     CE2 : B03C 002C           	CMP.b		#$2C,d0				; compare with ","
    2318/     CE6 : 6600 F960           	BNE		LAB_15C2				; if not "," go do interpreter inner loop
    2319/     CEA :                     
    2320/     CEA :                     								; was "," so another NEXT variable to do
    2321/     CEA : 6100 017E           	BSR		LAB_IGBY				; else increment & scan memory
    2322/     CEE : 6100 FF5E           	BSR		LAB_1A46				; do NEXT (var)
    2323/     CF2 :                     
    2324/     CF2 :                     
    2325/     CF2 :                     ;************************************************************************************
    2326/     CF2 :                     ;
    2327/     CF2 :                     ; evaluate expression & check is numeric, else do type mismatch
    2328/     CF2 :                     
    2329/     CF2 :                     LAB_EVNM
    2330/     CF2 : 6116                	BSR.s		LAB_EVEX				; evaluate expression
    2331/     CF4 :                     
    2332/     CF4 :                     
    2333/     CF4 :                     ;************************************************************************************
    2334/     CF4 :                     ;
    2335/     CF4 :                     ; check if source is numeric, else do type mismatch
    2336/     CF4 :                     
    2337/     CF4 :                     LAB_CTNM
    2338/     CF4 : B040                	CMP.w		d0,d0					; required type is numeric so clear carry
    2339/     CF6 :                     
    2340/     CF6 :                     
    2341/     CF6 :                     ;************************************************************************************
    2342/     CF6 :                     ;
    2343/     CF6 :                     ; type match check, set C for string, clear C for numeric
    2344/     CF6 :                     
    2345/     CF6 :                     LAB_CKTM
    2346/     CF6 : 082B 0007 05B5      	BTST.b	#7,Dtypef(a3)			; test data type flag, don't change carry
    2347/     CFC : 6606                	BNE.s		LAB_1ABA				; branch if data type is string
    2348/     CFE :                     
    2349/     CFE :                     								; else data type was numeric
    2350/     CFE : 6500 F4F8           	BCS		LAB_TMER				; if required type is string do type mismatch
    2351/     D02 :                     								; error
    2352/     D02 :                     
    2353/     D02 : 4E75                	RTS
    2354/     D04 :                     								; data type was string, now check required type
    2355/     D04 :                     LAB_1ABA
    2356/     D04 : 6400 F4F2           	BCC		LAB_TMER				; if required type is numeric do type mismatch
    2357/     D08 :                     								; error
    2358/     D08 : 4E75                	RTS
    2359/     D0A :                     
    2360/     D0A :                     
    2361/     D0A :                     ;************************************************************************************
    2362/     D0A :                     ;
    2363/     D0A :                     ; this routine evaluates any type of expression. first it pushes an end marker so
    2364/     D0A :                     ; it knows when the expression has been evaluated, this is a precedence value of zero.
    2365/     D0A :                     ; next the first value is evaluated, this can be an in line value, either numeric or
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 44 - 10/11/2023 16:23:32


    2366/     D0A :                     ; string, a variable or array element of any type, a function or even an expression
    2367/     D0A :                     ; in parenthesis. this value is kept in FAC_1
    2368/     D0A :                     ; after the value is evaluated a test is made on the next BASIC program byte, if it
    2369/     D0A :                     ; is a comparrison operator i.e. "<", "=" or ">", then the corresponding bit is set
    2370/     D0A :                     ; in the comparison evaluation flag. this test loops until no more comparrison operators
    2371/     D0A :                     ; are found or more than one of any type is found. in the last case an error is generated
    2372/     D0A :                     
    2373/     D0A :                     ; evaluate expression
    2374/     D0A :                     
    2375/     D0A :                     LAB_EVEX
    2376/     D0A : 534D                	SUBQ.w	#1,a5					; decrement BASIC execute pointer
    2377/     D0C :                     LAB_EVEZ
    2378/     D0C : 7200                	MOVEQ		#0,d1					; clear precedence word
    2379/     D0E : 1741 05B5           	MOVE.b	d1,Dtypef(a3)			; clear the data type, $80=string, $40=integer,
    2380/     D12 :                     								; $00=float
    2381/     D12 : 601C                	BRA.s		LAB_1ACD				; enter loop
    2382/     D14 :                     
    2383/     D14 :                     ; get vector, set up operator then continue evaluation
    2384/     D14 :                     
    2385/     D14 :                     LAB_1B43
    2386/     D14 : 41FA 22CA           	LEA		LAB_OPPT(pc),a0			; point to operator vector table
    2387/     D18 : 3030 1002           	MOVE.w	2(a0,d1.w),d0			; get vector offset
    2388/     D1C : 4870 0000           	PEA		(a0,d0.w)				; push vector
    2389/     D20 :                     
    2390/     D20 : 2F2B 0590           	MOVE.l	FAC1_m(a3),-(sp)			; push FAC1 mantissa
    2391/     D24 : 3F2B 0594           	MOVE.w	FAC1_e(a3),-(sp)			; push sign and exponent
    2392/     D28 : 1F2B 05E3           	MOVE.b	comp_f(a3),-(sp)			; push comparison evaluation flag
    2393/     D2C :                     
    2394/     D2C : 3230 1000           	MOVE.w	(a0,d1.w),d1			; get precedence value
    2395/     D30 :                     LAB_1ACD
    2396/     D30 : 3F01                	MOVE.w	d1,-(sp)				; push precedence value
    2397/     D32 : 6100 00E4           	BSR		LAB_GVAL				; get value from line
    2398/     D36 : 177C 0000 05E3      	MOVE.b	#$00,comp_f(a3)			; clear compare function flag
    2399/     D3C :                     LAB_1ADB
    2400/     D3C : 6100 012E           	BSR		LAB_GBYT				; scan memory
    2401/     D40 :                     LAB_1ADE
    2402/     D40 : 903C 00BC           	SUB.b		#TK_GT,d0				; subtract token for > (lowest compare function)
    2403/     D44 : 652A                	BCS.s		LAB_1AFA				; branch if < TK_GT
    2404/     D46 :                     
    2405/     D46 : B03C 0003           	CMP.b		#$03,d0				; compare with ">" to "<" tokens
    2406/     D4A : 650A                	BCS.s		LAB_1AE0				; branch if <= TK_SGN (is compare function)
    2407/     D4C :                     
    2408/     D4C : 4A2B 05E3           	TST.b		comp_f(a3)				; test compare function flag
    2409/     D50 : 6660                	BNE.s		LAB_1B2A				; branch if compare function
    2410/     D52 :                     
    2411/     D52 : 6000 0086           	BRA		LAB_1B78				; go do functions
    2412/     D56 :                     
    2413/     D56 :                     								; was token for > = or < (d0 = 0, 1 or 2)
    2414/     D56 :                     LAB_1AE0
    2415/     D56 : 7201                	MOVEQ		#1,d1					; set to 0000 0001
    2416/     D58 : E121                	ASL.b		d0,d1					; 1 if >, 2 if =, 4 if <
    2417/     D5A : 102B 05E3           	MOVE.b	comp_f(a3),d0			; copy old compare function flag
    2418/     D5E : B32B 05E3           	EOR.b		d1,comp_f(a3)			; EOR in this compare function bit
    2419/     D62 : B02B 05E3           	CMP.b		comp_f(a3),d0			; compare old with new compare function flag
    2420/     D66 : 6400 F4BC           	BCC		LAB_SNER				; if new <= old comp_f do syntax error and warm
    2421/     D6A :                     								; start, there was more than one <, = or >
    2422/     D6A : 6100 00FE           	BSR		LAB_IGBY				; increment & scan memory
    2423/     D6E : 60D0                	BRA.s		LAB_1ADE				; go do next character
    2424/     D70 :                     
    2425/     D70 :                     								; token is < ">" or > "<" tokens
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 45 - 10/11/2023 16:23:32


    2426/     D70 :                     LAB_1AFA
    2427/     D70 : 4A2B 05E3           	TST.b		comp_f(a3)				; test compare function flag
    2428/     D74 : 663C                	BNE.s		LAB_1B2A				; branch if compare function
    2429/     D76 :                     
    2430/     D76 :                     								; was < TK_GT so is operator or lower
    2431/     D76 : D03C 000A           	ADD.b	#(TK_GT-TK_PLUS),d0			; add # of operators (+ -	; / ^ AND OR EOR)
    2432/     D7A : 645E                	BCC.s		LAB_1B78				; branch if < + operator
    2433/     D7C :                     
    2434/     D7C : 6608                	BNE.s		LAB_1B0B				; branch if not + token
    2435/     D7E :                     
    2436/     D7E : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
    2437/     D82 :                     								; $00=float
    2438/     D82 : 6B00 087E           	BMI		LAB_224D				; type is string & token was +
    2439/     D86 :                     
    2440/     D86 :                     LAB_1B0B
    2441/     D86 : 7200                	MOVEQ		#0,d1					; clear longword
    2442/     D88 : D000                	ADD.b		d0,d0					; *2
    2443/     D8A : D000                	ADD.b		d0,d0					; *4
    2444/     D8C : 1200                	MOVE.b	d0,d1					; copy to index
    2445/     D8E :                     LAB_1B13
    2446/     D8E : 301F                	MOVE.w	(sp)+,d0				; pull previous precedence
    2447/     D90 : 41FA 224E           	LEA		LAB_OPPT(pc),a0			; set pointer to operator table
    2448/     D94 : B070 1000           	CMP.w		(a0,d1.w),d0			; compare with this opperator precedence
    2449/     D98 : 6446                	BCC.s		LAB_1B7D				; branch if previous precedence (d0) >=
    2450/     D9A :                     
    2451/     D9A : 6100 FF58           	BSR		LAB_CTNM				; check if source is numeric, else type mismatch
    2452/     D9E :                     LAB_1B1C
    2453/     D9E : 3F00                	MOVE.w	d0,-(sp)				; save precedence
    2454/     DA0 :                     LAB_1B1D
    2455/     DA0 : 6100 FF72           	BSR		LAB_1B43				; get vector, set-up operator and continue
    2456/     DA4 :                     								; evaluation
    2457/     DA4 : 301F                	MOVE.w	(sp)+,d0				; restore precedence
    2458/     DA6 : 222B 05D8           	MOVE.l	prstk(a3),d1			; get stacked function pointer
    2459/     DAA : 6A22                	BPL.s		LAB_1B3C				; branch if stacked values
    2460/     DAC :                     
    2461/     DAC : 3000                	MOVE.w	d0,d0					; copy precedence (set flags)
    2462/     DAE : 672E                	BEQ.s		LAB_1B7B				; exit if done
    2463/     DB0 :                     
    2464/     DB0 : 603C                	BRA.s		LAB_1B86				; else pop FAC2 & return (do function)
    2465/     DB2 :                     
    2466/     DB2 :                     								; was compare function (< = >)
    2467/     DB2 :                     LAB_1B2A
    2468/     DB2 : 102B 05B5           	MOVE.b	Dtypef(a3),d0			; get data type flag
    2469/     DB6 : 122B 05E3           	MOVE.b	comp_f(a3),d1			; get compare function flag
    2470/     DBA : D000                	ADD.b		d0,d0					; string bit flag into X bit
    2471/     DBC : D301                	ADDX.b	d1,d1					; shift compare function flag
    2472/     DBE :                     
    2473/     DBE : 177C 0000 05B5      	MOVE.b	#0,Dtypef(a3)			; clear data type flag, $00=float
    2474/     DC4 : 1741 05E3           	MOVE.b	d1,comp_f(a3)			; save new compare function flag
    2475/     DC8 : 534D                	SUBQ.w	#1,a5					; decrement BASIC execute pointer
    2476/     DCA : 7230                	MOVEQ		#(TK_LT-TK_PLUS)*4,d1		; set offset to last operator entry
    2477/     DCC : 60C0                	BRA.s		LAB_1B13				; branch always
    2478/     DCE :                     
    2479/     DCE :                     LAB_1B3C
    2480/     DCE : 41FA 2210           	LEA		LAB_OPPT(pc),a0			; point to function vector table
    2481/     DD2 : B070 1000           	CMP.w		(a0,d1.w),d0			; compare with this opperator precedence
    2482/     DD6 : 6416                	BCC.s		LAB_1B86				; branch if d0 >=, pop FAC2 & return
    2483/     DD8 :                     
    2484/     DD8 : 60C4                	BRA.s		LAB_1B1C				; branch always
    2485/     DDA :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 46 - 10/11/2023 16:23:32


    2486/     DDA :                     ; do functions
    2487/     DDA :                     
    2488/     DDA :                     LAB_1B78
    2489/     DDA : 72FF                	MOVEQ		#-1,d1				; flag all done
    2490/     DDC : 301F                	MOVE.w	(sp)+,d0				; pull precedence word
    2491/     DDE :                     LAB_1B7B
    2492/     DDE : 6732                	BEQ.s		LAB_1B9D				; exit if done
    2493/     DE0 :                     
    2494/     DE0 :                     LAB_1B7D
    2495/     DE0 : B07C 0064           	CMP.w		#$64,d0				; compare previous precedence with $64
    2496/     DE4 : 6704                	BEQ.s		LAB_1B84				; branch if was $64 (< function can be string)
    2497/     DE6 :                     
    2498/     DE6 : 6100 FF0C           	BSR		LAB_CTNM				; check if source is numeric, else type mismatch
    2499/     DEA :                     LAB_1B84
    2500/     DEA : 2741 05D8           	MOVE.l	d1,prstk(a3)			; save current operator index
    2501/     DEE :                     
    2502/     DEE :                     								; pop FAC2 & return
    2503/     DEE :                     LAB_1B86
    2504/     DEE : 101F                	MOVE.b	(sp)+,d0				; pop comparison evaluation flag
    2505/     DF0 : 1200                	MOVE.b	d0,d1					; copy comparison evaluation flag
    2506/     DF2 : E208                	LSR.b		#1,d0					; shift out comparison evaluation lowest bit
    2507/     DF4 : 1740 05E1           	MOVE.b	d0,Cflag(a3)			; save comparison evaluation flag
    2508/     DF8 : 375F 059C           	MOVE.w	(sp)+,FAC2_e(a3)			; pop exponent and sign
    2509/     DFC : 275F 0598           	MOVE.l	(sp)+,FAC2_m(a3)			; pop mantissa
    2510/     E00 : 176B 059D 059E      	MOVE.b	FAC2_s(a3),FAC_sc(a3)		; copy FAC2 sign
    2511/     E06 : 102B 0595           	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
    2512/     E0A : B12B 059E           	EOR.b		d0,FAC_sc(a3)			; EOR FAC1 sign and set sign compare
    2513/     E0E :                     
    2514/     E0E : E209                	LSR.b		#1,d1					; type bit into X and C
    2515/     E10 : 4E75                	RTS
    2516/     E12 :                     
    2517/     E12 :                     LAB_1B9D
    2518/     E12 : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
    2519/     E16 : 4E75                	RTS
    2520/     E18 :                     
    2521/     E18 :                     
    2522/     E18 :                     ;************************************************************************************
    2523/     E18 :                     ;
    2524/     E18 :                     ; get a value from the BASIC line
    2525/     E18 :                     
    2526/     E18 :                     LAB_GVAL
    2527/     E18 : 6150                	BSR.s		LAB_IGBY				; increment & scan memory
    2528/     E1A : 6500 1B4C           	BCS		LAB_2887				; if numeric get FAC1 from string & return
    2529/     E1E :                     
    2530/     E1E : 4A00                	TST.b		d0					; test byte
    2531/     E20 : 6B00 0090           	BMI		LAB_1BD0				; if -ve go test token values
    2532/     E24 :                     
    2533/     E24 :                     								; else it is either a string, number, variable
    2534/     E24 :                     								; or (<expr>)
    2535/     E24 : B03C 0024           	CMP.b		#'$',d0				; compare with "$"
    2536/     E28 : 6700 1B3E           	BEQ		LAB_2887				; if "$" get hex number from string & return
    2537/     E2C :                     
    2538/     E2C : B03C 0025           	CMP.b		#'%',d0				; else compare with "%"
    2539/     E30 : 6700 1B36           	BEQ		LAB_2887				; if "%" get binary number from string & return
    2540/     E34 :                     
    2541/     E34 : B03C 002E           	CMP.b		#$2E,d0				; compare with "."
    2542/     E38 : 6700 1B2E           	BEQ		LAB_2887				; if so get FAC1 from string and return
    2543/     E3C :                     								; (e.g. .123)
    2544/     E3C :                     
    2545/     E3C :                     								; wasn't a number so ...
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 47 - 10/11/2023 16:23:32


    2546/     E3C : B03C 0022           	CMP.b		#$22,d0				; compare with "
    2547/     E40 : 660C                	BNE.s		LAB_1BF3				; if not open quote it must be a variable or
    2548/     E42 :                     								; open bracket
    2549/     E42 :                     
    2550/     E42 :                     								; was open quote so get the enclosed string
    2551/     E42 :                     
    2552/     E42 :                     ; print "..." string to string stack
    2553/     E42 :                     
    2554/     E42 :                     LAB_1BC1
    2555/     E42 : 101D                	MOVE.b	(a5)+,d0				; increment BASIC execute pointer (past ")
    2556/     E44 :                     								; fastest/shortest method
    2557/     E44 : 204D                	MOVEA.l	a5,a0					; copy basic execute pointer (string start)
    2558/     E46 : 6100 063A           	BSR		LAB_20AE				; print " terminated string to stack
    2559/     E4A : 2A4A                	MOVEA.l	a2,a5					; restore BASIC execute pointer from temp
    2560/     E4C : 4E75                	RTS
    2561/     E4E :                     
    2562/     E4E :                     ; get value from line .. continued
    2563/     E4E :                     								; wasn't any sort of number so ...
    2564/     E4E :                     LAB_1BF3
    2565/     E4E : B03C 0028           	CMP.b		#'(',d0				; compare with "("
    2566/     E52 : 6644                	BNE.s		LAB_1C18				; if not "(" get (var) and return value in FAC1
    2567/     E54 :                     								; and $ flag
    2568/     E54 :                     
    2569/     E54 :                     
    2570/     E54 :                     ;************************************************************************************
    2571/     E54 :                     ;
    2572/     E54 :                     ; evaluate expression within parentheses
    2573/     E54 :                     
    2574/     E54 :                     LAB_1BF7
    2575/     E54 : 6100 FEB6           	BSR		LAB_EVEZ				; evaluate expression (no decrement)
    2576/     E58 :                     
    2577/     E58 :                     
    2578/     E58 :                     ;************************************************************************************
    2579/     E58 :                     ;
    2580/     E58 :                     ; all the 'scan for' routines return the character after the sought character
    2581/     E58 :                     
    2582/     E58 :                     ; scan for ")", else do syntax error, then warm start
    2583/     E58 :                     
    2584/     E58 :                     LAB_1BFB
    2585/     E58 : 7029                	MOVEQ		#$29,d0				; load d0 with ")"
    2586/     E5A : 6006                	BRA.s		LAB_SCCA
    2587/     E5C :                     
    2588/     E5C :                     
    2589/     E5C :                     ;************************************************************************************
    2590/     E5C :                     ;
    2591/     E5C :                     ; scan for "," and get byte, else do Syntax error then warm start
    2592/     E5C :                     
    2593/     E5C :                     LAB_SCGB
    2594/     E5C : 487A 0978           	PEA		LAB_GTBY(pc)			; return address is to get byte parameter
    2595/     E60 :                     
    2596/     E60 :                     
    2597/     E60 :                     ;************************************************************************************
    2598/     E60 :                     ;
    2599/     E60 :                     ; scan for ",", else do syntax error, then warm start
    2600/     E60 :                     
    2601/     E60 :                     LAB_1C01
    2602/     E60 : 702C                	MOVEQ		#$2C,d0				; load d0 with ","
    2603/     E62 :                     
    2604/     E62 :                     
    2605/     E62 :                     ;************************************************************************************
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 48 - 10/11/2023 16:23:32


    2606/     E62 :                     ;
    2607/     E62 :                     ; scan for CHR$(d0) , else do syntax error, then warm start
    2608/     E62 :                     
    2609/     E62 :                     LAB_SCCA
    2610/     E62 : B01D                	CMP.b		(a5)+,d0				; check next byte is = d0
    2611/     E64 : 6706                	BEQ.s		LAB_GBYT				; if so go get next
    2612/     E66 :                     
    2613/     E66 : 6000 F3BC           	BRA		LAB_SNER				; else do syntax error/warm start
    2614/     E6A :                     
    2615/     E6A :                     
    2616/     E6A :                     ;************************************************************************************
    2617/     E6A :                     ;
    2618/     E6A :                     ; BASIC increment and scan memory routine
    2619/     E6A :                     
    2620/     E6A :                     LAB_IGBY
    2621/     E6A : 101D                	MOVE.b	(a5)+,d0				; get byte & increment pointer
    2622/     E6C :                     
    2623/     E6C :                     ; scan memory routine, exit with Cb = 1 if numeric character
    2624/     E6C :                     ; also skips any spaces encountered
    2625/     E6C :                     
    2626/     E6C :                     LAB_GBYT
    2627/     E6C : 1015                	MOVE.b	(a5),d0				; get byte
    2628/     E6E :                     
    2629/     E6E : B03C 0020           	CMP.b		#$20,d0				; compare with " "
    2630/     E72 : 67F6                	BEQ.s		LAB_IGBY				; if " " go do next
    2631/     E74 :                     
    2632/     E74 :                     ; test current BASIC byte, exit with Cb = 1 if numeric character
    2633/     E74 :                     
    2634/     E74 : B03C 00A9           	CMP.b		#TK_ELSE,d0				; compare with the token for ELSE
    2635/     E78 : 640E                	BCC.s		RTS_001				; exit if >= (not numeric, carry clear)
    2636/     E7A :                     
    2637/     E7A : B03C 003A           	CMP.b		#$3A,d0				; compare with ":"
    2638/     E7E : 6408                	BCC.s		RTS_001				; exit if >= (not numeric, carry clear)
    2639/     E80 :                     
    2640/     E80 : 1C3C 00D0           	MOVE.b		#$D0,d6				; set -"0"
    2641/     E84 : D006                	ADD.b		d6,d0					; add -"0"
    2642/     E86 : 9006                	SUB.b		d6,d0					; subtract -"0"
    2643/     E88 :                     RTS_001							; carry set if byte = "0"-"9"
    2644/     E88 : 4E75                	RTS
    2645/     E8A :                     
    2646/     E8A :                     
    2647/     E8A :                     ;************************************************************************************
    2648/     E8A :                     ;
    2649/     E8A :                     ; set-up for - operator
    2650/     E8A :                     
    2651/     E8A :                     LAB_1C11
    2652/     E8A : 6100 FE68           	BSR		LAB_CTNM				; check if source is numeric, else type mismatch
    2653/     E8E : 7228                	MOVEQ	#(TK_GT-TK_PLUS)*4,d1			; set offset from base to - operator
    2654/     E90 :                     LAB_1C13
    2655/     E90 : 4FEF 0004           	LEA		4(sp),sp				; dump GVAL return address
    2656/     E94 : 6000 FF0A           	BRA		LAB_1B1D				; continue evaluating expression
    2657/     E98 :                     
    2658/     E98 :                     
    2659/     E98 :                     ;************************************************************************************
    2660/     E98 :                     ;
    2661/     E98 :                     ; variable name set-up
    2662/     E98 :                     ; get (var), return value in FAC_1 & data type flag
    2663/     E98 :                     
    2664/     E98 :                     LAB_1C18
    2665/     E98 : 6100 01E2           	BSR		LAB_GVAR				; get variable address in a0
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 49 - 10/11/2023 16:23:32


    2666/     E9C :                     
    2667/     E9C :                     ; return existing variable value
    2668/     E9C :                     
    2669/     E9C :                     LAB_1C19
    2670/     E9C : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
    2671/     EA0 :                     								; $00=float
    2672/     EA0 : 6700 0D90           	BEQ		LAB_UFAC				; if float unpack memory (a0) into FAC1 and
    2673/     EA4 :                     								; return
    2674/     EA4 :                     
    2675/     EA4 : 6A06                	BPL.s		LAB_1C1A				; if integer unpack memory (a0) into FAC1
    2676/     EA6 :                     								; and return
    2677/     EA6 :                     
    2678/     EA6 : 2748 0590           	MOVE.l	a0,FAC1_m(a3)			; else save descriptor pointer in FAC1
    2679/     EAA : 4E75                	RTS
    2680/     EAC :                     
    2681/     EAC :                     LAB_1C1A
    2682/     EAC : 2010                	MOVE.l	(a0),d0				; get integer value
    2683/     EAE : 6000 04BC           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
    2684/     EB2 :                     
    2685/     EB2 :                     
    2686/     EB2 :                     ;************************************************************************************
    2687/     EB2 :                     ;
    2688/     EB2 :                     ; get value from line .. continued
    2689/     EB2 :                     ; do tokens
    2690/     EB2 :                     
    2691/     EB2 :                     LAB_1BD0
    2692/     EB2 : B03C 00B3           	CMP.b		#TK_MINUS,d0			; compare with token for -
    2693/     EB6 : 67D2                	BEQ.s		LAB_1C11				; branch if - token (do set-up for - operator)
    2694/     EB8 :                     
    2695/     EB8 :                     								; wasn't -123 so ...
    2696/     EB8 : B03C 00B2           	CMP.b		#TK_PLUS,d0				; compare with token for +
    2697/     EBC : 6700 FF5A           	BEQ		LAB_GVAL				; branch if + token (+n = n so ignore leading +)
    2698/     EC0 :                     
    2699/     EC0 : B03C 00AE           	CMP.b		#TK_NOT,d0				; compare with token for NOT
    2700/     EC4 : 6606                	BNE.s		LAB_1BE7				; branch if not token for NOT
    2701/     EC6 :                     
    2702/     EC6 :                     								; was NOT token
    2703/     EC6 : 323C 002C           	MOVE.w	#(TK_EQUAL-TK_PLUS)*4,d1		; offset to NOT function
    2704/     ECA : 60C4                	BRA.s		LAB_1C13				; do set-up for function then execute
    2705/     ECC :                     
    2706/     ECC :                     								; wasn't +, - or NOT so ...
    2707/     ECC :                     LAB_1BE7
    2708/     ECC : B03C 00AB           	CMP.b		#TK_FN,d0				; compare with token for FN
    2709/     ED0 : 6700 0514           	BEQ		LAB_201E				; if FN go evaluate FNx
    2710/     ED4 :                     
    2711/     ED4 :                     								; wasn't +, -, NOT or FN so ...
    2712/     ED4 : 903C 00BF           	SUB.b		#TK_SGN,d0				; compare with token for SGN & normalise
    2713/     ED8 : 6500 F34A           	BCS		LAB_SNER				; if < SGN token then do syntax error
    2714/     EDC :                     
    2715/     EDC :                     ; get value from line .. continued
    2716/     EDC :                     ; only functions left so set up function references
    2717/     EDC :                     
    2718/     EDC :                     ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
    2719/     EDC :                     ; to process function calls. now the function vector is computed and pushed on the stack
    2720/     EDC :                     ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
    2721/     EDC :                     ; is calculated and the routine called, if not this routine just does RTS. whichever
    2722/     EDC :                     ; happens the RTS at the end of this routine, or the preprocess routine calls, the
    2723/     EDC :                     ; function code
    2724/     EDC :                     
    2725/     EDC :                     ; this also removes some less than elegant code that was used to bypass type checking
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 50 - 10/11/2023 16:23:32


    2726/     EDC :                     ; for functions that returned strings
    2727/     EDC :                     
    2728/     EDC : C07C 007F           	AND.w		#$7F,d0				; mask byte
    2729/     EE0 : D040                	ADD.w		d0,d0					; *2 (2 bytes per function offset)
    2730/     EE2 :                     
    2731/     EE2 : 41FA 20B0           	LEA		LAB_FTBL(pc),a0			; pointer to functions vector table
    2732/     EE6 : 3230 0000           	MOVE.w	(a0,d0.w),d1			; get function vector offset
    2733/     EEA : 4870 1000           	PEA		(a0,d1.w)				; push function vector
    2734/     EEE :                     
    2735/     EEE : 41FA 2058           	LEA		LAB_FTPP(pc),a0			; pointer to functions preprocess vector table
    2736/     EF2 : 3030 0000           	MOVE.w	(a0,d0.w),d0			; get function preprocess vector offset
    2737/     EF6 : 6712                	BEQ.s		LAB_1C2A				; no preprocess vector so go do function
    2738/     EF8 :                     
    2739/     EF8 : 41F0 0000           	LEA		(a0,d0.w),a0			; get function preprocess vector
    2740/     EFC : 4ED0                	JMP		(a0)					; go do preprocess routine then function
    2741/     EFE :                     
    2742/     EFE :                     
    2743/     EFE :                     ;************************************************************************************
    2744/     EFE :                     ;
    2745/     EFE :                     ; process string expression in parenthesis
    2746/     EFE :                     
    2747/     EFE :                     LAB_PPFS
    2748/     EFE : 6100 FF54           	BSR		LAB_1BF7				; process expression in parenthesis
    2749/     F02 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type
    2750/     F06 : 6A00 F2F0           	BPL		LAB_TMER				; if numeric do Type missmatch Error/warm start
    2751/     F0A :                     
    2752/     F0A :                     LAB_1C2A
    2753/     F0A : 4E75                	RTS							; else do function
    2754/     F0C :                     
    2755/     F0C :                     
    2756/     F0C :                     ;************************************************************************************
    2757/     F0C :                     ;
    2758/     F0C :                     ; process numeric expression in parenthesis
    2759/     F0C :                     
    2760/     F0C :                     LAB_PPFN
    2761/     F0C : 6100 FF46           	BSR		LAB_1BF7				; process expression in parenthesis
    2762/     F10 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type
    2763/     F14 : 6B00 F2E2           	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
    2764/     F18 :                     
    2765/     F18 : 4E75                	RTS							; else do function
    2766/     F1A :                     
    2767/     F1A :                     
    2768/     F1A :                     ;************************************************************************************
    2769/     F1A :                     ;
    2770/     F1A :                     ; set numeric data type and increment BASIC execute pointer
    2771/     F1A :                     
    2772/     F1A :                     LAB_PPBI
    2773/     F1A : 177C 0000 05B5      	MOVE.b	#$00,Dtypef(a3)			; clear data type flag, $00=float
    2774/     F20 : 101D                	MOVE.b	(a5)+,d0				; get next BASIC byte
    2775/     F22 : 4E75                	RTS							; do function
    2776/     F24 :                     
    2777/     F24 :                     
    2778/     F24 :                     ;************************************************************************************
    2779/     F24 :                     ;
    2780/     F24 :                     ; process string for LEFT$, RIGHT$ or MID$
    2781/     F24 :                     
    2782/     F24 :                     LAB_LRMS
    2783/     F24 : 6100 FDE6           	BSR		LAB_EVEZ				; evaluate (should be string) expression
    2784/     F28 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type flag
    2785/     F2C : 6A00 F2CA           	BPL		LAB_TMER				; if type is not string do type mismatch error
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 51 - 10/11/2023 16:23:32


    2786/     F30 :                     
    2787/     F30 : 141D                	MOVE.b	(a5)+,d2				; get BASIC byte
    2788/     F32 : B43C 002C           	CMP.b		#',',d2				; compare with comma
    2789/     F36 : 6600 F2EC           	BNE		LAB_SNER				; if not "," go do syntax error/warm start
    2790/     F3A :                     
    2791/     F3A : 2F2B 0590           	MOVE.l	FAC1_m(a3),-(sp)			; save descriptor pointer
    2792/     F3E : 6100 08AC           	BSR		LAB_GTWO				; get word parameter, result in d0 and Itemp
    2793/     F42 : 205F                	MOVEA.l	(sp)+,a0				; restore descriptor pointer
    2794/     F44 : 4E75                	RTS							; do function
    2795/     F46 :                     
    2796/     F46 :                     
    2797/     F46 :                     ;************************************************************************************
    2798/     F46 :                     ;
    2799/     F46 :                     ; process numeric expression(s) for BIN$ or HEX$
    2800/     F46 :                     
    2801/     F46 :                     LAB_BHSS
    2802/     F46 : 6100 FDC4           	BSR		LAB_EVEZ				; evaluate expression (no decrement)
    2803/     F4A : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type
    2804/     F4E : 6B00 F2A8           	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
    2805/     F52 :                     
    2806/     F52 : 6100 0DD0           	BSR		LAB_2831				; convert FAC1 floating to fixed
    2807/     F56 :                     								; result in d0 and Itemp
    2808/     F56 : 7200                	MOVEQ		#0,d1					; set default to no leading "0"s
    2809/     F58 : 141D                	MOVE.b	(a5)+,d2				; get BASIC byte
    2810/     F5A : B43C 002C           	CMP.b		#',',d2				; compare with comma
    2811/     F5E : 660C                	BNE.s		LAB_BHCB				; if not "," go check close bracket
    2812/     F60 :                     
    2813/     F60 : 2F00                	MOVE.l	d0,-(sp)				; copy number to stack
    2814/     F62 : 6100 0872           	BSR		LAB_GTBY				; get byte value
    2815/     F66 : 2200                	MOVE.l	d0,d1					; copy leading 0s #
    2816/     F68 : 201F                	MOVE.l	(sp)+,d0				; restore number from stack
    2817/     F6A : 141D                	MOVE.b	(a5)+,d2				; get BASIC byte
    2818/     F6C :                     LAB_BHCB
    2819/     F6C : B43C 0029           	CMP.b		#')',d2				; compare with close bracket
    2820/     F70 : 6600 F2B2           	BNE		LAB_SNER				; if not ")" do Syntax Error/warm start
    2821/     F74 :                     
    2822/     F74 : 4E75                	RTS							; go do function
    2823/     F76 :                     
    2824/     F76 :                     
    2825/     F76 :                     ;************************************************************************************
    2826/     F76 :                     ;
    2827/     F76 :                     ; perform EOR
    2828/     F76 :                     
    2829/     F76 :                     LAB_EOR
    2830/     F76 : 6116                	BSR.s		GetFirst				; get two values for OR, AND or EOR
    2831/     F78 :                     								; first in d0, and Itemp, second in d2
    2832/     F78 : B580                	EOR.l		d2,d0					; EOR values
    2833/     F7A : 6000 03F0           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
    2834/     F7E :                     
    2835/     F7E :                     
    2836/     F7E :                     ;************************************************************************************
    2837/     F7E :                     ;
    2838/     F7E :                     ; perform OR
    2839/     F7E :                     
    2840/     F7E :                     LAB_OR
    2841/     F7E : 610E                	BSR.s		GetFirst				; get two values for OR, AND or EOR
    2842/     F80 :                     								; first in d0, and Itemp, second in d2
    2843/     F80 : 8082                	OR.l		d2,d0					; do OR
    2844/     F82 : 6000 03E8           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
    2845/     F86 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 52 - 10/11/2023 16:23:32


    2846/     F86 :                     
    2847/     F86 :                     ;************************************************************************************
    2848/     F86 :                     ;
    2849/     F86 :                     ; perform AND
    2850/     F86 :                     
    2851/     F86 :                     LAB_AND
    2852/     F86 : 6106                	BSR.s		GetFirst				; get two values for OR, AND or EOR
    2853/     F88 :                     								; first in d0, and Itemp, second in d2
    2854/     F88 : C082                	AND.l		d2,d0					; do AND
    2855/     F8A : 6000 03E0           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
    2856/     F8E :                     
    2857/     F8E :                     
    2858/     F8E :                     ;************************************************************************************
    2859/     F8E :                     ;
    2860/     F8E :                     ; get two values for OR, AND, EOR
    2861/     F8E :                     ; first in d0, second in d2
    2862/     F8E :                     
    2863/     F8E :                     GetFirst
    2864/     F8E : 6100 0228           	BSR		LAB_EVIR				; evaluate integer expression (no sign check)
    2865/     F92 :                     								; result in d0 and Itemp
    2866/     F92 : 2400                	MOVE.l	d0,d2					; copy second value
    2867/     F94 : 6100 0CF6           	BSR		LAB_279B				; copy FAC2 to FAC1, get first value in
    2868/     F98 :                     								; expression
    2869/     F98 : 6000 021E           	BRA		LAB_EVIR				; evaluate integer expression (no sign check)
    2870/     F9C :                     								; result in d0 and Itemp & return
    2871/     F9C :                     
    2872/     F9C :                     
    2873/     F9C :                     ;************************************************************************************
    2874/     F9C :                     ;
    2875/     F9C :                     ; perform NOT
    2876/     F9C :                     
    2877/     F9C :                     LAB_EQUAL
    2878/     F9C : 6100 021A           	BSR		LAB_EVIR				; evaluate integer expression (no sign check)
    2879/     FA0 :                     								; result in d0 and Itemp
    2880/     FA0 : 4680                	NOT.l		d0					; bitwise invert
    2881/     FA2 : 6000 03C8           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
    2882/     FA6 :                     
    2883/     FA6 :                     
    2884/     FA6 :                     ;************************************************************************************
    2885/     FA6 :                     ;
    2886/     FA6 :                     ; perform comparisons
    2887/     FA6 :                     ; do < compare
    2888/     FA6 :                     
    2889/     FA6 :                     LAB_LTHAN
    2890/     FA6 : 6100 FD4E           	BSR		LAB_CKTM				; type match check, set C for string
    2891/     FAA : 6506                	BCS.s		LAB_1CAE				; branch if string
    2892/     FAC :                     
    2893/     FAC :                     								; do numeric < compare
    2894/     FAC : 6100 0D4A           	BSR		LAB_27FA				; compare FAC1 with FAC2
    2895/     FB0 :                     								; returns d0=+1 if FAC1 > FAC2
    2896/     FB0 :                     								; returns d0= 0 if FAC1 = FAC2
    2897/     FB0 :                     								; returns d0=-1 if FAC1 < FAC2
    2898/     FB0 : 6042                	BRA.s		LAB_1CF2				; process result
    2899/     FB2 :                     
    2900/     FB2 :                     								; do string < compare
    2901/     FB2 :                     LAB_1CAE
    2902/     FB2 : 177C 0000 05B5      	MOVE.b	#$00,Dtypef(a3)			; clear data type, $80=string, $40=integer,
    2903/     FB8 :                     								; $00=float
    2904/     FB8 : 6100 06BC           	BSR		LAB_22B6				; pop string off descriptor stack, or from top
    2905/     FBC :                     								; of string space returns d0 = length,
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 53 - 10/11/2023 16:23:32


    2906/     FBC :                     								; a0 = pointer
    2907/     FBC : 2248                	MOVEA.l	a0,a1					; copy string 2 pointer
    2908/     FBE : 2200                	MOVE.l	d0,d1					; copy string 2 length
    2909/     FC0 : 206B 0598           	MOVEA.l	FAC2_m(a3),a0			; get string 1 descriptor pointer
    2910/     FC4 : 6100 06B4           	BSR		LAB_22BA				; pop (a0) descriptor, returns with ..
    2911/     FC8 :                     								; d0 = length, a0 = pointer
    2912/     FC8 : 2400                	MOVE.l	d0,d2					; copy length
    2913/     FCA : 6604                	BNE.s		LAB_1CB5				; branch if not null string
    2914/     FCC :                     
    2915/     FCC : 4A81                	TST.l		d1					; test if string 2 is null also
    2916/     FCE : 6724                	BEQ.s		LAB_1CF2				; if so do string 1 = string 2
    2917/     FD0 :                     
    2918/     FD0 :                     LAB_1CB5
    2919/     FD0 : 9481                	SUB.l		d1,d2					; subtract string 2 length
    2920/     FD2 : 670C                	BEQ.s		LAB_1CD5				; branch if strings = length
    2921/     FD4 :                     
    2922/     FD4 : 6504                	BCS.s		LAB_1CD4				; branch if string 1 < string 2
    2923/     FD6 :                     
    2924/     FD6 : 70FF                	MOVEQ		#-1,d0				; set for string 1 > string 2
    2925/     FD8 : 6008                	BRA.s		LAB_1CD6				; go do character comapare
    2926/     FDA :                     
    2927/     FDA :                     LAB_1CD4
    2928/     FDA : 2200                	MOVE.l	d0,d1					; string 1 length is compare length
    2929/     FDC : 7001                	MOVEQ		#1,d0					; and set for string 1 < string 2
    2930/     FDE : 6002                	BRA.s		LAB_1CD6				; go do character comapare
    2931/     FE0 :                     
    2932/     FE0 :                     LAB_1CD5
    2933/     FE0 : 2002                	MOVE.l	d2,d0					; set for string 1 = string 2
    2934/     FE2 :                     LAB_1CD6
    2935/     FE2 : 5381                	SUBQ.l	#1,d1					; adjust length for DBcc loop
    2936/     FE4 :                     
    2937/     FE4 :                     								; d1 is length to compare, d0 is <=> for length
    2938/     FE4 :                     								; a0 is string 1 pointer, a1 is string 2 pointer
    2939/     FE4 :                     LAB_1CE6
    2940/     FE4 : B308                	CMPM.b	(a0)+,(a1)+				; compare string bytes (1 with 2)
    2941/     FE6 : 56C9 FFFC           	DBNE		d1,LAB_1CE6				; loop if same and not end yet
    2942/     FEA :                     
    2943/     FEA : 6708                	BEQ.s		LAB_1CF2				; if = to here, then go use length compare
    2944/     FEC :                     
    2945/     FEC : 6404                	BCC.s		LAB_1CDB				; else branch if string 1 > string 2
    2946/     FEE :                     
    2947/     FEE : 70FF                	MOVEQ		#-1,d0				; else set for string 1 < string 2
    2948/     FF0 : 6002                	BRA.s		LAB_1CF2				; go set result
    2949/     FF2 :                     
    2950/     FF2 :                     LAB_1CDB
    2951/     FF2 : 7001                	MOVEQ		#1,d0					; and set for string 1 > string 2
    2952/     FF4 :                     
    2953/     FF4 :                     LAB_1CF2
    2954/     FF4 : 5200                	ADDQ.b	#1,d0					; make result 0, 1 or 2
    2955/     FF6 : 1200                	MOVE.b	d0,d1					; copy to d1
    2956/     FF8 : 7001                	MOVEQ		#1,d0					; set d0 longword
    2957/     FFA : E338                	ROL.b		d1,d0					; make 1, 2 or 4 (result = flag bit)
    2958/     FFC : C02B 05E1           	AND.b		Cflag(a3),d0			; AND with comparison evaluation flag
    2959/    1000 : 6700 0CDE           	BEQ		LAB_27DB				; exit if not a wanted result (i.e. false)
    2960/    1004 :                     
    2961/    1004 : 70FF                	MOVEQ		#-1,d0				; else set -1 (true)
    2962/    1006 : 6000 0CD8           	BRA		LAB_27DB				; save d0 as integer & return
    2963/    100A :                     
    2964/    100A :                     
    2965/    100A :                     LAB_1CFE
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 54 - 10/11/2023 16:23:32


    2966/    100A : 6100 FE54           	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
    2967/    100E :                     
    2968/    100E :                     
    2969/    100E :                     ;************************************************************************************
    2970/    100E :                     ;
    2971/    100E :                     ; perform DIM
    2972/    100E :                     
    2973/    100E :                     LAB_DIM
    2974/    100E : 72FF                	MOVEQ		#-1,d1				; set "DIM" flag
    2975/    1010 : 6170                	BSR.s		LAB_1D10				; search for or dimension a variable
    2976/    1012 : 6100 FE58           	BSR		LAB_GBYT				; scan memory
    2977/    1016 : 66F2                	BNE.s		LAB_1CFE				; loop and scan for "," if not null
    2978/    1018 :                     
    2979/    1018 : 4E75                	RTS
    2980/    101A :                     
    2981/    101A :                     
    2982/    101A :                     ;************************************************************************************
    2983/    101A :                     ;
    2984/    101A :                     ; perform << (left shift)
    2985/    101A :                     
    2986/    101A :                     LAB_LSHIFT
    2987/    101A : 612E                	BSR.s		GetPair				; get an integer and byte pair
    2988/    101C :                     								; byte is in d2, integer is in d0 and Itemp
    2989/    101C : 6708                	BEQ.s		NoShift				; branch if byte zero
    2990/    101E :                     
    2991/    101E : B43C 0020           	CMP.b		#$20,d2				; compare bit count with 32d
    2992/    1022 : 6420                	BCC.s		TooBig				; branch if >=
    2993/    1024 :                     
    2994/    1024 : E5A0                	ASL.l		d2,d0					; shift longword
    2995/    1026 :                     NoShift
    2996/    1026 : 6000 0344           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
    2997/    102A :                     
    2998/    102A :                     
    2999/    102A :                     ;************************************************************************************
    3000/    102A :                     ;
    3001/    102A :                     ; perform >> (right shift)
    3002/    102A :                     
    3003/    102A :                     LAB_RSHIFT
    3004/    102A : 611E                	BSR.s		GetPair				; get an integer and byte pair
    3005/    102C :                     								; byte is in d2, integer is in d0 and Itemp
    3006/    102C : 67F8                	BEQ.s		NoShift				; branch if byte zero
    3007/    102E :                     
    3008/    102E : B43C 0020           	CMP.b		#$20,d2				; compare bit count with 32d
    3009/    1032 : 650A                	BCS.s		Not2Big				; branch if >= (return shift)
    3010/    1034 :                     
    3011/    1034 : 4A80                	TST.l		d0					; test sign bit
    3012/    1036 : 6A0C                	BPL.s		TooBig				; branch if +ve
    3013/    1038 :                     
    3014/    1038 : 70FF                	MOVEQ		#-1,d0				; set longword
    3015/    103A : 6000 0330           	BRA		LAB_AYFC				; convert d0 to longword in FAC1 & RET
    3016/    103E :                     
    3017/    103E :                     Not2Big
    3018/    103E : E4A0                	ASR.l		d2,d0					; shift longword
    3019/    1040 : 6000 032A           	BRA		LAB_AYFC				; convert d0 to longword in FAC1 & RET
    3020/    1044 :                     
    3021/    1044 :                     TooBig
    3022/    1044 : 7000                	MOVEQ		#0,d0					; clear longword
    3023/    1046 : 6000 0324           	BRA		LAB_AYFC				; convert d0 to longword in FAC1 & RET
    3024/    104A :                     
    3025/    104A :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 55 - 10/11/2023 16:23:32


    3026/    104A :                     ;************************************************************************************
    3027/    104A :                     ;
    3028/    104A :                     ; get an integer and byte pair
    3029/    104A :                     ; byte is in d2, integer is in d0 and Itemp
    3030/    104A :                     
    3031/    104A :                     GetPair
    3032/    104A : 6100 078E           	BSR		LAB_EVBY				; evaluate byte expression, result in d0 and
    3033/    104E :                     								; Itemp
    3034/    104E : 1400                	MOVE.b	d0,d2					; save it
    3035/    1050 : 6100 0C3A           	BSR		LAB_279B				; copy FAC2 to FAC1, get first value in
    3036/    1054 :                     								; expression
    3037/    1054 : 6100 0162           	BSR		LAB_EVIR				; evaluate integer expression (no sign check)
    3038/    1058 :                     								; result in d0 and Itemp
    3039/    1058 : 4A02                	TST.b		d2					; test byte value
    3040/    105A : 4E75                	RTS
    3041/    105C :                     
    3042/    105C :                     
    3043/    105C :                     ;************************************************************************************
    3044/    105C :                     ;
    3045/    105C :                     ; check alpha, return C=0 if<"A" or >"Z" or <"a" to "z">
    3046/    105C :                     
    3047/    105C :                     LAB_CASC
    3048/    105C : B03C 0061           	CMP.b		#$61,d0				; compare with "a"
    3049/    1060 : 6410                	BCC.s		LAB_1D83				; if >="a" go check =<"z"
    3050/    1062 :                     
    3051/    1062 :                     
    3052/    1062 :                     ;************************************************************************************
    3053/    1062 :                     ;
    3054/    1062 :                     ; check alpha upper case, return C=0 if<"A" or >"Z"
    3055/    1062 :                     
    3056/    1062 :                     LAB_CAUC
    3057/    1062 : B03C 0041           	CMP.b		#$41,d0				; compare with "A"
    3058/    1066 : 6404                	BCC.s		LAB_1D8A				; if >="A" go check =<"Z"
    3059/    1068 :                     
    3060/    1068 : 8040                	OR		d0,d0					; make C=0
    3061/    106A : 4E75                	RTS
    3062/    106C :                     
    3063/    106C :                     LAB_1D8A
    3064/    106C : B03C 005B           	CMP.b		#$5B,d0				; compare with "Z"+1
    3065/    1070 :                     								; carry set if byte<="Z"
    3066/    1070 : 4E75                	RTS
    3067/    1072 :                     
    3068/    1072 :                     LAB_1D83
    3069/    1072 : B03C 007B           	CMP.b		#$7B,d0				; compare with "z"+1
    3070/    1076 :                     								; carry set if byte<="z"
    3071/    1076 : 4E75                	RTS
    3072/    1078 :                     
    3073/    1078 :                     
    3074/    1078 :                     ;************************************************************************************
    3075/    1078 :                     ;
    3076/    1078 :                     ; search for or create variable. this is used to automatically create a variable if
    3077/    1078 :                     ; it is not found. any routines that need to create the variable call LAB_GVAR via
    3078/    1078 :                     ; this point and error generation is supressed and the variable will be created
    3079/    1078 :                     ;
    3080/    1078 :                     ; return pointer to variable in Cvaral and a0
    3081/    1078 :                     ; set data type to variable type
    3082/    1078 :                     
    3083/    1078 :                     LAB_SVAR
    3084/    1078 : 6102                	BSR.s		LAB_GVAR				; search for variable
    3085/    107A :                     LAB_FVAR
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 56 - 10/11/2023 16:23:32


    3086/    107A : 4E75                	RTS
    3087/    107C :                     
    3088/    107C :                     
    3089/    107C :                     ;************************************************************************************
    3090/    107C :                     ;
    3091/    107C :                     ; search for variable. if this routine is called from anywhere but the above call and
    3092/    107C :                     ; the variable searched for does not exist then an error will be returned
    3093/    107C :                     ;
    3094/    107C :                     ; DIM flag is in d1.b
    3095/    107C :                     ; return pointer to variable in Cvaral and a0
    3096/    107C :                     ; set data type to variable type
    3097/    107C :                     
    3098/    107C :                     LAB_GVAR
    3099/    107C : 7200                	MOVEQ		#$00,d1				; set DIM flag = $00
    3100/    107E : 6100 FDEC           	BSR		LAB_GBYT				; scan memory (1st character)
    3101/    1082 :                     LAB_1D10
    3102/    1082 : 1741 05B4           	MOVE.b	d1,Defdim(a3)			; save DIM flag
    3103/    1086 :                     
    3104/    1086 :                     ; search for FN name entry point
    3105/    1086 :                     
    3106/    1086 :                     LAB_1D12
    3107/    1086 : 61D4                	BSR.s		LAB_CASC				; check byte, return C=0 if<"A" or >"Z"
    3108/    1088 : 6400 F19A           	BCC		LAB_SNER				; if not, syntax error then warm start
    3109/    108C :                     
    3110/    108C :                     								; it is a variable name so ...
    3111/    108C : 7200                	MOVEQ		#$0,d1				; set index for name byte
    3112/    108E : 41EB 046A           	LEA		Varname(a3),a0			; pointer to variable name
    3113/    1092 : 2081                	MOVE.l	d1,(a0)				; clear the variable name
    3114/    1094 : 1741 05B5           	MOVE.b	d1,Dtypef(a3)			; clear the data type, $80=string, $40=integer,
    3115/    1098 :                     								; $00=float
    3116/    1098 :                     
    3117/    1098 :                     LAB_1D2D
    3118/    1098 : B27C 0004           	CMP.w		#$04,d1				; done all significant characters?
    3119/    109C : 6406                	BCC.s		LAB_1D2E				; if so go ignore any more
    3120/    109E :                     
    3121/    109E : 1180 1000           	MOVE.b	d0,(a0,d1.w)			; save the character
    3122/    10A2 : 5241                	ADDQ.w	#1,d1					; increment index
    3123/    10A4 :                     LAB_1D2E
    3124/    10A4 : 6100 FDC4           	BSR		LAB_IGBY				; increment & scan memory (next character)
    3125/    10A8 : 65EE                	BCS.s		LAB_1D2D				; branch if character = "0"-"9" (ok)
    3126/    10AA :                     
    3127/    10AA :                     								; character wasn't "0" to "9" so ...
    3128/    10AA : 61B0                	BSR.s		LAB_CASC				; check byte, return C=0 if<"A" or >"Z"
    3129/    10AC : 65EA                	BCS.s		LAB_1D2D				; branch if = "A"-"Z" (ok)
    3130/    10AE :                     
    3131/    10AE :                     								; check if string variable
    3132/    10AE : B03C 0024           	CMP.b		#'$',d0				; compare with "$"
    3133/    10B2 : 660C                	BNE.s		LAB_1D44				; branch if not string
    3134/    10B4 :                     
    3135/    10B4 :                     								; type is string
    3136/    10B4 : 002B 0080 046B      	OR.b		#$80,Varname+1(a3)		; set top bit of 2nd character, indicate string
    3137/    10BA : 6100 FDAE           	BSR		LAB_IGBY				; increment & scan memory
    3138/    10BE : 6010                	BRA.s		LAB_1D45				; skip integer check
    3139/    10C0 :                     
    3140/    10C0 :                     								; check if integer variable
    3141/    10C0 :                     LAB_1D44
    3142/    10C0 : B03C 0026           	CMP.b		#'&',d0				; compare with "&"
    3143/    10C4 : 660A                	BNE.s		LAB_1D45				; branch if not integer
    3144/    10C6 :                     
    3145/    10C6 :                     								; type is integer
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 57 - 10/11/2023 16:23:32


    3146/    10C6 : 002B 0080 046C      	OR.b		#$80,Varname+2(a3)		; set top bit of 3rd character, indicate integer
    3147/    10CC : 6100 FD9C           	BSR		LAB_IGBY				; increment & scan memory
    3148/    10D0 :                     
    3149/    10D0 :                     ; after we have determined the variable type we need to determine
    3150/    10D0 :                     ; if it's an array of type
    3151/    10D0 :                     
    3152/    10D0 :                     								; gets here with character after var name in d0
    3153/    10D0 :                     LAB_1D45
    3154/    10D0 : 4A2B 05DF           	TST.b		Sufnxf(a3)				; test function name flag
    3155/    10D4 : 670E                	BEQ.s		LAB_1D48				; if not FN or FN variable continue
    3156/    10D6 :                     
    3157/    10D6 : 6A14                	BPL.s		LAB_1D49				; if FN variable go find or create it
    3158/    10D8 :                     
    3159/    10D8 :                     								; else was FN name
    3160/    10D8 : 202B 046A           	MOVE.l	Varname(a3),d0			; get whole function name
    3161/    10DC : 7208                	MOVEQ		#8,d1					; set step to next function size -4
    3162/    10DE : 41EB 0432           	LEA		Sfncl(a3),a0			; get pointer to start of functions
    3163/    10E2 : 601C                	BRA.s		LAB_1D4B				; go find function
    3164/    10E4 :                     
    3165/    10E4 :                     LAB_1D48
    3166/    10E4 : 903C 0028           	SUB.b		#'(',d0				; subtract "("
    3167/    10E8 : 6700 00F4           	BEQ		LAB_1E17				; if "(" go find, or make, array
    3168/    10EC :                     
    3169/    10EC :                     ; either find or create var
    3170/    10EC :                     ; var name (1st four characters only!) is in Varname
    3171/    10EC :                     
    3172/    10EC :                     								; variable name wasn't var( .. so look for
    3173/    10EC :                     								; plain variable
    3174/    10EC :                     LAB_1D49
    3175/    10EC : 202B 046A           	MOVE.l	Varname(a3),d0			; get whole variable name
    3176/    10F0 :                     LAB_1D4A
    3177/    10F0 : 7204                	MOVEQ		#4,d1					; set step to next variable size -4
    3178/    10F2 : 41EB 0436           	LEA		Svarl(a3),a0			; get pointer to start of variables
    3179/    10F6 :                     
    3180/    10F6 : 0800 0017           	BTST.l	#23,d0				; test if string name
    3181/    10FA : 6704                	BEQ.s		LAB_1D4B				; branch if not
    3182/    10FC :                     
    3183/    10FC : 5441                	ADDQ.w	#2,d1					; 6 bytes per string entry
    3184/    10FE : 5848                	ADDQ.w	#(Sstrl-Svarl),a0			; move to string area
    3185/    1100 :                     
    3186/    1100 :                     LAB_1D4B
    3187/    1100 : 2268 0004           	MOVEA.l	4(a0),a1				; get end address
    3188/    1104 : 2050                	MOVEA.l	(a0),a0				; get start address
    3189/    1106 : 6006                	BRA.s		LAB_1D5E				; enter loop at exit check
    3190/    1108 :                     
    3191/    1108 :                     LAB_1D5D
    3192/    1108 : B098                	CMP.l		(a0)+,d0				; compare this variable with name
    3193/    110A : 6776                	BEQ.s		LAB_1DD7				; branch if match (found var)
    3194/    110C :                     
    3195/    110C : D1C1                	ADDA.l	d1,a0					; add offset to next variable
    3196/    110E :                     LAB_1D5E
    3197/    110E : B1C9                	CMPA.l	a1,a0					; compare address with variable space end
    3198/    1110 : 66F6                	BNE.s		LAB_1D5D				; if not end go check next
    3199/    1112 :                     
    3200/    1112 : 4A2B 05DF           	TST.b		Sufnxf(a3)				; is it a function or function variable
    3201/    1116 : 660A                	BNE.s		LAB_1D94				; if was go do DEF or function variable
    3202/    1118 :                     
    3203/    1118 :                     								; reached end of variable mem without match
    3204/    1118 :                     								; ... so create new variable, possibly
    3205/    1118 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 58 - 10/11/2023 16:23:32


    3206/    1118 : 45FA FF60           	LEA		LAB_FVAR(pc),a2			; get the address of the create if doesn't
    3207/    111C :                     								; exist call to LAB_GVAR
    3208/    111C : B5D7                	CMPA.l	(sp),a2				; compare the return address with expected
    3209/    111E : 6600 F0C0           	BNE		LAB_UVER				; if not create go do error or return null
    3210/    1122 :                     
    3211/    1122 :                     ; this will only branch if the call to LAB_GVAR wasn't from LAB_SVAR
    3212/    1122 :                     
    3213/    1122 :                     LAB_1D94
    3214/    1122 : 082B 0000 05DF      	BTST.b	#0,Sufnxf(a3)			; test function search flag
    3215/    1128 : 6600 F0BE           	BNE		LAB_UFER				; if not doing DEF then go do undefined
    3216/    112C :                     								; function error
    3217/    112C :                     
    3218/    112C :                     								; else create new variable/function
    3219/    112C :                     LAB_1D98
    3220/    112C : 246B 0442           	MOVEA.l	Earryl(a3),a2			; get end of block to move
    3221/    1130 : 240A                	MOVE.l	a2,d2					; copy end of block to move
    3222/    1132 : 9489                	SUB.l		a1,d2					; calculate block to move size
    3223/    1134 :                     
    3224/    1134 : 204A                	MOVEA.l	a2,a0					; copy end of block to move
    3225/    1136 : 5881                	ADDQ.l	#4,d1					; space for one variable/function + name
    3226/    1138 : D5C1                	ADDA.l	d1,a2					; add space for one variable/function
    3227/    113A : 274A 0442           	MOVE.l	a2,Earryl(a3)			; set new array mem end
    3228/    113E : E28A                	LSR.l		#1,d2					; /2 for word copy
    3229/    1140 : 6712                	BEQ.s		LAB_1DAF				; skip move if zero length block
    3230/    1142 :                     
    3231/    1142 : 5382                	SUBQ.l	#1,d2					; -1 for DFB loop
    3232/    1144 : 4842                	SWAP		d2					; swap high word to low word
    3233/    1146 :                     LAB_1DAC
    3234/    1146 : 4842                	SWAP		d2					; swap high word to low word
    3235/    1148 :                     LAB_1DAE
    3236/    1148 : 3520                	MOVE.w	-(a0),-(a2)				; copy word
    3237/    114A : 51CA FFFC           	DBF		d2,LAB_1DAE				; loop until done
    3238/    114E :                     
    3239/    114E : 4842                	SWAP		d2					; swap high word to low word
    3240/    1150 : 51CA FFF4           	DBF		d2,LAB_1DAC				; decrement high count and loop until done
    3241/    1154 :                     
    3242/    1154 :                     ; get here after creating either a function, variable or string
    3243/    1154 :                     ; if function set variables start, string start, array start
    3244/    1154 :                     ; if variable set string start, array start
    3245/    1154 :                     ; if string set array start
    3246/    1154 :                     
    3247/    1154 :                     LAB_1DAF
    3248/    1154 : 4A2B 05DF           	TST.b		Sufnxf(a3)				; was it function
    3249/    1158 : 6B08                	BMI.s		LAB_1DB0				; branch if was FN
    3250/    115A :                     
    3251/    115A : 0800 0017           	BTST.l	#23,d0				; was it string
    3252/    115E : 660A                	BNE.s		LAB_1DB2				; branch if string
    3253/    1160 :                     
    3254/    1160 : 6004                	BRA.s		LAB_1DB1				; branch if was plain variable
    3255/    1162 :                     
    3256/    1162 :                     LAB_1DB0
    3257/    1162 : D3AB 0436           	ADD.l		d1,Svarl(a3)			; set new variable memory start
    3258/    1166 :                     LAB_1DB1
    3259/    1166 : D3AB 043A           	ADD.l		d1,Sstrl(a3)			; set new start of strings
    3260/    116A :                     LAB_1DB2
    3261/    116A : D3AB 043E           	ADD.l		d1,Sarryl(a3)			; set new array memory start
    3262/    116E : 20C0                	MOVE.l	d0,(a0)+				; save variable/function name
    3263/    1170 : 20BC 0000 0000      	MOVE.l	#$00,(a0)				; initialise variable
    3264/    1176 : 0800 0017           	BTST.l	#23,d0				; was it string
    3265/    117A : 6706                	BEQ.s		LAB_1DD7				; branch if not string
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 59 - 10/11/2023 16:23:32


    3266/    117C :                     
    3267/    117C : 317C 0000 0004      	MOVE.w	#$00,4(a0)				; else initialise string length
    3268/    1182 :                     
    3269/    1182 :                     								; found a match for var ((Vrschl) = ptr)
    3270/    1182 :                     LAB_1DD7
    3271/    1182 : 2200                	MOVE.l	d0,d1					; ........ $....... &....... ........
    3272/    1184 : D281                	ADD.l		d1,d1					; .......$ .......& ........ .......0
    3273/    1186 : 4841                	SWAP		d1					; ........ .......0 .......$ .......&
    3274/    1188 : E219                	ROR.b		#1,d1					; ........ .......0 .......$ &.......
    3275/    118A : E249                	LSR.w		#1,d1					; ........ .......0 0....... $&......
    3276/    118C : C23C 00C0           	AND.b		#$C0,d1				; mask the type bits
    3277/    1190 : 1741 05B5           	MOVE.b	d1,Dtypef(a3)			; save the data type
    3278/    1194 :                     
    3279/    1194 : 177C 0000 05DF      	MOVE.b	#$00,Sufnxf(a3)			; clear FN flag byte
    3280/    119A : 4E75                	RTS
    3281/    119C :                     
    3282/    119C :                     
    3283/    119C :                     ;************************************************************************************
    3284/    119C :                     ;
    3285/    119C :                     ; set-up array pointer, d0, to first element in array
    3286/    119C :                     ; set d0 to (a0)+2*(Dimcnt)+$0A
    3287/    119C :                     
    3288/    119C :                     LAB_1DE6
    3289/    119C : 7005                	MOVEQ		#5,d0					; set d0 to 5 (*2 = 10, later)
    3290/    119E : D02B 05DB           	ADD.b		Dimcnt(a3),d0			; add # of dimensions (1, 2 or 3)
    3291/    11A2 : D080                	ADD.l		d0,d0					; *2 (bytes per dimension size)
    3292/    11A4 : D088                	ADD.l		a0,d0					; add array start pointer
    3293/    11A6 : 4E75                	RTS
    3294/    11A8 :                     
    3295/    11A8 :                     
    3296/    11A8 :                     ;************************************************************************************
    3297/    11A8 :                     ;
    3298/    11A8 :                     ; evaluate unsigned integer expression
    3299/    11A8 :                     
    3300/    11A8 :                     LAB_EVIN
    3301/    11A8 : 6100 FCC0           	BSR		LAB_IGBY				; increment & scan memory
    3302/    11AC : 6100 FB44           	BSR		LAB_EVNM				; evaluate expression & check is numeric,
    3303/    11B0 :                     								; else do type mismatch
    3304/    11B0 :                     
    3305/    11B0 :                     
    3306/    11B0 :                     ;************************************************************************************
    3307/    11B0 :                     ;
    3308/    11B0 :                     ; evaluate positive integer expression, result in d0 and Itemp
    3309/    11B0 :                     
    3310/    11B0 :                     LAB_EVPI
    3311/    11B0 : 4A2B 0595           	TST.b		FAC1_s(a3)				; test FAC1 sign (b7)
    3312/    11B4 : 6B00 F062           	BMI		LAB_FCER				; do function call error if -ve
    3313/    11B8 :                     
    3314/    11B8 :                     
    3315/    11B8 :                     ;************************************************************************************
    3316/    11B8 :                     ;
    3317/    11B8 :                     ; evaluate integer expression, no sign check
    3318/    11B8 :                     ; result in d0 and Itemp, exit with flags set correctly
    3319/    11B8 :                     
    3320/    11B8 :                     LAB_EVIR
    3321/    11B8 : 0C2B 00A0 0594      	CMPI.b	#$A0,FAC1_e(a3)			; compare exponent with exponent = 2^32 (n>2^31)
    3322/    11BE : 6500 0B64           	BCS		LAB_2831				; convert FAC1 floating to fixed
    3323/    11C2 :                     								; result in d0 and Itemp
    3324/    11C2 : 6600 F054           	BNE		LAB_FCER				; if > do function call error, then warm start
    3325/    11C6 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 60 - 10/11/2023 16:23:32


    3326/    11C6 : 4A2B 0595           	TST.b		FAC1_s(a3)				; test sign of FAC1
    3327/    11CA : 6A00 0B58           	BPL		LAB_2831				; if +ve then ok
    3328/    11CE :                     
    3329/    11CE : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get mantissa
    3330/    11D2 : 4480                	NEG.l		d0					; do -d0
    3331/    11D4 : 6800 F042           	BVC		LAB_FCER				; if not $80000000 do FC error, then warm start
    3332/    11D8 :                     
    3333/    11D8 : 2740 042A           	MOVE.l	d0,Itemp(a3)			; else just set it
    3334/    11DC : 4E75                	RTS
    3335/    11DE :                     
    3336/    11DE :                     
    3337/    11DE :                     ;************************************************************************************
    3338/    11DE :                     ;
    3339/    11DE :                     ; find or make array
    3340/    11DE :                     
    3341/    11DE :                     LAB_1E17
    3342/    11DE : 3F2B 05B4           	MOVE.w	Defdim(a3),-(sp)			; get DIM flag and data type flag (word in mem)
    3343/    11E2 : 7200                	MOVEQ		#0,d1					; clear dimensions count
    3344/    11E4 :                     
    3345/    11E4 :                     ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
    3346/    11E4 :                     
    3347/    11E4 :                     LAB_1E1F
    3348/    11E4 : 3F01                	MOVE.w	d1,-(sp)				; save dimensions count
    3349/    11E6 : 2F2B 046A           	MOVE.l	Varname(a3),-(sp)			; save variable name
    3350/    11EA : 61BC                	BSR.s		LAB_EVIN				; evaluate integer expression
    3351/    11EC :                     
    3352/    11EC : 4840                	SWAP		d0					; swap high word to low word
    3353/    11EE : 4A40                	TST.w		d0					; test swapped high word
    3354/    11F0 : 6600 F016           	BNE		LAB_ABER				; if too big do array bounds error
    3355/    11F4 :                     
    3356/    11F4 : 275F 046A           	MOVE.l	(sp)+,Varname(a3)			; restore variable name
    3357/    11F8 : 321F                	MOVE.w	(sp)+,d1				; restore dimensions count
    3358/    11FA : 301F                	MOVE.w	(sp)+,d0				; restore DIM and data type flags
    3359/    11FC : 3F2B 042C           	MOVE.w	Itemp+2(a3),-(sp)			; stack this dimension size
    3360/    1200 : 3F00                	MOVE.w	d0,-(sp)				; save DIM and data type flags
    3361/    1202 : 5241                	ADDQ.w	#1,d1					; increment dimensions count
    3362/    1204 : 6100 FC66           	BSR		LAB_GBYT				; scan memory
    3363/    1208 : B03C 002C           	CMP.b		#$2C,d0				; compare with ","
    3364/    120C : 67D6                	BEQ.s		LAB_1E1F				; if found go do next dimension
    3365/    120E :                     
    3366/    120E : 1741 05DB           	MOVE.b	d1,Dimcnt(a3)			; store dimensions count
    3367/    1212 : 6100 FC44           	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
    3368/    1216 : 375F 05B4           	MOVE.w	(sp)+,Defdim(a3)			; restore DIM and data type flags (word in mem)
    3369/    121A : 206B 043E           	MOVEA.l	Sarryl(a3),a0			; get array mem start
    3370/    121E :                     
    3371/    121E :                     ; now check to see if we are at the end of array memory (we would be if there were
    3372/    121E :                     ; no arrays).
    3373/    121E :                     
    3374/    121E :                     LAB_1E5C
    3375/    121E : 2748 05AC           	MOVE.l	a0,Astrtl(a3)			; save as array start pointer
    3376/    1222 : B1EB 0442           	CMPA.l	Earryl(a3),a0			; compare with array mem end
    3377/    1226 : 672E                	BEQ.s		LAB_1EA1				; go build array if not found
    3378/    1228 :                     
    3379/    1228 :                     								; search for array
    3380/    1228 : 2010                	MOVE.l	(a0),d0				; get this array name
    3381/    122A : B0AB 046A           	CMP.l		Varname(a3),d0			; compare with array name
    3382/    122E : 670A                	BEQ.s		LAB_1E8D				; array found so branch
    3383/    1230 :                     
    3384/    1230 :                     								; no match
    3385/    1230 : 2068 0004           	MOVEA.l	4(a0),a0				; get this array size
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 61 - 10/11/2023 16:23:32


    3386/    1234 : D1EB 05AC           	ADDA.l	Astrtl(a3),a0			; add to array start pointer
    3387/    1238 : 60E4                	BRA.s		LAB_1E5C				; go check next array
    3388/    123A :                     
    3389/    123A :                     								; found array, are we trying to dimension it?
    3390/    123A :                     LAB_1E8D
    3391/    123A : 4A2B 05B4           	TST.b		Defdim(a3)				; are we trying to dimension it?
    3392/    123E : 6600 EFC4           	BNE		LAB_DDER				; if so do double dimension error/warm start
    3393/    1242 :                     
    3394/    1242 :                     ; found the array and we're not dimensioning it so we must find an element in it
    3395/    1242 :                     
    3396/    1242 : 6100 FF58           	BSR		LAB_1DE6				; set data pointer, d0, to the first element
    3397/    1246 :                     								; in the array
    3398/    1246 : 5048                	ADDQ.w	#8,a0					; index to dimension count
    3399/    1248 : 3018                	MOVE.w	(a0)+,d0				; get no of dimensions
    3400/    124A : B02B 05DB           	CMP.b		Dimcnt(a3),d0			; compare with dimensions count
    3401/    124E : 6700 0094           	BEQ		LAB_1F28				; found array so go get element
    3402/    1252 :                     
    3403/    1252 : 6000 EF84           	BRA		LAB_WDER				; else wrong so do "Wrong dimensions" error
    3404/    1256 :                     
    3405/    1256 :                     								; array not found, so possibly build it
    3406/    1256 :                     LAB_1EA1
    3407/    1256 : 4A2B 05B4           	TST.b		Defdim(a3)				; test the default DIM flag
    3408/    125A : 6700 EF80           	BEQ		LAB_UDER				; if default flag is clear then we are not
    3409/    125E :                     								; explicitly dimensioning an array so go
    3410/    125E :                     								; do an "Undimensioned array" error
    3411/    125E :                     
    3412/    125E : 6100 FF3C           	BSR		LAB_1DE6				; set data pointer, d0, to the first element
    3413/    1262 :                     								; in the array
    3414/    1262 : 202B 046A           	MOVE.l	Varname(a3),d0			; get array name
    3415/    1266 : 20C0                	MOVE.l	d0,(a0)+				; save array name
    3416/    1268 : 7204                	MOVEQ		#4,d1					; set 4 bytes per element
    3417/    126A : 0800 0017           	BTST.l	#23,d0				; test if string array
    3418/    126E : 6702                	BEQ.s		LAB_1EDF				; branch if not string
    3419/    1270 :                     
    3420/    1270 : 7206                	MOVEQ		#6,d1					; else 6 bytes per element
    3421/    1272 :                     LAB_1EDF
    3422/    1272 : 2741 05A8           	MOVE.l	d1,Asptl(a3)			; set array data size (bytes per element)
    3423/    1276 : 122B 05DB           	MOVE.b	Dimcnt(a3),d1			; get dimensions count
    3424/    127A : 5848                	ADDQ.w	#4,a0					; skip the array size now (don't know it yet!)
    3425/    127C : 30C1                	MOVE.w	d1,(a0)+				; set array's dimensions count
    3426/    127E :                     
    3427/    127E :                     ; now calculate the array data space size
    3428/    127E :                     
    3429/    127E :                     LAB_1EC0
    3430/    127E :                     
    3431/    127E :                     ; If you want arrays to dimension themselves by default then comment out the test
    3432/    127E :                     ; above and uncomment the next three code lines and the label LAB_1ED0
    3433/    127E :                     
    3434/    127E :                     ;	MOVE.w	#$0A,d1				; set default dimension value, allow 0 to 9
    3435/    127E :                     ;	TST.b		Defdim(a3)				; test default DIM flag
    3436/    127E :                     ;	BNE.s		LAB_1ED0				; branch if b6 of Defdim is clear
    3437/    127E :                     
    3438/    127E : 321F                	MOVE.w	(sp)+,d1				; get dimension size
    3439/    1280 :                     ;LAB_1ED0
    3440/    1280 : 30C1                	MOVE.w	d1,(a0)+				; save to array header
    3441/    1282 : 6100 00AE           	BSR		LAB_1F7C				; do this dimension size+1	; array size
    3442/    1286 :                     								; (d1+1)*(Asptl), result in d0
    3443/    1286 : 2740 05A8           	MOVE.l	d0,Asptl(a3)			; save array data size
    3444/    128A : 532B 05DB           	SUBQ.b	#1,Dimcnt(a3)			; decrement dimensions count
    3445/    128E : 66EE                	BNE.s		LAB_1EC0				; loop while not = 0
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 62 - 10/11/2023 16:23:32


    3446/    1290 :                     
    3447/    1290 : D1EB 05A8           	ADDA.l	Asptl(a3),a0			; add size to first element address
    3448/    1294 : 6500 EF7A           	BCS		LAB_OMER				; if overflow go do "Out of memory" error
    3449/    1298 :                     
    3450/    1298 : B1EB 0446           	CMPA.l	Sstorl(a3),a0			; compare with bottom of string memory
    3451/    129C : 650C                	BCS.s		LAB_1ED6				; branch if less (is ok)
    3452/    129E :                     
    3453/    129E : 6100 028E           	BSR		LAB_GARB				; do garbage collection routine
    3454/    12A2 : B1EB 0446           	CMPA.l	Sstorl(a3),a0			; compare with bottom of string memory
    3455/    12A6 : 6400 EF68           	BCC		LAB_OMER				; if Sstorl <= a0 do "Out of memory"
    3456/    12AA :                     								; error then warm start
    3457/    12AA :                     
    3458/    12AA :                     LAB_1ED6							; ok exit, carry set
    3459/    12AA : 2748 0442           	MOVE.l	a0,Earryl(a3)			; save array mem end
    3460/    12AE : 7000                	MOVEQ		#0,d0					; zero d0
    3461/    12B0 : 222B 05A8           	MOVE.l	Asptl(a3),d1			; get size in bytes
    3462/    12B4 : E289                	LSR.l		#1,d1					; /2 for word fill (may be odd # words)
    3463/    12B6 : 5341                	SUBQ.w	#1,d1					; adjust for DBF loop
    3464/    12B8 :                     LAB_1ED8
    3465/    12B8 : 3100                	MOVE.w	d0,-(a0)				; decrement pointer and clear word
    3466/    12BA : 51C9 FFFC           	DBF		d1,LAB_1ED8				; decrement & loop until low word done
    3467/    12BE :                     
    3468/    12BE : 4841                	SWAP		d1					; swap words
    3469/    12C0 : 4A41                	TST.w		d1					; test high word
    3470/    12C2 : 6706                	BEQ.s		LAB_1F07				; exit if done
    3471/    12C4 :                     
    3472/    12C4 : 5341                	SUBQ.w	#1,d1					; decrement low (high) word
    3473/    12C6 : 4841                	SWAP		d1					; swap back
    3474/    12C8 : 60EE                	BRA.s		LAB_1ED8				; go do a whole block
    3475/    12CA :                     
    3476/    12CA :                     ; now we need to calculate the array size by doing Earryl - Astrtl
    3477/    12CA :                     
    3478/    12CA :                     LAB_1F07
    3479/    12CA : 206B 05AC           	MOVEA.l	Astrtl(a3),a0			; get for calculation and as pointer
    3480/    12CE : 202B 0442           	MOVE.l	Earryl(a3),d0			; get array memory end
    3481/    12D2 : 9088                	SUB.l		a0,d0					; calculate array size
    3482/    12D4 : 2140 0004           	MOVE.l	d0,4(a0)				; save size to array
    3483/    12D8 : 4A2B 05B4           	TST.b		Defdim(a3)				; test default DIM flag
    3484/    12DC : 6652                	BNE.s		RTS_011				; exit (RET) if this was a DIM command
    3485/    12DE :                     
    3486/    12DE :                     								; else, find element
    3487/    12DE : 5048                	ADDQ.w	#8,a0					; index to dimension count
    3488/    12E0 : 3758 05DB           	MOVE.w	(a0)+,Dimcnt(a3)			; get array's dimension count
    3489/    12E4 :                     
    3490/    12E4 :                     ; we have found, or built, the array. now we need to find the element
    3491/    12E4 :                     
    3492/    12E4 :                     LAB_1F28
    3493/    12E4 : 7000                	MOVEQ		#0,d0					; clear first result
    3494/    12E6 : 2740 05A8           	MOVE.l	d0,Asptl(a3)			; clear array data pointer
    3495/    12EA :                     
    3496/    12EA :                     ; compare nth dimension bound (a0) with nth index (sp)+
    3497/    12EA :                     ; if greater do array bounds error
    3498/    12EA :                     
    3499/    12EA :                     LAB_1F2C
    3500/    12EA : 3218                	MOVE.w	(a0)+,d1				; get nth dimension bound
    3501/    12EC : B257                	CMP.w		(sp),d1				; compare nth index with nth dimension bound
    3502/    12EE : 6500 EF18           	BCS		LAB_ABER				; if d1 less or = do array bounds error
    3503/    12F2 :                     
    3504/    12F2 :                     ; now do pointer = pointer	; nth dimension + nth index
    3505/    12F2 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 63 - 10/11/2023 16:23:32


    3506/    12F2 : 4A80                	TST.l		d0					; test pointer
    3507/    12F4 : 6702                	BEQ.s		LAB_1F5A				; skip multiply if last result = null
    3508/    12F6 :                     
    3509/    12F6 : 613A                	BSR.s		LAB_1F7C				; do this dimension size+1	; array size
    3510/    12F8 :                     LAB_1F5A
    3511/    12F8 : 7200                	MOVEQ		#0,d1					; clear longword
    3512/    12FA : 321F                	MOVE.w	(sp)+,d1				; get nth dimension index
    3513/    12FC : D081                	ADD.l		d1,d0					; add index to size
    3514/    12FE : 2740 05A8           	MOVE.l	d0,Asptl(a3)			; save array data pointer
    3515/    1302 :                     
    3516/    1302 : 532B 05DB           	SUBQ.b	#1,Dimcnt(a3)			; decrement dimensions count
    3517/    1306 : 66E2                	BNE.s		LAB_1F2C				; loop if dimensions still to do
    3518/    1308 :                     
    3519/    1308 : 177C 0000 05B5      	MOVE.b	#0,Dtypef(a3)			; set data type to float
    3520/    130E : 7203                	MOVEQ		#3,d1					; set for numeric array
    3521/    1310 : 4A2B 046B           	TST.b		Varname+1(a3)			; test if string array
    3522/    1314 : 6A0A                	BPL.s		LAB_1F6A				; branch if not string
    3523/    1316 :                     
    3524/    1316 : 7205                	MOVEQ		#5,d1					; else set for string array
    3525/    1318 : 177C 0080 05B5      	MOVE.b	#$80,Dtypef(a3)			; and set data type to string
    3526/    131E : 600C                	BRA.s		LAB_1F6B				; skip integer test
    3527/    1320 :                     
    3528/    1320 :                     LAB_1F6A
    3529/    1320 : 4A2B 046C           	TST.b		Varname+2(a3)			; test if integer array
    3530/    1324 : 6A06                	BPL.s		LAB_1F6B				; branch if not integer
    3531/    1326 :                     
    3532/    1326 : 177C 0040 05B5      	MOVE.b	#$40,Dtypef(a3)			; else set data type to integer
    3533/    132C :                     LAB_1F6B
    3534/    132C : 6104                	BSR.s		LAB_1F7C				; do element size (d1)	; array size (Asptl)
    3535/    132E : D1C0                	ADDA.l	d0,a0					; add array data start pointer
    3536/    1330 :                     RTS_011
    3537/    1330 : 4E75                	RTS
    3538/    1332 :                     
    3539/    1332 :                     
    3540/    1332 :                     ;************************************************************************************
    3541/    1332 :                     ;
    3542/    1332 :                     ; do this dimension size (d1)	; array data size (Asptl)
    3543/    1332 :                     
    3544/    1332 :                     ; do a 16 x 32 bit multiply
    3545/    1332 :                     ; d1 holds the 16 bit multiplier
    3546/    1332 :                     ; Asptl holds the 32 bit multiplicand
    3547/    1332 :                     
    3548/    1332 :                     ; d0	bbbb  bbbb
    3549/    1332 :                     ; d1	0000  aaaa
    3550/    1332 :                     ;	----------
    3551/    1332 :                     ; d0	rrrr  rrrr
    3552/    1332 :                     
    3553/    1332 :                     LAB_1F7C
    3554/    1332 : 202B 05A8           	MOVE.l	Asptl(a3),d0			; get result
    3555/    1336 : 2400                	MOVE.l	d0,d2					; copy it
    3556/    1338 : 4842                	SWAP		d2					; shift high word to low word
    3557/    133A : C0C1                	MULU.w	d1,d0					; d1	; low word = low result
    3558/    133C : C4C1                	MULU.w	d1,d2					; d1	; high word = high result
    3559/    133E : 4842                	SWAP		d2					; align words for test
    3560/    1340 : 4A42                	TST.w		d2					; must be zero
    3561/    1342 : 6600 EECC           	BNE		LAB_OMER				; if overflow go do "Out of memory" error
    3562/    1346 :                     
    3563/    1346 : D082                	ADD.l		d2,d0					; calculate result
    3564/    1348 : 6500 EEC6           	BCS		LAB_OMER				; if overflow go do "Out of memory" error
    3565/    134C :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 64 - 10/11/2023 16:23:32


    3566/    134C : D0AB 05A8           	ADD.l		Asptl(a3),d0			; add original
    3567/    1350 : 6500 EEBE           	BCS		LAB_OMER				; if overflow go do "Out of memory" error
    3568/    1354 :                     
    3569/    1354 : 4E75                	RTS
    3570/    1356 :                     
    3571/    1356 :                     
    3572/    1356 :                     ;************************************************************************************
    3573/    1356 :                     ;
    3574/    1356 :                     ; perform FRE()
    3575/    1356 :                     
    3576/    1356 :                     LAB_FRE
    3577/    1356 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type, $80=string, $40=integer,
    3578/    135A :                     								; $00=float
    3579/    135A : 6A04                	BPL.s		LAB_1FB4				; branch if numeric
    3580/    135C :                     
    3581/    135C : 6100 0318           	BSR		LAB_22B6				; pop string off descriptor stack, or from
    3582/    1360 :                     								; top of string space, returns d0 = length,
    3583/    1360 :                     								; a0 = pointer
    3584/    1360 :                     
    3585/    1360 :                     								; FRE(n) was numeric so do this
    3586/    1360 :                     LAB_1FB4
    3587/    1360 : 6100 01CC           	BSR		LAB_GARB				; go do garbage collection
    3588/    1364 : 202B 0446           	MOVE.l	Sstorl(a3),d0			; get bottom of string space
    3589/    1368 : 90AB 0442           	SUB.l		Earryl(a3),d0			; subtract array mem end
    3590/    136C :                     
    3591/    136C :                     
    3592/    136C :                     ;************************************************************************************
    3593/    136C :                     ;
    3594/    136C :                     ; convert d0 to signed longword in FAC1
    3595/    136C :                     
    3596/    136C :                     LAB_AYFC
    3597/    136C : 177C 0000 05B5      	MOVE.b	#$00,Dtypef(a3)			; clear data type, $80=string, $40=integer,
    3598/    1372 :                     								; $00=float
    3599/    1372 : 377C A000 0594      	MOVE.w	#$A000,FAC1_e(a3)			; set FAC1 exponent and clear sign (b7)
    3600/    1378 : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; save FAC1 mantissa
    3601/    137C : 6A00 0640           	BPL		LAB_24D0				; convert if +ve
    3602/    1380 :                     
    3603/    1380 : 003C 0001           	ORI.b		#1,CCR				; else set carry
    3604/    1384 : 6000 0638           	BRA		LAB_24D0				; do +/- (carry is sign) & normalise FAC1
    3605/    1388 :                     
    3606/    1388 :                     
    3607/    1388 :                     ;************************************************************************************
    3608/    1388 :                     ;
    3609/    1388 :                     ; remember if the line length is zero (infinite line) then POS(n) will return
    3610/    1388 :                     ; position MOD tabsize
    3611/    1388 :                     
    3612/    1388 :                     ; perform POS()
    3613/    1388 :                     
    3614/    1388 :                     LAB_POS
    3615/    1388 : 102B 05E5           	MOVE.b	TPos(a3),d0				; get terminal position
    3616/    138C :                     
    3617/    138C :                     ; convert d0 to unsigned byte in FAC1
    3618/    138C :                     
    3619/    138C :                     LAB_1FD0
    3620/    138C : C0BC 0000 00FF      	AND.l		#$FF,d0				; clear high bits
    3621/    1392 : 60D8                	BRA.s		LAB_AYFC				; convert d0 to signed longword in FAC1 & RET
    3622/    1394 :                     
    3623/    1394 :                     ; check not direct (used by DEF and INPUT)
    3624/    1394 :                     
    3625/    1394 :                     LAB_CKRN
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 65 - 10/11/2023 16:23:32


    3626/    1394 : 4A2B 0452           	TST.b		Clinel(a3)				; test current line #
    3627/    1398 : 6B00 EE62           	BMI		LAB_IDER				; if -ve go do illegal direct error then warm
    3628/    139C :                     								; start
    3629/    139C :                     
    3630/    139C : 4E75                	RTS							; can continue so return
    3631/    139E :                     
    3632/    139E :                     
    3633/    139E :                     ;************************************************************************************
    3634/    139E :                     ;
    3635/    139E :                     ; perform DEF
    3636/    139E :                     
    3637/    139E :                     LAB_DEF
    3638/    139E : 70AB                	MOVEQ		#TK_FN-$100,d0			; get FN token
    3639/    13A0 : 6100 FAC0           	BSR		LAB_SCCA				; scan for CHR$(d0), else syntax error and
    3640/    13A4 :                     								; warm start
    3641/    13A4 :                     								; return character after d0
    3642/    13A4 : 177C 0080 05DF      	MOVE.b	#$80,Sufnxf(a3)			; set FN flag bit
    3643/    13AA : 6100 FCDA           	BSR		LAB_1D12				; get FN name
    3644/    13AE : 2748 05B0           	MOVE.l	a0,func_l(a3)			; save function pointer
    3645/    13B2 :                     
    3646/    13B2 : 61E0                	BSR.s		LAB_CKRN				; check not direct (back here if ok)
    3647/    13B4 : 0C1D 0028           	CMP.b		#$28,(a5)+				; check next byte is "(" and increment
    3648/    13B8 : 6600 EE6A           	BNE		LAB_SNER				; else do syntax error/warm start
    3649/    13BC :                     
    3650/    13BC : 177C 007E 05DF      	MOVE.b	#$7E,Sufnxf(a3)			; set FN variable flag bits
    3651/    13C2 : 6100 FCB4           	BSR		LAB_SVAR				; search for or create a variable
    3652/    13C6 :                     								; return the variable address in a0
    3653/    13C6 : 6100 FA90           	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
    3654/    13CA : 70BD                	MOVEQ		#TK_EQUAL-$100,d0			; = token
    3655/    13CC : 6100 FA94           	BSR		LAB_SCCA				; scan for CHR$(A), else syntax error/warm start
    3656/    13D0 :                     								; return character after d0
    3657/    13D0 : 2F2B 046A           	MOVE.l	Varname(a3),-(sp)			; push current variable name
    3658/    13D4 : 2F0D                	MOVE.l	a5,-(sp)				; push BASIC execute pointer
    3659/    13D6 : 6100 F412           	BSR		LAB_DATA				; go perform DATA, find end of DEF FN statement
    3660/    13DA : 206B 05B0           	MOVEA.l	func_l(a3),a0			; get the function pointer
    3661/    13DE : 209F                	MOVE.l	(sp)+,(a0)				; save BASIC execute pointer to function
    3662/    13E0 : 215F 0004           	MOVE.l	(sp)+,4(a0)				; save current variable name to function
    3663/    13E4 : 4E75                	RTS
    3664/    13E6 :                     
    3665/    13E6 :                     
    3666/    13E6 :                     ;************************************************************************************
    3667/    13E6 :                     ;
    3668/    13E6 :                     ; evaluate FNx
    3669/    13E6 :                     
    3670/    13E6 :                     LAB_201E
    3671/    13E6 : 177C 0081 05DF      	MOVE.b	#$81,Sufnxf(a3)			; set FN flag (find not create)
    3672/    13EC : 6100 FA7C           	BSR		LAB_IGBY				; increment & scan memory
    3673/    13F0 : 6100 FC94           	BSR		LAB_1D12				; get FN name
    3674/    13F4 : 1F2B 05B5           	MOVE.b	Dtypef(a3),-(sp)			; push data type flag (function type)
    3675/    13F8 : 2F08                	MOVE.l	a0,-(sp)				; push function pointer
    3676/    13FA : 0C15 0028           	CMP.b		#$28,(a5)				; check next byte is "(", no increment
    3677/    13FE : 6600 EE24           	BNE		LAB_SNER				; else do syntax error/warm start
    3678/    1402 :                     
    3679/    1402 : 6100 FA50           	BSR		LAB_1BF7				; evaluate expression within parentheses
    3680/    1406 : 205F                	MOVEA.l	(sp)+,a0				; pop function pointer
    3681/    1408 : 2748 05B0           	MOVE.l	a0,func_l(a3)			; set function pointer
    3682/    140C : 1F2B 05B5           	MOVE.b	Dtypef(a3),-(sp)			; push data type flag (function expression type)
    3683/    1410 :                     
    3684/    1410 : 2028 0004           	MOVE.l	4(a0),d0				; get function variable name
    3685/    1414 : 6100 FCDA           	BSR		LAB_1D4A				; go find function variable (already created)
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 66 - 10/11/2023 16:23:32


    3686/    1418 :                     
    3687/    1418 :                     								; now check type match for variable
    3688/    1418 : 101F                	MOVE.b	(sp)+,d0				; pop data type flag (function expression type)
    3689/    141A : E318                	ROL.b		#1,d0					; set carry if type = string
    3690/    141C : 6100 F8D8           	BSR		LAB_CKTM				; type match check, set C for string
    3691/    1420 :                     
    3692/    1420 :                     								; now stack the function variable value before
    3693/    1420 :                     								; use
    3694/    1420 : 6712                	BEQ.s		LAB_2043				; branch if not string
    3695/    1422 :                     
    3696/    1422 : 43EB 0476           	LEA		des_sk_e(a3),a1			; get string stack pointer max+1
    3697/    1426 : B9C9                	CMPA.l	a1,a4					; compare string stack pointer with max+1
    3698/    1428 : 6700 EDC6           	BEQ		LAB_SCER				; if no space on the stack go do string too
    3699/    142C :                     								; complex error
    3700/    142C :                     
    3701/    142C : 3928 0004           	MOVE.w	4(a0),-(a4)				; string length on descriptor stack
    3702/    1430 : 2910                	MOVE.l	(a0),-(a4)				; string address on stack
    3703/    1432 : 6002                	BRA.s		LAB_204S				; skip var push
    3704/    1434 :                     
    3705/    1434 :                     LAB_2043
    3706/    1434 : 2F10                	MOVE.l	(a0),-(sp)				; push variable
    3707/    1436 :                     LAB_204S
    3708/    1436 : 2F08                	MOVE.l	a0,-(sp)				; push variable address
    3709/    1438 : 1F2B 05B5           	MOVE.b	Dtypef(a3),-(sp)			; push variable data type
    3710/    143C :                     
    3711/    143C : 6132                	BSR.s		LAB_2045				; pack function expression value into (a0)
    3712/    143E :                     								; (function variable)
    3713/    143E : 2F0D                	MOVE.l	a5,-(sp)				; push BASIC execute pointer
    3714/    1440 : 206B 05B0           	MOVEA.l	func_l(a3),a0			; get function pointer
    3715/    1444 : 2A50                	MOVEA.l	(a0),a5				; save function execute ptr as BASIC execute ptr
    3716/    1446 : 6100 F8C2           	BSR		LAB_EVEX				; evaluate expression
    3717/    144A : 6100 FA20           	BSR		LAB_GBYT				; scan memory
    3718/    144E : 6600 EDD4           	BNE		LAB_SNER				; if not [EOL] or [EOS] do syntax error and
    3719/    1452 :                     								; warm start
    3720/    1452 :                     
    3721/    1452 : 2A5F                	MOVE.l	(sp)+,a5				; restore BASIC execute pointer
    3722/    1454 :                     
    3723/    1454 :                     ; restore variable from stack and test data type
    3724/    1454 :                     
    3725/    1454 : 101F                	MOVE.b	(sp)+,d0				; pull variable data type
    3726/    1456 : 205F                	MOVEA.l	(sp)+,a0				; pull variable address
    3727/    1458 : 4A00                	TST.b		d0					; test variable data type
    3728/    145A : 6A08                	BPL.s		LAB_204T				; branch if not string
    3729/    145C :                     
    3730/    145C : 209C                	MOVE.l	(a4)+,(a0)				; string address from descriptor stack
    3731/    145E : 315C 0004           	MOVE.w	(a4)+,4(a0)				; string length from descriptor stack
    3732/    1462 : 6002                	BRA.s		LAB_2044				; skip variable pull
    3733/    1464 :                     
    3734/    1464 :                     LAB_204T
    3735/    1464 : 209F                	MOVE.l	(sp)+,(a0)				; restore variable from stack
    3736/    1466 :                     LAB_2044
    3737/    1466 : 101F                	MOVE.b	(sp)+,d0				; pop data type flag (function type)
    3738/    1468 : E318                	ROL.b		#1,d0					; set carry if type = string
    3739/    146A : 6100 F88A           	BSR		LAB_CKTM				; type match check, set C for string
    3740/    146E : 4E75                	RTS
    3741/    1470 :                     
    3742/    1470 :                     LAB_2045
    3743/    1470 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type
    3744/    1474 : 6A00 07F0           	BPL		LAB_2778				; if numeric pack FAC1 into variable (a0)
    3745/    1478 :                     								; and return
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 67 - 10/11/2023 16:23:32


    3746/    1478 :                     
    3747/    1478 : 2448                	MOVEA.l	a0,a2					; copy variable pointer
    3748/    147A : 6000 F512           	BRA		LAB_17D6				; go do string LET & return
    3749/    147E :                     
    3750/    147E :                     
    3751/    147E :                     
    3752/    147E :                     ;************************************************************************************
    3753/    147E :                     ;
    3754/    147E :                     ; perform STR$()
    3755/    147E :                     
    3756/    147E :                     LAB_STRS
    3757/    147E : 6100 0950           	BSR		LAB_2970				; convert FAC1 to string
    3758/    1482 :                     
    3759/    1482 :                     ; scan, set up string
    3760/    1482 :                     ; print " terminated string to FAC1 stack
    3761/    1482 :                     
    3762/    1482 :                     LAB_20AE
    3763/    1482 : 7422                	MOVEQ		#$22,d2				; set Srchc character (terminator 1)
    3764/    1484 : 3602                	MOVE.w	d2,d3					; set Asrch character (terminator 2)
    3765/    1486 :                     
    3766/    1486 :                     ; print d2/d3 terminated string to FAC1 stack
    3767/    1486 :                     ; d2 = Srchc, d3 = Asrch, a0 is source
    3768/    1486 :                     ; a6 is temp
    3769/    1486 :                     
    3770/    1486 :                     LAB_20B4
    3771/    1486 : 7200                	MOVEQ		#0,d1					; clear longword
    3772/    1488 : 5341                	SUBQ.w	#1,d1					; set length to -1
    3773/    148A : 2448                	MOVEA.l	a0,a2					; copy start to calculate end
    3774/    148C :                     LAB_20BE
    3775/    148C : 5241                	ADDQ.w	#1,d1					; increment length
    3776/    148E : 1030 1000           	MOVE.b	(a0,d1.w),d0			; get byte from string
    3777/    1492 : 6710                	BEQ.s		LAB_20D0				; exit loop if null byte [EOS]
    3778/    1494 :                     
    3779/    1494 : B002                	CMP.b		d2,d0					; compare with search character (terminator 1)
    3780/    1496 : 6704                	BEQ.s		LAB_20CB				; branch if terminator
    3781/    1498 :                     
    3782/    1498 : B003                	CMP.b		d3,d0					; compare with terminator 2
    3783/    149A : 66F0                	BNE.s		LAB_20BE				; loop if not terminator 2 (or null string)
    3784/    149C :                     
    3785/    149C :                     LAB_20CB
    3786/    149C : B03C 0022           	CMP.b		#$22,d0				; compare with "
    3787/    14A0 : 6602                	BNE.s		LAB_20D0				; branch if not "
    3788/    14A2 :                     
    3789/    14A2 : 524A                	ADDQ.w	#1,a2					; else increment string start (skip " at end)
    3790/    14A4 :                     LAB_20D0
    3791/    14A4 : D5C1                	ADDA.l	d1,a2					; add longowrd length to make string end+1
    3792/    14A6 :                     
    3793/    14A6 : B1CB                	CMPA.l	a3,a0					; is string in ram
    3794/    14A8 : 651E                	BCS.s		LAB_RTST				; if not go push descriptor on stack & exit
    3795/    14AA :                     								; (could be message string from ROM)
    3796/    14AA :                     
    3797/    14AA : B1EB 042E           	CMPA.l	Smeml(a3),a0			; is string in utility ram
    3798/    14AE : 6418                	BCC.s		LAB_RTST				; if not go push descriptor on stack & exit
    3799/    14B0 :                     								; (is in string or program space)
    3800/    14B0 :                     
    3801/    14B0 :                     								; (else) copy string to string memory
    3802/    14B0 :                     LAB_20C9
    3803/    14B0 : 2248                	MOVEA.l	a0,a1					; copy descriptor pointer
    3804/    14B2 : 2001                	MOVE.l	d1,d0					; copy longword length
    3805/    14B4 : 6604                	BNE.s		LAB_20D8				; branch if not null string
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 68 - 10/11/2023 16:23:32


    3806/    14B6 :                     
    3807/    14B6 : 2041                	MOVEA.l	d1,a0					; make null pointer
    3808/    14B8 : 600E                	BRA.s		LAB_RTST				; go push descriptor on stack & exit
    3809/    14BA :                     
    3810/    14BA :                     LAB_20D8
    3811/    14BA : 6126                	BSR.s		LAB_2115				; make string space d1 bytes long
    3812/    14BC : D1C1                	ADDA.l	d1,a0					; new string end
    3813/    14BE : D3C1                	ADDA.l	d1,a1					; old string end
    3814/    14C0 : 5340                	SUBQ.w	#1,d0					; -1 for DBF loop
    3815/    14C2 :                     LAB_20E0
    3816/    14C2 : 1121                	MOVE.b	-(a1),-(a0)				; copy byte (source can be odd aligned)
    3817/    14C4 : 51C8 FFFC           	DBF		d0,LAB_20E0				; loop until done
    3818/    14C8 :                     
    3819/    14C8 :                     
    3820/    14C8 :                     
    3821/    14C8 :                     ;************************************************************************************
    3822/    14C8 :                     ;
    3823/    14C8 :                     ; check for space on descriptor stack then ...
    3824/    14C8 :                     ; put string address and length on descriptor stack & update stack pointers
    3825/    14C8 :                     ; start is in a0, length is in d1
    3826/    14C8 :                     
    3827/    14C8 :                     LAB_RTST
    3828/    14C8 : 43EB 0476           	LEA		des_sk_e(a3),a1			; get string stack pointer max+1
    3829/    14CC : B9C9                	CMPA.l	a1,a4					; compare string stack pointer with max+1
    3830/    14CE : 6700 ED20           	BEQ		LAB_SCER				; if no space on string stack ..
    3831/    14D2 :                     								; .. go do 'string too complex' error
    3832/    14D2 :                     
    3833/    14D2 :                     								; push string & update pointers
    3834/    14D2 : 3901                	MOVE.w	d1,-(a4)				; string length on descriptor stack
    3835/    14D4 : 2908                	MOVE.l	a0,-(a4)				; string address on stack
    3836/    14D6 : 274C 0590           	MOVE.l	a4,FAC1_m(a3)			; string descriptor pointer in FAC1
    3837/    14DA : 177C 0080 05B5      	MOVE.b	#$80,Dtypef(a3)			; save data type flag, $80=string
    3838/    14E0 : 4E75                	RTS
    3839/    14E2 :                     
    3840/    14E2 :                     
    3841/    14E2 :                     ;************************************************************************************
    3842/    14E2 :                     ;
    3843/    14E2 :                     ; build descriptor a0/d1
    3844/    14E2 :                     ; make space in string memory for string d1.w long
    3845/    14E2 :                     ; return pointer in a0/Sutill
    3846/    14E2 :                     
    3847/    14E2 :                     LAB_2115
    3848/    14E2 : 4A41                	TST.w		d1					; test length
    3849/    14E4 : 672E                	BEQ.s		LAB_2128				; branch if user wants null string
    3850/    14E6 :                     
    3851/    14E6 :                     								; make space for string d1 long
    3852/    14E6 : 2F00                	MOVE.l	d0,-(sp)				; save d0
    3853/    14E8 : 7000                	MOVEQ		#0,d0					; clear longword
    3854/    14EA : 1740 05DE           	MOVE.b	d0,Gclctd(a3)			; clear garbage collected flag (b7)
    3855/    14EE : 7001                	MOVEQ		#1,d0					; +1 to possibly round up
    3856/    14F0 : C041                	AND.w		d1,d0					; mask odd bit
    3857/    14F2 : D041                	ADD.w		d1,d0					; ensure d0 is even length
    3858/    14F4 : 6404                	BCC.s		LAB_2117				; branch if no overflow
    3859/    14F6 :                     
    3860/    14F6 : 7001                	MOVEQ		#1,d0					; set to allocate 65536 bytes
    3861/    14F8 : 4840                	SWAP		d0					; makes $00010000
    3862/    14FA :                     LAB_2117
    3863/    14FA : 206B 0446           	MOVEA.l	Sstorl(a3),a0			; get bottom of string space
    3864/    14FE : 91C0                	SUBA.l	d0,a0					; subtract string length
    3865/    1500 : B1EB 0442           	CMPA.l	Earryl(a3),a0			; compare with top of array space
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 69 - 10/11/2023 16:23:32


    3866/    1504 : 6512                	BCS.s		LAB_2137				; if less do out of memory error
    3867/    1506 :                     
    3868/    1506 : 2748 0446           	MOVE.l	a0,Sstorl(a3)			; save bottom of string space
    3869/    150A : 2748 044E           	MOVE.l	a0,Sutill(a3)			; save string utility pointer
    3870/    150E : 201F                	MOVE.l	(sp)+,d0				; restore d0
    3871/    1510 : 4A41                	TST.w		d1					; set flags on length
    3872/    1512 : 4E75                	RTS
    3873/    1514 :                     
    3874/    1514 :                     LAB_2128
    3875/    1514 : 3041                	MOVEA.w	d1,a0					; make null pointer
    3876/    1516 : 4E75                	RTS
    3877/    1518 :                     
    3878/    1518 :                     LAB_2137
    3879/    1518 : 4A2B 05DE           	TST.b		Gclctd(a3)				; get garbage collected flag
    3880/    151C : 6B00 ECF2           	BMI		LAB_OMER				; do "Out of memory" error, then warm start
    3881/    1520 :                     
    3882/    1520 : 2F09                	MOVE.l	a1,-(sp)				; save a1
    3883/    1522 : 610A                	BSR.s		LAB_GARB				; else go do garbage collection
    3884/    1524 : 225F                	MOVEA.l	(sp)+,a1				; restore a1
    3885/    1526 : 177C 0080 05DE      	MOVE.b	#$80,Gclctd(a3)			; set garbage collected flag
    3886/    152C : 60CC                	BRA.s		LAB_2117				; go try again
    3887/    152E :                     
    3888/    152E :                     
    3889/    152E :                     ;************************************************************************************
    3890/    152E :                     ;
    3891/    152E :                     ; garbage collection routine
    3892/    152E :                     
    3893/    152E :                     LAB_GARB
    3894/    152E : 48E7 E0E0           	MOVEM.l	d0-d2/a0-a2,-(sp)			; save registers
    3895/    1532 : 276B 044A 0446      	MOVE.l	Ememl(a3),Sstorl(a3)		; start with no strings
    3896/    1538 :                     
    3897/    1538 :                     								; re-run routine from last ending
    3898/    1538 :                     LAB_214B
    3899/    1538 : 222B 0442           	MOVE.l	Earryl(a3),d1			; set highest uncollected string so far
    3900/    153C : 7000                	MOVEQ		#0,d0					; clear longword
    3901/    153E : 2240                	MOVEA.l	d0,a1					; clear string to move pointer
    3902/    1540 : 206B 043A           	MOVEA.l	Sstrl(a3),a0			; set pointer to start of strings
    3903/    1544 : 41E8 0004           	LEA		4(a0),a0				; index to string pointer
    3904/    1548 : 246B 043E           	MOVEA.l	Sarryl(a3),a2			; set end pointer to start of arrays (end of
    3905/    154C :                     								; strings)
    3906/    154C : 6008                	BRA.s		LAB_2176				; branch into loop at end loop test
    3907/    154E :                     
    3908/    154E :                     LAB_2161
    3909/    154E : 6100 0084           	BSR		LAB_2206				; test and set if this is the highest string
    3910/    1552 : 41E8 000A           	LEA		10(a0),a0				; increment to next string
    3911/    1556 :                     LAB_2176
    3912/    1556 : B1CA                	CMPA.l	a2,a0					; compare end of area with pointer
    3913/    1558 : 65F4                	BCS.s		LAB_2161				; go do next if not at end
    3914/    155A :                     
    3915/    155A :                     ; done strings, now do arrays.
    3916/    155A :                     
    3917/    155A : 41E8 FFFC           	LEA		-4(a0),a0				; decrement pointer to start of arrays
    3918/    155E : 246B 0442           	MOVEA.l	Earryl(a3),a2			; set end pointer to end of arrays
    3919/    1562 : 6024                	BRA.s		LAB_218F				; branch into loop at end loop test
    3920/    1564 :                     
    3921/    1564 :                     LAB_217E
    3922/    1564 : 2428 0004           	MOVE.l	4(a0),d2				; get array size
    3923/    1568 : D488                	ADD.l		a0,d2					; makes start of next array
    3924/    156A :                     
    3925/    156A : 2010                	MOVE.l	(a0),d0				; get array name
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 70 - 10/11/2023 16:23:32


    3926/    156C : 0800 0017           	BTST		#23,d0				; test string flag
    3927/    1570 : 6714                	BEQ.s		LAB_218B				; branch if not string
    3928/    1572 :                     
    3929/    1572 : 3028 0008           	MOVE.w	8(a0),d0				; get # of dimensions
    3930/    1576 : D040                	ADD.w		d0,d0					; *2
    3931/    1578 : D0C0                	ADDA.w	d0,a0					; add to skip dimension size(s)
    3932/    157A : 41E8 000A           	LEA		10(a0),a0				; increment to first element
    3933/    157E :                     LAB_2183
    3934/    157E : 6154                	BSR.s		LAB_2206				; test and set if this is the highest string
    3935/    1580 : 5C48                	ADDQ.w	#6,a0					; increment to next element
    3936/    1582 : B1C2                	CMPA.l	d2,a0					; compare with start of next array
    3937/    1584 : 66F8                	BNE.s		LAB_2183				; go do next if not at end of array
    3938/    1586 :                     
    3939/    1586 :                     LAB_218B
    3940/    1586 : 2042                	MOVEA.l	d2,a0					; pointer to next array
    3941/    1588 :                     LAB_218F
    3942/    1588 : B5C8                	CMPA.l	a0,a2					; compare pointer with array end
    3943/    158A : 66D8                	BNE.s		LAB_217E				; go do next if not at end
    3944/    158C :                     
    3945/    158C :                     ; done arrays and variables, now just the descriptor stack to do
    3946/    158C :                     
    3947/    158C : 204C                	MOVEA.l	a4,a0					; get descriptor stack pointer
    3948/    158E : 45EB 048E           	LEA		des_sk(a3),a2			; set end pointer to end of stack
    3949/    1592 : 6006                	BRA.s		LAB_21C4				; branch into loop at end loop test
    3950/    1594 :                     
    3951/    1594 :                     LAB_21C2
    3952/    1594 : 613E                	BSR.s		LAB_2206				; test and set if this is the highest string
    3953/    1596 : 41E8 0006           	LEA		6(a0),a0				; increment to next string
    3954/    159A :                     LAB_21C4
    3955/    159A : B5C8                	CMPA.l	a0,a2					; compare pointer with stack end
    3956/    159C : 66F6                	BNE.s		LAB_21C2				; go do next if not at end
    3957/    159E :                     
    3958/    159E :                     ; descriptor search complete, now either exit or set-up and move string
    3959/    159E :                     
    3960/    159E : 2009                	MOVE.l	a1,d0					; set the flags (a1 is move string)
    3961/    15A0 : 672C                	BEQ.s		LAB_21D1				; go tidy up and exit if no move
    3962/    15A2 :                     
    3963/    15A2 : 2051                	MOVEA.l	(a1),a0				; a0 is now string start
    3964/    15A4 : 7200                	MOVEQ		#0,d1					; clear d1
    3965/    15A6 : 3229 0004           	MOVE.w	4(a1),d1				; d1 is string length
    3966/    15AA : 5281                	ADDQ.l	#1,d1					; +1
    3967/    15AC : C23C 00FE           	AND.b		#$FE,d1				; make even length
    3968/    15B0 : D1C1                	ADDA.l	d1,a0					; pointer is now to string end+1
    3969/    15B2 : 246B 0446           	MOVEA.l	Sstorl(a3),a2			; is destination end+1
    3970/    15B6 : B1CA                	CMPA.l	a2,a0					; does the string need moving
    3971/    15B8 : 670C                	BEQ.s		LAB_2240				; branch if not
    3972/    15BA :                     
    3973/    15BA : E289                	LSR.l		#1,d1					; word move so do /2
    3974/    15BC : 5341                	SUBQ.w	#1,d1					; -1 for DBF loop
    3975/    15BE :                     LAB_2216
    3976/    15BE : 3520                	MOVE.w	-(a0),-(a2)				; copy word
    3977/    15C0 : 51C9 FFFC           	DBF		d1,LAB_2216				; loop until done
    3978/    15C4 :                     
    3979/    15C4 : 228A                	MOVE.l	a2,(a1)				; save new string start
    3980/    15C6 :                     LAB_2240
    3981/    15C6 : 2751 0446           	MOVE.l	(a1),Sstorl(a3)			; string start is new string mem start
    3982/    15CA : 6000 FF6C           	BRA		LAB_214B				; re-run routine from last ending
    3983/    15CE :                     								; (but don't collect this string)
    3984/    15CE :                     
    3985/    15CE :                     LAB_21D1
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 71 - 10/11/2023 16:23:32


    3986/    15CE : 4CDF 0707           	MOVEM.l	(sp)+,d0-d2/a0-a2			; restore registers
    3987/    15D2 : 4E75                	RTS
    3988/    15D4 :                     
    3989/    15D4 :                     ; test and set if this is the highest string
    3990/    15D4 :                     
    3991/    15D4 :                     LAB_2206
    3992/    15D4 : 2010                	MOVE.l	(a0),d0				; get this string pointer
    3993/    15D6 : 6728                	BEQ.s		RTS_012				; exit if null string
    3994/    15D8 :                     
    3995/    15D8 : B280                	CMP.l		d0,d1					; compare with highest uncollected string so far
    3996/    15DA : 6424                	BCC.s		RTS_012				; exit if <= with highest so far
    3997/    15DC :                     
    3998/    15DC : B0AB 0446           	CMP.l		Sstorl(a3),d0			; compare with bottom of string space
    3999/    15E0 : 641E                	BCC.s		RTS_012				; exit if >= bottom of string space
    4000/    15E2 :                     
    4001/    15E2 : 70FF                	MOVEQ		#-1,d0				; d0 = $FFFFFFFF
    4002/    15E4 : 3028 0004           	MOVE.w	4(a0),d0				; d0 is string length
    4003/    15E8 : 4440                	NEG.w		d0					; make -ve
    4004/    15EA : C03C 00FE           	AND.b		#$FE,d0				; make -ve even length
    4005/    15EE : D0AB 0446           	ADD.l		Sstorl(a3),d0			; add string store to -ve length
    4006/    15F2 : B090                	CMP.l		(a0),d0				; compare with string address
    4007/    15F4 : 6706                	BEQ.s		LAB_2212				; if = go move string store pointer down
    4008/    15F6 :                     
    4009/    15F6 : 2210                	MOVE.l	(a0),d1				; highest = current
    4010/    15F8 : 2248                	MOVEA.l	a0,a1					; string to move = current
    4011/    15FA : 4E75                	RTS
    4012/    15FC :                     
    4013/    15FC :                     LAB_2212
    4014/    15FC : 2740 0446           	MOVE.l	d0,Sstorl(a3)			; set new string store start
    4015/    1600 :                     RTS_012
    4016/    1600 : 4E75                	RTS
    4017/    1602 :                     
    4018/    1602 :                     
    4019/    1602 :                     ;************************************************************************************
    4020/    1602 :                     ;
    4021/    1602 :                     ; concatenate - add strings
    4022/    1602 :                     ; string descriptor 1 is in FAC1_m, string 2 is in line
    4023/    1602 :                     
    4024/    1602 :                     LAB_224D
    4025/    1602 : 487A F738           	PEA		LAB_1ADB(pc)			; continue evaluation after concatenate
    4026/    1606 : 2F2B 0590           	MOVE.l	FAC1_m(a3),-(sp)			; stack descriptor pointer for string 1
    4027/    160A :                     
    4028/    160A : 6100 F80C           	BSR		LAB_GVAL				; get value from line
    4029/    160E : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type flag
    4030/    1612 : 6A00 EBE4           	BPL		LAB_TMER				; if type is not string do type mismatch error
    4031/    1616 :                     
    4032/    1616 : 205F                	MOVEA.l	(sp)+,a0				; restore descriptor pointer for string 1
    4033/    1618 :                     
    4034/    1618 :                     ;************************************************************************************
    4035/    1618 :                     ;
    4036/    1618 :                     ; concatenate
    4037/    1618 :                     ; string descriptor 1 is in a0, string descriptor 2 is in FAC1_m
    4038/    1618 :                     
    4039/    1618 :                     LAB_224E
    4040/    1618 : 226B 0590           	MOVEA.l	FAC1_m(a3),a1			; copy descriptor pointer 2
    4041/    161C : 3228 0004           	MOVE.w	4(a0),d1				; get length 1
    4042/    1620 : D269 0004           	ADD.w		4(a1),d1				; add length 2
    4043/    1624 : 6500 EBCE           	BCS		LAB_SLER				; if overflow go do 'string too long' error
    4044/    1628 :                     
    4045/    1628 : 2F08                	MOVE.l	a0,-(sp)				; save descriptor pointer 1
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 72 - 10/11/2023 16:23:32


    4046/    162A : 6100 FEB6           	BSR		LAB_2115				; make space d1 bytes long
    4047/    162E : 2748 0598           	MOVE.l	a0,FAC2_m(a3)			; save new string start pointer
    4048/    1632 : 2057                	MOVEA.l	(sp),a0				; copy descriptor pointer 1 from stack
    4049/    1634 : 3028 0004           	MOVE.w	4(a0),d0				; get length
    4050/    1638 : 2050                	MOVEA.l	(a0),a0				; get string pointer
    4051/    163A : 6120                	BSR.s		LAB_229E				; copy string d0 bytes long from a0 to Sutill
    4052/    163C :                     								; return with a0 = pointer, d1 = length
    4053/    163C :                     
    4054/    163C : 206B 0590           	MOVEA.l	FAC1_m(a3),a0			; get descriptor pointer for string 2
    4055/    1640 : 6138                	BSR.s		LAB_22BA				; pop (a0) descriptor, returns with ..
    4056/    1642 :                     								; a0 = pointer, d0 = length
    4057/    1642 : 6118                	BSR.s		LAB_229E				; copy string d0 bytes long from a0 to Sutill
    4058/    1644 :                     								; return with a0 = pointer, d1 = length
    4059/    1644 :                     
    4060/    1644 : 205F                	MOVEA.l	(sp)+,a0				; get descriptor pointer for string 1
    4061/    1646 : 6132                	BSR.s		LAB_22BA				; pop (a0) descriptor, returns with ..
    4062/    1648 :                     								; d0 = length, a0 = pointer
    4063/    1648 :                     
    4064/    1648 : 206B 0598           	MOVEA.l	FAC2_m(a3),a0			; retreive the result string pointer
    4065/    164C : 2208                	MOVE.l	a0,d1					; copy the result string pointer
    4066/    164E : 6700 FE78           	BEQ		LAB_RTST				; if it is a null string just return it
    4067/    1652 :                     								; a0 = pointer, d1 = length
    4068/    1652 :                     
    4069/    1652 : 4481                	NEG.l		d1					; else make the start pointer negative
    4070/    1654 : D2AB 044E           	ADD.l		Sutill(a3),d1			; add the end pointert to give the length
    4071/    1658 : 6000 FE6E           	BRA		LAB_RTST				; push string on descriptor stack
    4072/    165C :                     								; a0 = pointer, d1 = length
    4073/    165C :                     
    4074/    165C :                     
    4075/    165C :                     ;************************************************************************************
    4076/    165C :                     ;
    4077/    165C :                     ; copy string d0 bytes long from a0 to Sutill
    4078/    165C :                     ; return with a0 = pointer, d1 = length
    4079/    165C :                     
    4080/    165C :                     LAB_229E
    4081/    165C : 3200                	MOVE.w	d0,d1					; copy and check length
    4082/    165E : 6714                	BEQ.s		RTS_013				; skip copy if null
    4083/    1660 :                     
    4084/    1660 : 226B 044E           	MOVEA.l	Sutill(a3),a1			; get destination pointer
    4085/    1664 : 2F09                	MOVE.l	a1,-(sp)				; save destination string pointer
    4086/    1666 : 5340                	SUBQ.w	#1,d0					; subtract for DBF loop
    4087/    1668 :                     LAB_22A0
    4088/    1668 : 12D8                	MOVE.b	(a0)+,(a1)+				; copy byte
    4089/    166A : 51C8 FFFC           	DBF		d0,LAB_22A0				; loop if not done
    4090/    166E :                     
    4091/    166E : 2749 044E           	MOVE.l	a1,Sutill(a3)			; update Sutill to end of copied string
    4092/    1672 : 205F                	MOVEA.l	(sp)+,a0				; restore destination string pointer
    4093/    1674 :                     RTS_013
    4094/    1674 : 4E75                	RTS
    4095/    1676 :                     
    4096/    1676 :                     
    4097/    1676 :                     ;************************************************************************************
    4098/    1676 :                     ;
    4099/    1676 :                     ; pop string off descriptor stack, or from top of string space
    4100/    1676 :                     ; returns with d0.l = length, a0 = pointer
    4101/    1676 :                     
    4102/    1676 :                     LAB_22B6
    4103/    1676 : 206B 0590           	MOVEA.l	FAC1_m(a3),a0			; get descriptor pointer
    4104/    167A :                     
    4105/    167A :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 73 - 10/11/2023 16:23:32


    4106/    167A :                     ;************************************************************************************
    4107/    167A :                     ;
    4108/    167A :                     ; pop (a0) descriptor off stack or from string space
    4109/    167A :                     ; returns with d0.l = length, a0 = pointer
    4110/    167A :                     
    4111/    167A :                     LAB_22BA
    4112/    167A : 48E7 4040           	MOVEM.l	a1/d1,-(sp)				; save other regs
    4113/    167E : B9C8                	CMPA.l	a0,a4					; is string on the descriptor stack
    4114/    1680 : 6602                	BNE.s		LAB_22BD				; skip pop if not
    4115/    1682 :                     
    4116/    1682 : 5C4C                	ADDQ.w	#$06,a4				; else update stack pointer
    4117/    1684 :                     LAB_22BD
    4118/    1684 : 7000                	MOVEQ		#0,d0					; clear string length longword
    4119/    1686 : 2258                	MOVEA.l	(a0)+,a1				; get string address
    4120/    1688 : 3018                	MOVE.w	(a0)+,d0				; get string length
    4121/    168A :                     
    4122/    168A : B9C8                	CMPA.l	a0,a4					; was it on the descriptor stack
    4123/    168C : 6610                	BNE.s		LAB_22E6				; branch if it wasn't
    4124/    168E :                     
    4125/    168E : B3EB 0446           	CMPA.l	Sstorl(a3),a1			; compare string address with bottom of string
    4126/    1692 :                     								; space
    4127/    1692 : 660A                	BNE.s		LAB_22E6				; branch if <>
    4128/    1694 :                     
    4129/    1694 : 7201                	MOVEQ		#1,d1					; mask for odd bit
    4130/    1696 : C240                	AND.w		d0,d1					; AND length
    4131/    1698 : D280                	ADD.l		d0,d1					; make it fit word aligned length
    4132/    169A :                     
    4133/    169A : D3AB 0446           	ADD.l		d1,Sstorl(a3)			; add to bottom of string space
    4134/    169E :                     LAB_22E6
    4135/    169E : 2049                	MOVEA.l	a1,a0					; copy to a0
    4136/    16A0 : 4CDF 0202           	MOVEM.l	(sp)+,a1/d1				; restore other regs
    4137/    16A4 : 4A80                	TST.l		d0					; set flags on length
    4138/    16A6 : 4E75                	RTS
    4139/    16A8 :                     
    4140/    16A8 :                     
    4141/    16A8 :                     ;************************************************************************************
    4142/    16A8 :                     ;
    4143/    16A8 :                     ; perform CHR$()
    4144/    16A8 :                     
    4145/    16A8 :                     LAB_CHRS
    4146/    16A8 : 6100 0130           	BSR		LAB_EVBY				; evaluate byte expression, result in d0 and
    4147/    16AC :                     								; Itemp
    4148/    16AC :                     LAB_MKCHR
    4149/    16AC : 7201                	MOVEQ		#1,d1					; string is single byte
    4150/    16AE : 6100 FE32           	BSR		LAB_2115				; make string space d1 bytes long
    4151/    16B2 :                     								; return a0/Sutill = pointer, others unchanged
    4152/    16B2 : 1080                	MOVE.b	d0,(a0)				; save byte in string (byte IS string!)
    4153/    16B4 : 6000 FE12           	BRA		LAB_RTST				; push string on descriptor stack
    4154/    16B8 :                     								; a0 = pointer, d1 = length
    4155/    16B8 :                     
    4156/    16B8 :                     
    4157/    16B8 :                     ;************************************************************************************
    4158/    16B8 :                     ;
    4159/    16B8 :                     ; perform LEFT$()
    4160/    16B8 :                     
    4161/    16B8 :                     ; enter with a0 is descriptor, d0 & Itemp is word 1
    4162/    16B8 :                     
    4163/    16B8 :                     LAB_LEFT
    4164/    16B8 : C141                	EXG		d0,d1					; word in d1
    4165/    16BA : 6100 F79C           	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 74 - 10/11/2023 16:23:32


    4166/    16BE :                     
    4167/    16BE : 4A81                	TST.l		d1					; test returned length
    4168/    16C0 : 6722                	BEQ.s		LAB_231C				; branch if null return
    4169/    16C2 :                     
    4170/    16C2 : 7000                	MOVEQ		#0,d0					; clear start offset
    4171/    16C4 : B268 0004           	CMP.w		4(a0),d1				; compare word parameter with string length
    4172/    16C8 : 651A                	BCS.s		LAB_231C				; branch if string length > word parameter
    4173/    16CA :                     
    4174/    16CA : 6014                	BRA.s		LAB_2317				; go copy whole string
    4175/    16CC :                     
    4176/    16CC :                     
    4177/    16CC :                     ;************************************************************************************
    4178/    16CC :                     ;
    4179/    16CC :                     ; perform RIGHT$()
    4180/    16CC :                     
    4181/    16CC :                     ; enter with a0 is descriptor, d0 & Itemp is word 1
    4182/    16CC :                     
    4183/    16CC :                     LAB_RIGHT
    4184/    16CC : C141                	EXG		d0,d1					; word in d1
    4185/    16CE : 6100 F788           	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
    4186/    16D2 :                     
    4187/    16D2 : 4A81                	TST.l		d1					; test returned length
    4188/    16D4 : 670E                	BEQ.s		LAB_231C				; branch if null return
    4189/    16D6 :                     
    4190/    16D6 : 3028 0004           	MOVE.w	4(a0),d0				; get string length
    4191/    16DA : 9081                	SUB.l		d1,d0					; subtract word
    4192/    16DC : 6406                	BCC.s		LAB_231C				; branch if string length > word parameter
    4193/    16DE :                     
    4194/    16DE :                     								; else copy whole string
    4195/    16DE :                     LAB_2316
    4196/    16DE : 7000                	MOVEQ		#0,d0					; clear start offset
    4197/    16E0 :                     LAB_2317
    4198/    16E0 : 3228 0004           	MOVE.w	4(a0),d1				; else make parameter = length
    4199/    16E4 :                     
    4200/    16E4 :                     ; get here with ...
    4201/    16E4 :                     ;   a0 - points to descriptor
    4202/    16E4 :                     ;   d0 - is offset from string start
    4203/    16E4 :                     ;   d1 - is required string length
    4204/    16E4 :                     
    4205/    16E4 :                     LAB_231C
    4206/    16E4 : 2248                	MOVEA.l	a0,a1					; save string descriptor pointer
    4207/    16E6 : 6100 FDFA           	BSR		LAB_2115				; make string space d1 bytes long
    4208/    16EA :                     								; return a0/Sutill = pointer, others unchanged
    4209/    16EA : 2049                	MOVEA.l	a1,a0					; restore string descriptor pointer
    4210/    16EC : 2F00                	MOVE.l	d0,-(sp)				; save start offset (longword)
    4211/    16EE : 618A                	BSR.s		LAB_22BA				; pop (a0) descriptor, returns with ..
    4212/    16F0 :                     								; d0 = length, a0 = pointer
    4213/    16F0 : D1DF                	ADDA.l	(sp)+,a0				; adjust pointer to start of wanted string
    4214/    16F2 : 3001                	MOVE.w	d1,d0					; length to d0
    4215/    16F4 : 6100 FF66           	BSR		LAB_229E				; store string d0 bytes long from (a0) to
    4216/    16F8 :                     								; (Sutill) return with a0 = pointer,
    4217/    16F8 :                     								; d1 = length
    4218/    16F8 : 6000 FDCE           	BRA		LAB_RTST				; push string on descriptor stack
    4219/    16FC :                     								; a0 = pointer, d1 = length
    4220/    16FC :                     
    4221/    16FC :                     
    4222/    16FC :                     ;************************************************************************************
    4223/    16FC :                     ;
    4224/    16FC :                     ; perform MID$()
    4225/    16FC :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 75 - 10/11/2023 16:23:32


    4226/    16FC :                     ; enter with a0 is descriptor, d0 & Itemp is word 1
    4227/    16FC :                     
    4228/    16FC :                     LAB_MIDS
    4229/    16FC : 7E00                	MOVEQ		#0,d7					; clear longword
    4230/    16FE : 5347                	SUBQ.w	#1,d7					; set default length = 65535
    4231/    1700 : 2F00                	MOVE.l	d0,-(sp)				; save word 1
    4232/    1702 : 6100 F768           	BSR		LAB_GBYT				; scan memory
    4233/    1706 : B03C 002C           	CMP.b		#',',d0				; was it ","
    4234/    170A : 660C                	BNE.s		LAB_2358				; branch if not "," (skip second byte get)
    4235/    170C :                     
    4236/    170C : 101D                	MOVE.b	(a5)+,d0				; increment pointer past ","
    4237/    170E : 2F08                	MOVE.l	a0,-(sp)				; save descriptor pointer
    4238/    1710 : 6100 00DA           	BSR		LAB_GTWO				; get word parameter, result in d0 and Itemp
    4239/    1714 : 205F                	MOVEA.l	(sp)+,a0				; restore descriptor pointer
    4240/    1716 : 2E00                	MOVE.l	d0,d7					; copy length
    4241/    1718 :                     LAB_2358
    4242/    1718 : 6100 F73E           	BSR		LAB_1BFB				; scan for ")", else do syntax error then warm
    4243/    171C :                     								; start
    4244/    171C : 201F                	MOVE.l	(sp)+,d0				; restore word 1
    4245/    171E : 7200                	MOVEQ		#0,d1					; null length
    4246/    1720 : 5380                	SUBQ.l	#1,d0					; decrement start index (word 1)
    4247/    1722 : 6B00 EAF4           	BMI		LAB_FCER				; if was null do function call error then warm
    4248/    1726 :                     								; start
    4249/    1726 :                     
    4250/    1726 : B068 0004           	CMP.w		4(a0),d0				; compare string length with start index
    4251/    172A : 64B8                	BCC.s		LAB_231C				; if start not in string do null string (d1=0)
    4252/    172C :                     
    4253/    172C : 2207                	MOVE.l	d7,d1					; get length back
    4254/    172E : DE40                	ADD.w		d0,d7					; d7 now = MID$() end
    4255/    1730 : 6506                	BCS.s		LAB_2368				; already too long so do RIGHT$ equivalent
    4256/    1732 :                     
    4257/    1732 : BE68 0004           	CMP.w		4(a0),d7				; compare string length with start index+length
    4258/    1736 : 65AC                	BCS.s		LAB_231C				; if end in string go do string
    4259/    1738 :                     
    4260/    1738 :                     LAB_2368
    4261/    1738 : 3228 0004           	MOVE.w	4(a0),d1				; get string length
    4262/    173C : 9240                	SUB.w		d0,d1					; subtract start offset
    4263/    173E : 60A4                	BRA.s		LAB_231C				; go do string (effectively RIGHT$)
    4264/    1740 :                     
    4265/    1740 :                     
    4266/    1740 :                     ;************************************************************************************
    4267/    1740 :                     ;
    4268/    1740 :                     ; perform LCASE$()
    4269/    1740 :                     
    4270/    1740 :                     LAB_LCASE
    4271/    1740 : 6100 FF34           	BSR		LAB_22B6				; pop string off descriptor stack or from memory
    4272/    1744 :                     								; returns with d0 = length, a0 = pointer
    4273/    1744 : 2200                	MOVE.l	d0,d1					; copy the string length
    4274/    1746 : 6756                	BEQ.s		NoString				; if null go return a null string
    4275/    1748 :                     
    4276/    1748 :                     ; else copy and change the string
    4277/    1748 :                     
    4278/    1748 : 2248                	MOVEA.l	a0,a1					; copy the string address
    4279/    174A : 6100 FD96           	BSR		LAB_2115				; make a string space d1 bytes long
    4280/    174E : D1C1                	ADDA.l	d1,a0					; new string end
    4281/    1750 : D3C1                	ADDA.l	d1,a1					; old string end
    4282/    1752 : 3401                	MOVE.w	d1,d2					; copy length for loop
    4283/    1754 : 5342                	SUBQ.w	#1,d2					; -1 for DBF loop
    4284/    1756 :                     LC_loop
    4285/    1756 : 1021                	MOVE.b	-(a1),d0				; get byte from string
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 76 - 10/11/2023 16:23:32


    4286/    1758 :                     
    4287/    1758 : B03C 005B           	CMP.b		#$5B,d0				; compare with "Z"+1
    4288/    175C : 640A                	BCC.s		NoUcase				; if > "Z" skip change
    4289/    175E :                     
    4290/    175E : B03C 0041           	CMP.b		#$41,d0				; compare with "A"
    4291/    1762 : 6504                	BCS.s		NoUcase				; if < "A" skip change
    4292/    1764 :                     
    4293/    1764 : 0000 0020           	ORI.b		#$20,d0				; convert upper case to lower case
    4294/    1768 :                     NoUcase
    4295/    1768 : 1100                	MOVE.b	d0,-(a0)				; copy upper case byte back to string
    4296/    176A : 51CA FFEA           	DBF		d2,LC_loop				; decrement and loop if not all done
    4297/    176E :                     
    4298/    176E : 602E                	BRA.s		NoString				; tidy up & exit (branch always)
    4299/    1770 :                     
    4300/    1770 :                     
    4301/    1770 :                     ;************************************************************************************
    4302/    1770 :                     ;
    4303/    1770 :                     ; perform UCASE$()
    4304/    1770 :                     
    4305/    1770 :                     LAB_UCASE
    4306/    1770 : 6100 FF04           	BSR		LAB_22B6				; pop string off descriptor stack or from memory
    4307/    1774 :                     								; returns with d0 = length, a0 = pointer
    4308/    1774 : 2200                	MOVE.l	d0,d1					; copy the string length
    4309/    1776 : 6726                	BEQ.s		NoString				; if null go return a null string
    4310/    1778 :                     
    4311/    1778 :                     ; else copy and change the string
    4312/    1778 :                     
    4313/    1778 : 2248                	MOVEA.l	a0,a1					; copy the string address
    4314/    177A : 6100 FD66           	BSR		LAB_2115				; make a string space d1 bytes long
    4315/    177E : D1C1                	ADDA.l	d1,a0					; new string end
    4316/    1780 : D3C1                	ADDA.l	d1,a1					; old string end
    4317/    1782 : 3401                	MOVE.w	d1,d2					; copy length for loop
    4318/    1784 : 5342                	SUBQ.w	#1,d2					; -1 for DBF loop
    4319/    1786 :                     UC_loop
    4320/    1786 : 1021                	MOVE.b	-(a1),d0				; get a byte from the string
    4321/    1788 :                     
    4322/    1788 : B03C 0061           	CMP.b		#$61,d0				; compare with "a"
    4323/    178C : 650A                	BCS.s		NoLcase				; if < "a" skip change
    4324/    178E :                     
    4325/    178E : B03C 007B           	CMP.b		#$7B,d0				; compare with "z"+1
    4326/    1792 : 6404                	BCC.s		NoLcase				; if > "z" skip change
    4327/    1794 :                     
    4328/    1794 : 0200 00DF           	ANDI.b	#$DF,d0				; convert lower case to upper case
    4329/    1798 :                     NoLcase
    4330/    1798 : 1100                	MOVE.b	d0,-(a0)				; copy upper case byte back to string
    4331/    179A : 51CA FFEA           	DBF		d2,UC_loop				; decrement and loop if not all done
    4332/    179E :                     
    4333/    179E :                     NoString
    4334/    179E : 6000 FD28           	BRA		LAB_RTST				; push string on descriptor stack
    4335/    17A2 :                     								; a0 = pointer, d1 = length
    4336/    17A2 :                     
    4337/    17A2 :                     
    4338/    17A2 :                     ;************************************************************************************
    4339/    17A2 :                     ;
    4340/    17A2 :                     ; perform SADD()
    4341/    17A2 :                     
    4342/    17A2 :                     LAB_SADD
    4343/    17A2 : 101D                	MOVE.b	(a5)+,d0				; increment pointer
    4344/    17A4 : 6100 F8D6           	BSR		LAB_GVAR				; get variable address in a0
    4345/    17A8 : 6100 F6AE           	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 77 - 10/11/2023 16:23:32


    4346/    17AC : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type flag
    4347/    17B0 : 6A00 EA46           	BPL		LAB_TMER				; if numeric do Type missmatch Error
    4348/    17B4 : 2010                	MOVE.l	(a0),d0					; get string address
    4349/    17B6 : 6000 FBB4           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
    4350/    17BA :                     
    4351/    17BA :                     
    4352/    17BA :                     ;************************************************************************************
    4353/    17BA :                     ;
    4354/    17BA :                     ; perform LEN()
    4355/    17BA :                     
    4356/    17BA :                     LAB_LENS
    4357/    17BA : 487A FBB0           	PEA		LAB_AYFC(pc)			; set return address to convert d0 to signed
    4358/    17BE :                     								; longword in FAC1
    4359/    17BE : 6000 FEB6           	BRA		LAB_22B6				; pop string off descriptor stack or from memory
    4360/    17C2 :                     								; returns with d0 = length, a0 = pointer
    4361/    17C2 :                     
    4362/    17C2 :                     
    4363/    17C2 :                     ;************************************************************************************
    4364/    17C2 :                     ;
    4365/    17C2 :                     ; perform ASC()
    4366/    17C2 :                     
    4367/    17C2 :                     LAB_ASC
    4368/    17C2 : 6100 FEB2           	BSR		LAB_22B6				; pop string off descriptor stack or from memory
    4369/    17C6 :                     								; returns with d0 = length, a0 = pointer
    4370/    17C6 : 4A40                	TST.w		d0					; test length
    4371/    17C8 : 6700 EA4E           	BEQ		LAB_FCER				; if null do function call error then warm start
    4372/    17CC :                     
    4373/    17CC : 1010                	MOVE.b	(a0),d0				; get first character byte
    4374/    17CE : 6000 FBBC           	BRA		LAB_1FD0				; convert d0 to unsigned byte in FAC1 & return
    4375/    17D2 :                     
    4376/    17D2 :                     
    4377/    17D2 :                     ;************************************************************************************
    4378/    17D2 :                     ;
    4379/    17D2 :                     ; increment and get byte, result in d0 and Itemp
    4380/    17D2 :                     
    4381/    17D2 :                     LAB_SGBY
    4382/    17D2 : 6100 F696           	BSR		LAB_IGBY				; increment & scan memory
    4383/    17D6 :                     
    4384/    17D6 :                     
    4385/    17D6 :                     ;************************************************************************************
    4386/    17D6 :                     ;
    4387/    17D6 :                     ; get byte parameter, result in d0 and Itemp
    4388/    17D6 :                     
    4389/    17D6 :                     LAB_GTBY
    4390/    17D6 : 6100 F51A           	BSR		LAB_EVNM				; evaluate expression & check is numeric,
    4391/    17DA :                     								; else do type mismatch
    4392/    17DA :                     
    4393/    17DA :                     
    4394/    17DA :                     ;************************************************************************************
    4395/    17DA :                     ;
    4396/    17DA :                     ; evaluate byte expression, result in d0 and Itemp
    4397/    17DA :                     
    4398/    17DA :                     LAB_EVBY
    4399/    17DA : 6100 F9D4           	BSR		LAB_EVPI				; evaluate positive integer expression
    4400/    17DE :                     								; result in d0 and Itemp
    4401/    17DE : 123C 0080           	MOVE.b		#$80,d1				; set mask/2
    4402/    17E2 : D281                	ADD.l		d1,d1					; =$FFFFFF00
    4403/    17E4 : C280                	AND.l		d0,d1					; check top 24 bits
    4404/    17E6 : 6600 EA30           	BNE		LAB_FCER				; if <> 0 do function call error/warm start
    4405/    17EA :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 78 - 10/11/2023 16:23:32


    4406/    17EA : 4E75                	RTS
    4407/    17EC :                     
    4408/    17EC :                     
    4409/    17EC :                     ;************************************************************************************
    4410/    17EC :                     ;
    4411/    17EC :                     ; get word parameter, result in d0 and Itemp
    4412/    17EC :                     
    4413/    17EC :                     LAB_GTWO
    4414/    17EC : 6100 F504           	BSR		LAB_EVNM				; evaluate expression & check is numeric,
    4415/    17F0 :                     								; else do type mismatch
    4416/    17F0 : 6100 F9BE           	BSR		LAB_EVPI				; evaluate positive integer expression
    4417/    17F4 :                     								; result in d0 and Itemp
    4418/    17F4 : 4840                	SWAP		d0					; copy high word to low word
    4419/    17F6 : 4A40                	TST.w		d0					; set flags
    4420/    17F8 : 6600 EA1E           	BNE		LAB_FCER				; if <> 0 do function call error/warm start
    4421/    17FC :                     
    4422/    17FC : 4840                	SWAP		d0					; copy high word to low word
    4423/    17FE : 4E75                	RTS
    4424/    1800 :                     
    4425/    1800 :                     
    4426/    1800 :                     ;************************************************************************************
    4427/    1800 :                     ;
    4428/    1800 :                     ; perform VAL()
    4429/    1800 :                     
    4430/    1800 :                     LAB_VAL
    4431/    1800 : 6100 FE74           	BSR		LAB_22B6				; pop string off descriptor stack or from memory
    4432/    1804 :                     								; returns with d0 = length, a0 = pointer
    4433/    1804 : 6722                	BEQ.s		LAB_VALZ				; string was null so set result = $00
    4434/    1806 :                     								; clear FAC1 exponent & sign & return
    4435/    1806 :                     
    4436/    1806 : 2C4D                	MOVEA.l	a5,a6					; save BASIC execute pointer
    4437/    1808 : 2A48                	MOVEA.l	a0,a5					; copy string pointer to execute pointer
    4438/    180A : D1C0                	ADDA.l	d0,a0					; string end+1
    4439/    180C : 1010                	MOVE.b	(a0),d0				; get byte from string+1
    4440/    180E : 3F00                	MOVE.w	d0,-(sp)				; save it
    4441/    1810 : 2F08                	MOVE.l	a0,-(sp)				; save address
    4442/    1812 : 10BC 0000           	MOVE.b	#0,(a0)				; null terminate string
    4443/    1816 : 6100 F654           	BSR		LAB_GBYT				; scan memory
    4444/    181A : 6100 114C           	BSR		LAB_2887				; get FAC1 from string
    4445/    181E : 205F                	MOVEA.l	(sp)+,a0				; restore pointer
    4446/    1820 : 301F                	MOVE.w	(sp)+,d0				; pop byte
    4447/    1822 : 1080                	MOVE.b	d0,(a0)				; restore to memory
    4448/    1824 : 2A4E                	MOVEA.l	a6,a5					; restore BASIC execute pointer
    4449/    1826 : 4E75                	RTS
    4450/    1828 :                     
    4451/    1828 :                     LAB_VALZ
    4452/    1828 : 3740 0594           	MOVE.w	d0,FAC1_e(a3)			; clear FAC1 exponent & sign
    4453/    182C : 4E75                	RTS
    4454/    182E :                     
    4455/    182E :                     
    4456/    182E :                     ;************************************************************************************
    4457/    182E :                     ;
    4458/    182E :                     ; get two parameters for POKE or WAIT, first parameter in a0, second in d0
    4459/    182E :                     
    4460/    182E :                     LAB_GADB
    4461/    182E : 6100 F4C2           	BSR		LAB_EVNM				; evaluate expression & check is numeric,
    4462/    1832 :                     								; else do type mismatch
    4463/    1832 : 6100 F984           	BSR		LAB_EVIR				; evaluate integer expression
    4464/    1836 :                     								; (does FC error not OF error if out of range)
    4465/    1836 : 2F00                	MOVE.l	d0,-(sp)				; copy to stack
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 79 - 10/11/2023 16:23:32


    4466/    1838 : 6100 F626           	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
    4467/    183C : 6198                	BSR.s		LAB_GTBY				; get byte parameter, result in d0 and Itemp
    4468/    183E : 205F                	MOVEA.l	(sp)+,a0				; pull address
    4469/    1840 : 4E75                	RTS
    4470/    1842 :                     
    4471/    1842 :                     
    4472/    1842 :                     ;************************************************************************************
    4473/    1842 :                     ;
    4474/    1842 :                     ; get two parameters for DOKE or WAITW, first parameter in a0, second in d0
    4475/    1842 :                     
    4476/    1842 :                     LAB_GADW
    4477/    1842 : 611E                	BSR.s		LAB_GEAD				; get even address for word/long memory actions
    4478/    1844 :                     								; address returned in d0 and on the stack
    4479/    1844 : 6100 F61A           	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
    4480/    1848 : 6100 F4A8           	BSR		LAB_EVNM				; evaluate expression & check is numeric,
    4481/    184C :                     								; else do type mismatch
    4482/    184C : 6100 F96A           	BSR		LAB_EVIR				; evaluate integer expression
    4483/    1850 :                     								; result in d0 and Itemp
    4484/    1850 : 4840                	SWAP		d0					; swap words
    4485/    1852 : 4A40                	TST.w		d0					; test high word
    4486/    1854 : 6706                	BEQ.s		LAB_XGADW				; exit if null
    4487/    1856 :                     
    4488/    1856 : 5240                	ADDQ.w	#1,d0					; increment word
    4489/    1858 : 6600 E9BE           	BNE		LAB_FCER				; if <> 0 do function call error/warm start
    4490/    185C :                     
    4491/    185C :                     LAB_XGADW
    4492/    185C : 4840                	SWAP		d0					; swap words back
    4493/    185E : 205F                	MOVEA.l	(sp)+,a0				; pull address
    4494/    1860 : 4E75                	RTS
    4495/    1862 :                     
    4496/    1862 :                     
    4497/    1862 :                     ;************************************************************************************
    4498/    1862 :                     ;
    4499/    1862 :                     ; get even address (for word or longword memory actions)
    4500/    1862 :                     ; address returned in d0 and on the stack
    4501/    1862 :                     ; does address error if the address is odd
    4502/    1862 :                     
    4503/    1862 :                     LAB_GEAD
    4504/    1862 : 6100 F48E           	BSR		LAB_EVNM				; evaluate expression & check is numeric,
    4505/    1866 :                     								; else do type mismatch
    4506/    1866 : 6100 F950           	BSR		LAB_EVIR				; evaluate integer expression
    4507/    186A :                     								; (does FC error not OF error if out of range)
    4508/    186A : 0800 0000           	BTST		#0,d0					; test low bit of longword
    4509/    186E : 6600 E964           	BNE		LAB_ADER				; if address is odd do address error/warm start
    4510/    1872 :                     
    4511/    1872 : 2057                	MOVEA.l	(sp),a0				; copy return address
    4512/    1874 : 2E80                	MOVE.l	d0,(sp)				; even address on stack
    4513/    1876 : 4ED0                	JMP		(a0)					; effectively RTS
    4514/    1878 :                     
    4515/    1878 :                     
    4516/    1878 :                     ;************************************************************************************
    4517/    1878 :                     ;
    4518/    1878 :                     ; perform PEEK()
    4519/    1878 :                     
    4520/    1878 :                     LAB_PEEK
    4521/    1878 : 6100 F93E           	BSR		LAB_EVIR				; evaluate integer expression
    4522/    187C :                     								; (does FC error not OF error if out of range)
    4523/    187C : 2040                	MOVEA.l	d0,a0					; copy to address register
    4524/    187E : 1010                	MOVE.b	(a0),d0				; get byte
    4525/    1880 : 6000 FB0A           	BRA		LAB_1FD0				; convert d0 to unsigned byte in FAC1 & return
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 80 - 10/11/2023 16:23:32


    4526/    1884 :                     
    4527/    1884 :                     
    4528/    1884 :                     ;************************************************************************************
    4529/    1884 :                     ;
    4530/    1884 :                     ; perform POKE
    4531/    1884 :                     
    4532/    1884 :                     LAB_POKE
    4533/    1884 : 61A8                	BSR.s		LAB_GADB				; get two parameters for POKE or WAIT
    4534/    1886 :                     								; first parameter in a0, second in d0
    4535/    1886 : 1080                	MOVE.b	d0,(a0)				; put byte in memory
    4536/    1888 : 4E75                	RTS
    4537/    188A :                     
    4538/    188A :                     
    4539/    188A :                     ;************************************************************************************
    4540/    188A :                     ;
    4541/    188A :                     ; perform DEEK()
    4542/    188A :                     
    4543/    188A :                     LAB_DEEK
    4544/    188A : 6100 F92C           	BSR		LAB_EVIR				; evaluate integer expression
    4545/    188E :                     								; (does FC error not OF error if out of range)
    4546/    188E : E208                	LSR.b		#1,d0					; shift bit 0 to carry
    4547/    1890 : 6500 E942           	BCS		LAB_ADER				; if address is odd do address error/warm start
    4548/    1894 :                     
    4549/    1894 : D000                	ADD.b		d0,d0					; shift byte back
    4550/    1896 : C188                	EXG		d0,a0					; copy to address register
    4551/    1898 : 7000                	MOVEQ		#0,d0					; clear top bits
    4552/    189A : 3010                	MOVE.w	(a0),d0				; get word
    4553/    189C : 6000 FACE           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
    4554/    18A0 :                     
    4555/    18A0 :                     
    4556/    18A0 :                     ;************************************************************************************
    4557/    18A0 :                     ;
    4558/    18A0 :                     ; perform LEEK()
    4559/    18A0 :                     
    4560/    18A0 :                     LAB_LEEK
    4561/    18A0 : 6100 F916           	BSR		LAB_EVIR				; evaluate integer expression
    4562/    18A4 :                     								; (does FC error not OF error if out of range)
    4563/    18A4 : E208                	LSR.b		#1,d0					; shift bit 0 to carry
    4564/    18A6 : 6500 E92C           	BCS		LAB_ADER				; if address is odd do address error/warm start
    4565/    18AA :                     
    4566/    18AA : D000                	ADD.b		d0,d0					; shift byte back
    4567/    18AC : C188                	EXG		d0,a0					; copy to address register
    4568/    18AE : 2010                	MOVE.l	(a0),d0				; get longword
    4569/    18B0 : 6000 FABA           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
    4570/    18B4 :                     
    4571/    18B4 :                     
    4572/    18B4 :                     ;************************************************************************************
    4573/    18B4 :                     ;
    4574/    18B4 :                     ; perform DOKE
    4575/    18B4 :                     
    4576/    18B4 :                     LAB_DOKE
    4577/    18B4 : 618C                	BSR.s		LAB_GADW				; get two parameters for DOKE or WAIT
    4578/    18B6 :                     								; first parameter in a0, second in d0
    4579/    18B6 : 3080                	MOVE.w	d0,(a0)				; put word in memory
    4580/    18B8 : 4E75                	RTS
    4581/    18BA :                     
    4582/    18BA :                     
    4583/    18BA :                     ;************************************************************************************
    4584/    18BA :                     ;
    4585/    18BA :                     ; perform LOKE
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 81 - 10/11/2023 16:23:32


    4586/    18BA :                     
    4587/    18BA :                     LAB_LOKE
    4588/    18BA : 61A6                	BSR.s		LAB_GEAD				; get even address for word/long memory actions
    4589/    18BC :                     								; address returned in d0 and on the stack
    4590/    18BC : 6100 F5A2           	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
    4591/    18C0 : 6100 F430           	BSR		LAB_EVNM				; evaluate expression & check is numeric,
    4592/    18C4 :                     								; else do type mismatch
    4593/    18C4 : 6100 F8F2           	BSR		LAB_EVIR				; evaluate integer value (no sign check)
    4594/    18C8 : 205F                	MOVEA.l	(sp)+,a0				; pull address
    4595/    18CA : 2080                	MOVE.l	d0,(a0)				; put longword in memory
    4596/    18CC :                     RTS_015
    4597/    18CC : 4E75                	RTS
    4598/    18CE :                     
    4599/    18CE :                     
    4600/    18CE :                     ;************************************************************************************
    4601/    18CE :                     ;
    4602/    18CE :                     ; perform SWAP
    4603/    18CE :                     
    4604/    18CE :                     LAB_SWAP
    4605/    18CE : 6100 F7AC           	BSR		LAB_GVAR				; get variable 1 address in a0
    4606/    18D2 : 2F08                	MOVE.l	a0,-(sp)				; save variable 1 address
    4607/    18D4 : 182B 05B5           	MOVE.b	Dtypef(a3),d4			; copy variable 1 data type, $80=string,
    4608/    18D8 :                     								; $40=inetger, $00=float
    4609/    18D8 :                     
    4610/    18D8 : 6100 F586           	BSR		LAB_1C01				; scan for ",", else do syntax error/warm start
    4611/    18DC : 6100 F79E           	BSR		LAB_GVAR				; get variable 2 address in a0
    4612/    18E0 : 245F                	MOVEA.l	(sp)+,a2				; restore variable 1 address
    4613/    18E2 : B82B 05B5           	CMP.b		Dtypef(a3),d4			; compare variable 1 data type with variable 2
    4614/    18E6 :                     								; data type
    4615/    18E6 : 6600 E910           	BNE		LAB_TMER				; if not both the same type do "Type mismatch"
    4616/    18EA :                     								; error then warm start
    4617/    18EA :                     
    4618/    18EA : 2010                	MOVE.l	(a0),d0				; get variable 2
    4619/    18EC : 20D2                	MOVE.l	(a2),(a0)+				; copy variable 1 to variable 2
    4620/    18EE : 24C0                	MOVE.l	d0,(a2)+				; save variable 2 to variable 1
    4621/    18F0 :                     
    4622/    18F0 : 4A04                	TST.b		d4					; check data type
    4623/    18F2 : 6AD8                	BPL.s		RTS_015				; exit if not string
    4624/    18F4 :                     
    4625/    18F4 : 3010                	MOVE.w	(a0),d0				; get string 2 length
    4626/    18F6 : 3092                	MOVE.w	(a2),(a0)				; copy string 1 length to string 2 length
    4627/    18F8 : 3480                	MOVE.w	d0,(a2)				; save string 2 length to string 1 length
    4628/    18FA : 4E75                	RTS
    4629/    18FC :                     
    4630/    18FC :                     
    4631/    18FC :                     ;************************************************************************************
    4632/    18FC :                     ;
    4633/    18FC :                     ; perform USR
    4634/    18FC :                     
    4635/    18FC :                     LAB_USR
    4636/    18FC : 4EAB 0406           	JSR		Usrjmp(a3)				; do user vector
    4637/    1900 : 6000 F556           	BRA		LAB_1BFB				; scan for ")", else do syntax error/warm start
    4638/    1904 :                     
    4639/    1904 :                     
    4640/    1904 :                     ;************************************************************************************
    4641/    1904 :                     ;
    4642/    1904 :                     ; perform LOAD
    4643/    1904 :                     
    4644/    1904 :                     LAB_LOAD
    4645/    1904 : 4EEB 0418           	JMP		V_LOAD(a3)				; do load vector
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 82 - 10/11/2023 16:23:32


    4646/    1908 :                     
    4647/    1908 :                     
    4648/    1908 :                     ;************************************************************************************
    4649/    1908 :                     ;
    4650/    1908 :                     ; perform SAVE
    4651/    1908 :                     
    4652/    1908 :                     LAB_SAVE
    4653/    1908 : 4EEB 041E           	JMP		V_SAVE(a3)				; do save vector
    4654/    190C :                     
    4655/    190C :                     
    4656/    190C :                     ;************************************************************************************
    4657/    190C :                     ;
    4658/    190C :                     ; perform CALL
    4659/    190C :                     
    4660/    190C :                     LAB_CALL
    4661/    190C : 487A F55E           	PEA		LAB_GBYT(pc)			; put return address on stack
    4662/    1910 : 6100 FF50           	BSR		LAB_GEAD				; get even address for word/long memory actions
    4663/    1914 :                     								; address returned in d0 and on the stack
    4664/    1914 : 4E75                	RTS							; effectively calls the routine
    4665/    1916 :                     
    4666/    1916 :                     ; if the called routine exits correctly then it will return via the get byte routine.
    4667/    1916 :                     ; this will then get the next byte for the interpreter and return
    4668/    1916 :                     
    4669/    1916 :                     
    4670/    1916 :                     ;************************************************************************************
    4671/    1916 :                     ;
    4672/    1916 :                     ; perform WAIT
    4673/    1916 :                     
    4674/    1916 :                     LAB_WAIT
    4675/    1916 : 6100 FF16           	BSR		LAB_GADB				; get two parameters for POKE or WAIT
    4676/    191A :                     								; first parameter in a0, second in d0
    4677/    191A : 2F08                	MOVE.l	a0,-(sp)				; save address
    4678/    191C : 3F00                	MOVE.w	d0,-(sp)				; save byte
    4679/    191E : 7400                	MOVEQ		#0,d2					; clear mask
    4680/    1920 : 6100 F54A           	BSR		LAB_GBYT				; scan memory
    4681/    1924 : 6706                	BEQ.s		LAB_2441				; skip if no third argument
    4682/    1926 :                     
    4683/    1926 : 6100 F534           	BSR		LAB_SCGB				; scan for "," & get byte,
    4684/    192A :                     								; else do syntax error/warm start
    4685/    192A : 2400                	MOVE.l	d0,d2					; copy mask
    4686/    192C :                     LAB_2441
    4687/    192C : 321F                	MOVE.w	(sp)+,d1				; get byte
    4688/    192E : 205F                	MOVEA.l	(sp)+,a0				; get address
    4689/    1930 :                     LAB_2445
    4690/    1930 : 1010                	MOVE.b	(a0),d0				; read memory byte
    4691/    1932 : B500                	EOR.b		d2,d0					; EOR with second argument (mask)
    4692/    1934 : C001                	AND.b		d1,d0					; AND with first argument (byte)
    4693/    1936 : 67F8                	BEQ.s		LAB_2445				; loop if result is zero
    4694/    1938 :                     
    4695/    1938 : 4E75                	RTS
    4696/    193A :                     
    4697/    193A :                     
    4698/    193A :                     ;************************************************************************************
    4699/    193A :                     ;
    4700/    193A :                     ; perform subtraction, FAC1 from FAC2
    4701/    193A :                     
    4702/    193A :                     LAB_SUBTRACT
    4703/    193A : 0A2B 0080 0595      	EORI.b	#$80,FAC1_s(a3)			; complement FAC1 sign
    4704/    1940 : 176B 059D 059E      	MOVE.b	FAC2_s(a3),FAC_sc(a3)		; copy FAC2 sign byte
    4705/    1946 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 83 - 10/11/2023 16:23:32


    4706/    1946 : 102B 0595           	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign byte
    4707/    194A : B12B 059E           	EOR.b		d0,FAC_sc(a3)			; EOR with FAC2 sign
    4708/    194E :                     
    4709/    194E :                     
    4710/    194E :                     ;************************************************************************************
    4711/    194E :                     ;
    4712/    194E :                     ; add FAC2 to FAC1
    4713/    194E :                     
    4714/    194E :                     LAB_ADD
    4715/    194E : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get exponent
    4716/    1952 : 6700 0338           	BEQ		LAB_279B				; FAC1 was zero so copy FAC2 to FAC1 & return
    4717/    1956 :                     
    4718/    1956 :                     								; FAC1 is non zero
    4719/    1956 : 41EB 0598           	LEA		FAC2_m(a3),a0			; set pointer1 to FAC2 mantissa
    4720/    195A : 102B 059C           	MOVE.b	FAC2_e(a3),d0			; get FAC2 exponent
    4721/    195E : 6746                	BEQ.s		RTS_016				; exit if zero
    4722/    1960 :                     
    4723/    1960 : 902B 0594           	SUB.b		FAC1_e(a3),d0			; subtract FAC1 exponent
    4724/    1964 : 6722                	BEQ.s		LAB_24A8				; branch if = (go add mantissa)
    4725/    1966 :                     
    4726/    1966 : 650A                	BCS.s		LAB_249C				; branch if FAC2 < FAC1
    4727/    1968 :                     
    4728/    1968 :                     								; FAC2 > FAC1
    4729/    1968 : 376B 059C 0594      	MOVE.w	FAC2_e(a3),FAC1_e(a3)		; copy sign and exponent of FAC2
    4730/    196E : 4400                	NEG.b		d0					; negate exponent difference (make diff -ve)
    4731/    1970 : 5148                	SUBQ.w	#8,a0					; pointer1 to FAC1
    4732/    1972 :                     
    4733/    1972 :                     LAB_249C
    4734/    1972 : 4400                	NEG.b		d0					; negate exponent difference (make diff +ve)
    4735/    1974 : 2F01                	MOVE.l	d1,-(sp)				; save d1
    4736/    1976 : B03C 0020           	CMP.b		#32,d0				; compare exponent diff with 32
    4737/    197A : 6D04                	BLT.s		LAB_2467				; branch if range >= 32
    4738/    197C :                     
    4739/    197C : 7200                	MOVEQ		#0,d1					; clear d1
    4740/    197E : 6004                	BRA.s		LAB_2468				; go clear smaller mantissa
    4741/    1980 :                     
    4742/    1980 :                     LAB_2467
    4743/    1980 : 2210                	MOVE.l	(a0),d1				; get FACx mantissa
    4744/    1982 : E0A9                	LSR.l		d0,d1					; shift d0 times right
    4745/    1984 :                     LAB_2468
    4746/    1984 : 2081                	MOVE.l	d1,(a0)				; save it back
    4747/    1986 : 221F                	MOVE.l	(sp)+,d1				; restore d1
    4748/    1988 :                     
    4749/    1988 :                     								; exponents are equal now do mantissa add or
    4750/    1988 :                     								; subtract
    4751/    1988 :                     LAB_24A8
    4752/    1988 : 4A2B 059E           	TST.b		FAC_sc(a3)				; test sign compare (FAC1 EOR FAC2)
    4753/    198C : 6B1A                	BMI.s		LAB_24F8				; if <> go do subtract
    4754/    198E :                     
    4755/    198E : 202B 0598           	MOVE.l	FAC2_m(a3),d0			; get FAC2 mantissa
    4756/    1992 : D0AB 0590           	ADD.l		FAC1_m(a3),d0			; add FAC1 mantissa
    4757/    1996 : 640A                	BCC.s		LAB_24F7				; save and exit if no carry (FAC1 is normal)
    4758/    1998 :                     
    4759/    1998 : E290                	ROXR.l	#1,d0					; else shift carry back into mantissa
    4760/    199A : 522B 0594           	ADDQ.b	#1,FAC1_e(a3)			; increment FAC1 exponent
    4761/    199E : 6500 E874           	BCS		LAB_OFER				; if carry do overflow error & warm start
    4762/    19A2 :                     
    4763/    19A2 :                     LAB_24F7
    4764/    19A2 : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; save mantissa
    4765/    19A6 :                     RTS_016
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 84 - 10/11/2023 16:23:32


    4766/    19A6 : 4E75                	RTS
    4767/    19A8 :                     								; signs are different
    4768/    19A8 :                     LAB_24F8
    4769/    19A8 : 43EB 0590           	LEA		FAC1_m(a3),a1			; pointer 2 to FAC1
    4770/    19AC : B3C8                	CMPA.l	a0,a1					; compare pointers
    4771/    19AE : 6602                	BNE.s		LAB_24B4				; branch if <>
    4772/    19B0 :                     
    4773/    19B0 : 5049                	ADDQ.w	#8,a1					; else pointer2 to FAC2
    4774/    19B2 :                     
    4775/    19B2 :                     								; take smaller from bigger (take sign of bigger)
    4776/    19B2 :                     LAB_24B4
    4777/    19B2 : 2011                	MOVE.l	(a1),d0				; get larger mantissa
    4778/    19B4 : 2210                	MOVE.l	(a0),d1				; get smaller mantissa
    4779/    19B6 : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; save larger mantissa
    4780/    19BA : 93AB 0590           	SUB.l		d1,FAC1_m(a3)			; subtract smaller
    4781/    19BE :                     
    4782/    19BE :                     
    4783/    19BE :                     ;************************************************************************************
    4784/    19BE :                     ;
    4785/    19BE :                     ; do +/- (carry is sign) & normalise FAC1
    4786/    19BE :                     
    4787/    19BE :                     LAB_24D0
    4788/    19BE : 640A                	BCC.s		LAB_24D5				; branch if result is +ve
    4789/    19C0 :                     
    4790/    19C0 :                     								; erk! subtract is the wrong way round so
    4791/    19C0 :                     								; negate everything
    4792/    19C0 : 0A2B 00FF 0595      	EORI.b	#$FF,FAC1_s(a3)			; complement FAC1 sign
    4793/    19C6 : 44AB 0590           	NEG.l		FAC1_m(a3)				; negate FAC1 mantissa
    4794/    19CA :                     
    4795/    19CA :                     
    4796/    19CA :                     ;************************************************************************************
    4797/    19CA :                     ;
    4798/    19CA :                     ; normalise FAC1
    4799/    19CA :                     
    4800/    19CA :                     LAB_24D5
    4801/    19CA : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get mantissa
    4802/    19CE : 6B2E                	BMI.s		LAB_24DA				; mantissa is normal so just exit
    4803/    19D0 :                     
    4804/    19D0 : 6606                	BNE.s		LAB_24D9				; mantissa is not zero so go normalise FAC1
    4805/    19D2 :                     
    4806/    19D2 : 3740 0594           	MOVE.w	d0,FAC1_e(a3)			; else make FAC1 = +zero
    4807/    19D6 : 4E75                	RTS
    4808/    19D8 :                     
    4809/    19D8 :                     LAB_24D9
    4810/    19D8 : 2F01                	MOVE.l	d1,-(sp)				; save d1
    4811/    19DA : 2200                	MOVE.l	d0,d1					; mantissa to d1
    4812/    19DC : 7000                	MOVEQ		#0,d0					; clear d0
    4813/    19DE : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get exponent byte
    4814/    19E2 : 6714                	BEQ.s		LAB_24D8				; if exponent is zero then clean up and exit
    4815/    19E4 :                     LAB_24D6
    4816/    19E4 : D281                	ADD.l		d1,d1					; shift mantissa, ADD is quicker for a single
    4817/    19E6 :                     								; shift
    4818/    19E6 : 5BC8 FFFC           	DBMI		d0,LAB_24D6				; decrement exponent and loop if mantissa and
    4819/    19EA :                     								; exponent +ve
    4820/    19EA :                     
    4821/    19EA : 4A40                	TST.w		d0					; test exponent
    4822/    19EC : 670A                	BEQ.s		LAB_24D8				; if exponent is zero make FAC1 zero
    4823/    19EE :                     
    4824/    19EE : 6A02                	BPL.s		LAB_24D7				; if exponent is >zero go save FAC1
    4825/    19F0 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 85 - 10/11/2023 16:23:32


    4826/    19F0 : 7001                	MOVEQ		#1,d0					; else set for zero after correction
    4827/    19F2 :                     LAB_24D7
    4828/    19F2 : 5300                	SUBQ.b	#1,d0					; adjust exponent for loop
    4829/    19F4 : 2741 0590           	MOVE.l	d1,FAC1_m(a3)			; save normalised mantissa
    4830/    19F8 :                     LAB_24D8
    4831/    19F8 : 221F                	MOVE.l	(sp)+,d1				; restore d1
    4832/    19FA : 1740 0594           	MOVE.b	d0,FAC1_e(a3)			; save corrected exponent
    4833/    19FE :                     LAB_24DA
    4834/    19FE : 4E75                	RTS
    4835/    1A00 :                     
    4836/    1A00 :                     
    4837/    1A00 :                     ;************************************************************************************
    4838/    1A00 :                     ;
    4839/    1A00 :                     ; perform LOG()
    4840/    1A00 :                     
    4841/    1A00 :                     LAB_LOG
    4842/    1A00 : 4A2B 0595           	TST.b		FAC1_s(a3)				; test sign
    4843/    1A04 : 6B00 E812           	BMI		LAB_FCER				; if -ve do function call error/warm start
    4844/    1A08 :                     
    4845/    1A08 : 7E00                	MOVEQ		#0,d7					; clear d7
    4846/    1A0A : 1747 059E           	MOVE.b	d7,FAC_sc(a3)			; clear sign compare
    4847/    1A0E : 1E2B 0594           	MOVE.b	FAC1_e(a3),d7			; get exponent
    4848/    1A12 : 6700 E804           	BEQ		LAB_FCER				; if 0 do function call error/warm start
    4849/    1A16 :                     
    4850/    1A16 : 9EBC 0000 0081      	SUB.l		#$81,d7				; normalise exponent
    4851/    1A1C : 177C 0081 0594      	MOVE.b	#$81,FAC1_e(a3)			; force a value between 1 and 2
    4852/    1A22 : 2C2B 0590           	MOVE.l	FAC1_m(a3),d6			; copy mantissa
    4853/    1A26 :                     
    4854/    1A26 : 277C 8000 0000      	MOVE.l	#$80000000,FAC2_m(a3)		; set mantissa for 1
             1A2C : 0598             
    4855/    1A2E : 377C 8100 059C      	MOVE.w	#$8100,FAC2_e(a3)			; set exponent for 1
    4856/    1A34 : 6100 FF18           	BSR		LAB_ADD				; find arg+1
    4857/    1A38 : 7000                	MOVEQ		#0,d0					; setup for calc skip
    4858/    1A3A : 3740 059C           	MOVE.w	d0,FAC2_e(a3)			; set FAC1 for zero result
    4859/    1A3E : DC86                	ADD.l		d6,d6					; shift 1 bit out
    4860/    1A40 : 2746 0598           	MOVE.l	d6,FAC2_m(a3)			; put back FAC2
    4861/    1A44 : 6758                	BEQ.s		LAB_LONN				; if 0 skip calculation
    4862/    1A46 :                     
    4863/    1A46 : 377C 8000 059C      	MOVE.w	#$8000,FAC2_e(a3)			; set exponent for .5
    4864/    1A4C : 6100 0130           	BSR		LAB_DIVIDE				; do (arg-1)/(arg+1)
    4865/    1A50 : 4A2B 0594           	TST.b		FAC1_e(a3)				; test exponent
    4866/    1A54 : 6748                	BEQ.s		LAB_LONN				; if 0 skip calculation
    4867/    1A56 :                     
    4868/    1A56 : 122B 0594           	MOVE.b	FAC1_e(a3),d1			; get exponent
    4869/    1A5A : 923C 0082           	SUB.b		#$82,d1				; normalise and two integer bits
    4870/    1A5E : 4401                	NEG.b		d1					; negate for shift
    4871/    1A60 :                     ;	CMP.b		#$1F,d1				; will mantissa vanish?
    4872/    1A60 :                     ;	BGT.s		LAB_dunno				; if so do ???
    4873/    1A60 :                     
    4874/    1A60 : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get mantissa
    4875/    1A64 : E2A8                	LSR.l		d1,d0					; shift in two integer bits
    4876/    1A66 :                     
    4877/    1A66 :                     ; d0 = arg
    4878/    1A66 :                     ; d0 = x, d1 = y
    4879/    1A66 :                     ; d2 = x1, d3 = y1
    4880/    1A66 :                     ; d4 = shift count
    4881/    1A66 :                     ; d5 = loop count
    4882/    1A66 :                     ; d6 = z
    4883/    1A66 :                     ; a0 = table pointer
    4884/    1A66 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 86 - 10/11/2023 16:23:32


    4885/    1A66 : 7C00                	MOVEQ		#0,d6					; z = 0
    4886/    1A68 : 223C 4000 0000      	MOVE.l	#1<<30,d1				; y = 1
    4887/    1A6E : 41FA 1408           	LEA		TAB_HTHET(pc),a0			; get pointer to hyperbolic tangent table
    4888/    1A72 : 7A1E                	MOVEQ		#30,d5				; loop 31 times
    4889/    1A74 : 7801                	MOVEQ		#1,d4					; set shift count
    4890/    1A76 : 6006                	BRA.s		LAB_LOCC				; entry point for loop
    4891/    1A78 :                     
    4892/    1A78 :                     LAB_LAAD
    4893/    1A78 : E8A2                	ASR.l		d4,d2					; x1 >> i
    4894/    1A7A : 9282                	SUB.l		d2,d1					; y = y - x1
    4895/    1A7C : DC90                	ADD.l		(a0),d6				; z = z + tanh(i)
    4896/    1A7E :                     LAB_LOCC
    4897/    1A7E : 2400                	MOVE.l	d0,d2					; x1 = x
    4898/    1A80 : 2601                	MOVE.l	d1,d3					; y1 = Y
    4899/    1A82 : E8A3                	ASR.l		d4,d3					; y1 >> i
    4900/    1A84 : 6402                	BCC.s		LAB_LOLP
    4901/    1A86 :                     
    4902/    1A86 : 5283                	ADDQ.l	#1,d3
    4903/    1A88 :                     LAB_LOLP
    4904/    1A88 : 9083                	SUB.l		d3,d0					; x = x - y1
    4905/    1A8A : 6AEC                	BPL.s		LAB_LAAD				; branch if > 0
    4906/    1A8C :                     
    4907/    1A8C : 2002                	MOVE.l	d2,d0					; get x back
    4908/    1A8E : 5848                	ADDQ.w	#4,a0					; next entry
    4909/    1A90 : 5284                	ADDQ.l	#1,d4					; next i
    4910/    1A92 : E28B                	LSR.l		#1,d3					; /2
    4911/    1A94 : 6704                	BEQ.s		LAB_LOCX				; branch y1 = 0
    4912/    1A96 :                     
    4913/    1A96 : 51CD FFF0           	DBF		d5,LAB_LOLP				; decrement and loop if not done
    4914/    1A9A :                     
    4915/    1A9A :                     								; now sort out the result
    4916/    1A9A :                     LAB_LOCX
    4917/    1A9A : DC86                	ADD.l		d6,d6					; *2
    4918/    1A9C : 2006                	MOVE.l	d6,d0					; setup for d7 = 0
    4919/    1A9E :                     LAB_LONN
    4920/    1A9E : 2800                	MOVE.l	d0,d4					; save cordic result
    4921/    1AA0 : 7A00                	MOVEQ		#0,d5					; set default exponent sign
    4922/    1AA2 : 4A87                	TST.l		d7					; check original exponent sign
    4923/    1AA4 : 6716                	BEQ.s		LAB_LOXO				; branch if original was 0
    4924/    1AA6 :                     
    4925/    1AA6 : 6A04                	BPL.s		LAB_LOXP				; branch if was +ve
    4926/    1AA8 :                     
    4927/    1AA8 : 4487                	NEG.l		d7					; make original exponent +ve
    4928/    1AAA : 7A80                	MOVEQ		#$80-$100,d5			; make sign -ve
    4929/    1AAC :                     LAB_LOXP
    4930/    1AAC : 1745 0595           	MOVE.b	d5,FAC1_s(a3)			; save original exponent sign
    4931/    1AB0 : 4847                	SWAP		d7					; 16 bit shift
    4932/    1AB2 : E18F                	LSL.l		#8,d7					; easy first part
    4933/    1AB4 : 7A88                	MOVEQ		#$88-$100,d5			; start with byte
    4934/    1AB6 :                     LAB_LONE
    4935/    1AB6 : 5385                	SUBQ.l	#1,d5					; decrement exponent
    4936/    1AB8 : DE87                	ADD.l		d7,d7					; shift mantissa
    4937/    1ABA : 6AFA                	BPL.s		LAB_LONE				; loop if not normal
    4938/    1ABC :                     
    4939/    1ABC :                     LAB_LOXO
    4940/    1ABC : 2747 0590           	MOVE.l	d7,FAC1_m(a3)			; save original exponent as mantissa
    4941/    1AC0 : 1745 0594           	MOVE.b	d5,FAC1_e(a3)			; save exponent for this
    4942/    1AC4 : 277C B172 17F8      	MOVE.l	#$B17217F8,FAC2_m(a3)		; LOG(2) mantissa
             1ACA : 0598             
    4943/    1ACC : 377C 8000 059C      	MOVE.w	#$8000,FAC2_e(a3)			; LOG(2) exponent & sign
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 87 - 10/11/2023 16:23:32


    4944/    1AD2 : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; make sign compare = FAC1 sign
    4945/    1AD8 : 6118                	BSR.s		LAB_MULTIPLY			; do multiply
    4946/    1ADA : 2744 0598           	MOVE.l	d4,FAC2_m(a3)			; save cordic result
    4947/    1ADE : 6710                	BEQ.s		LAB_LOWZ				; branch if zero
    4948/    1AE0 :                     
    4949/    1AE0 : 377C 8200 059C      	MOVE.w	#$8200,FAC2_e(a3)			; set exponent & sign
    4950/    1AE6 : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; clear sign compare
    4951/    1AEC : 6100 FE60           	BSR		LAB_ADD				; and add for final result
    4952/    1AF0 :                     
    4953/    1AF0 :                     LAB_LOWZ
    4954/    1AF0 : 4E75                	RTS
    4955/    1AF2 :                     
    4956/    1AF2 :                     
    4957/    1AF2 :                     ;************************************************************************************
    4958/    1AF2 :                     ;
    4959/    1AF2 :                     ; multiply FAC1 by FAC2
    4960/    1AF2 :                     
    4961/    1AF2 :                     LAB_MULTIPLY
    4962/    1AF2 : 48E7 F800           	MOVEM.l	d0-d4,-(sp)				; save registers
    4963/    1AF6 : 4A2B 0594           	TST.b		FAC1_e(a3)				; test FAC1 exponent
    4964/    1AFA : 6776                	BEQ.s		LAB_MUUF				; if exponent zero go make result zero
    4965/    1AFC :                     
    4966/    1AFC : 102B 059C           	MOVE.b	FAC2_e(a3),d0			; get FAC2 exponent
    4967/    1B00 : 6770                	BEQ.s		LAB_MUUF				; if exponent zero go make result zero
    4968/    1B02 :                     
    4969/    1B02 : 176B 059E 0595      	MOVE.b	FAC_sc(a3),FAC1_s(a3)		; sign compare becomes sign
    4970/    1B08 :                     
    4971/    1B08 : D02B 0594           	ADD.b		FAC1_e(a3),d0			; multiply exponents by adding
    4972/    1B0C : 640A                	BCC.s		LAB_MNOC				; branch if no carry
    4973/    1B0E :                     
    4974/    1B0E : 903C 0080           	SUB.b		#$80,d0				; normalise result
    4975/    1B12 : 6400 E700           	BCC		LAB_OFER				; if no carry do overflow
    4976/    1B16 :                     
    4977/    1B16 : 6006                	BRA.s		LAB_MADD				; branch
    4978/    1B18 :                     
    4979/    1B18 :                     								; no carry for exponent add
    4980/    1B18 :                     LAB_MNOC
    4981/    1B18 : 903C 0080           	SUB.b		#$80,d0				; normalise result
    4982/    1B1C : 6554                	BCS.s		LAB_MUUF				; return zero if underflow
    4983/    1B1E :                     
    4984/    1B1E :                     LAB_MADD
    4985/    1B1E : 1740 0594           	MOVE.b	d0,FAC1_e(a3)			; save exponent
    4986/    1B22 :                     
    4987/    1B22 :                     								; d1 (FAC1) x d2 (FAC2)
    4988/    1B22 : 222B 0590           	MOVE.l	FAC1_m(a3),d1			; get FAC1 mantissa
    4989/    1B26 : 242B 0598           	MOVE.l	FAC2_m(a3),d2			; get FAC2 mantissa
    4990/    1B2A :                     
    4991/    1B2A : 3801                	MOVE.w	d1,d4					; copy low word FAC1
    4992/    1B2C : 2001                	MOVE.l	d1,d0					; copy long word FAC1
    4993/    1B2E : 4840                	SWAP		d0					; high word FAC1 to low word FAC1
    4994/    1B30 : 3600                	MOVE.w	d0,d3					; copy high word FAC1
    4995/    1B32 :                     
    4996/    1B32 : C2C2                	MULU		d2,d1					; low word FAC2 x low word FAC1
    4997/    1B34 : C0C2                	MULU		d2,d0					; low word FAC2 x high word FAC1
    4998/    1B36 : 4842                	SWAP		d2					; high word FAC2 to low word FAC2
    4999/    1B38 : C8C2                	MULU		d2,d4					; high word FAC2 x low word FAC1
    5000/    1B3A : C6C2                	MULU		d2,d3					; high word FAC2 x high word FAC1
    5001/    1B3C :                     
    5002/    1B3C :                     ; done multiply, now add partial products
    5003/    1B3C :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 88 - 10/11/2023 16:23:32


    5004/    1B3C :                     ;			d1 =					aaaa  ----	FAC2_L x FAC1_L
    5005/    1B3C :                     ;			d0 =				bbbb  aaaa		FAC2_L x FAC1_H
    5006/    1B3C :                     ;			d4 =				bbbb  aaaa		FAC2_H x FAC1_L
    5007/    1B3C :                     ;			d3 =			cccc  bbbb			FAC2_H x FAC1_H
    5008/    1B3C :                     ;			product =		mmmm  mmmm
    5009/    1B3C :                     
    5010/    1B3C : D2BC 0000 8000      	ADD.L		#$8000,d1				; round up lowest word
    5011/    1B42 : 4241                	CLR.w		d1					; clear low word, don't need it
    5012/    1B44 : 4841                	SWAP		d1					; align high word
    5013/    1B46 : D280                	ADD.l		d0,d1					; add FAC2_L x FAC1_H (can't be carry)
    5014/    1B48 :                     LAB_MUF1
    5015/    1B48 : D284                	ADD.l		d4,d1					; now add intermediate (FAC2_H x FAC1_L)
    5016/    1B4A : 6406                	BCC.s		LAB_MUF2				; branch if no carry
    5017/    1B4C :                     
    5018/    1B4C : D6BC 0001 0000      	ADD.l		#$10000,d3				; else correct result
    5019/    1B52 :                     LAB_MUF2
    5020/    1B52 : D2BC 0000 8000      	ADD.l		#$8000,d1				; round up low word
    5021/    1B58 : 4241                	CLR.w		d1					; clear low word
    5022/    1B5A : 4841                	SWAP		d1					; align for final add
    5023/    1B5C : D283                	ADD.l		d3,d1					; add FAC2_H x FAC1_H, result
    5024/    1B5E : 6B08                	BMI.s		LAB_MUF3				; branch if normalisation not needed
    5025/    1B60 :                     
    5026/    1B60 : D281                	ADD.l		d1,d1					; shift mantissa
    5027/    1B62 : 532B 0594           	SUBQ.b	#1,FAC1_e(a3)			; adjust exponent
    5028/    1B66 : 670A                	BEQ.s		LAB_MUUF				; branch if underflow
    5029/    1B68 :                     
    5030/    1B68 :                     LAB_MUF3
    5031/    1B68 : 2741 0590           	MOVE.l	d1,FAC1_m(a3)			; save mantissa
    5032/    1B6C :                     LAB_MUEX
    5033/    1B6C : 4CDF 001F           	MOVEM.l	(sp)+,d0-d4				; restore registers
    5034/    1B70 : 4E75                	RTS
    5035/    1B72 :                     								; either zero or underflow result
    5036/    1B72 :                     LAB_MUUF
    5037/    1B72 : 7000                	MOVEQ		#0,d0					; quick clear
    5038/    1B74 : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; clear mantissa
    5039/    1B78 : 3740 0594           	MOVE.w	d0,FAC1_e(a3)			; clear sign and exponent
    5040/    1B7C : 60EE                	BRA.s		LAB_MUEX				; restore regs & exit
    5041/    1B7E :                     
    5042/    1B7E :                     
    5043/    1B7E :                     ;************************************************************************************
    5044/    1B7E :                     ;
    5045/    1B7E :                     ; do FAC2/FAC1, result in FAC1
    5046/    1B7E :                     ; fast hardware divide version
    5047/    1B7E :                     
    5048/    1B7E :                     LAB_DIVIDE
    5049/    1B7E : 2F07                	MOVE.l	d7,-(sp)				; save d7
    5050/    1B80 : 7000                	MOVEQ		#0,d0					; clear FAC2 exponent
    5051/    1B82 : 2400                	MOVE.l	d0,d2					; clear FAC1 exponent
    5052/    1B84 :                     
    5053/    1B84 : 142B 0594           	MOVE.b	FAC1_e(a3),d2			; get FAC1 exponent
    5054/    1B88 : 6700 E676           	BEQ		LAB_DZER				; if zero go do /0 error
    5055/    1B8C :                     
    5056/    1B8C : 102B 059C           	MOVE.b	FAC2_e(a3),d0			; get FAC2 exponent
    5057/    1B90 : 6766                	BEQ.s		LAB_DIV0				; if zero return zero
    5058/    1B92 :                     
    5059/    1B92 : 9042                	SUB.w		d2,d0					; get result exponent by subtracting
    5060/    1B94 : D07C 0080           	ADD.w		#$80,d0				; correct 16 bit exponent result
    5061/    1B98 :                     
    5062/    1B98 : 176B 059E 0595      	MOVE.b	FAC_sc(a3),FAC1_s(a3)		; sign compare is result sign
    5063/    1B9E :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 89 - 10/11/2023 16:23:32


    5064/    1B9E :                     ; now to do 32/32 bit mantissa divide
    5065/    1B9E :                     
    5066/    1B9E : 422B 059F           	CLR.b		flag(a3)				; clear 'flag' byte
    5067/    1BA2 : 262B 0590           	MOVE.l	FAC1_m(a3),d3			; get FAC1 mantissa
    5068/    1BA6 : 282B 0598           	MOVE.l	FAC2_m(a3),d4			; get FAC2 mantissa
    5069/    1BAA : B883                	CMP.l		d3,d4					; compare FAC2 with FAC1 mantissa
    5070/    1BAC : 6744                	BEQ.s		LAB_MAN1				; set mantissa result = 1 if equal
    5071/    1BAE :                     
    5072/    1BAE : 6506                	BCS.s		AC1gtAC2				; branch if FAC1 > FAC2
    5073/    1BB0 :                     
    5074/    1BB0 : 9883                	SUB.l		d3,d4					; subtract FAC1 from FAC2, result now must be <1
    5075/    1BB2 : 562B 059F           	ADDQ.b	#3,flag(a3)				; FAC2>FAC1 so set 'flag' byte
    5076/    1BB6 :                     AC1gtAC2
    5077/    1BB6 : 6146                	BSR.s		LAB_32_16				; do 32/16 divide
    5078/    1BB8 : 4841                	SWAP		d1					; move 16 bit result to high word
    5079/    1BBA : 2802                	MOVE.l	d2,d4					; copy remainder longword
    5080/    1BBC : 6142                	BSR.s		LAB_3216				; do 32/16 divide again (skip copy d4 to d2)
    5081/    1BBE : 84C5                	DIVU.w	d5,d2					; now divide remainder to make guard word
    5082/    1BC0 : 1E2B 059F           	MOVE.b	flag(a3),d7				; now normalise, get flag byte back
    5083/    1BC4 : 6708                	BEQ.s		LAB_DIVX				; skip add if null
    5084/    1BC6 :                     
    5085/    1BC6 :                     ; else result was >1 so we need to add 1 to result mantissa and adjust exponent
    5086/    1BC6 :                     
    5087/    1BC6 : E20F                	LSR.b		#1,d7					; shift 1 into eXtend
    5088/    1BC8 : E291                	ROXR.l	#1,d1					; shift extend result >>
    5089/    1BCA : E252                	ROXR.w	#1,d2					; shift extend guard word >>
    5090/    1BCC : 5200                	ADDQ.b	#1,d0					; adjust exponent
    5091/    1BCE :                     
    5092/    1BCE :                     ; now round result to 32 bits
    5093/    1BCE :                     
    5094/    1BCE :                     LAB_DIVX
    5095/    1BCE : D442                	ADD.w		d2,d2					; guard bit into eXtend bit
    5096/    1BD0 : 6408                	BCC.s		L_DIVRND				; branch if guard=0
    5097/    1BD2 :                     
    5098/    1BD2 : 5281                	ADDQ.l	#1,d1					; add guard to mantissa
    5099/    1BD4 : 6404                	BCC.s		L_DIVRND				; branch if no overflow
    5100/    1BD6 :                     
    5101/    1BD6 :                     LAB_SET1
    5102/    1BD6 : E291                	ROXR.l	#1,d1					; shift extend result >>
    5103/    1BD8 : 5240                	ADDQ.w	#1,d0					; adjust exponent
    5104/    1BDA :                     
    5105/    1BDA :                     								; test for over/under flow
    5106/    1BDA :                     L_DIVRND
    5107/    1BDA : 3600                	MOVE.w	d0,d3					; copy exponent
    5108/    1BDC : 6B1A                	BMI.s		LAB_DIV0				; if -ve return zero
    5109/    1BDE :                     
    5110/    1BDE : 0243 FF00           	ANDI.w	#$FF00,d3				; mask word high byte
    5111/    1BE2 : 6600 E630           	BNE		LAB_OFER				; branch if overflow
    5112/    1BE6 :                     
    5113/    1BE6 :                     								; move result into FAC1
    5114/    1BE6 :                     LAB_XDIV
    5115/    1BE6 : 2E1F                	MOVE.l	(sp)+,d7				; restore d7
    5116/    1BE8 : 1740 0594           	MOVE.b	d0,FAC1_e(a3)			; save result exponent
    5117/    1BEC : 2741 0590           	MOVE.l	d1,FAC1_m(a3)			; save result mantissa
    5118/    1BF0 : 4E75                	RTS
    5119/    1BF2 :                     
    5120/    1BF2 :                     ; FAC1 mantissa = FAC2 mantissa so set result mantissa
    5121/    1BF2 :                     
    5122/    1BF2 :                     LAB_MAN1
    5123/    1BF2 : 7201                	MOVEQ		#1,d1					; set bit
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 90 - 10/11/2023 16:23:32


    5124/    1BF4 : E2A9                	LSR.l		d1,d1					; bit into eXtend
    5125/    1BF6 : 60DE                	BRA.s		LAB_SET1				; set mantissa, adjust exponent and exit
    5126/    1BF8 :                     
    5127/    1BF8 :                     ; result is zero
    5128/    1BF8 :                     
    5129/    1BF8 :                     LAB_DIV0
    5130/    1BF8 : 7000                	MOVEQ		#0,d0					; zero exponent & sign
    5131/    1BFA : 2200                	MOVE.l	d0,d1					; zero mantissa
    5132/    1BFC : 60E8                	BRA		LAB_XDIV				; exit divide
    5133/    1BFE :                     
    5134/    1BFE :                     ; divide 16 bits into 32, AB/Ex
    5135/    1BFE :                     ;
    5136/    1BFE :                     ; d4			AAAA	BBBB				; 32 bit numerator
    5137/    1BFE :                     ; d3			EEEE	xxxx				; 16 bit denominator
    5138/    1BFE :                     ;
    5139/    1BFE :                     ; returns -
    5140/    1BFE :                     ;
    5141/    1BFE :                     ; d1			xxxx	DDDD				; 16 bit result
    5142/    1BFE :                     ; d2				HHHH	IIII			; 32 bit remainder
    5143/    1BFE :                     
    5144/    1BFE :                     LAB_32_16
    5145/    1BFE : 2404                	MOVE.l	d4,d2					; copy FAC2 mantissa		(AB)
    5146/    1C00 :                     LAB_3216
    5147/    1C00 : 2A03                	MOVE.l	d3,d5					; copy FAC1 mantissa		(EF)
    5148/    1C02 : 4245                	CLR.w		d5					; clear low word d1		(Ex)
    5149/    1C04 : 4845                	SWAP		d5					; swap high word to low word	(xE)
    5150/    1C06 :                     
    5151/    1C06 :                     ; d3			EEEE	FFFF				; denominator copy
    5152/    1C06 :                     ; d5		0000	EEEE					; denominator high word
    5153/    1C06 :                     ; d2			AAAA	BBBB				; numerator copy
    5154/    1C06 :                     ; d4			AAAA	BBBB				; numerator
    5155/    1C06 :                     
    5156/    1C06 : 88C5                	DIVU.w	d5,d4					; do FAC2/FAC1 high word	(AB/E)
    5157/    1C08 : 6802                	BVC.s		LAB_LT_1				; if no overflow DIV was ok
    5158/    1C0A :                     
    5159/    1C0A : 78FF                	MOVEQ		#-1,d4				; else set default value
    5160/    1C0C :                     
    5161/    1C0C :                     ; done the divide, now check the result, we have ...
    5162/    1C0C :                     
    5163/    1C0C :                     ; d3			EEEE	FFFF				; denominator copy
    5164/    1C0C :                     ; d5		0000	EEEE					; denominator high word
    5165/    1C0C :                     ; d2			AAAA	BBBB				; numerator copy
    5166/    1C0C :                     ; d4			MMMM	DDDD				; result MOD and DIV
    5167/    1C0C :                     
    5168/    1C0C :                     LAB_LT_1
    5169/    1C0C : 3C04                	MOVE.w	d4,d6					; copy 16 bit result
    5170/    1C0E : 3204                	MOVE.w	d4,d1					; copy 16 bit result again
    5171/    1C10 :                     
    5172/    1C10 :                     ; we now have ..
    5173/    1C10 :                     ; d3			EEEE	FFFF				; denominator copy
    5174/    1C10 :                     ; d5		0000	EEEE					; denominator high word
    5175/    1C10 :                     ; d6			xxxx  DDDD				; result DIV copy
    5176/    1C10 :                     ; d1			xxxx  DDDD				; result DIV copy
    5177/    1C10 :                     ; d2			AAAA	BBBB				; numerator copy
    5178/    1C10 :                     ; d4			MMMM	DDDD				; result MOD and DIV
    5179/    1C10 :                     
    5180/    1C10 :                     ; now multiply out 32 bit denominator by 16 bit result
    5181/    1C10 :                     ; QRS = AB*D
    5182/    1C10 :                     
    5183/    1C10 : CCC3                	MULU.w	d3,d6					; FFFF	; DDDD =       rrrr  SSSS
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 91 - 10/11/2023 16:23:32


    5184/    1C12 : C8C5                	MULU.w	d5,d4					; EEEE	; DDDD = QQQQ  rrrr
    5185/    1C14 :                     
    5186/    1C14 :                     ; we now have ..
    5187/    1C14 :                     ; d3			EEEE	FFFF				; denominator copy
    5188/    1C14 :                     ; d5		0000	EEEE					; denominator high word
    5189/    1C14 :                     ; d6				rrrr  SSSS			; 48 bit result partial low
    5190/    1C14 :                     ; d1			xxxx  DDDD				; result DIV copy
    5191/    1C14 :                     ; d2			AAAA	BBBB				; numerator copy
    5192/    1C14 :                     ; d4			QQQQ	rrrr				; 48 bit result partial
    5193/    1C14 :                     
    5194/    1C14 : 3E06                	MOVE.w	d6,d7					; copy low word of low multiply
    5195/    1C16 :                     
    5196/    1C16 :                     ; d7				xxxx	SSSS			; 48 bit result partial low
    5197/    1C16 :                     
    5198/    1C16 : 4246                	CLR.w		d6					; clear low word of low multiply
    5199/    1C18 : 4846                	SWAP		d6					; high word of low multiply to low word
    5200/    1C1A :                     
    5201/    1C1A :                     ; d6			0000	rrrr				; high word of 48 bit result partial low
    5202/    1C1A :                     
    5203/    1C1A : D886                	ADD.l		d6,d4
    5204/    1C1C :                     
    5205/    1C1C :                     ; d4			QQQQ	RRRR				; 48 bit result partial high longword
    5206/    1C1C :                     
    5207/    1C1C : 7C00                	MOVEQ		#0,d6					; clear to extend numerator to 48 bits
    5208/    1C1E :                     
    5209/    1C1E :                     ; now do GHI = AB0 - QRS (which is the remainder)
    5210/    1C1E :                     
    5211/    1C1E : 9C47                	SUB.w		d7,d6					; low word subtract
    5212/    1C20 :                     
    5213/    1C20 :                     ; d6				xxxx	IIII			; remainder low word
    5214/    1C20 :                     
    5215/    1C20 : 9584                	SUBX.l	d4,d2					; high longword subtract
    5216/    1C22 :                     
    5217/    1C22 :                     ; d2			GGGG	HHHH				; remainder high longword
    5218/    1C22 :                     
    5219/    1C22 :                     ; now if we got the divide correct then the remainder high longword will be +ve
    5220/    1C22 :                     
    5221/    1C22 : 6A08                	BPL.s		L_DDIV				; branch if result is ok (<needed)
    5222/    1C24 :                     
    5223/    1C24 :                     ; remainder was -ve so DDDD is too big
    5224/    1C24 :                     
    5225/    1C24 :                     LAB_REMM
    5226/    1C24 : 5341                	SUBQ.w	#1,d1					; adjust DDDD
    5227/    1C26 :                     
    5228/    1C26 :                     ; d3				xxxx	FFFF			; denominator copy
    5229/    1C26 :                     ; d6				xxxx	IIII			; remainder low word
    5230/    1C26 :                     
    5231/    1C26 : DC43                	ADD.w		d3,d6					; add EF*1 low remainder low word
    5232/    1C28 :                     
    5233/    1C28 :                     ; d5			0000	EEEE				; denominator high word
    5234/    1C28 :                     ; d2			GGGG	HHHH				; remainder high longword
    5235/    1C28 :                     
    5236/    1C28 : D585                	ADDX.l	d5,d2					; add extend EF*1 to remainder high longword
    5237/    1C2A : 6BF8                	BMI.s		LAB_REMM				; loop if result still too big
    5238/    1C2C :                     
    5239/    1C2C :                     ; all done and result correct or <
    5240/    1C2C :                     
    5241/    1C2C :                     L_DDIV
    5242/    1C2C : 4842                	SWAP		d2					; remainder mid word to high word
    5243/    1C2E :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 92 - 10/11/2023 16:23:32


    5244/    1C2E :                     ; d2			HHHH	GGGG				; (high word /should/ be $0000)
    5245/    1C2E :                     
    5246/    1C2E : 3406                	MOVE.w	d6,d2					; remainder in high word
    5247/    1C30 :                     
    5248/    1C30 :                     ; d2				HHHH	IIII			; now is 32 bit remainder
    5249/    1C30 :                     ; d1			xxxx	DDDD				; 16 bit result
    5250/    1C30 :                     
    5251/    1C30 : 4E75                	RTS
    5252/    1C32 :                     
    5253/    1C32 :                     
    5254/    1C32 :                     ;************************************************************************************
    5255/    1C32 :                     ;
    5256/    1C32 :                     ; unpack memory (a0) into FAC1
    5257/    1C32 :                     
    5258/    1C32 :                     LAB_UFAC
    5259/    1C32 : 2010                	MOVE.l	(a0),d0				; get packed value
    5260/    1C34 : 4840                	SWAP		d0					; exponent and sign into least significant word
    5261/    1C36 : 3740 0594           	MOVE.w	d0,FAC1_e(a3)			; save exponent and sign
    5262/    1C3A : 6708                	BEQ.s		LAB_NB1T				; branch if exponent (and the rest) zero
    5263/    1C3C :                     
    5264/    1C3C : 807C 0080           	OR.w		#$80,d0				; set MSb
    5265/    1C40 : 4840                	SWAP		d0					; word order back to normal
    5266/    1C42 : E180                	ASL.l		#8,d0					; shift exponent & clear guard byte
    5267/    1C44 :                     LAB_NB1T
    5268/    1C44 : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; move into FAC1
    5269/    1C48 :                     
    5270/    1C48 : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
    5271/    1C4C : 4E75                	RTS
    5272/    1C4E :                     
    5273/    1C4E :                     
    5274/    1C4E :                     ;************************************************************************************
    5275/    1C4E :                     ;
    5276/    1C4E :                     ; set numeric variable, pack FAC1 into Lvarpl
    5277/    1C4E :                     
    5278/    1C4E :                     LAB_PFAC
    5279/    1C4E : 2F08                	MOVE.l	a0,-(sp)				; save pointer
    5280/    1C50 : 206B 0472           	MOVEA.l	Lvarpl(a3),a0			; get destination pointer
    5281/    1C54 : 082B 0006 05B5      	BTST		#6,Dtypef(a3)			; test data type
    5282/    1C5A : 670C                	BEQ.s		LAB_277C				; branch if floating
    5283/    1C5C :                     
    5284/    1C5C : 6100 00C6           	BSR		LAB_2831				; convert FAC1 floating to fixed
    5285/    1C60 :                     								; result in d0 and Itemp
    5286/    1C60 : 2080                	MOVE.l	d0,(a0)				; save in var
    5287/    1C62 : 205F                	MOVE.l	(sp)+,a0				; restore pointer
    5288/    1C64 : 4E75                	RTS
    5289/    1C66 :                     
    5290/    1C66 :                     
    5291/    1C66 :                     ;************************************************************************************
    5292/    1C66 :                     ;
    5293/    1C66 :                     ; normalise round and pack FAC1 into (a0)
    5294/    1C66 :                     
    5295/    1C66 :                     LAB_2778
    5296/    1C66 : 2F08                	MOVE.l	a0,-(sp)				; save pointer
    5297/    1C68 :                     LAB_277C
    5298/    1C68 : 6100 FD60           	BSR		LAB_24D5				; normalise FAC1
    5299/    1C6C : 612C                	BSR.s		LAB_27BA				; round FAC1
    5300/    1C6E : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get FAC1 mantissa
    5301/    1C72 : E098                	ROR.l		#8,d0					; align 24/32 bit mantissa
    5302/    1C74 : 4840                	SWAP		d0					; exponent/sign into 0-15
    5303/    1C76 : C07C 007F           	AND.w		#$7F,d0				; clear exponent and sign bit
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 93 - 10/11/2023 16:23:32


    5304/    1C7A : 022B 0080 0595      	ANDI.b	#$80,FAC1_s(a3)			; clear non sign bits in sign
    5305/    1C80 : 806B 0594           	OR.w		FAC1_e(a3),d0			; OR in exponent and sign
    5306/    1C84 : 4840                	SWAP		d0					; move exponent and sign back to 16-31
    5307/    1C86 : 2080                	MOVE.l	d0,(a0)				; store in destination
    5308/    1C88 : 205F                	MOVE.l	(sp)+,a0				; restore pointer
    5309/    1C8A : 4E75                	RTS
    5310/    1C8C :                     
    5311/    1C8C :                     
    5312/    1C8C :                     ;************************************************************************************
    5313/    1C8C :                     ;
    5314/    1C8C :                     ; copy FAC2 to FAC1
    5315/    1C8C :                     
    5316/    1C8C :                     LAB_279B
    5317/    1C8C : 376B 059C 0594      	MOVE.w	FAC2_e(a3),FAC1_e(a3)		; copy exponent & sign
    5318/    1C92 : 276B 0598 0590      	MOVE.l	FAC2_m(a3),FAC1_m(a3)		; copy mantissa
    5319/    1C98 : 4E75                	RTS
    5320/    1C9A :                     
    5321/    1C9A :                     
    5322/    1C9A :                     ;************************************************************************************
    5323/    1C9A :                     ;
    5324/    1C9A :                     ; round FAC1
    5325/    1C9A :                     
    5326/    1C9A :                     LAB_27BA
    5327/    1C9A : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
    5328/    1C9E : 6720                	BEQ.s		LAB_27C4				; branch if zero
    5329/    1CA0 :                     
    5330/    1CA0 : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get FAC1
    5331/    1CA4 : D0BC 0000 0080      	ADD.l		#$80,d0				; round to 24 bit
    5332/    1CAA : 640A                	BCC.s		LAB_27C3				; branch if no overflow
    5333/    1CAC :                     
    5334/    1CAC : E290                	ROXR.l	#1,d0					; shift FAC1 mantissa
    5335/    1CAE : 522B 0594           	ADDQ.b	#1,FAC1_e(a3)			; correct exponent
    5336/    1CB2 : 6500 E560           	BCS		LAB_OFER				; if carry do overflow error & warm start
    5337/    1CB6 :                     
    5338/    1CB6 :                     LAB_27C3
    5339/    1CB6 : C03C 0000           	AND.b		#$00,d0				; clear guard byte
    5340/    1CBA : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; save back to FAC1
    5341/    1CBE : 4E75                	RTS
    5342/    1CC0 :                     
    5343/    1CC0 :                     LAB_27C4
    5344/    1CC0 : 1740 0595           	MOVE.b	d0,FAC1_s(a3)			; make zero always +ve
    5345/    1CC4 :                     RTS_017
    5346/    1CC4 : 4E75                	RTS
    5347/    1CC6 :                     
    5348/    1CC6 :                     
    5349/    1CC6 :                     ;************************************************************************************
    5350/    1CC6 :                     ;
    5351/    1CC6 :                     ; get FAC1 sign
    5352/    1CC6 :                     ; return d0=-1,C=1/-ve d0=+1,C=0/+ve
    5353/    1CC6 :                     
    5354/    1CC6 :                     LAB_27CA
    5355/    1CC6 : 7000                	MOVEQ		#0,d0					; clear d0
    5356/    1CC8 : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
    5357/    1CCC : 67F6                	BEQ.s		RTS_017				; exit if zero (already correct SGN(0)=0)
    5358/    1CCE :                     
    5359/    1CCE :                     
    5360/    1CCE :                     ;************************************************************************************
    5361/    1CCE :                     ;
    5362/    1CCE :                     ; return d0=-1,C=1/-ve d0=+1,C=0/+ve
    5363/    1CCE :                     ; no = 0 check
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 94 - 10/11/2023 16:23:32


    5364/    1CCE :                     
    5365/    1CCE :                     LAB_27CE
    5366/    1CCE : 102B 0595           	MOVE.b	FAC1_s(a3),d0			; else get FAC1 sign (b7)
    5367/    1CD2 :                     
    5368/    1CD2 :                     
    5369/    1CD2 :                     ;************************************************************************************
    5370/    1CD2 :                     ;
    5371/    1CD2 :                     ; return d0=-1,C=1/-ve d0=+1,C=0/+ve
    5372/    1CD2 :                     ; no = 0 check, sign in d0
    5373/    1CD2 :                     
    5374/    1CD2 :                     LAB_27D0
    5375/    1CD2 : 4880                	EXT.w		d0					; make word
    5376/    1CD4 : 48C0                	EXT.l		d0					; make longword
    5377/    1CD6 : E080                	ASR.l		#8,d0					; move sign bit through byte to carry
    5378/    1CD8 : 65EA                	BCS.s		RTS_017				; exit if carry set
    5379/    1CDA :                     
    5380/    1CDA : 7001                	MOVEQ		#1,d0					; set result for +ve sign
    5381/    1CDC : 4E75                	RTS
    5382/    1CDE :                     
    5383/    1CDE :                     
    5384/    1CDE :                     ;************************************************************************************
    5385/    1CDE :                     ;
    5386/    1CDE :                     ; perform SGN()
    5387/    1CDE :                     
    5388/    1CDE :                     LAB_SGN
    5389/    1CDE : 61E6                	BSR.s		LAB_27CA				; get FAC1 sign
    5390/    1CE0 :                     								; return d0=-1/-ve d0=+1/+ve
    5391/    1CE0 :                     
    5392/    1CE0 :                     
    5393/    1CE0 :                     ;************************************************************************************
    5394/    1CE0 :                     ;
    5395/    1CE0 :                     ; save d0 as integer longword
    5396/    1CE0 :                     
    5397/    1CE0 :                     LAB_27DB
    5398/    1CE0 : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; save FAC1 mantissa
    5399/    1CE4 : 377C A000 0594      	MOVE.w	#$A000,FAC1_e(a3)			; set FAC1 exponent & sign
    5400/    1CEA : D080                	ADD.l		d0,d0					; top bit into carry
    5401/    1CEC : 6000 FCD0           	BRA		LAB_24D0				; do +/- (carry is sign) & normalise FAC1
    5402/    1CF0 :                     
    5403/    1CF0 :                     
    5404/    1CF0 :                     ;************************************************************************************
    5405/    1CF0 :                     ;
    5406/    1CF0 :                     ; perform ABS()
    5407/    1CF0 :                     
    5408/    1CF0 :                     LAB_ABS
    5409/    1CF0 : 177C 0000 0595      	MOVE.b	#0,FAC1_s(a3)			; clear FAC1 sign
    5410/    1CF6 : 4E75                	RTS
    5411/    1CF8 :                     
    5412/    1CF8 :                     
    5413/    1CF8 :                     ;************************************************************************************
    5414/    1CF8 :                     ;
    5415/    1CF8 :                     ; compare FAC1 with FAC2
    5416/    1CF8 :                     ; returns d0=+1 Cb=0 if FAC1 > FAC2
    5417/    1CF8 :                     ; returns d0= 0 Cb=0 if FAC1 = FAC2
    5418/    1CF8 :                     ; returns d0=-1 Cb=1 if FAC1 < FAC2
    5419/    1CF8 :                     
    5420/    1CF8 :                     LAB_27FA
    5421/    1CF8 : 122B 059C           	MOVE.b	FAC2_e(a3),d1			; get FAC2 exponent
    5422/    1CFC : 67C8                	BEQ.s		LAB_27CA				; branch if FAC2 exponent=0 & get FAC1 sign
    5423/    1CFE :                     								; d0=-1,C=1/-ve d0=+1,C=0/+ve
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 95 - 10/11/2023 16:23:32


    5424/    1CFE :                     
    5425/    1CFE : 102B 059E           	MOVE.b	FAC_sc(a3),d0			; get FAC sign compare
    5426/    1D02 : 6BCA                	BMI.s		LAB_27CE				; if signs <> do return d0=-1,C=1/-ve
    5427/    1D04 :                     								; d0=+1,C=0/+ve & return
    5428/    1D04 :                     
    5429/    1D04 : 102B 0595           	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
    5430/    1D08 : B22B 0594           	CMP.b		FAC1_e(a3),d1			; compare FAC1 exponent with FAC2 exponent
    5431/    1D0C : 660A                	BNE.s		LAB_2828				; branch if different
    5432/    1D0E :                     
    5433/    1D0E : 222B 0598           	MOVE.l	FAC2_m(a3),d1			; get FAC2 mantissa
    5434/    1D12 : B2AB 0590           	CMP.l		FAC1_m(a3),d1			; compare mantissas
    5435/    1D16 : 6708                	BEQ.s		LAB_282F				; exit if mantissas equal
    5436/    1D18 :                     
    5437/    1D18 :                     ; gets here if number <> FAC1
    5438/    1D18 :                     
    5439/    1D18 :                     LAB_2828
    5440/    1D18 : 65B8                	BCS.s		LAB_27D0				; if FAC1 > FAC2 return d0=-1,C=1/-ve d0=+1,
    5441/    1D1A :                     								; C=0/+ve
    5442/    1D1A :                     
    5443/    1D1A : 0A00 0080           	EORI.b	#$80,d0				; else toggle FAC1 sign
    5444/    1D1E :                     LAB_282E
    5445/    1D1E : 60B2                	BRA.s		LAB_27D0				; return d0=-1,C=1/-ve d0=+1,C=0/+ve
    5446/    1D20 :                     
    5447/    1D20 :                     LAB_282F
    5448/    1D20 : 7000                	MOVEQ		#0,d0					; clear result
    5449/    1D22 : 4E75                	RTS
    5450/    1D24 :                     
    5451/    1D24 :                     
    5452/    1D24 :                     ;************************************************************************************
    5453/    1D24 :                     ;
    5454/    1D24 :                     ; convert FAC1 floating to fixed
    5455/    1D24 :                     ; result in d0 and Itemp, sets flags correctly
    5456/    1D24 :                     
    5457/    1D24 :                     LAB_2831
    5458/    1D24 : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; copy mantissa
    5459/    1D28 : 6732                	BEQ.s		LAB_284J				; branch if mantissa = 0
    5460/    1D2A :                     
    5461/    1D2A : 2F01                	MOVE.l	d1,-(sp)				; save d1
    5462/    1D2C : 123C 00A0           	MOVE.b		#$A0,d1				; set for no floating bits
    5463/    1D30 : 922B 0594           	SUB.b		FAC1_e(a3),d1			; subtract FAC1 exponent
    5464/    1D34 : 6500 E4DE           	BCS		LAB_OFER				; do overflow if too big
    5465/    1D38 :                     
    5466/    1D38 : 660E                	BNE.s		LAB_284G				; branch if exponent was not $A0
    5467/    1D3A :                     
    5468/    1D3A : 4A2B 0595           	TST.b		FAC1_s(a3)				; test FAC1 sign
    5469/    1D3E : 6A1A                	BPL.s		LAB_284H				; branch if FAC1 +ve
    5470/    1D40 :                     
    5471/    1D40 : 4480                	NEG.l		d0
    5472/    1D42 : 6916                	BVS.s		LAB_284H				; branch if was $80000000
    5473/    1D44 :                     
    5474/    1D44 : 6000 E4CE           	BRA		LAB_OFER				; do overflow if too big
    5475/    1D48 :                     
    5476/    1D48 :                     LAB_284G
    5477/    1D48 : B23C 0020           	CMP.b		#$20,d1				; compare with minimum result for integer
    5478/    1D4C : 6502                	BCS.s		LAB_284L				; if < minimum just do shift
    5479/    1D4E :                     
    5480/    1D4E : 7000                	MOVEQ		#0,d0					; else return zero
    5481/    1D50 :                     LAB_284L
    5482/    1D50 : E2A8                	LSR.l		d1,d0					; shift integer
    5483/    1D52 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 96 - 10/11/2023 16:23:32


    5484/    1D52 : 4A2B 0595           	TST.b		FAC1_s(a3)				; test FAC1 sign (b7)
    5485/    1D56 : 6A02                	BPL.s		LAB_284H				; branch if FAC1 +ve
    5486/    1D58 :                     
    5487/    1D58 : 4480                	NEG.l		d0					; negate integer value
    5488/    1D5A :                     LAB_284H
    5489/    1D5A : 221F                	MOVE.l	(sp)+,d1				; restore d1
    5490/    1D5C :                     LAB_284J
    5491/    1D5C : 2740 042A           	MOVE.l	d0,Itemp(a3)			; save result to Itemp
    5492/    1D60 : 4E75                	RTS
    5493/    1D62 :                     
    5494/    1D62 :                     
    5495/    1D62 :                     ;************************************************************************************
    5496/    1D62 :                     ;
    5497/    1D62 :                     ; perform INT()
    5498/    1D62 :                     
    5499/    1D62 :                     LAB_INT
    5500/    1D62 : 103C 00A0           	MOVE.b		#$A0,d0				; set for no floating bits
    5501/    1D66 : 902B 0594           	SUB.b		FAC1_e(a3),d0			; subtract FAC1 exponent
    5502/    1D6A : 6310                	BLS.s		LAB_IRTS				; exit if exponent >= $A0
    5503/    1D6C :                     								; (too big for fraction part!)
    5504/    1D6C :                     
    5505/    1D6C : B03C 0020           	CMP.b		#$20,d0				; compare with minimum result for integer
    5506/    1D70 : 6400 0262           	BCC		LAB_POZE				; if >= minimum go return 0
    5507/    1D74 :                     								; (too small for integer part!)
    5508/    1D74 :                     
    5509/    1D74 : 72FF                	MOVEQ		#-1,d1				; set integer mask
    5510/    1D76 : E1A1                	ASL.l		d0,d1					; shift mask [8+2*d0]
    5511/    1D78 : C3AB 0590           	AND.l		d1,FAC1_m(a3)			; mask mantissa
    5512/    1D7C :                     LAB_IRTS
    5513/    1D7C : 4E75                	RTS
    5514/    1D7E :                     
    5515/    1D7E :                     
    5516/    1D7E :                     ;************************************************************************************
    5517/    1D7E :                     ;
    5518/    1D7E :                     ; print " in line [LINE #]"
    5519/    1D7E :                     
    5520/    1D7E :                     LAB_2953
    5521/    1D7E : 41FA 1800           	LEA		LAB_LMSG(pc),a0			; point to " in line " message
    5522/    1D82 : 6100 ED1C           	BSR		LAB_18C3				; print null terminated string
    5523/    1D86 :                     
    5524/    1D86 :                     								; Print Basic line #
    5525/    1D86 : 202B 0452           	MOVE.l	Clinel(a3),d0			; get current line
    5526/    1D8A :                     
    5527/    1D8A :                     
    5528/    1D8A :                     ;************************************************************************************
    5529/    1D8A :                     ;
    5530/    1D8A :                     ; print d0 as unsigned integer
    5531/    1D8A :                     
    5532/    1D8A :                     LAB_295E
    5533/    1D8A : 43FA 0DEE           	LEA		Bin2dec(pc),a1			; get table address
    5534/    1D8E : 7200                	MOVEQ		#0,d1					; table index
    5535/    1D90 : 41EB 05CC           	LEA		Usdss(a3),a0			; output string start
    5536/    1D94 : 2401                	MOVE.l	d1,d2					; output string index
    5537/    1D96 :                     LAB_2967
    5538/    1D96 : 2631 1000           	MOVE.l	(a1,d1.w),d3			; get table value
    5539/    1D9A : 6714                	BEQ.s		LAB_2969				; exit if end marker
    5540/    1D9C :                     
    5541/    1D9C : 782F                	MOVEQ		#'0'-1,d4				; set character to "0"-1
    5542/    1D9E :                     LAB_2968
    5543/    1D9E : 5244                	ADDQ.w	#1,d4					; next numeric character
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 97 - 10/11/2023 16:23:32


    5544/    1DA0 : 9083                	SUB.l		d3,d0					; subtract table value
    5545/    1DA2 : 6AFA                	BPL.s		LAB_2968				; not overdone so loop
    5546/    1DA4 :                     
    5547/    1DA4 : D083                	ADD.l		d3,d0					; correct value
    5548/    1DA6 : 1184 2000           	MOVE.b	d4,(a0,d2.w)			; character out to string
    5549/    1DAA : 5841                	ADDQ.w	#4,d1					; increment table pointer
    5550/    1DAC : 5242                	ADDQ.w	#1,d2					; increment output string pointer
    5551/    1DAE : 60E6                	BRA.s		LAB_2967				; loop
    5552/    1DB0 :                     
    5553/    1DB0 :                     LAB_2969
    5554/    1DB0 : D03C 0030           	ADD.b		#'0',d0				; make last character
    5555/    1DB4 : 1180 2000           	MOVE.b	d0,(a0,d2.w)			; character out to string
    5556/    1DB8 : 5348                	SUBQ.w	#1,a0					; decrement a0 (allow simple loop)
    5557/    1DBA :                     
    5558/    1DBA :                     								; now find non zero start of string
    5559/    1DBA :                     LAB_296A
    5560/    1DBA : 5248                	ADDQ.w	#1,a0					; increment a0 (this will never carry to b16)
    5561/    1DBC : 43EB 05D5           	LEA		BHsend-1(a3),a1			; get string end
    5562/    1DC0 : B1C9                	CMPA.l	a1,a0					; are we at end
    5563/    1DC2 : 6700 ECDC           	BEQ		LAB_18C3				; if so print null terminated string and RETURN
    5564/    1DC6 :                     
    5565/    1DC6 : 0C10 0030           	CMPI.b	#'0',(a0)				; is character "0" ?
    5566/    1DCA : 67EE                	BEQ.s		LAB_296A				; loop if so
    5567/    1DCC :                     
    5568/    1DCC : 6000 ECD2           	BRA		LAB_18C3				; print null terminated string from memory & RET
    5569/    1DD0 :                     
    5570/    1DD0 :                     
    5571/    1DD0 :                     ;************************************************************************************
    5572/    1DD0 :                     ;
    5573/    1DD0 :                     ; convert FAC1 to ASCII string result in (a0)
    5574/    1DD0 :                     ; STR$() function enters here
    5575/    1DD0 :                     
    5576/    1DD0 :                     ; now outputs 7 significant digits
    5577/    1DD0 :                     
    5578/    1DD0 :                     ; d0 is character out
    5579/    1DD0 :                     ; d1 is save index
    5580/    1DD0 :                     ; d2 is gash
    5581/    1DD0 :                     
    5582/    1DD0 :                     ; a0 is output string pointer
    5583/    1DD0 :                     
    5584/    1DD0 :                     LAB_2970
    5585/    1DD0 : 43EB 05C6           	LEA		Decss(a3),a1			; set output string start
    5586/    1DD4 :                     
    5587/    1DD4 : 7420                	MOVEQ		#' ',d2				; character = " ", assume +ve
    5588/    1DD6 : 08AB 0007 0595      	BCLR.b	#7,FAC1_s(a3)			; test and clear FAC1 sign (b7)
    5589/    1DDC : 6702                	BEQ.s		LAB_2978				; branch if +ve
    5590/    1DDE :                     
    5591/    1DDE : 742D                	MOVEQ		#'-',d2				; else character = "-"
    5592/    1DE0 :                     LAB_2978
    5593/    1DE0 : 1282                	MOVE.b	d2,(a1)				; save the sign character
    5594/    1DE2 : 142B 0594           	MOVE.b	FAC1_e(a3),d2			; get FAC1 exponent
    5595/    1DE6 : 6608                	BNE.s		LAB_2989				; branch if FAC1<>0
    5596/    1DE8 :                     
    5597/    1DE8 :                     								; exponent was $00 so FAC1 is 0
    5598/    1DE8 : 7030                	MOVEQ		#'0',d0				; set character = "0"
    5599/    1DEA : 7201                	MOVEQ		#1,d1					; set output string index
    5600/    1DEC : 6000 01A8           	BRA		LAB_2A89				; save last character, [EOT] & exit
    5601/    1DF0 :                     
    5602/    1DF0 :                     								; FAC1 is some non zero value
    5603/    1DF0 :                     LAB_2989
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 98 - 10/11/2023 16:23:32


    5604/    1DF0 : 177C 0000 05AC      	MOVE.b	#0,numexp(a3)			; clear number exponent count
    5605/    1DF6 : B43C 0081           	CMP.b		#$81,d2				; compare FAC1 exponent with $81 (>1.00000)
    5606/    1DFA :                     
    5607/    1DFA : 6448                	BCC.s		LAB_299C				; branch if FAC1=>1
    5608/    1DFC :                     
    5609/    1DFC :                     								; else FAC1 < 1
    5610/    1DFC : 277C 9896 8000      	MOVE.l	#$98968000,FAC2_m(a3)		; 10000000 mantissa
             1E02 : 0598             
    5611/    1E04 : 377C 9800 059C      	MOVE.w	#$9800,FAC2_e(a3)			; 10000000 exponent & sign
    5612/    1E0A : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; make FAC1 sign sign compare
    5613/    1E10 : 6100 FCE0           	BSR		LAB_MULTIPLY			; do FAC2*FAC1
    5614/    1E14 :                     
    5615/    1E14 : 177C 00F9 05AC      	MOVE.b	#$F9,numexp(a3)			; set number exponent count (-7)
    5616/    1E1A : 6028                	BRA.s		LAB_299C				; go test for fit
    5617/    1E1C :                     
    5618/    1E1C :                     LAB_29B9
    5619/    1E1C : 376B 0594 059C      	MOVE.w	FAC1_e(a3),FAC2_e(a3)		; copy exponent & sign from FAC1 to FAC2
    5620/    1E22 : 276B 0590 0598      	MOVE.l	FAC1_m(a3),FAC2_m(a3)		; copy FAC1 mantissa to FAC2 mantissa
    5621/    1E28 : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; save FAC1_s as sign compare
    5622/    1E2E :                     
    5623/    1E2E : 277C CCCC CCCD      	MOVE.l	#$CCCCCCCD,FAC1_m(a3)		; 1/10 mantissa
             1E34 : 0590             
    5624/    1E36 : 377C 7D00 0594      	MOVE.w	#$7D00,FAC1_e(a3)			; 1/10 exponent & sign
    5625/    1E3C : 6100 FCB4           	BSR		LAB_MULTIPLY			; do FAC2*FAC1, effectively divide by 10 but
    5626/    1E40 :                     								; faster
    5627/    1E40 :                     
    5628/    1E40 : 522B 05AC           	ADDQ.b	#1,numexp(a3)			; increment number exponent count
    5629/    1E44 :                     LAB_299C
    5630/    1E44 : 277C 9896 7F70      	MOVE.l	#$98967F70,FAC2_m(a3)		; 9999999.4375 mantissa
             1E4A : 0598             
    5631/    1E4C : 377C 9800 059C      	MOVE.w	#$9800,FAC2_e(a3)			; 9999999.4375 exponent & sign
    5632/    1E52 :                     								; (max before scientific notation)
    5633/    1E52 : 6100 0150           	BSR		LAB_27F0				; fast compare FAC1 with FAC2
    5634/    1E56 :                     								; returns d0=+1 C=0 if FAC1 > FAC2
    5635/    1E56 :                     								; returns d0= 0 C=0 if FAC1 = FAC2
    5636/    1E56 :                     								; returns d0=-1 C=1 if FAC1 < FAC2
    5637/    1E56 : 62C4                	BHI.s		LAB_29B9				; go do /10 if FAC1 > 9999999.4375
    5638/    1E58 :                     
    5639/    1E58 : 6750                	BEQ.s		LAB_29C3				; branch if FAC1 = 9999999.4375
    5640/    1E5A :                     
    5641/    1E5A :                     								; FAC1 < 9999999.4375
    5642/    1E5A : 277C F423 F800      	MOVE.l	#$F423F800,FAC2_m(a3)		; set mantissa for 999999.5
             1E60 : 0598             
    5643/    1E62 : 377C 9400 059C      	MOVE.w	#$9400,FAC2_e(a3)			; set exponent for 999999.5
    5644/    1E68 :                     
    5645/    1E68 : 41EB 0590           	LEA		FAC1_m(a3),a0			; set pointer for x10
    5646/    1E6C :                     LAB_29A7
    5647/    1E6C : 6100 0136           	BSR		LAB_27F0				; fast compare FAC1 with FAC2
    5648/    1E70 :                     								; returns d0=+1 C=0 if FAC1 > FAC2
    5649/    1E70 :                     								; returns d0= 0 C=0 if FAC1 = FAC2
    5650/    1E70 :                     								; returns d0=-1 C=1 if FAC1 < FAC2
    5651/    1E70 : 6220                	BHI.s		LAB_29C0				; branch if FAC1 > 99999.9375,no decimal places
    5652/    1E72 :                     
    5653/    1E72 :                     								; FAC1 <= 999999.5 so do x 10
    5654/    1E72 : 2010                	MOVE.l	(a0),d0				; get FAC1 mantissa
    5655/    1E74 : 1228 0004           	MOVE.b	4(a0),d1				; get FAC1 exponent
    5656/    1E78 : 2400                	MOVE.l	d0,d2					; copy it
    5657/    1E7A : E488                	LSR.l		#2,d0					; /4
    5658/    1E7C : D082                	ADD.l		d2,d0					; add FAC1 (x1.125)
    5659/    1E7E : 6404                	BCC.s		LAB_29B7				; branch if no carry
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 99 - 10/11/2023 16:23:32


    5660/    1E80 :                     
    5661/    1E80 : E290                	ROXR.l	#1,d0					; shift carry back in
    5662/    1E82 : 5201                	ADDQ.b	#1,d1					; increment exponent (never overflows)
    5663/    1E84 :                     LAB_29B7
    5664/    1E84 : 5601                	ADDQ.b	#3,d1					; correct exponent ( 8 x 1.125 = 10 )
    5665/    1E86 :                     								; (never overflows)
    5666/    1E86 : 2080                	MOVE.l	d0,(a0)				; save new mantissa
    5667/    1E88 : 1141 0004           	MOVE.b	d1,4(a0)				; save new exponent
    5668/    1E8C : 532B 05AC           	SUBQ.b	#1,numexp(a3)			; decrement number exponent count
    5669/    1E90 : 60DA                	BRA.s		LAB_29A7				; go test again
    5670/    1E92 :                     
    5671/    1E92 :                     								; now we have just the digits to do
    5672/    1E92 :                     LAB_29C0
    5673/    1E92 : 277C 8000 0000      	MOVE.l	#$80000000,FAC2_m(a3)		; set mantissa for 0.5
             1E98 : 0598             
    5674/    1E9A : 377C 8000 059C      	MOVE.w	#$8000,FAC2_e(a3)			; set exponent for 0.5
    5675/    1EA0 : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; sign compare = sign
    5676/    1EA6 : 6100 FAA6           	BSR		LAB_ADD				; add the 0.5 to FAC1 (round FAC1)
    5677/    1EAA :                     
    5678/    1EAA :                     LAB_29C3
    5679/    1EAA : 6100 FE78           	BSR		LAB_2831				; convert FAC1 floating to fixed
    5680/    1EAE :                     								; result in d0 and Itemp
    5681/    1EAE : 7401                	MOVEQ		#$01,d2				; set default digits before dp = 1
    5682/    1EB0 : 102B 05AC           	MOVE.b	numexp(a3),d0			; get number exponent count
    5683/    1EB4 : D03C 0008           	ADD.b		#8,d0					; allow 7 digits before point
    5684/    1EB8 : 6B0C                	BMI.s		LAB_29D9				; if -ve then 1 digit before dp
    5685/    1EBA :                     
    5686/    1EBA : B03C 0009           	CMP.b		#$09,d0				; d0>=9 if n>=1E7
    5687/    1EBE : 6406                	BCC.s		LAB_29D9				; branch if >= $09
    5688/    1EC0 :                     
    5689/    1EC0 :                     								; < $08
    5690/    1EC0 : 5300                	SUBQ.b	#1,d0					; take 1 from digit count
    5691/    1EC2 : 1400                	MOVE.b	d0,d2					; copy byte
    5692/    1EC4 : 7002                	MOVEQ		#$02,d0				; set exponent adjust
    5693/    1EC6 :                     LAB_29D9
    5694/    1EC6 : 7200                	MOVEQ		#0,d1					; set output string index
    5695/    1EC8 : 5500                	SUBQ.b	#2,d0					; -2
    5696/    1ECA : 1740 05AD           	MOVE.b	d0,expcnt(a3)			; save exponent adjust
    5697/    1ECE : 1742 05AC           	MOVE.b	d2,numexp(a3)			; save digits before dp count
    5698/    1ED2 : 1002                	MOVE.b	d2,d0					; copy digits before dp count
    5699/    1ED4 : 6702                	BEQ.s		LAB_29E4				; branch if no digits before dp
    5700/    1ED6 :                     
    5701/    1ED6 : 6A14                	BPL.s		LAB_29F7				; branch if digits before dp
    5702/    1ED8 :                     
    5703/    1ED8 :                     LAB_29E4
    5704/    1ED8 : 5281                	ADDQ.l	#1,d1					; increment index
    5705/    1EDA : 13BC 002E 1000      	MOVE.b	#'.',(a1,d1.w)			; save to output string
    5706/    1EE0 :                     
    5707/    1EE0 : 4A02                	TST.b		d2					; test digits before dp count
    5708/    1EE2 : 6708                	BEQ.s		LAB_29F7				; branch if no digits before dp
    5709/    1EE4 :                     
    5710/    1EE4 : 5281                	ADDQ.l	#1,d1					; increment index
    5711/    1EE6 : 13BC 0030 1000      	MOVE.b	#'0',(a1,d1.w)			; save to output string
    5712/    1EEC :                     LAB_29F7
    5713/    1EEC : 7400                	MOVEQ		#0,d2					; clear index (point to 1,000,000)
    5714/    1EEE : 7080                	MOVEQ		#$80-$100,d0			; set output character
    5715/    1EF0 :                     LAB_29FB
    5716/    1EF0 : 41FA 1122           	LEA		LAB_2A9A(pc),a0			; get base of table
    5717/    1EF4 : 2630 2000           	MOVE.l	(a0,d2.w),d3			; get table value
    5718/    1EF8 :                     LAB_29FD
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 100 - 10/11/2023 16:23:32


    5719/    1EF8 : 5200                	ADDQ.b	#1,d0					; increment output character
    5720/    1EFA : D7AB 042A           	ADD.l		d3,Itemp(a3)			; add to (now fixed) mantissa
    5721/    1EFE : 0800 0007           	BTST		#7,d0					; set test sense (z flag only)
    5722/    1F02 : 6504                	BCS.s		LAB_2A18				; did carry so has wrapped past zero
    5723/    1F04 :                     
    5724/    1F04 : 67F2                	BEQ.s		LAB_29FD				; no wrap and +ve test so try again
    5725/    1F06 :                     
    5726/    1F06 : 6002                	BRA.s		LAB_2A1A				; found this digit
    5727/    1F08 :                     
    5728/    1F08 :                     LAB_2A18
    5729/    1F08 : 66EE                	BNE.s		LAB_29FD				; wrap and -ve test so try again
    5730/    1F0A :                     
    5731/    1F0A :                     LAB_2A1A
    5732/    1F0A : 6406                	BCC.s		LAB_2A21				; branch if +ve test result
    5733/    1F0C :                     
    5734/    1F0C : 4400                	NEG.b		d0					; negate the digit number
    5735/    1F0E : D03C 000B           	ADD.b		#$0B,d0				; and subtract from 11 decimal
    5736/    1F12 :                     LAB_2A21
    5737/    1F12 : D03C 002F           	ADD.b		#$2F,d0				; add "0"-1 to result
    5738/    1F16 : 5842                	ADDQ.w	#4,d2					; increment index to next less power of ten
    5739/    1F18 : 5241                	ADDQ.w	#1,d1					; increment output string index
    5740/    1F1A : 1600                	MOVE.b	d0,d3					; copy character to d3
    5741/    1F1C : C63C 007F           	AND.b		#$7F,d3				; mask out top bit
    5742/    1F20 : 1383 1000           	MOVE.b	d3,(a1,d1.w)			; save to output string
    5743/    1F24 : 042B 0001 05AC      	SUB.b		#1,numexp(a3)			; decrement # of characters before the dp
    5744/    1F2A : 6608                	BNE.s		LAB_2A3B				; branch if still characters to do
    5745/    1F2C :                     
    5746/    1F2C :                     								; else output the point
    5747/    1F2C : 5281                	ADDQ.l	#1,d1					; increment index
    5748/    1F2E : 13BC 002E 1000      	MOVE.b	#'.',(a1,d1.w)			; save to output string
    5749/    1F34 :                     LAB_2A3B
    5750/    1F34 : C03C 0080           	AND.b		#$80,d0				; mask test sense bit
    5751/    1F38 : 0A00 0080           	EORI.b	#$80,d0				; invert it
    5752/    1F3C : B43C 001C           	CMP.b		#LAB_2A9B-LAB_2A9A,d2		; compare table index with max+4
    5753/    1F40 : 66AE                	BNE.s		LAB_29FB				; loop if not max
    5754/    1F42 :                     
    5755/    1F42 :                     								; now remove trailing zeroes
    5756/    1F42 :                     LAB_2A4B
    5757/    1F42 : 1031 1000           	MOVE.b	(a1,d1.w),d0			; get character from output string
    5758/    1F46 : 5381                	SUBQ.l	#1,d1					; decrement output string index
    5759/    1F48 : B03C 0030           	CMP.b		#'0',d0				; compare with "0"
    5760/    1F4C : 67F4                	BEQ.s		LAB_2A4B				; loop until non "0" character found
    5761/    1F4E :                     
    5762/    1F4E : B03C 002E           	CMP.b		#'.',d0				; compare with "."
    5763/    1F52 : 6702                	BEQ.s		LAB_2A58				; branch if was dp
    5764/    1F54 :                     
    5765/    1F54 :                     								; else restore last character
    5766/    1F54 : 5281                	ADDQ.l	#1,d1					; increment output string index
    5767/    1F56 :                     LAB_2A58
    5768/    1F56 : 13BC 002B 1002      	MOVE.b	#'+',2(a1,d1.w)			; save character "+" to output string
    5769/    1F5C : 4A2B 05AD           	TST.b		expcnt(a3)				; test exponent count
    5770/    1F60 : 6738                	BEQ.s		LAB_2A8C				; if zero go set null terminator & exit
    5771/    1F62 :                     
    5772/    1F62 :                     								; exponent isn't zero so write exponent
    5773/    1F62 : 6A0A                	BPL.s		LAB_2A68				; branch if exponent count +ve
    5774/    1F64 :                     
    5775/    1F64 : 13BC 002D 1002      	MOVE.b	#'-',2(a1,d1.w)			; save character "-" to output string
    5776/    1F6A : 442B 05AD           	NEG.b		expcnt(a3)				; convert -ve to +ve
    5777/    1F6E :                     LAB_2A68
    5778/    1F6E : 13BC 0045 1001      	MOVE.b	#'E',1(a1,d1.w)			; save character "E" to output string
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 101 - 10/11/2023 16:23:32


    5779/    1F74 : 142B 05AD           	MOVE.b	expcnt(a3),d2			; get exponent count
    5780/    1F78 : 702F                	MOVEQ		#$2F,d0				; one less than "0" character
    5781/    1F7A :                     LAB_2A74
    5782/    1F7A : 5200                	ADDQ.b	#1,d0					; increment 10's character
    5783/    1F7C : 943C 000A           	SUB.b		#$0A,d2				; subtract 10 from exponent count
    5784/    1F80 : 64F8                	BCC.s		LAB_2A74				; loop while still >= 0
    5785/    1F82 :                     
    5786/    1F82 : D43C 003A           	ADD.b		#$3A,d2				; add character ":", $30+$0A, result is 10-value
    5787/    1F86 : 1380 1003           	MOVE.b	d0,3(a1,d1.w)			; save 10's character to output string
    5788/    1F8A : 1382 1004           	MOVE.b	d2,4(a1,d1.w)			; save 1's character to output string
    5789/    1F8E : 13BC 0000 1005      	MOVE.b	#0,5(a1,d1.w)			; save null terminator after last character
    5790/    1F94 : 600A                	BRA.s		LAB_2A91				; go set string pointer (a0) and exit
    5791/    1F96 :                     
    5792/    1F96 :                     LAB_2A89
    5793/    1F96 : 1380 1000           	MOVE.b	d0,(a1,d1.w)			; save last character to output string
    5794/    1F9A :                     LAB_2A8C
    5795/    1F9A : 13BC 0000 1001      	MOVE.b	#0,1(a1,d1.w)			; save null terminator after last character
    5796/    1FA0 :                     LAB_2A91
    5797/    1FA0 : 2049                	MOVEA.l	a1,a0					; set result string pointer (a0)
    5798/    1FA2 : 4E75                	RTS
    5799/    1FA4 :                     
    5800/    1FA4 :                     
    5801/    1FA4 :                     ;************************************************************************************
    5802/    1FA4 :                     ;
    5803/    1FA4 :                     ; fast compare FAC1 with FAC2
    5804/    1FA4 :                     ; assumes both are +ve and FAC2>0
    5805/    1FA4 :                     ; returns d0=+1 C=0 if FAC1 > FAC2
    5806/    1FA4 :                     ; returns d0= 0 C=0 if FAC1 = FAC2
    5807/    1FA4 :                     ; returns d0=-1 C=1 if FAC1 < FAC2
    5808/    1FA4 :                     
    5809/    1FA4 :                     LAB_27F0
    5810/    1FA4 : 7000                	MOVEQ		#0,d0					; set for FAC1 = FAC2
    5811/    1FA6 : 122B 059C           	MOVE.b	FAC2_e(a3),d1			; get FAC2 exponent
    5812/    1FAA : B22B 0594           	CMP.b		FAC1_e(a3),d1			; compare FAC1 exponent with FAC2 exponent
    5813/    1FAE : 660A                	BNE.s		LAB_27F1				; branch if different
    5814/    1FB0 :                     
    5815/    1FB0 : 222B 0598           	MOVE.l	FAC2_m(a3),d1			; get FAC2 mantissa
    5816/    1FB4 : B2AB 0590           	CMP.l		FAC1_m(a3),d1			; compare mantissas
    5817/    1FB8 : 6708                	BEQ.s		LAB_27F3				; exit if mantissas equal
    5818/    1FBA :                     
    5819/    1FBA :                     LAB_27F1
    5820/    1FBA : 6504                	BCS.s		LAB_27F2				; if FAC1 > FAC2 return d0=+1,C=0
    5821/    1FBC :                     
    5822/    1FBC : 5380                	SUBQ.l	#1,d0					; else FAC1 < FAC2 return d0=-1,C=1
    5823/    1FBE : 4E75                	RTS
    5824/    1FC0 :                     
    5825/    1FC0 :                     LAB_27F2
    5826/    1FC0 : 5280                	ADDQ.l	#1,d0
    5827/    1FC2 :                     LAB_27F3
    5828/    1FC2 : 4E75                	RTS
    5829/    1FC4 :                     
    5830/    1FC4 :                     
    5831/    1FC4 :                     ;************************************************************************************
    5832/    1FC4 :                     ;
    5833/    1FC4 :                     ; make FAC1 = 1
    5834/    1FC4 :                     
    5835/    1FC4 :                     LAB_POON
    5836/    1FC4 : 277C 8000 0000      	MOVE.l	#$80000000,FAC1_m(a3)		; 1 mantissa
             1FCA : 0590             
    5837/    1FCC : 377C 8100 0594      	MOVE.w	#$8100,FAC1_e(a3)			; 1 exonent & sign
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 102 - 10/11/2023 16:23:32


    5838/    1FD2 : 4E75                	RTS
    5839/    1FD4 :                     
    5840/    1FD4 :                     
    5841/    1FD4 :                     ;************************************************************************************
    5842/    1FD4 :                     ;
    5843/    1FD4 :                     ; make FAC1 = 0
    5844/    1FD4 :                     
    5845/    1FD4 :                     LAB_POZE
    5846/    1FD4 : 7000                	MOVEQ		#0,d0					; clear longword
    5847/    1FD6 : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; 0 mantissa
    5848/    1FDA : 3740 0594           	MOVE.w	d0,FAC1_e(a3)			; 0 exonent & sign
    5849/    1FDE : 4E75                	RTS
    5850/    1FE0 :                     
    5851/    1FE0 :                     
    5852/    1FE0 :                     ;************************************************************************************
    5853/    1FE0 :                     ;
    5854/    1FE0 :                     ; perform power function
    5855/    1FE0 :                     ; the number is in FAC2, the power is in FAC1
    5856/    1FE0 :                     ; no longer trashes Itemp
    5857/    1FE0 :                     
    5858/    1FE0 :                     LAB_POWER
    5859/    1FE0 : 4A2B 0594           	TST.b		FAC1_e(a3)				; test power
    5860/    1FE4 : 67DE                	BEQ.s		LAB_POON				; if zero go return 1
    5861/    1FE6 :                     
    5862/    1FE6 : 4A2B 059C           	TST.b		FAC2_e(a3)				; test number
    5863/    1FEA : 67E8                	BEQ.s		LAB_POZE				; if zero go return 0
    5864/    1FEC :                     
    5865/    1FEC : 1F2B 059D           	MOVE.b	FAC2_s(a3),-(sp)			; save number sign
    5866/    1FF0 : 6A20                	BPL.s		LAB_POWP				; power of positive number
    5867/    1FF2 :                     
    5868/    1FF2 : 7200                	MOVEQ		#0,d1					; clear d1
    5869/    1FF4 : 1741 059D           	MOVE.b	d1,FAC2_s(a3)			; make sign +ve
    5870/    1FF8 :                     
    5871/    1FF8 :                     								; number sign was -ve and can only be raised to
    5872/    1FF8 :                     								; an integer power which gives an x +j0 result,
    5873/    1FF8 :                     								; else do 'function call' error
    5874/    1FF8 : 122B 0594           	MOVE.b	FAC1_e(a3),d1			; get power exponent
    5875/    1FFC : 927C 0080           	SUB.w		#$80,d1				; normalise to .5
    5876/    2000 : 6300 E216           	BLS		LAB_FCER				; if 0<power<1 then do 'function call' error
    5877/    2004 :                     
    5878/    2004 :                     								; now shift all the integer bits out
    5879/    2004 : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get power mantissa
    5880/    2008 : E3A0                	ASL.l		d1,d0					; shift mantissa
    5881/    200A : 6600 E20C           	BNE		LAB_FCER				; if power<>INT(power) then do 'function call'
    5882/    200E :                     								; error
    5883/    200E :                     
    5884/    200E : 6502                	BCS.s		LAB_POWP				; if integer value odd then leave result -ve
    5885/    2010 :                     
    5886/    2010 : 1E80                	MOVE.b	d0,(sp)				; save result sign +ve
    5887/    2012 :                     LAB_POWP
    5888/    2012 : 2F2B 0590           	MOVE.l	FAC1_m(a3),-(sp)			; save power mantissa
    5889/    2016 : 3F2B 0594           	MOVE.w	FAC1_e(a3),-(sp)			; save power sign & exponent
    5890/    201A :                     
    5891/    201A : 6100 FC70           	BSR		LAB_279B				; copy number to FAC1
    5892/    201E : 6100 F9E0           	BSR		LAB_LOG				; find log of number
    5893/    2022 :                     
    5894/    2022 : 301F                	MOVE.w	(sp)+,d0				; get power sign & exponent
    5895/    2024 : 275F 0598           	MOVE.l	(sp)+,FAC2_m(a3)			; get power mantissa
    5896/    2028 : 3740 059C           	MOVE.w	d0,FAC2_e(a3)			; save sign & exponent to FAC2
    5897/    202C : 1740 059E           	MOVE.b	d0,FAC_sc(a3)			; save sign as sign compare
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 103 - 10/11/2023 16:23:32


    5898/    2030 : 102B 0595           	MOVE.b	FAC1_s(a3),d0			; get FAC1 sign
    5899/    2034 : B12B 059E           	EOR.b		d0,FAC_sc(a3)			; make sign compare (FAC1_s EOR FAC2_s)
    5900/    2038 :                     
    5901/    2038 : 6100 FAB8           	BSR		LAB_MULTIPLY			; multiply by power
    5902/    203C : 6158                	BSR.s		LAB_EXP				; find exponential
    5903/    203E : 175F 0595           	MOVE.b	(sp)+,FAC1_s(a3)			; restore number sign
    5904/    2042 : 4E75                	RTS
    5905/    2044 :                     
    5906/    2044 :                     
    5907/    2044 :                     ;************************************************************************************
    5908/    2044 :                     ;
    5909/    2044 :                     ; do - FAC1
    5910/    2044 :                     
    5911/    2044 :                     LAB_GTHAN
    5912/    2044 : 4A2B 0594           	TST.b		FAC1_e(a3)				; test for non zero FAC1
    5913/    2048 : 6706                	BEQ.s		RTS_020				; branch if null
    5914/    204A :                     
    5915/    204A : 0A2B 0080 0595      	EORI.b	#$80,FAC1_s(a3)			; (else) toggle FAC1 sign bit
    5916/    2050 :                     RTS_020
    5917/    2050 : 4E75                	RTS
    5918/    2052 :                     
    5919/    2052 :                     
    5920/    2052 :                     ;************************************************************************************
    5921/    2052 :                     ;
    5922/    2052 :                     								; return +1
    5923/    2052 :                     LAB_EX1
    5924/    2052 : 277C 8000 0000      	MOVE.l	#$80000000,FAC1_m(a3)		; +1 mantissa
             2058 : 0590             
    5925/    205A : 377C 8100 0594      	MOVE.w	#$8100,FAC1_e(a3)			; +1 sign & exponent
    5926/    2060 : 4E75                	RTS
    5927/    2062 :                     								; do over/under flow
    5928/    2062 :                     LAB_EXOU
    5929/    2062 : 4A2B 0595           	TST.b		FAC1_s(a3)				; test sign
    5930/    2066 : 6A00 E1AC           	BPL		LAB_OFER				; was +ve so do overflow error
    5931/    206A :                     
    5932/    206A :                     								; else underflow so return zero
    5933/    206A : 7000                	MOVEQ		#0,d0					; clear longword
    5934/    206C : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; 0 mantissa
    5935/    2070 : 3740 0594           	MOVE.w	d0,FAC1_e(a3)			; 0 sign & exponent
    5936/    2074 : 4E75                	RTS
    5937/    2076 :                     								; fraction was zero so do 2^n
    5938/    2076 :                     LAB_EXOF
    5939/    2076 : 277C 8000 0000      	MOVE.l	#$80000000,FAC1_m(a3)		; +n mantissa
             207C : 0590             
    5940/    207E : 177C 0000 0595      	MOVE.b	#0,FAC1_s(a3)			; clear sign
    5941/    2084 : 4A2B 05B4           	TST.b		cosout(a3)				; test sign flag
    5942/    2088 : 6A02                	BPL.s		LAB_EXOL				; branch if +ve
    5943/    208A :                     
    5944/    208A : 4481                	NEG.l		d1					; else do 1/2^n
    5945/    208C :                     LAB_EXOL
    5946/    208C : D23C 0081           	ADD.b		#$81,d1				; adjust exponent
    5947/    2090 : 1741 0594           	MOVE.b	d1,FAC1_e(a3)			; save exponent
    5948/    2094 : 4E75                	RTS
    5949/    2096 :                     
    5950/    2096 :                     ; perform EXP()	(x^e)
    5951/    2096 :                     ; valid input range is -88 to +88
    5952/    2096 :                     
    5953/    2096 :                     LAB_EXP
    5954/    2096 : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get exponent
    5955/    209A : 67B6                	BEQ.s		LAB_EX1				; return 1 for zero in
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 104 - 10/11/2023 16:23:32


    5956/    209C :                     
    5957/    209C : B03C 0064           	CMP.b		#$64,d0				; compare exponent with min
    5958/    20A0 : 65B0                	BCS.s		LAB_EX1				; if smaller just return 1
    5959/    20A2 :                     
    5960/    20A2 :                     ;	MOVEM.l	d1-d6/a0,-(sp)			; save the registers
    5961/    20A2 : 177C 0000 05B4      	MOVE.b	#0,cosout(a3)			; flag +ve number
    5962/    20A8 : 222B 0590           	MOVE.l	FAC1_m(a3),d1			; get mantissa
    5963/    20AC : B03C 0087           	CMP.b		#$87,d0				; compare exponent with max
    5964/    20B0 : 62B0                	BHI.s		LAB_EXOU				; go do over/under flow if greater
    5965/    20B2 :                     
    5966/    20B2 : 6608                	BNE.s		LAB_EXCM				; branch if less
    5967/    20B4 :                     
    5968/    20B4 :                     								; else is 2^7
    5969/    20B4 : B2BC B00F 33C7      	CMP.l		#$B00F33C7,d1			; compare mantissa with n*2^7 max
    5970/    20BA : 64A6                	BCC.s		LAB_EXOU				; if => go over/underflow
    5971/    20BC :                     
    5972/    20BC :                     LAB_EXCM
    5973/    20BC : 4A2B 0595           	TST.b		FAC1_s(a3)				; test sign
    5974/    20C0 : 6A0C                	BPL.s		LAB_EXPS				; branch if arg +ve
    5975/    20C2 :                     
    5976/    20C2 : 177C 00FF 05B4      	MOVE.b	#$FF,cosout(a3)			; flag -ve number
    5977/    20C8 : 177C 0000 0595      	MOVE.b	#0,FAC1_s(a3)			; take absolute value
    5978/    20CE :                     LAB_EXPS
    5979/    20CE :                     								; now do n/LOG(2)
    5980/    20CE : 277C B8AA 3B29      	MOVE.l	#$B8AA3B29,FAC2_m(a3)		; 1/LOG(2) mantissa
             20D4 : 0598             
    5981/    20D6 : 377C 8100 059C      	MOVE.w	#$8100,FAC2_e(a3)			; 1/LOG(2) exponent & sign
    5982/    20DC : 177C 0000 059E      	MOVE.b	#0,FAC_sc(a3)			; we know they're both +ve
    5983/    20E2 : 6100 FA0E           	BSR		LAB_MULTIPLY			; effectively divide by log(2)
    5984/    20E6 :                     
    5985/    20E6 :                     								; max here is +/- 127
    5986/    20E6 :                     								; now separate integer and fraction
    5987/    20E6 : 177C 0000 05D9      	MOVE.b	#0,tpower(a3)			; clear exponent add byte
    5988/    20EC : 1A2B 0594           	MOVE.b	FAC1_e(a3),d5			; get exponent
    5989/    20F0 : 9A3C 0080           	SUB.b		#$80,d5				; normalise
    5990/    20F4 : 6324                	BLS.s		LAB_ESML				; branch if < 1 (d5 is 0 or -ve)
    5991/    20F6 :                     
    5992/    20F6 :                     								; result is > 1
    5993/    20F6 : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get mantissa
    5994/    20FA : 2200                	MOVE.l	d0,d1					; copy it
    5995/    20FC : 2C05                	MOVE.l	d5,d6					; copy normalised exponent
    5996/    20FE :                     
    5997/    20FE : 4446                	NEG.w		d6					; make -ve
    5998/    2100 : DC7C 0020           	ADD.w		#32,d6				; is now 32-d6
    5999/    2104 : ECA9                	LSR.l		d6,d1					; just integer bits
    6000/    2106 : 1741 05D9           	MOVE.b	d1,tpower(a3)			; set exponent add byte
    6001/    210A :                     
    6002/    210A : EBA8                	LSL.l		d5,d0					; shift out integer bits
    6003/    210C : 6700 FF68           	BEQ		LAB_EXOF				; fraction is zero so do 2^n
    6004/    2110 :                     
    6005/    2110 : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; fraction to FAC1
    6006/    2114 : 377C 8000 0594      	MOVE.w	#$8000,FAC1_e(a3)			; set exponent & sign
    6007/    211A :                     
    6008/    211A :                     								; multiple was < 1
    6009/    211A :                     LAB_ESML
    6010/    211A : 277C B172 17F8      	MOVE.l	#$B17217F8,FAC2_m(a3)		; LOG(2) mantissa
             2120 : 0598             
    6011/    2122 : 377C 8000 059C      	MOVE.w	#$8000,FAC2_e(a3)			; LOG(2) exponent & sign
    6012/    2128 : 177C 0000 059E      	MOVE.b	#0,FAC_sc(a3)			; clear sign compare
    6013/    212E : 6100 F9C2           	BSR		LAB_MULTIPLY			; multiply by log(2)
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 105 - 10/11/2023 16:23:32


    6014/    2132 :                     
    6015/    2132 : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get mantissa
    6016/    2136 : 1A2B 0594           	MOVE.b	FAC1_e(a3),d5			; get exponent
    6017/    213A : 9A7C 0082           	SUB.w		#$82,d5				; normalise and -2 (result is -1 to -30)
    6018/    213E : 4445                	NEG.w		d5					; make +ve
    6019/    2140 : EAA8                	LSR.l		d5,d0					; shift for 2 integer bits
    6020/    2142 :                     
    6021/    2142 :                     ; d0 = arg
    6022/    2142 :                     ; d6 = x, d1 = y
    6023/    2142 :                     ; d2 = x1, d3 = y1
    6024/    2142 :                     ; d4 = shift count
    6025/    2142 :                     ; d5 = loop count
    6026/    2142 :                     								; now do cordic set-up
    6027/    2142 : 7200                	MOVEQ		#0,d1					; y = 0
    6028/    2144 : 2C3C 26A3 D110      	MOVE.l	#KFCTSEED,d6			; x = 1 with jkh inverse factored out
    6029/    214A : 41FA 0D2C           	LEA		TAB_HTHET(pc),a0			; get pointer to hyperbolic arctan table
    6030/    214E : 7800                	MOVEQ		#0,d4					; clear shift count
    6031/    2150 :                      
    6032/    2150 :                     								; cordic loop, shifts 4 and 13 (and 39
    6033/    2150 :                     								; if it went that far) need to be repeated
    6034/    2150 : 7A03                	MOVEQ		#3,d5					; 4 loops
    6035/    2152 : 6136                	BSR.s		LAB_EXCC				; do loops 1 through 4
    6036/    2154 : 5948                	SUBQ.w	#4,a0					; do table entry again
    6037/    2156 : 5384                	SUBQ.l	#1,d4					; do shift count again
    6038/    2158 : 7A09                	MOVEQ		#9,d5					; 10 loops
    6039/    215A : 612E                	BSR.s		LAB_EXCC				; do loops 4 (again) through 13
    6040/    215C : 5948                	SUBQ.w	#4,a0					; do table entry again
    6041/    215E : 5384                	SUBQ.l	#1,d4					; do shift count again
    6042/    2160 : 7A12                	MOVEQ		#18,d5				; 19 loops
    6043/    2162 : 6126                	BSR.s		LAB_EXCC				; do loops 13 (again) through 31
    6044/    2164 :                      
    6045/    2164 :                     								; now get the result
    6046/    2164 : 4A2B 05B4           	TST.b		cosout(a3)				; test sign flag
    6047/    2168 : 6A06                	BPL.s		LAB_EXPL				; branch if +ve
    6048/    216A :                     
    6049/    216A : 4481                	NEG.l		d1					; do -y
    6050/    216C : 442B 05D9           	NEG.b		tpower(a3)				; do -exp
    6051/    2170 :                     LAB_EXPL
    6052/    2170 : 7083                	MOVEQ		#$83-$100,d0			; set exponent
    6053/    2172 : DC81                	ADD.l		d1,d6					; y = y +/- x
    6054/    2174 : 6B06                	BMI.s		LAB_EXRN				; branch if result normal
    6055/    2176 :                     
    6056/    2176 :                     LAB_EXNN
    6057/    2176 : 5380                	SUBQ.l	#1,d0					; decrement exponent
    6058/    2178 : DC86                	ADD.l		d6,d6					; shift mantissa
    6059/    217A : 6AFA                	BPL.s		LAB_EXNN				; loop if not normal
    6060/    217C :                     
    6061/    217C :                     LAB_EXRN
    6062/    217C : 2746 0590           	MOVE.l	d6,FAC1_m(a3)			; save exponent result
    6063/    2180 : D02B 05D9           	ADD.b		tpower(a3),d0			; add integer part
    6064/    2184 : 1740 0594           	MOVE.b	d0,FAC1_e(a3)			; save exponent
    6065/    2188 :                     ;	MOVEM.l	(sp)+,d1-d6/a0			; restore registers
    6066/    2188 : 4E75                	RTS
    6067/    218A :                      
    6068/    218A :                     								; cordic loop
    6069/    218A :                     LAB_EXCC
    6070/    218A : 5284                	ADDQ.l	#1,d4					; increment shift count
    6071/    218C : 2406                	MOVE.l	d6,d2					; x1 = x
    6072/    218E : E8A2                	ASR.l		d4,d2					; x1 >> n
    6073/    2190 : 2601                	MOVE.l	d1,d3					; y1 = y
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 106 - 10/11/2023 16:23:32


    6074/    2192 : E8A3                	ASR.l		d4,d3					; y1 >> n
    6075/    2194 : 4A80                	TST.l		d0					; test arg
    6076/    2196 : 6B0C                	BMI.s		LAB_EXAD				; branch if -ve
    6077/    2198 :                     
    6078/    2198 : D282                	ADD.l		d2,d1					; y = y + x1
    6079/    219A : DC83                	ADD.l		d3,d6					; x = x + y1
    6080/    219C : 9098                	SUB.l		(a0)+,d0				; arg = arg - atnh(a0)
    6081/    219E : 51CD FFEA           	DBF		d5,LAB_EXCC				; decrement and loop if not done
    6082/    21A2 :                     
    6083/    21A2 : 4E75                	RTS
    6084/    21A4 :                     
    6085/    21A4 :                     LAB_EXAD
    6086/    21A4 : 9282                	SUB.l		d2,d1					; y = y - x1
    6087/    21A6 : 9C83                	SUB.l		d3,d6					; x = x + y1
    6088/    21A8 : D098                	ADD.l		(a0)+,d0				; arg = arg + atnh(a0)
    6089/    21AA : 51CD FFDE           	DBF		d5,LAB_EXCC				; decrement and loop if not done
    6090/    21AE :                     
    6091/    21AE : 4E75                	RTS
    6092/    21B0 :                     
    6093/    21B0 :                     
    6094/    21B0 :                     ;************************************************************************************
    6095/    21B0 :                     ;
    6096/    21B0 :                     ; RND(n), 32 bit Galois version. make n=0 for 19th next number in sequence or n<>0
    6097/    21B0 :                     ; to get 19th next number in sequence after seed n. This version of the PRNG uses
    6098/    21B0 :                     ; the Galois method and a sample of 65536 bytes produced gives the following values.
    6099/    21B0 :                     
    6100/    21B0 :                     ; Entropy = 7.997442 bits per byte
    6101/    21B0 :                     ; Optimum compression would reduce these 65536 bytes by 0 percent
    6102/    21B0 :                     
    6103/    21B0 :                     ; Chi square distribution for 65536 samples is 232.01, and
    6104/    21B0 :                     ; randomly would exceed this value 75.00 percent of the time
    6105/    21B0 :                     
    6106/    21B0 :                     ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
    6107/    21B0 :                     ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
    6108/    21B0 :                     ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
    6109/    21B0 :                     
    6110/    21B0 :                     LAB_RND
    6111/    21B0 : 4A2B 0594           	TST.b		FAC1_e(a3)				; get FAC1 exponent
    6112/    21B4 : 6708                	BEQ.s		NextPRN				; do next random number if zero
    6113/    21B6 :                     
    6114/    21B6 :                     								; else get seed into random number store
    6115/    21B6 : 41EB 05A0           	LEA		PRNlword(a3),a0			; set PRNG pointer
    6116/    21BA : 6100 FAAA           	BSR		LAB_2778				; pack FAC1 into (a0)
    6117/    21BE :                     NextPRN
    6118/    21BE : 72AF                	MOVEQ		#$AF-$100,d1			; set EOR value
    6119/    21C0 : 7412                	MOVEQ		#18,d2				; do this 19 times
    6120/    21C2 : 202B 05A0           	MOVE.l	PRNlword(a3),d0			; get current
    6121/    21C6 :                     Ninc0
    6122/    21C6 : D080                	ADD.l		d0,d0					; shift left 1 bit
    6123/    21C8 : 6402                	BCC.s		Ninc1					; branch if bit 32 not set
    6124/    21CA :                     
    6125/    21CA : B300                	EOR.b		d1,d0					; do Galois LFSR feedback
    6126/    21CC :                     Ninc1
    6127/    21CC : 51CA FFF8           	DBF		d2,Ninc0				; loop
    6128/    21D0 :                     
    6129/    21D0 : 2740 05A0           	MOVE.l	d0,PRNlword(a3)			; save back to seed word
    6130/    21D4 : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; copy to FAC1 mantissa
    6131/    21D8 : 377C 8000 0594      	MOVE.w	#$8000,FAC1_e(a3)			; set the exponent and clear the sign
    6132/    21DE : 6000 F7EA           	BRA		LAB_24D5				; normalise FAC1 & return
    6133/    21E2 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 107 - 10/11/2023 16:23:32


    6134/    21E2 :                     
    6135/    21E2 :                     ;************************************************************************************
    6136/    21E2 :                     ;
    6137/    21E2 :                     ; cordic TAN(x) routine, TAN(x) = SIN(x)/COS(x)
    6138/    21E2 :                     ; x = angle in radians
    6139/    21E2 :                     
    6140/    21E2 :                     LAB_TAN
    6141/    21E2 : 6138                	BSR.s		LAB_SIN				; go do SIN/COS cordic compute
    6142/    21E4 : 376B 0594 059C      	MOVE.w	FAC1_e(a3),FAC2_e(a3)		; copy exponent & sign from FAC1 to FAC2
    6143/    21EA : 276B 0590 0598      	MOVE.l	FAC1_m(a3),FAC2_m(a3)		; copy FAC1 mantissa to FAC2 mantissa
    6144/    21F0 : 2741 0590           	MOVE.l	d1,FAC1_m(a3)			; get COS(x) mantissa
    6145/    21F4 : 1743 0594           	MOVE.b	d3,FAC1_e(a3)			; get COS(x) exponent
    6146/    21F8 : 6700 E01A           	BEQ		LAB_OFER				; do overflow if COS = 0
    6147/    21FC :                     
    6148/    21FC : 6100 F7CC           	BSR		LAB_24D5				; normalise FAC1
    6149/    2200 : 6000 F97C           	BRA		LAB_DIVIDE				; do FAC2/FAC1 and return, FAC_sc set by SIN
    6150/    2204 :                     								; COS calculation
    6151/    2204 :                     
    6152/    2204 :                     
    6153/    2204 :                     ;************************************************************************************
    6154/    2204 :                     ;
    6155/    2204 :                     ; cordic SIN(x), COS(x) routine
    6156/    2204 :                     ; x = angle in radians
    6157/    2204 :                     
    6158/    2204 :                     LAB_COS
    6159/    2204 : 277C C90F DAA3      	MOVE.l	#$C90FDAA3,FAC2_m(a3)		; pi/2 mantissa (LSB is rounded up so
             220A : 0598             
    6160/    220C :                     								; COS(PI/2)=0)
    6161/    220C : 377C 8100 059C      	MOVE.w	#$8100,FAC2_e(a3)			; pi/2 exponent and sign
    6162/    2212 : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; sign = FAC1 sign (b7)
    6163/    2218 : 6100 F734           	BSR		LAB_ADD				; add FAC2 to FAC1, adjust for COS(x)
    6164/    221C :                     
    6165/    221C :                     
    6166/    221C :                     ;************************************************************************************
    6167/    221C :                     ;
    6168/    221C :                     ; SIN/COS cordic calculator
    6169/    221C :                     
    6170/    221C :                     LAB_SIN
    6171/    221C : 177C 0000 05B4      	MOVE.b	#0,cosout(a3)			; set needed result
    6172/    2222 :                     
    6173/    2222 : 277C A2F9 836F      	MOVE.l	#$A2F9836F,FAC2_m(a3)		; 1/pi mantissa (LSB is rounded up so SIN(PI)=0)
             2228 : 0598             
    6174/    222A : 377C 7F00 059C      	MOVE.w	#$7F00,FAC2_e(a3)			; 1/pi exponent & sign
    6175/    2230 : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; sign = FAC1 sign (b7)
    6176/    2236 : 6100 F8BA           	BSR		LAB_MULTIPLY			; multiply by 1/pi
    6177/    223A :                     
    6178/    223A : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
    6179/    223E : 671C                	BEQ.s		LAB_SCZE				; branch if zero
    6180/    2240 :                     
    6181/    2240 : 41FA 0B36           	LEA		TAB_SNCO(pc),a0			; get pointer to constants table
    6182/    2244 : 2C2B 0590           	MOVE.l	FAC1_m(a3),d6			; get FAC1 mantissa
    6183/    2248 : 5300                	SUBQ.b	#1,d0					; 2 radians in 360 degrees so /2
    6184/    224A : 6710                	BEQ.s		LAB_SCZE				; branch if zero
    6185/    224C :                     
    6186/    224C : 903C 0080           	SUB.b		#$80,d0				; normalise exponent
    6187/    2250 : 6B18                	BMI.s		LAB_SCL0				; branch if < 1
    6188/    2252 :                     
    6189/    2252 :                     								; X is > 1
    6190/    2252 : B03C 0020           	CMP.b		#$20,d0				; is it >= 2^32
    6191/    2256 : 6404                	BCC.s		LAB_SCZE				; may as well do zero
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 108 - 10/11/2023 16:23:32


    6192/    2258 :                     
    6193/    2258 : E1AE                	LSL.l		d0,d6					; shift out integer part bits
    6194/    225A : 6618                	BNE.s		LAB_CORD				; if fraction go test quadrant and adjust
    6195/    225C :                     
    6196/    225C :                     								; else no fraction so do zero
    6197/    225C :                     LAB_SCZE
    6198/    225C : 7481                	MOVEQ		#$81-$100,d2			; set exponent for 1.0
    6199/    225E : 7600                	MOVEQ		#0,d3					; set exponent for 0.0
    6200/    2260 : 203C 8000 0000      	MOVE.l	#$80000000,d0			; mantissa for 1.0
    6201/    2266 : 2203                	MOVE.l	d3,d1					; mantissa for 0.0
    6202/    2268 : 6062                	BRA.s		outloop				; go output it
    6203/    226A :                     
    6204/    226A :                     								; x is < 1
    6205/    226A :                     LAB_SCL0
    6206/    226A : 4400                	NEG.b		d0					; make +ve
    6207/    226C : B03C 001E           	CMP.b		#$1E,d0				; is it <= 2^-30
    6208/    2270 : 64EA                	BCC.s		LAB_SCZE				; may as well do zero
    6209/    2272 :                     
    6210/    2272 : E0AE                	LSR.l		d0,d6					; shift out <= 2^-32 bits
    6211/    2274 :                     
    6212/    2274 :                     ; cordic calculator, argument in d6
    6213/    2274 :                     ; table pointer in a0, returns in d0-d3
    6214/    2274 :                     
    6215/    2274 :                     LAB_CORD
    6216/    2274 : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; copy as sign compare for TAN
    6217/    227A : DC86                	ADD.l		d6,d6					; shift 0.5 bit into carry
    6218/    227C : 6406                	BCC.s		LAB_LTPF				; branch if less than 0.5
    6219/    227E :                     
    6220/    227E : 0A2B 00FF 0595      	EORI.b	#$FF,FAC1_s(a3)			; toggle result sign
    6221/    2284 :                     LAB_LTPF
    6222/    2284 : DC86                	ADD.l		d6,d6					; shift 0.25 bit into carry
    6223/    2286 : 640C                	BCC.s		LAB_LTPT				; branch if less than 0.25
    6224/    2288 :                     
    6225/    2288 : 0A2B 00FF 05B4      	EORI.b	#$FF,cosout(a3)			; toggle needed result
    6226/    228E : 0A2B 00FF 059E      	EORI.b	#$FF,FAC_sc(a3)			; toggle sign compare for TAN
    6227/    2294 :                     
    6228/    2294 :                     LAB_LTPT
    6229/    2294 : E48E                	LSR.l		#2,d6					; shift the bits back (clear integer bits)
    6230/    2296 : 67C4                	BEQ.s		LAB_SCZE				; no fraction so go do zero
    6231/    2298 :                     
    6232/    2298 :                     								; set start values
    6233/    2298 : 7A01                	MOVEQ		#1,d5					; set bit count
    6234/    229A : 2028 FFFC           	MOVE.l	-4(a0),d0				; get multiply constant (1st itteration d0)
    6235/    229E : 2200                	MOVE.l	d0,d1					; 1st itteration d1
    6236/    22A0 : 9C98                	SUB.l		(a0)+,d6				; 1st always +ve so do 1st step
    6237/    22A2 : 6008                	BRA.s		mainloop				; jump into routine
    6238/    22A4 :                     
    6239/    22A4 :                     subloop
    6240/    22A4 : 9C98                	SUB.l		(a0)+,d6				; z = z - arctan(i)/2pi
    6241/    22A6 : 9083                	SUB.l		d3,d0					; x = x - y1
    6242/    22A8 : D282                	ADD.l		d2,d1					; y = y + x1
    6243/    22AA : 6012                	BRA.s		nexta					; back to main loop
    6244/    22AC :                     
    6245/    22AC :                     mainloop
    6246/    22AC : 2400                	MOVE.l	d0,d2					; x1 = x
    6247/    22AE : EAA2                	ASR.l		d5,d2					; / (2 ^ i)
    6248/    22B0 : 2601                	MOVE.l	d1,d3					; y1 = y
    6249/    22B2 : EAA3                	ASR.l		d5,d3					; / (2 ^ i)
    6250/    22B4 : 4A86                	TST.l		d6					; test sign (is 2^0 bit)
    6251/    22B6 : 6AEC                	BPL.s		subloop				; go do subtract if > 1
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 109 - 10/11/2023 16:23:32


    6252/    22B8 :                     
    6253/    22B8 : DC98                	ADD.l		(a0)+,d6				; z = z + arctan(i)/2pi
    6254/    22BA : D083                	ADD.l		d3,d0					; x = x + y1
    6255/    22BC : 9282                	SUB.l		d2,d1					; y = y + x1
    6256/    22BE :                     nexta
    6257/    22BE : 5285                	ADDQ.l	#1,d5					; i = i + 1
    6258/    22C0 : BABC 0000 001E      	CMP.l		#$1E,d5				; check end condition
    6259/    22C6 : 66E4                	BNE.s		mainloop				; loop if not all done
    6260/    22C8 :                     
    6261/    22C8 :                     								; now untangle output value
    6262/    22C8 : 7481                	MOVEQ		#$81-$100,d2			; set exponent for 0 to .99 rec.
    6263/    22CA : 2602                	MOVE.l	d2,d3					; copy it for cos output
    6264/    22CC :                     outloop
    6265/    22CC : 4A2B 05B4           	TST.b		cosout(a3)				; did we want cos output?
    6266/    22D0 : 6B04                	BMI.s		subexit				; if so skip
    6267/    22D2 :                     
    6268/    22D2 : C141                	EXG		d0,d1					; swap SIN and COS mantissas
    6269/    22D4 : C543                	EXG		d2,d3					; swap SIN and COS exponents
    6270/    22D6 :                     subexit
    6271/    22D6 : 2740 0590           	MOVE.l	d0,FAC1_m(a3)			; set result mantissa
    6272/    22DA : 1742 0594           	MOVE.b	d2,FAC1_e(a3)			; set result exponent
    6273/    22DE : 6000 F6EA           	BRA		LAB_24D5				; normalise FAC1 & return
    6274/    22E2 :                     
    6275/    22E2 :                     
    6276/    22E2 :                     
    6277/    22E2 :                     ;************************************************************************************
    6278/    22E2 :                     ;
    6279/    22E2 :                     ; perform ATN()
    6280/    22E2 :                     
    6281/    22E2 :                     LAB_ATN
    6282/    22E2 : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get FAC1 exponent
    6283/    22E6 : 6700 00AC           	BEQ		RTS_021				; ATN(0) = 0 so skip calculation
    6284/    22EA :                     
    6285/    22EA : 177C 0000 05B4      	MOVE.b	#0,cosout(a3)			; set result needed
    6286/    22F0 : B03C 0081           	CMP.b		#$81,d0				; compare exponent with 1
    6287/    22F4 : 6528                	BCS.s		LAB_ATLE				; branch if n<1
    6288/    22F6 :                     
    6289/    22F6 : 6608                	BNE.s		LAB_ATGO				; branch if n>1
    6290/    22F8 :                     
    6291/    22F8 : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get mantissa
    6292/    22FC : D080                	ADD.l		d0,d0					; shift left
    6293/    22FE : 671E                	BEQ.s		LAB_ATLE				; branch if n=1
    6294/    2300 :                     
    6295/    2300 :                     LAB_ATGO
    6296/    2300 : 277C 8000 0000      	MOVE.l	#$80000000,FAC2_m(a3)		; set mantissa for 1
             2306 : 0598             
    6297/    2308 : 377C 8100 059C      	MOVE.w	#$8100,FAC2_e(a3)			; set exponent for 1
    6298/    230E : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; sign compare = sign
    6299/    2314 : 6100 F868           	BSR		LAB_DIVIDE				; do 1/n
    6300/    2318 : 177C 00FF 05B4      	MOVE.b	#$FF,cosout(a3)			; set inverse result needed
    6301/    231E :                     LAB_ATLE
    6302/    231E : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; get FAC1 mantissa
    6303/    2322 : 123C 0082           	MOVE.b		#$82,d1				; set to correct exponent
    6304/    2326 : 922B 0594           	SUB.b		FAC1_e(a3),d1			; subtract FAC1 exponent (always <= 1)
    6305/    232A : E2A8                	LSR.l		d1,d0					; shift in two integer part bits
    6306/    232C : 41FA 0ACA           	LEA		TAB_ATNC(pc),a0			; get pointer to arctan table
    6307/    2330 : 7C00                	MOVEQ		#0,d6					; Z = 0
    6308/    2332 : 223C 4000 0000      	MOVE.l	#1<<30,d1				; y = 1
    6309/    2338 : 7A1D                	MOVEQ		#29,d5				; loop 30 times
    6310/    233A : 7801                	MOVEQ		#1,d4					; shift counter
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 110 - 10/11/2023 16:23:32


    6311/    233C : 6006                	BRA.s		LAB_ATCD				; enter loop
    6312/    233E :                     
    6313/    233E :                     LAB_ATNP
    6314/    233E : E8A2                	ASR.l		d4,d2					; x1 / 2^i
    6315/    2340 : D282                	ADD.l		d2,d1					; y = y + x1
    6316/    2342 : DC90                	ADD.l		(a0),d6				; z = z + atn(i)
    6317/    2344 :                     LAB_ATCD
    6318/    2344 : 2400                	MOVE.l	d0,d2					; x1 = x
    6319/    2346 : 2601                	MOVE.l	d1,d3					; y1 = y
    6320/    2348 : E8A3                	ASR.l		d4,d3					; y1 / 2^i
    6321/    234A :                     LAB_CATN
    6322/    234A : 9083                	SUB.l		d3,d0					; x = x - y1
    6323/    234C : 6AF0                	BPL.s		LAB_ATNP				; branch if x >= 0
    6324/    234E :                     
    6325/    234E : 2002                	MOVE.l	d2,d0					; else get x back
    6326/    2350 : 5848                	ADDQ.w	#4,a0					; increment pointer
    6327/    2352 : 5284                	ADDQ.l	#1,d4					; increment i
    6328/    2354 : E283                	ASR.l		#1,d3					; y1 / 2^i
    6329/    2356 : 51CD FFF2           	DBF		d5,LAB_CATN				; decrement and loop if not done
    6330/    235A :                     
    6331/    235A : 177C 0082 0594      	MOVE.b	#$82,FAC1_e(a3)			; set new exponent
    6332/    2360 : 2746 0590           	MOVE.l	d6,FAC1_m(a3)			; save mantissa
    6333/    2364 : 6100 F664           	BSR		LAB_24D5				; normalise FAC1
    6334/    2368 :                     
    6335/    2368 : 4A2B 05B4           	TST.b		cosout(a3)				; was it > 1 ?
    6336/    236C : 6A26                	BPL.s		RTS_021				; branch if not
    6337/    236E :                     
    6338/    236E : 1E2B 0595           	MOVE.b	FAC1_s(a3),d7			; get sign
    6339/    2372 : 177C 0000 0595      	MOVE.b	#0,FAC1_s(a3)			; clear sign
    6340/    2378 : 277C C90F DAA2      	MOVE.l	#$C90FDAA2,FAC2_m(a3)		; set -(pi/2)
             237E : 0598             
    6341/    2380 : 377C 8180 059C      	MOVE.w	#$8180,FAC2_e(a3)			; set exponent and sign
    6342/    2386 : 177C 00FF 059E      	MOVE.b	#$FF,FAC_sc(a3)			; set sign compare
    6343/    238C : 6100 F5C0           	BSR		LAB_ADD				; perform addition, FAC2 to FAC1
    6344/    2390 : 1747 0595           	MOVE.b	d7,FAC1_s(a3)			; restore sign
    6345/    2394 :                     RTS_021
    6346/    2394 : 4E75                	RTS
    6347/    2396 :                     
    6348/    2396 :                     
    6349/    2396 :                     ;************************************************************************************
    6350/    2396 :                     ;
    6351/    2396 :                     ; perform BITSET
    6352/    2396 :                     
    6353/    2396 :                     LAB_BITSET
    6354/    2396 : 6100 F496           	BSR		LAB_GADB				; get two parameters for POKE or WAIT
    6355/    239A :                     								; first parameter in a0, second in d0
    6356/    239A : B03C 0008           	CMP.b		#$08,d0				; only 0 to 7 are allowed
    6357/    239E : 6400 DE78           	BCC		LAB_FCER				; branch if > 7
    6358/    23A2 :                     
    6359/    23A2 : 01D0                	BSET		d0,(a0)				; set bit
    6360/    23A4 : 4E75                	RTS
    6361/    23A6 :                     
    6362/    23A6 :                     
    6363/    23A6 :                     ;************************************************************************************
    6364/    23A6 :                     ;
    6365/    23A6 :                     ; perform BITCLR
    6366/    23A6 :                     
    6367/    23A6 :                     LAB_BITCLR
    6368/    23A6 : 6100 F486           	BSR		LAB_GADB				; get two parameters for POKE or WAIT
    6369/    23AA :                     								; first parameter in a0, second in d0
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 111 - 10/11/2023 16:23:32


    6370/    23AA : B03C 0008           	CMP.b		#$08,d0				; only 0 to 7 are allowed
    6371/    23AE : 6400 DE68           	BCC		LAB_FCER				; branch if > 7
    6372/    23B2 :                     
    6373/    23B2 : 0190                	BCLR		d0,(a0)				; clear bit
    6374/    23B4 : 4E75                	RTS
    6375/    23B6 :                     
    6376/    23B6 :                     
    6377/    23B6 :                     ;************************************************************************************
    6378/    23B6 :                     ;
    6379/    23B6 :                     ; perform BITTST()
    6380/    23B6 :                     
    6381/    23B6 :                     LAB_BTST
    6382/    23B6 : 101D                	MOVE.b	(a5)+,d0				; increment BASIC pointer
    6383/    23B8 : 6100 F474           	BSR		LAB_GADB				; get two parameters for POKE or WAIT
    6384/    23BC :                     								; first parameter in a0, second in d0
    6385/    23BC : B03C 0008           	CMP.b		#$08,d0				; only 0 to 7 are allowed
    6386/    23C0 : 6400 DE56           	BCC		LAB_FCER				; branch if > 7
    6387/    23C4 :                     
    6388/    23C4 : 2200                	MOVE.l	d0,d1					; copy bit # to test
    6389/    23C6 : 6100 EAA4           	BSR		LAB_GBYT				; get next BASIC byte
    6390/    23CA : B03C 0029           	CMP.b		#')',d0				; is next character ")"
    6391/    23CE : 6600 DE54           	BNE		LAB_SNER				; if not ")" go do syntax error, then warm start
    6392/    23D2 :                     
    6393/    23D2 : 6100 EA96           	BSR		LAB_IGBY				; update execute pointer (to character past ")")
    6394/    23D6 : 7000                	MOVEQ		#0,d0					; set the result as zero
    6395/    23D8 : 0310                	BTST		d1,(a0)				; test bit
    6396/    23DA : 6700 F904           	BEQ		LAB_27DB				; branch if zero (already correct)
    6397/    23DE :                     
    6398/    23DE : 70FF                	MOVEQ		#-1,d0				; set for -1 result
    6399/    23E0 : 6000 F8FE           	BRA		LAB_27DB				; go do SGN tail
    6400/    23E4 :                     
    6401/    23E4 :                     
    6402/    23E4 :                     ;************************************************************************************
    6403/    23E4 :                     ;
    6404/    23E4 :                     ; perform USING$()
    6405/    23E4 :                     
    6406/    23E4 : =$0                 fsd		EQU	 0						;   (sp) format string descriptor pointer
    6407/    23E4 : =$4                 fsti	EQU	 4						;  4(sp) format string this index
    6408/    23E4 : =$6                 fsli	EQU	 6						;  6(sp) format string last index
    6409/    23E4 : =$8                 fsdpi	EQU	 8						;  8(sp) format string decimal point index
    6410/    23E4 : =$A                 fsdc	EQU	10						; 10(sp) format string decimal characters
    6411/    23E4 : =$8                 fend	EQU	12-4						;  x(sp) end-4, fsd is popped by itself
    6412/    23E4 :                     
    6413/    23E4 : ='#'                ofchr	EQU	'#'						; the overflow character
    6414/    23E4 :                     
    6415/    23E4 :                     LAB_USINGS
    6416/    23E4 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type, $80=string
    6417/    23E8 : 6A00 DDE6           	BPL		LAB_FOER				; if not string type go do format error
    6418/    23EC :                     
    6419/    23EC : 246B 0590           	MOVEA.l	FAC1_m(a3),a2			; get the format string descriptor pointer
    6420/    23F0 : 3E2A 0004           	MOVE.w	4(a2),d7				; get the format string length
    6421/    23F4 : 6700 DDDA           	BEQ		LAB_FOER				; if null string go do format error
    6422/    23F8 :                     
    6423/    23F8 :                     ; clear the format string values
    6424/    23F8 :                     
    6425/    23F8 : 7000                	MOVEQ		#0,d0					; clear d0
    6426/    23FA : 3F00                	MOVE.w	d0,-(sp)				; clear the format string decimal characters
    6427/    23FC : 3F00                	MOVE.w	d0,-(sp)				; clear the format string decimal point index
    6428/    23FE : 3F00                	MOVE.w	d0,-(sp)				; clear the format string last index
    6429/    2400 : 3F00                	MOVE.w	d0,-(sp)				; clear the format string this index
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 112 - 10/11/2023 16:23:32


    6430/    2402 : 2F0A                	MOVE.l	a2,-(sp)				; save the format string descriptor pointer
    6431/    2404 :                     
    6432/    2404 :                     ; make a null return string for the first string add
    6433/    2404 :                     
    6434/    2404 : 7200                	MOVEQ		#0,d1					; make a null string
    6435/    2406 : 2041                	MOVEA.l	d1,a0					; with a null pointer
    6436/    2408 : 6100 F0BE           	BSR		LAB_RTST				; push a string on the descriptor stack
    6437/    240C :                     								; a0 = pointer, d1 = length
    6438/    240C :                     
    6439/    240C :                     ; do the USING$() function next value
    6440/    240C :                     
    6441/    240C : 101D                	MOVE.b	(a5)+,d0				; get the next BASIC byte
    6442/    240E :                     LAB_U002
    6443/    240E : B03C 002C           	CMP.b		#',',d0				; compare with comma
    6444/    2412 : 6600 DE10           	BNE		LAB_SNER				; if not "," go do syntax error
    6445/    2416 :                     
    6446/    2416 : 6100 028E           	BSR		LAB_ProcFo				; process the format string
    6447/    241A : 4A02                	TST.b		d2					; test the special characters flag
    6448/    241C : 6700 DDB2           	BEQ		LAB_FOER				; if no special characters go do format error
    6449/    2420 :                     
    6450/    2420 : 6100 E8E8           	BSR		LAB_EVEX				; evaluate the expression
    6451/    2424 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test the data type
    6452/    2428 : 6B00 DDCE           	BMI		LAB_TMER				; if string type go do type missmatch error
    6453/    242C :                     
    6454/    242C : 4A2B 0594           	TST.b		FAC1_e(a3)				; test FAC1 exponent
    6455/    2430 : 6732                	BEQ.s		LAB_U004				; if FAC1 = 0 skip the rounding
    6456/    2432 :                     
    6457/    2432 : 322F 000A           	MOVE.w	fsdc(sp),d1				; get the format string decimal character count
    6458/    2436 : B27C 0008           	CMP.w		#8,d1					; compare the fraction digit count with 8
    6459/    243A : 6428                	BCC.s		LAB_U004				; if >= 8 skip the rounding
    6460/    243C :                     
    6461/    243C : 3001                	MOVE.w	d1,d0					; else copy the fraction digit count
    6462/    243E : D241                	ADD.w		d1,d1					;	; 2
    6463/    2440 : D240                	ADD.w		d0,d1					;	; 3
    6464/    2442 : D241                	ADD.w		d1,d1					;	; 6
    6465/    2444 : 41FA 0844           	LEA		LAB_P_10(pc),a0			; get the rounding table base
    6466/    2448 : 2770 1002 0598      	MOVE.l	2(a0,d1.w),FAC2_m(a3)		; get the rounding mantissa
    6467/    244E : 3030 1000           	MOVE.w	(a0,d1.w),d0			; get the rounding exponent
    6468/    2452 : 907C 0100           	SUB.w		#$100,d0				; effectively divide the mantissa by 2
    6469/    2456 : 3740 059C           	MOVE.w	d0,FAC2_e(a3)			; save the rounding exponent
    6470/    245A : 177C 0000 059E      	MOVE.b	#$00,FAC_sc(a3)			; clear the sign compare
    6471/    2460 : 6100 F4EC           	BSR		LAB_ADD				; round the value to n places
    6472/    2464 :                     LAB_U004
    6473/    2464 : 6100 F96A           	BSR		LAB_2970				; convert FAC1 to string - not on stack
    6474/    2468 :                     
    6475/    2468 : 6100 01FE           	BSR		LAB_DupFmt				; duplicate the processed format string section
    6476/    246C :                     								; returns length in d1, pointer in a0
    6477/    246C :                     
    6478/    246C :                     ; process the number string, length in d6, decimal point index in d2
    6479/    246C :                     
    6480/    246C : 45EB 05C6           	LEA		Decss(a3),a2			; set the number string start
    6481/    2470 : 7C00                	MOVEQ		#0,d6					; clear the number string index
    6482/    2472 : 782E                	MOVEQ		#'.',d4				; set the decimal point character
    6483/    2474 :                     LAB_U005
    6484/    2474 : 3406                	MOVE.w	d6,d2					; save the index to flag the decimal point
    6485/    2476 :                     LAB_U006
    6486/    2476 : 5246                	ADDQ.w	#1,d6					; increment the number string index
    6487/    2478 : 1032 6000           	MOVE.b	(a2,d6.w),d0			; get a number string character
    6488/    247C : 677A                	BEQ.s		LAB_U010				; if null then number complete
    6489/    247E :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 113 - 10/11/2023 16:23:32


    6490/    247E : B03C 0045           	CMP.b		#'E',d0				; compare the character with an "E"
    6491/    2482 : 6706                	BEQ.s		LAB_U008				; was sx[.x]Esxx so go handle sci notation
    6492/    2484 :                     
    6493/    2484 : B004                	CMP.b		d4,d0					; compare the character with "."
    6494/    2486 : 66EE                	BNE.s		LAB_U006				; if not decimal point go get the next digit
    6495/    2488 :                     
    6496/    2488 : 60EA                	BRA.s		LAB_U005				; go save the index and get the next digit
    6497/    248A :                     
    6498/    248A :                     ; have found an sx[.x]Esxx number, the [.x] will not be present for a single digit
    6499/    248A :                     
    6500/    248A :                     LAB_U008
    6501/    248A : 3606                	MOVE.w	d6,d3					; copy the index to the "E"
    6502/    248C : 5343                	SUBQ.w	#1,d3					; -1 gives the last digit index
    6503/    248E :                     
    6504/    248E : 5246                	ADDQ.w	#1,d6					; increment the index to the exponent sign
    6505/    2490 : 1032 6000           	MOVE.b	(a2,d6.w),d0			; get the exponent sign character
    6506/    2494 : B03C 002D           	CMP.b		#'-',d0				; compare the exponent sign with "-"
    6507/    2498 : 6600 DD7E           	BNE		LAB_FCER				; if it wasn't sx[.x]E-xx go do function
    6508/    249C :                     								; call error
    6509/    249C :                     
    6510/    249C :                     ; found an sx[.x]E-xx number so check the exponent magnitude
    6511/    249C :                     
    6512/    249C : 5246                	ADDQ.w	#1,d6					; increment the index to the exponent 10s
    6513/    249E : 1032 6000           	MOVE.b	(a2,d6.w),d0			; get the exponent 10s character
    6514/    24A2 : B03C 0030           	CMP.b		#'0',d0				; compare the exponent 10s with "0"
    6515/    24A6 : 6704                	BEQ.s		LAB_U009				; if it was sx[.x]E-0x go get the exponent
    6516/    24A8 :                     								; 1s character
    6517/    24A8 :                     
    6518/    24A8 : 700A                	MOVEQ		#10,d0				; else start writing at index 10
    6519/    24AA : 6008                	BRA.s		LAB_U00A				; go copy the digits
    6520/    24AC :                     
    6521/    24AC :                     ; found an sx[.x]E-0x number so get the exponent magnitude
    6522/    24AC :                     
    6523/    24AC :                     LAB_U009
    6524/    24AC : 5246                	ADDQ.w	#1,d6					; increment the index to the exponent 1s
    6525/    24AE : 700F                	MOVEQ		#$0F,d0				; set the mask for the exponent 1s digit
    6526/    24B0 : C032 6000           	AND.b		(a2,d6.w),d0			; get and convert the exponent 1s digit
    6527/    24B4 :                     LAB_U00A
    6528/    24B4 : 3403                	MOVE.w	d3,d2					; copy the number last digit index
    6529/    24B6 : 0C42 0001           	CMPI.w	#1,d2					; is the number of the form sxE-0x
    6530/    24BA : 6602                	BNE.s		LAB_U00B				; if it is sx.xE-0x skip the increment
    6531/    24BC :                     
    6532/    24BC :                     								; else make room for the decimal point
    6533/    24BC : 5242                	ADDQ.w	#1,d2					; add 1 to the write index
    6534/    24BE :                     LAB_U00B
    6535/    24BE : D440                	ADD.w		d0,d2					; add the exponent 1s to the write index
    6536/    24C0 : 700A                	MOVEQ		#10,d0				; set the maximum write index
    6537/    24C2 : 9042                	SUB.w		d2,d0					; compare the index with the maximum
    6538/    24C4 : 6E0C                	BGT.s		LAB_U00C				; if the index < the maximum continue
    6539/    24C6 :                     
    6540/    24C6 : D440                	ADD.w		d0,d2					; else set the index to the maximum
    6541/    24C8 : D640                	ADD.w		d0,d3					; adjust the read index
    6542/    24CA : 0C43 0001           	CMPI.w	#1,d3					; compare the adjusted index with 1
    6543/    24CE : 6E02                	BGT.s		LAB_U00C				; if > 1 continue
    6544/    24D0 :                     
    6545/    24D0 : 7600                	MOVEQ		#0,d3					; else allow for the decimal point
    6546/    24D2 :                     LAB_U00C
    6547/    24D2 : 3C02                	MOVE.w		d2,d6					; copy the write index as the number
    6548/    24D4 :                     								; string length
    6549/    24D4 : 7000                	MOVEQ		#0,d0					; clear d0 to null terminate the number
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 114 - 10/11/2023 16:23:32


    6550/    24D6 :                     								; string
    6551/    24D6 :                     LAB_U00D
    6552/    24D6 : 1580 2000           	MOVE.b	d0,(a2,d2.w)			; save the character to the number string
    6553/    24DA : 5342                	SUBQ.w	#1,d2					; decrement the number write index
    6554/    24DC : 0C42 0001           	CMPI.w	#1,d2					; compare the number write index with 1
    6555/    24E0 : 6712                	BEQ.s		LAB_U00F				; if at the decimal point go save it
    6556/    24E2 :                     
    6557/    24E2 :                     								; else write a digit to the number string
    6558/    24E2 : 7030                	MOVEQ		#'0',d0				; default to "0"
    6559/    24E4 : 4A43                	TST.w		d3					; test the number read index
    6560/    24E6 : 67EE                	BEQ.s		LAB_U00D				; if zero just go save the "0"
    6561/    24E8 :                     
    6562/    24E8 :                     LAB_U00E
    6563/    24E8 : 1032 3000           	MOVE.b	(a2,d3.w),d0			; read the next number digit
    6564/    24EC : 5343                	SUBQ.w	#1,d3					; decrement the read index
    6565/    24EE : B004                	CMP.b		d4,d0					; compare the digit with "."
    6566/    24F0 : 66E4                	BNE.s		LAB_U00D				; if not "." go save the digit
    6567/    24F2 :                     
    6568/    24F2 : 60F4                	BRA.s		LAB_U00E				; else go get the next digit
    6569/    24F4 :                     
    6570/    24F4 :                     LAB_U00F
    6571/    24F4 : 1584 2000           	MOVE.b	d4,(a2,d2.w)			; save the decimal point
    6572/    24F8 :                     LAB_U010
    6573/    24F8 : 4A42                	TST.w		d2					; test the number string decimal point index
    6574/    24FA : 6602                	BNE.s		LAB_U014				; if dp present skip the reset
    6575/    24FC :                     
    6576/    24FC : 3406                	MOVE.w	d6,d2					; make the decimal point index = the length
    6577/    24FE :                     
    6578/    24FE :                     ; copy the fractional digit characters from the number string
    6579/    24FE :                     
    6580/    24FE :                     LAB_U014
    6581/    24FE : 3602                	MOVE.w	d2,d3					; copy the number string decimal point index
    6582/    2500 : 5243                	ADDQ.w	#1,d3					; increment the number string index
    6583/    2502 : 382F 0008           	MOVE.w	fsdpi(sp),d4			; get the new format string decimal point index
    6584/    2506 :                     LAB_U018
    6585/    2506 : 5244                	ADDQ.w	#1,d4					; increment the new format string index
    6586/    2508 : B244                	CMP.w		d4,d1					; compare it with the new format string length
    6587/    250A : 6322                	BLS.s		LAB_U022				; if done the fraction digits go do integer
    6588/    250C :                     
    6589/    250C : 1030 4000           	MOVE.b	(a0,d4.w),d0			; get a new format string character
    6590/    2510 : B03C 0025           	CMP.b		#'%',d0				; compare it with "%"
    6591/    2514 : 6706                	BEQ.s		LAB_U01C				; if "%" go copy a number character
    6592/    2516 :                     
    6593/    2516 : B03C 0023           	CMP.b		#'#',d0				; compare it with "#"
    6594/    251A : 66EA                	BNE.s		LAB_U018				; if not "#" go do the next new format character
    6595/    251C :                     
    6596/    251C :                     LAB_U01C
    6597/    251C : 7030                	MOVEQ		#'0',d0				; default to "0" character
    6598/    251E : BC43                	CMP.w		d3,d6					; compare the number string index with length
    6599/    2520 : 6306                	BLS.s		LAB_U020				; if there skip the character get
    6600/    2522 :                     
    6601/    2522 : 1032 3000           	MOVE.b	(a2,d3.w),d0			; get a character from the number string
    6602/    2526 : 5243                	ADDQ.w	#1,d3					; increment the number string index
    6603/    2528 :                     LAB_U020
    6604/    2528 : 1180 4000           	MOVE.b	d0,(a0,d4.w)			; save the number character to the new format
    6605/    252C :                     								; string
    6606/    252C : 60D8                	BRA.s		LAB_U018				; go do the next new format character
    6607/    252E :                     
    6608/    252E :                     ; now copy the integer digit characters from the number string
    6609/    252E :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 115 - 10/11/2023 16:23:32


    6610/    252E :                     LAB_U022
    6611/    252E : 7C00                	MOVEQ		#0,d6					; clear the sign done flag
    6612/    2530 : 7A00                	MOVEQ		#0,d5					; clear the sign present flag
    6613/    2532 : 5342                	SUBQ.w	#1,d2					; decrement the number string index
    6614/    2534 : 6608                	BNE.s		LAB_U026				; if not now at sign continue
    6615/    2536 :                     
    6616/    2536 : 7401                	MOVEQ		#1,d2					; increment the number string index
    6617/    2538 : 15BC 0030 2000      	MOVE.b	#'0',(a2,d2.w)			; replace the point with a zero
    6618/    253E :                     LAB_U026
    6619/    253E : 382F 0008           	MOVE.w	fsdpi(sp),d4			; get the new format string decimal point index
    6620/    2542 : B244                	CMP.w		d4,d1					; compare it with the new format string length
    6621/    2544 : 6402                	BCC.s		LAB_U02A				; if within the string go use the index
    6622/    2546 :                     
    6623/    2546 : 3801                	MOVE.w	d1,d4					; else set the index to the end of the string
    6624/    2548 :                     LAB_U02A
    6625/    2548 : 5344                	SUBQ.w	#1,d4					; decrement the new format string index
    6626/    254A : 6B62                	BMI.s		LAB_U03E				; if all done go test for any overflow
    6627/    254C :                     
    6628/    254C : 1030 4000           	MOVE.b	(a0,d4.w),d0			; else get a new format string character
    6629/    2550 :                     
    6630/    2550 : 7E30                	MOVEQ		#'0',d7				; default to "0" character
    6631/    2552 : B03C 0025           	CMP.b		#'%',d0				; compare it with "%"
    6632/    2556 : 6708                	BEQ.s		LAB_U02B				; if "%" go copy a number character
    6633/    2558 :                     
    6634/    2558 : 7E20                	MOVEQ		#' ',d7				; default to " " character
    6635/    255A : B03C 0023           	CMP.b		#'#',d0				; compare it with "#"
    6636/    255E : 6606                	BNE.s		LAB_U02C				; if not "#" go try ","
    6637/    2560 :                     
    6638/    2560 :                     LAB_U02B
    6639/    2560 : 4A42                	TST.w		d2					; test the number string index
    6640/    2562 : 6634                	BNE.s		LAB_U036				; if not at the sign go get a number character
    6641/    2564 :                     
    6642/    2564 : 6042                	BRA.s		LAB_U03C				; else go save the default character
    6643/    2566 :                     
    6644/    2566 :                     LAB_U02C
    6645/    2566 : B03C 002C           	CMP.b		#',',d0				; compare it with ","
    6646/    256A : 6610                	BNE.s		LAB_U030				; if not "," go try the sign characters
    6647/    256C :                     
    6648/    256C : 4A42                	TST.w		d2					; test the number string index
    6649/    256E : 6608                	BNE.s		LAB_U02E				; if not at the sign keep the ","
    6650/    2570 :                     
    6651/    2570 : 0C30 0025 40FF      	CMP.b		#'%',-1(a0,d4.w)			; else compare the next format string character
    6652/    2576 :                     								; with "%"
    6653/    2576 : 6630                	BNE.s		LAB_U03C				; if not "%" keep the default character
    6654/    2578 :                     
    6655/    2578 :                     LAB_U02E
    6656/    2578 : 1E00                	MOVE.b	d0,d7					; else use the "," character
    6657/    257A : 602C                	BRA.s		LAB_U03C				; go save the character to the string
    6658/    257C :                     
    6659/    257C :                     LAB_U030
    6660/    257C : B03C 002D           	CMP.b		#'-',d0				; compare it with "-"
    6661/    2580 : 6710                	BEQ.s		LAB_U034				; if "-" go do the sign character
    6662/    2582 :                     
    6663/    2582 : B03C 002B           	CMP.b		#'+',d0				; compare it with "+"
    6664/    2586 : 66C0                	BNE.s		LAB_U02A				; if not "+" go do the next new format character
    6665/    2588 :                     
    6666/    2588 : 0C12 002D           	CMP.b		#'-',(a2)				; compare the sign character with "-"
    6667/    258C : 6704                	BEQ.s		LAB_U034				; if "-" don't change the sign character
    6668/    258E :                     
    6669/    258E : 14BC 002B           	MOVE.b	#'+',(a2)				; else make the sign character "+"
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 116 - 10/11/2023 16:23:32


    6670/    2592 :                     LAB_U034
    6671/    2592 : 1A00                	MOVE.b	d0,d5					; set the sign present flag
    6672/    2594 : 4A42                	TST.w		d2					; test the number string index
    6673/    2596 : 6708                	BEQ.s		LAB_U038				; if at the sign keep the default character
    6674/    2598 :                     
    6675/    2598 :                     LAB_U036
    6676/    2598 : 1E32 2000           	MOVE.b	(a2,d2.w),d7			; else get a character from the number string
    6677/    259C : 5342                	SUBQ.w	#1,d2					; decrement the number string index
    6678/    259E : 6008                	BRA.s		LAB_U03C				; go save the character
    6679/    25A0 :                     
    6680/    25A0 :                     LAB_U038
    6681/    25A0 : 4A06                	TST.b		d6					; test the sign done flag
    6682/    25A2 : 6604                	BNE.s		LAB_U03C				; if the sign has been done go use the space
    6683/    25A4 :                     								; character
    6684/    25A4 :                     
    6685/    25A4 : 1E12                	MOVE.b	(a2),d7				; else get the sign character
    6686/    25A6 : 1C07                	MOVE.b	d7,d6					; flag that the sign has been done
    6687/    25A8 :                     LAB_U03C
    6688/    25A8 : 1187 4000           	MOVE.b	d7,(a0,d4.w)			; save the number character to the new format
    6689/    25AC :                     								; string
    6690/    25AC : 609A                	BRA.s		LAB_U02A				; go do the next new format character
    6691/    25AE :                     
    6692/    25AE :                     ; test for overflow conditions
    6693/    25AE :                     
    6694/    25AE :                     LAB_U03E
    6695/    25AE : 4A42                	TST.w		d2					; test the number string index
    6696/    25B0 : 6614                	BNE.s		LAB_U040				; if all the digits aren't done go output
    6697/    25B2 :                     								; an overflow indication
    6698/    25B2 :                     
    6699/    25B2 :                     ; test for sign overflows
    6700/    25B2 :                     
    6701/    25B2 : 4A05                	TST.b		d5					; test the sign present flag
    6702/    25B4 : 6754                	BEQ.s		LAB_U04A				; if no sign present go add the string
    6703/    25B6 :                     
    6704/    25B6 :                     ; there was a sign in the format string
    6705/    25B6 :                     
    6706/    25B6 : 4A06                	TST.b		d6					; test the sign done flag
    6707/    25B8 : 6650                	BNE.s		LAB_U04A				; if the sign is done go add the string
    6708/    25BA :                     
    6709/    25BA :                     ; the sign isn't done so see if it was mandatory
    6710/    25BA :                     
    6711/    25BA : 0C05 002B           	CMPI.b	#'+',d5				; compare the sign with "+"
    6712/    25BE : 6706                	BEQ.s		LAB_U040				; if it was "+" go output an overflow
    6713/    25C0 :                     								; indication
    6714/    25C0 :                     
    6715/    25C0 :                     ; the sign wasn't mandatory but the number may have been negative
    6716/    25C0 :                     
    6717/    25C0 : 0C12 002D           	CMP.b		#'-',(a2)				; compare the sign character with "-"
    6718/    25C4 : 6644                	BNE.s		LAB_U04A				; if it wasn't "-" go add the string
    6719/    25C6 :                     
    6720/    25C6 :                     ; else the sign was "-" and a sign hasn't been output so ..
    6721/    25C6 :                     
    6722/    25C6 :                     ; the number overflowed the format string so replace all the special format characters
    6723/    25C6 :                     ; with the overflow character
    6724/    25C6 :                     
    6725/    25C6 :                     LAB_U040
    6726/    25C6 : 7A23                	MOVEQ		#ofchr,d5				; set the overflow character
    6727/    25C8 : 3E01                	MOVE.w	d1,d7					; copy the new format string length
    6728/    25CA : 5347                	SUBQ.w	#1,d7					; adjust for the loop type
    6729/    25CC : 3C2F 0004           	MOVE.w	fsti(sp),d6				; copy the new format string last index
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 117 - 10/11/2023 16:23:32


    6730/    25D0 : 5346                	SUBQ.w	#1,d6					; -1 gives the last character of this string
    6731/    25D2 : 6E02                	BGT.s		LAB_U044				; if not zero continue
    6732/    25D4 :                     
    6733/    25D4 : 3C07                	MOVE.w	d7,d6					; else set the format string index to the end
    6734/    25D6 :                     LAB_U044
    6735/    25D6 : 1031 6000           	MOVE.b	(a1,d6.w),d0			; get a character from the format string
    6736/    25DA : 0C00 0023           	CMPI.b	#'#',d0				; compare it with "#" special format character
    6737/    25DE : 671E                	BEQ.s		LAB_U046				; if "#" go use the overflow character
    6738/    25E0 :                     
    6739/    25E0 : 0C00 0025           	CMPI.b	#'%',d0				; compare it with "%" special format character
    6740/    25E4 : 6718                	BEQ.s		LAB_U046				; if "%" go use the overflow character
    6741/    25E6 :                     
    6742/    25E6 : 0C00 002C           	CMPI.b	#',',d0				; compare it with "," special format character
    6743/    25EA : 6712                	BEQ.s		LAB_U046				; if "," go use the overflow character
    6744/    25EC :                     
    6745/    25EC : 0C00 002B           	CMPI.b	#'+',d0				; compare it with "+" special format character
    6746/    25F0 : 670C                	BEQ.s		LAB_U046				; if "+" go use the overflow character
    6747/    25F2 :                     
    6748/    25F2 : 0C00 002D           	CMPI.b	#'-',d0				; compare it with "-" special format character
    6749/    25F6 : 6706                	BEQ.s		LAB_U046				; if "-" go use the overflow character
    6750/    25F8 :                     
    6751/    25F8 : 0C00 002E           	CMPI.b	#'.',d0				; compare it with "." special format character
    6752/    25FC : 6602                	BNE.s		LAB_U048				; if not "." skip the using overflow character
    6753/    25FE :                     
    6754/    25FE :                     LAB_U046
    6755/    25FE : 1005                	MOVE.b	d5,d0					; use the overflow character
    6756/    2600 :                     LAB_U048
    6757/    2600 : 1180 7000           	MOVE.b	d0,(a0,d7.w)			; save the character to the new format string
    6758/    2604 : 5346                	SUBQ.w	#1,d6					; decrement the format string index
    6759/    2606 : 51CF FFCE           	DBF		d7,LAB_U044				; decrement the count and loop if not all done
    6760/    260A :                     
    6761/    260A :                     ; add the new string to the previous string
    6762/    260A :                     
    6763/    260A :                     LAB_U04A
    6764/    260A : 41EC 0006           	LEA		6(a4),a0				; get the descriptor pointer for string 1
    6765/    260E : 274C 0590           	MOVE.l	a4,FAC1_m(a3)			; save the descriptor pointer for string 2
    6766/    2612 : 6100 F004           	BSR		LAB_224E				; concatenate the strings
    6767/    2616 :                     
    6768/    2616 :                     ; now check for any tail on the format string
    6769/    2616 :                     
    6770/    2616 : 302F 0004           	MOVE.w	fsti(sp),d0				; get this index
    6771/    261A : 6720                	BEQ.s		LAB_U04C				; if at start of string skip the output
    6772/    261C :                     
    6773/    261C : 3F40 0006           	MOVE.w	d0,fsli(sp)				; save this index to the last index
    6774/    2620 : 6100 0084           	BSR		LAB_ProcFo				; now process the format string
    6775/    2624 : 4A02                	TST.b		d2					; test the special characters flag
    6776/    2626 : 6614                	BNE.s		LAB_U04C				; if special characters present skip the output
    6777/    2628 :                     
    6778/    2628 :                     ; else output the new string part
    6779/    2628 :                     
    6780/    2628 : 613E                	BSR.s		LAB_DupFmt				; duplicate the processed format string section
    6781/    262A : 3F6F 0004 0006      	MOVE.w	fsti(sp),fsli(sp)			; copy this index to the last index
    6782/    2630 :                     
    6783/    2630 :                     ; add the new string to the previous string
    6784/    2630 :                     
    6785/    2630 : 41EC 0006           	LEA		6(a4),a0				; get the descriptor pointer for string 1
    6786/    2634 : 274C 0590           	MOVE.l	a4,FAC1_m(a3)			; save the descriptor pointer for string 2
    6787/    2638 : 6100 EFDE           	BSR		LAB_224E				; concatenate the strings
    6788/    263C :                     
    6789/    263C :                     ; check for another value or end of function
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 118 - 10/11/2023 16:23:32


    6790/    263C :                     
    6791/    263C :                     LAB_U04C
    6792/    263C : 101D                	MOVE.b	(a5)+,d0				; get the next BASIC byte
    6793/    263E : B03C 0029           	CMP.b		#')',d0				; compare with close bracket
    6794/    2642 : 6600 FDCA           	BNE		LAB_U002				; if not ")" go do next value
    6795/    2646 :                     
    6796/    2646 :                     ; pop the result string off the descriptor stack
    6797/    2646 :                     
    6798/    2646 : 204C                	MOVEA.l	a4,a0					; copy the result string descriptor pointer
    6799/    2648 : 222B 0446           	MOVE.l	Sstorl(a3),d1			; save the bottom of string space
    6800/    264C : 6100 F02C           	BSR		LAB_22BA				; pop (a0) descriptor, returns with ..
    6801/    2650 :                     								; d0 = length, a0 = pointer
    6802/    2650 : 2741 0446           	MOVE.l	d1,Sstorl(a3)			; restore the bottom of string space
    6803/    2654 : 2248                	MOVEA.l	a0,a1					; copy the string result pointer
    6804/    2656 : 3200                	MOVE.w	d0,d1					; copy the string result length
    6805/    2658 :                     
    6806/    2658 :                     ; pop the format string off the descriptor stack
    6807/    2658 :                     
    6808/    2658 : 205F                	MOVEA.l	(sp)+,a0				; pull the format string descriptor pointer
    6809/    265A : 6100 F01E           	BSR		LAB_22BA				; pop (a0) descriptor, returns with ..
    6810/    265E :                     								; d0 = length, a0 = pointer
    6811/    265E :                     
    6812/    265E : 4FEF 0008           	LEA		fend(sp),sp				; dump the saved values
    6813/    2662 :                     
    6814/    2662 :                     ; push the result string back on the descriptor stack and return
    6815/    2662 :                     
    6816/    2662 : 2049                	MOVEA.l	a1,a0					; copy the result string pointer back
    6817/    2664 : 6000 EE62           	BRA		LAB_RTST				; push a string on the descriptor stack and
    6818/    2668 :                     								; return. a0 = pointer, d1 = length
    6819/    2668 :                     
    6820/    2668 :                     
    6821/    2668 :                     ;************************************************************************************
    6822/    2668 :                     ;
    6823/    2668 :                     ; duplicate the processed format string section
    6824/    2668 :                     
    6825/    2668 :                     								; make a string as long as the format string
    6826/    2668 :                     LAB_DupFmt
    6827/    2668 : 226F 0004           	MOVEA.l	4+fsd(sp),a1			; get the format string descriptor pointer
    6828/    266C : 3E29 0004           	MOVE.w	4(a1),d7				; get the format string length
    6829/    2670 : 342F 000A           	MOVE.w	4+fsli(sp),d2			; get the format string last index
    6830/    2674 : 3C2F 0008           	MOVE.w	4+fsti(sp),d6			; get the format string this index
    6831/    2678 : 3206                	MOVE.w	d6,d1					; copy the format string this index
    6832/    267A : 9242                	SUB.w		d2,d1					; subtract the format string last index
    6833/    267C : 6202                	BHI.s		LAB_D002				; if > 0 skip the correction
    6834/    267E :                     
    6835/    267E : D247                	ADD.w		d7,d1					; else add the format string length as the
    6836/    2680 :                     								; correction
    6837/    2680 :                     LAB_D002
    6838/    2680 : 6100 EE60           	BSR		LAB_2115				; make string space d1 bytes long
    6839/    2684 :                     								; return a0/Sutill = pointer, others unchanged
    6840/    2684 :                     
    6841/    2684 :                     ; push the new string on the descriptor stack
    6842/    2684 :                     
    6843/    2684 : 6100 EE42           	BSR		LAB_RTST				; push a string on the descriptor stack and
    6844/    2688 :                     								; return. a0 = pointer, d1 = length
    6845/    2688 :                     
    6846/    2688 :                     ; copy the characters from the format string
    6847/    2688 :                     
    6848/    2688 : 226F 0004           	MOVEA.l	4+fsd(sp),a1			; get the format string descriptor pointer
    6849/    268C : 2251                	MOVEA.l	(a1),a1				; get the format string pointer
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 119 - 10/11/2023 16:23:32


    6850/    268E : 7800                	MOVEQ		#0,d4					; clear the new string index
    6851/    2690 :                     LAB_D00A
    6852/    2690 : 11B1 2000 4000      	MOVE.b	(a1,d2.w),(a0,d4.w)		; get a character from the format string and
    6853/    2696 :                     								; save it to the new string
    6854/    2696 : 5244                	ADDQ.w	#1,d4					; increment the new string index
    6855/    2698 : 5242                	ADDQ.w	#1,d2					; increment the format string index
    6856/    269A : BE42                	CMP.w		d2,d7					; compare the format index with the length
    6857/    269C : 6602                	BNE.s		LAB_D00E				; if not there skip the reset
    6858/    269E :                     
    6859/    269E : 7400                	MOVEQ		#0,d2					; else reset the format string index
    6860/    26A0 :                     LAB_D00E
    6861/    26A0 : BC42                	CMP.w		d2,d6					; compare the index with this index
    6862/    26A2 : 66EC                	BNE.s		LAB_D00A				; if not equal go do the next character
    6863/    26A4 :                     
    6864/    26A4 : 4E75                	RTS
    6865/    26A6 :                     
    6866/    26A6 :                     
    6867/    26A6 :                     ;************************************************************************************
    6868/    26A6 :                     ;
    6869/    26A6 :                     ; process the format string
    6870/    26A6 :                     
    6871/    26A6 :                     LAB_ProcFo
    6872/    26A6 : 226F 0004           	MOVEA.l	4+fsd(sp),a1			; get the format string descriptor pointer
    6873/    26AA : 3E29 0004           	MOVE.w	4(a1),d7				; get the format string length
    6874/    26AE : 2251                	MOVEA.l	(a1),a1				; get the format string pointer
    6875/    26B0 : 3C2F 000A           	MOVE.w	4+fsli(sp),d6			; get the format string last index
    6876/    26B4 :                     
    6877/    26B4 : 3F47 000C           	MOVE.w	d7,4+fsdpi(sp)			; set the format string decimal point index
    6878/    26B8 :                     ;##	MOVE.w	#-1,4+fsdpi(sp)			; set the format string decimal point index
    6879/    26B8 : 7A00                	MOVEQ		#0,d5					; no decimal point
    6880/    26BA : 7600                	MOVEQ		#0,d3					; no decimal characters
    6881/    26BC : 7400                	MOVEQ		#0,d2					; no special characters
    6882/    26BE :                     LAB_P004
    6883/    26BE : 1031 6000           	MOVE.b	(a1,d6.w),d0			; get a format string byte
    6884/    26C2 :                     
    6885/    26C2 : B03C 002C           	CMP.b		#',',d0				; compare it with ","
    6886/    26C6 : 6742                	BEQ.s		LAB_P01A				; if "," go do the next format string byte
    6887/    26C8 :                     
    6888/    26C8 : B03C 0023           	CMP.b		#'#',d0				; compare it with "#"
    6889/    26CC : 6706                	BEQ.s		LAB_P008				; if "#" go flag special characters
    6890/    26CE :                     
    6891/    26CE : B03C 0025           	CMP.b		#'%',d0				; compare it with "%"
    6892/    26D2 : 6608                	BNE.s		LAB_P00C				; if not "%" go try "+"
    6893/    26D4 :                     
    6894/    26D4 :                     LAB_P008
    6895/    26D4 : 4A85                	TST.l		d5					; test the decimal point flag
    6896/    26D6 : 6A10                	BPL.s		LAB_P00E				; if no point skip counting decimal characters
    6897/    26D8 :                     
    6898/    26D8 : 5243                	ADDQ.w	#1,d3					; else increment the decimal character count
    6899/    26DA : 602E                	BRA.s		LAB_P01A				; go do the next character
    6900/    26DC :                     
    6901/    26DC :                     LAB_P00C
    6902/    26DC : B03C 002B           	CMP.b		#'+',d0				; compare it with "+"
    6903/    26E0 : 6706                	BEQ.s		LAB_P00E				; if "+" go flag special characters
    6904/    26E2 :                     
    6905/    26E2 : B03C 002D           	CMP.b		#'-',d0				; compare it with "-"
    6906/    26E6 : 6604                	BNE.s		LAB_P010				; if not "-" go check decimal point
    6907/    26E8 :                     
    6908/    26E8 :                     LAB_P00E
    6909/    26E8 : 8400                	OR.b		d0,d2					; flag special characters
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 120 - 10/11/2023 16:23:32


    6910/    26EA : 601E                	BRA.s		LAB_P01A				; go do the next character
    6911/    26EC :                     
    6912/    26EC :                     LAB_P010
    6913/    26EC : B03C 002E           	CMP.b		#'.',d0				; compare it with "."
    6914/    26F0 : 6614                	BNE.s		LAB_P018				; if not "." go check next
    6915/    26F2 :                     
    6916/    26F2 :                     ; "." a decimal point
    6917/    26F2 :                     
    6918/    26F2 : 4A85                	TST.l		d5					; if there is already a decimal point
    6919/    26F4 : 6B14                	BMI.s		LAB_P01A				; go do the next character
    6920/    26F6 :                     
    6921/    26F6 : 3006                	MOVE.w	d6,d0					; copy the decimal point index
    6922/    26F8 : 906F 000A           	SUB.w		4+fsli(sp),d0			; calculate it from the scan start
    6923/    26FC : 3F40 000C           	MOVE.w	d0,4+fsdpi(sp)			; save the decimal point index
    6924/    2700 : 7AFF                	MOVEQ		#-1,d5				; flag decimal point
    6925/    2702 : 8400                	OR.b		d0,d2					; flag special characters
    6926/    2704 : 6004                	BRA.s		LAB_P01A				; go do the next character
    6927/    2706 :                     
    6928/    2706 :                     ; was not a special character
    6929/    2706 :                     
    6930/    2706 :                     LAB_P018
    6931/    2706 : 4A02                	TST.b		d2					; test if there have been special characters
    6932/    2708 : 6608                	BNE.s		LAB_P01E				; if so exit the format string process
    6933/    270A :                     
    6934/    270A :                     LAB_P01A
    6935/    270A : 5246                	ADDQ.w	#1,d6					; increment the format string index
    6936/    270C : BE46                	CMP.w		d6,d7					; compare it with the format string length
    6937/    270E : 62AE                	BHI.s		LAB_P004				; if length > index go get the next character
    6938/    2710 :                     
    6939/    2710 : 7C00                	MOVEQ		#0,d6					; length = index so reset the format string
    6940/    2712 :                     								; index
    6941/    2712 :                     LAB_P01E
    6942/    2712 : 3F46 0008           	MOVE.w	d6,4+fsti(sp)			; save the format string this index
    6943/    2716 : 3F43 000E           	MOVE.w	d3,4+fsdc(sp)			; save the format string decimal characters
    6944/    271A :                     
    6945/    271A : 4E75                	RTS
    6946/    271C :                     
    6947/    271C :                     
    6948/    271C :                     ;************************************************************************************
    6949/    271C :                     ;
    6950/    271C :                     ; perform BIN$()
    6951/    271C :                     ; # of leading 0s is in d1, the number is in d0
    6952/    271C :                     
    6953/    271C :                     LAB_BINS
    6954/    271C : B23C 0021           	CMP.b		#$21,d1				; max + 1
    6955/    2720 : 6400 DAF6           	BCC		LAB_FCER				; exit if too big ( > or = )
    6956/    2724 :                     
    6957/    2724 : 741F                	MOVEQ		#$1F,d2				; bit count-1
    6958/    2726 : 41EB 05B6           	LEA		Binss(a3),a0			; point to string
    6959/    272A : 7830                	MOVEQ		#$30,d4				; "0" character for ADDX
    6960/    272C :                     NextB1
    6961/    272C : 7600                	MOVEQ		#0,d3					; clear byte
    6962/    272E : E288                	LSR.l		#1,d0					; shift bit into Xb
    6963/    2730 : D704                	ADDX.b	d4,d3					; add carry and character to zero
    6964/    2732 : 1183 2000           	MOVE.b	d3,(a0,d2.w)			; save character to string
    6965/    2736 : 51CA FFF4           	DBF		d2,NextB1				; decrement and loop if not done
    6966/    273A :                     
    6967/    273A :                     ; this is the exit code and is also used by HEX$()
    6968/    273A :                     
    6969/    273A :                     EndBHS
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 121 - 10/11/2023 16:23:32


    6970/    273A : 177C 0000 05D6      	MOVE.b	#0,BHsend(a3)			; null terminate the string
    6971/    2740 : 4A01                	TST.b		d1					; test # of characters
    6972/    2742 : 670E                	BEQ.s		NextB2				; go truncate string
    6973/    2744 :                     
    6974/    2744 : 4481                	NEG.l		d1					; make -ve
    6975/    2746 : D2BC 0000 05D6      	ADD.l		#BHsend,d1				; effectively (end-length)
    6976/    274C : 41F3 1000           	LEA		0(a3,d1.w),a0			; effectively add (end-length) to pointer
    6977/    2750 : 600E                	BRA.s		BinPr					; go print string
    6978/    2752 :                     
    6979/    2752 :                     ; truncate string to remove leading "0"s
    6980/    2752 :                     
    6981/    2752 :                     NextB2
    6982/    2752 : 1010                	MOVE.b	(a0),d0				; get byte
    6983/    2754 : 670A                	BEQ.s		BinPr					; if null then end of string so add 1 and go
    6984/    2756 :                     								; print it
    6985/    2756 :                     
    6986/    2756 : B03C 0030           	CMP.b		#'0',d0				; compare with "0"
    6987/    275A : 660E                	BNE.s		GoPr					; if not "0" then go print string from here
    6988/    275C :                     
    6989/    275C : 5248                	ADDQ.w	#1,a0					; else increment pointer
    6990/    275E : 60F2                	BRA.s		NextB2				; loop always
    6991/    2760 :                     
    6992/    2760 :                     ; make fixed length output string - ignore overflows!
    6993/    2760 :                     
    6994/    2760 :                     BinPr
    6995/    2760 : 43EB 05D6           	LEA		BHsend(a3),a1			; get string end
    6996/    2764 : B1C9                	CMPA.l	a1,a0					; are we at the string end
    6997/    2766 : 6602                	BNE.s		GoPr					; branch if not
    6998/    2768 :                     
    6999/    2768 : 5348                	SUBQ.w	#1,a0					; else need at least one zero
    7000/    276A :                     GoPr
    7001/    276A : 6000 ED16           	BRA		LAB_20AE				; print " terminated string to FAC1, stack & RET
    7002/    276E :                     
    7003/    276E :                     
    7004/    276E :                     ;************************************************************************************
    7005/    276E :                     ;
    7006/    276E :                     ; perform HEX$()
    7007/    276E :                     ; # of leading 0s is in d1, the number is in d0
    7008/    276E :                     
    7009/    276E :                     LAB_HEXS
    7010/    276E : B23C 0009           	CMP.b		#$09,d1				; max + 1
    7011/    2772 : 6400 DAA4           	BCC		LAB_FCER				; exit if too big ( > or = )
    7012/    2776 :                     
    7013/    2776 : 7407                	MOVEQ		#$07,d2				; nibble count-1
    7014/    2778 : 41EB 05CE           	LEA		Hexss(a3),a0			; point to string
    7015/    277C : 7830                	MOVEQ		#$30,d4				; "0" character for ABCD
    7016/    277E :                     NextH1
    7017/    277E : 1600                	MOVE.b	d0,d3					; copy lowest byte
    7018/    2780 : E898                	ROR.l		#4,d0					; shift nibble into 0-3
    7019/    2782 : C63C 000F           	AND.b		#$0F,d3				; just this nibble
    7020/    2786 : 1A03                	MOVE.b	d3,d5					; copy it
    7021/    2788 : DA3C 00F6           	ADD.b		#$F6,d5				; set extend bit
    7022/    278C : C704                	ABCD		d4,d3					; decimal add extend and character to zero
    7023/    278E : 1183 2000           	MOVE.b	d3,(a0,d2.w)			; save character to string
    7024/    2792 : 51CA FFEA           	DBF		d2,NextH1				; decrement and loop if not done
    7025/    2796 :                     
    7026/    2796 : 60A2                	BRA.s		EndBHS				; go process string
    7027/    2798 :                     
    7028/    2798 :                     
    7029/    2798 :                     ;************************************************************************************
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 122 - 10/11/2023 16:23:32


    7030/    2798 :                     ;
    7031/    2798 :                     ; ctrl-c check routine. includes limited "life" byte save for INGET routine
    7032/    2798 :                     
    7033/    2798 :                     VEC_CC
    7034/    2798 : 4A2B 05E8           	TST.b		ccflag(a3)				; check [CTRL-C] check flag
    7035/    279C : 661E                	BNE.s		RTS_022				; exit if [CTRL-C] check inhibited
    7036/    279E :                     
    7037/    279E : 4EAB 040C           	JSR		V_INPT(a3)				; scan input device
    7038/    27A2 : 640E                	BCC.s		LAB_FBA0				; exit if buffer empty
    7039/    27A4 :                     
    7040/    27A4 : 1740 05E9           	MOVE.b	d0,ccbyte(a3)			; save received byte
    7041/    27A8 : 177C 0020 05EA      	MOVE.b	#$20,ccnull(a3)			; set "life" timer for bytes countdown
    7042/    27AE : 6000 DEDE           	BRA		LAB_1636				; return to BASIC
    7043/    27B2 :                     
    7044/    27B2 :                     LAB_FBA0
    7045/    27B2 : 4A2B 05EA           	TST.b		ccnull(a3)				; get countdown byte
    7046/    27B6 : 6704                	BEQ.s		RTS_022				; exit if finished
    7047/    27B8 :                     
    7048/    27B8 : 532B 05EA           	SUBQ.b	#1,ccnull(a3)			; else decrement countdown
    7049/    27BC :                     RTS_022
    7050/    27BC : 4E75                	RTS
    7051/    27BE :                     
    7052/    27BE :                     
    7053/    27BE :                     ;************************************************************************************
    7054/    27BE :                     ;
    7055/    27BE :                     ; get byte from input device, no waiting
    7056/    27BE :                     ; returns with carry set if byte in A
    7057/    27BE :                     
    7058/    27BE :                     INGET
    7059/    27BE : 4EAB 040C           	JSR		V_INPT(a3)				; call scan input device
    7060/    27C2 : 650A                	BCS.s		LAB_FB95				; if byte go reset timer
    7061/    27C4 :                     
    7062/    27C4 : 102B 05EA           	MOVE.b	ccnull(a3),d0			; get countdown
    7063/    27C8 : 67F2                	BEQ.s		RTS_022				; exit if empty
    7064/    27CA :                     
    7065/    27CA : 102B 05E9           	MOVE.b	ccbyte(a3),d0			; get last received byte
    7066/    27CE :                     LAB_FB95
    7067/    27CE : 177C 0000 05EA      	MOVE.b	#$00,ccnull(a3)			; clear timer because we got a byte
    7068/    27D4 : 003C 0001           	ORI.b		#1,CCR				; set carry, flag we got a byte
    7069/    27D8 : 4E75                	RTS
    7070/    27DA :                     
    7071/    27DA :                     
    7072/    27DA :                     ;************************************************************************************
    7073/    27DA :                     ;
    7074/    27DA :                     ; perform MAX()
    7075/    27DA :                     
    7076/    27DA :                     LAB_MAX
    7077/    27DA : 6100 E530           	BSR		LAB_EVEZ				; evaluate expression (no decrement)
    7078/    27DE : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type
    7079/    27E2 : 6B00 DA14           	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
    7080/    27E6 :                     
    7081/    27E6 :                     LAB_MAXN
    7082/    27E6 : 612E                	BSR.s		LAB_PHFA				; push FAC1, evaluate expression,
    7083/    27E8 :                     								; pull FAC2 & compare with FAC1
    7084/    27E8 : 64FC                	BCC.s		LAB_MAXN				; branch if no swap to do
    7085/    27EA :                     
    7086/    27EA : 6100 F4A0           	BSR		LAB_279B				; copy FAC2 to FAC1
    7087/    27EE : 60F6                	BRA.s		LAB_MAXN				; go do next
    7088/    27F0 :                     
    7089/    27F0 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 123 - 10/11/2023 16:23:32


    7090/    27F0 :                     ;************************************************************************************
    7091/    27F0 :                     ;
    7092/    27F0 :                     ; perform MIN()
    7093/    27F0 :                     
    7094/    27F0 :                     LAB_MIN
    7095/    27F0 : 6100 E51A           	BSR		LAB_EVEZ				; evaluate expression (no decrement)
    7096/    27F4 : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type
    7097/    27F8 : 6B00 D9FE           	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
    7098/    27FC :                     
    7099/    27FC :                     LAB_MINN
    7100/    27FC : 6118                	BSR.s		LAB_PHFA				; push FAC1, evaluate expression,
    7101/    27FE :                     								; pull FAC2 & compare with FAC1
    7102/    27FE : 63FC                	BLS.s		LAB_MINN				; branch if no swap to do
    7103/    2800 :                     
    7104/    2800 : 6100 F48A           	BSR		LAB_279B				; copy FAC2 to FAC1
    7105/    2804 : 60F6                	BRA.s		LAB_MINN				; go do next (branch always)
    7106/    2806 :                     
    7107/    2806 :                     ; exit routine. don't bother returning to the loop code
    7108/    2806 :                     ; check for correct exit, else so syntax error
    7109/    2806 :                     
    7110/    2806 :                     LAB_MMEC
    7111/    2806 : B03C 0029           	CMP.b		#')',d0				; is it end of function?
    7112/    280A : 6600 DA18           	BNE		LAB_SNER				; if not do MAX MIN syntax error
    7113/    280E :                     
    7114/    280E : 4FEF 0004           	LEA		4(sp),sp				; dump return address (faster)
    7115/    2812 : 6000 E656           	BRA		LAB_IGBY				; update BASIC execute pointer (to chr past ")")
    7116/    2816 :                     								; and return
    7117/    2816 :                     
    7118/    2816 :                     ; check for next, evaluate & return or exit
    7119/    2816 :                     ; this is the routine that does most of the work
    7120/    2816 :                     
    7121/    2816 :                     LAB_PHFA
    7122/    2816 : 6100 E654           	BSR		LAB_GBYT				; get next BASIC byte
    7123/    281A : B03C 002C           	CMP.b		#',',d0				; is there more ?
    7124/    281E : 66E6                	BNE.s		LAB_MMEC				; if not go do end check
    7125/    2820 :                     
    7126/    2820 : 3F2B 0594           	MOVE.w	FAC1_e(a3),-(sp)			; push exponent and sign
    7127/    2824 : 2F2B 0590           	MOVE.l	FAC1_m(a3),-(sp)			; push mantissa
    7128/    2828 :                     
    7129/    2828 : 6100 E4E2           	BSR		LAB_EVEZ				; evaluate expression (no decrement)
    7130/    282C : 4A2B 05B5           	TST.b		Dtypef(a3)				; test data type
    7131/    2830 : 6B00 D9C6           	BMI		LAB_TMER				; if string do Type missmatch Error/warm start
    7132/    2834 :                     
    7133/    2834 :                     
    7134/    2834 :                     								; pop FAC2 (MAX/MIN expression so far)
    7135/    2834 : 275F 0598           	MOVE.l	(sp)+,FAC2_m(a3)			; pop mantissa
    7136/    2838 :                     
    7137/    2838 : 301F                	MOVE.w	(sp)+,d0				; pop exponent and sign
    7138/    283A : 3740 059C           	MOVE.w	d0,FAC2_e(a3)			; save exponent and sign
    7139/    283E : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; get FAC1 sign
    7140/    2844 : B12B 059E           	EOR.b		d0,FAC_sc(a3)			; EOR to create sign compare
    7141/    2848 : 6000 F4AE           	BRA		LAB_27FA				; compare FAC1 with FAC2 & return
    7142/    284C :                     								; returns d0=+1 Cb=0 if FAC1 > FAC2
    7143/    284C :                     								; returns d0= 0 Cb=0 if FAC1 = FAC2
    7144/    284C :                     								; returns d0=-1 Cb=1 if FAC1 < FAC2
    7145/    284C :                     
    7146/    284C :                     
    7147/    284C :                     ;************************************************************************************
    7148/    284C :                     ;
    7149/    284C :                     ; perform WIDTH
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 124 - 10/11/2023 16:23:32


    7150/    284C :                     
    7151/    284C :                     LAB_WDTH
    7152/    284C : B03C 002C           	CMP.b		#',',d0				; is next byte ","
    7153/    2850 : 672C                	BEQ.s		LAB_TBSZ				; if so do tab size
    7154/    2852 :                     
    7155/    2852 : 6100 EF82           	BSR		LAB_GTBY				; get byte parameter, result in d0 and Itemp
    7156/    2856 : 4A00                	TST.b		d0					; test result
    7157/    2858 : 6712                	BEQ.s		LAB_NSTT				; branch if set for infinite line
    7158/    285A :                     
    7159/    285A : B03C 0010           	CMP.b		#$10,d0				; else make min width = 16d
    7160/    285E : 6500 D9B8           	BCS		LAB_FCER				; if less do function call error & exit
    7161/    2862 :                     
    7162/    2862 :                     ; this next compare ensures that we can't exit WIDTH via an error leaving the
    7163/    2862 :                     ; tab size greater than the line length.
    7164/    2862 :                     
    7165/    2862 : B02B 05E2           	CMP.b		TabSiz(a3),d0			; compare with tab size
    7166/    2866 : 6404                	BCC.s		LAB_NSTT				; branch if >= tab size
    7167/    2868 :                     
    7168/    2868 : 1740 05E2           	MOVE.b	d0,TabSiz(a3)			; else make tab size = terminal width
    7169/    286C :                     LAB_NSTT
    7170/    286C : 1740 05E6           	MOVE.b	d0,TWidth(a3)			; set the terminal width
    7171/    2870 : 6100 E5FA           	BSR		LAB_GBYT				; get BASIC byte back
    7172/    2874 : 672C                	BEQ.s		WExit					; exit if no following
    7173/    2876 :                     
    7174/    2876 : B03C 002C           	CMP.b		#',',d0				; else is it ","
    7175/    287A : 6600 D9A8           	BNE		LAB_SNER				; if not do syntax error
    7176/    287E :                     
    7177/    287E :                     LAB_TBSZ
    7178/    287E : 6100 EF52           	BSR		LAB_SGBY				; increment and get byte, result in d0 and Itemp
    7179/    2882 : 4A00                	TST.b		d0					; test TAB size
    7180/    2884 : 6B00 D992           	BMI		LAB_FCER				; if >127 do function call error & exit
    7181/    2888 :                     
    7182/    2888 : B03C 0001           	CMP.b		#1,d0					; compare with min-1
    7183/    288C : 6500 D98A           	BCS		LAB_FCER				; if <=1 do function call error & exit
    7184/    2890 :                     
    7185/    2890 : 122B 05E6           	MOVE.b	TWidth(a3),d1			; set flags for width
    7186/    2894 : 6708                	BEQ.s		LAB_SVTB				; skip check if infinite line
    7187/    2896 :                     
    7188/    2896 : B02B 05E6           	CMP.b		TWidth(a3),d0			; compare TAB with width
    7189/    289A : 6E00 D97C           	BGT		LAB_FCER				; branch if too big
    7190/    289E :                     
    7191/    289E :                     LAB_SVTB
    7192/    289E : 1740 05E2           	MOVE.b	d0,TabSiz(a3)			; save TAB size
    7193/    28A2 :                     
    7194/    28A2 :                     ; calculate tab column limit from TAB size. The Iclim is set to the last tab
    7195/    28A2 :                     ; position on a line that still has at least one whole tab width between it
    7196/    28A2 :                     ; and the end of the line.
    7197/    28A2 :                     
    7198/    28A2 :                     WExit
    7199/    28A2 : 102B 05E6           	MOVE.b	TWidth(a3),d0			; get width
    7200/    28A6 : 670A                	BEQ.s		LAB_WDLP				; branch if infinite line
    7201/    28A8 :                     
    7202/    28A8 : B02B 05E2           	CMP.b		TabSiz(a3),d0			; compare with tab size
    7203/    28AC : 6404                	BCC.s		LAB_WDLP				; branch if >= tab size
    7204/    28AE :                     
    7205/    28AE : 1740 05E2           	MOVE.b	d0,TabSiz(a3)			; else make tab size = terminal width
    7206/    28B2 :                     LAB_WDLP
    7207/    28B2 : 902B 05E2           	SUB.b		TabSiz(a3),d0			; subtract tab size
    7208/    28B6 : 64FA                	BCC.s		LAB_WDLP				; loop while no borrow
    7209/    28B8 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 125 - 10/11/2023 16:23:32


    7210/    28B8 : D02B 05E2           	ADD.b		TabSiz(a3),d0			; add tab size back
    7211/    28BC : D02B 05E2           	ADD.b		TabSiz(a3),d0			; add tab size back again
    7212/    28C0 :                     
    7213/    28C0 : 4400                	NEG.b		d0					; make -ve
    7214/    28C2 : D02B 05E6           	ADD.b		TWidth(a3),d0			; subtract remainder from width
    7215/    28C6 : 1740 05E7           	MOVE.b	d0,Iclim(a3)			; save tab column limit
    7216/    28CA :                     RTS_023
    7217/    28CA : 4E75                	RTS
    7218/    28CC :                     
    7219/    28CC :                     
    7220/    28CC :                     ;************************************************************************************
    7221/    28CC :                     ;
    7222/    28CC :                     ; perform SQR()
    7223/    28CC :                     
    7224/    28CC :                     ; d0 is number to find the root of
    7225/    28CC :                     ; d1 is the root result
    7226/    28CC :                     ; d2 is the remainder
    7227/    28CC :                     ; d3 is a counter
    7228/    28CC :                     ; d4 is temp
    7229/    28CC :                     
    7230/    28CC :                     LAB_SQR
    7231/    28CC : 4A2B 0595           	TST.b		FAC1_s(a3)				; test FAC1 sign
    7232/    28D0 : 6B00 D946           	BMI		LAB_FCER				; if -ve do function call error
    7233/    28D4 :                     
    7234/    28D4 : 4A2B 0594           	TST.b		FAC1_e(a3)				; test exponent
    7235/    28D8 : 67F0                	BEQ.s		RTS_023				; exit if zero
    7236/    28DA :                     
    7237/    28DA : 48E7 7800           	MOVEM.l	d1-d4,-(sp)				; save registers
    7238/    28DE : 202B 0590           	MOVE.l	FAC1_m(a3),d0			; copy FAC1
    7239/    28E2 : 7400                	MOVEQ		#0,d2					; clear remainder
    7240/    28E4 : 2202                	MOVE.l	d2,d1					; clear root
    7241/    28E6 :                     
    7242/    28E6 : 761F                	MOVEQ		#$1F,d3				; $1F for DBF, 64 pairs of bits to
    7243/    28E8 :                     								; do for a 32 bit result
    7244/    28E8 : 082B 0000 0594      	BTST		#0,FAC1_e(a3)			; test exponent odd/even
    7245/    28EE : 6606                	BNE.s		LAB_SQE2				; if odd only 1 shift first time
    7246/    28F0 :                     
    7247/    28F0 :                     LAB_SQE1
    7248/    28F0 : D080                	ADD.l		d0,d0					; shift highest bit of number ..
    7249/    28F2 : D582                	ADDX.l	d2,d2					; .. into remainder .. never overflows
    7250/    28F4 : D281                	ADD.l		d1,d1					; root = root	; 2 .. never overflows
    7251/    28F6 :                     LAB_SQE2
    7252/    28F6 : D080                	ADD.l		d0,d0					; shift highest bit of number ..
    7253/    28F8 : D582                	ADDX.l	d2,d2					; .. into remainder .. never overflows
    7254/    28FA :                     
    7255/    28FA : 2801                	MOVE.l	d1,d4					; copy root
    7256/    28FC : D884                	ADD.l		d4,d4					; 2n
    7257/    28FE : 5284                	ADDQ.l	#1,d4					; 2n+1
    7258/    2900 :                     
    7259/    2900 : B484                	CMP.l		d4,d2					; compare 2n+1 to remainder
    7260/    2902 : 6504                	BCS.s		LAB_SQNS				; skip sub if remainder smaller
    7261/    2904 :                     
    7262/    2904 : 9484                	SUB.l		d4,d2					; subtract temp from remainder
    7263/    2906 : 5281                	ADDQ.l	#1,d1					; increment root
    7264/    2908 :                     LAB_SQNS
    7265/    2908 : 51CB FFE6           	DBF		d3,LAB_SQE1				; loop if not all done
    7266/    290C :                     
    7267/    290C : 2741 0590           	MOVE.l	d1,FAC1_m(a3)			; save result mantissa
    7268/    2910 : 102B 0594           	MOVE.b	FAC1_e(a3),d0			; get exponent (d0 is clear here)
    7269/    2914 : 907C 0080           	SUB.w		#$80,d0				; normalise
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 126 - 10/11/2023 16:23:32


    7270/    2918 : E248                	LSR.w		#1,d0					; /2
    7271/    291A : 6402                	BCC.s		LAB_SQNA				; skip increment if carry clear
    7272/    291C :                     
    7273/    291C : 5240                	ADDQ.w	#1,d0					; add bit zero back in (allow for half shift)
    7274/    291E :                     LAB_SQNA
    7275/    291E : D07C 0080           	ADD.w		#$80,d0				; re-bias to $80
    7276/    2922 : 1740 0594           	MOVE.b	d0,FAC1_e(a3)			; save it
    7277/    2926 : 4CDF 001E           	MOVEM.l	(sp)+,d1-d4				; restore registers
    7278/    292A : 6000 F09E           	BRA		LAB_24D5				; normalise FAC1 & return
    7279/    292E :                     
    7280/    292E :                     
    7281/    292E :                     ;************************************************************************************
    7282/    292E :                     ;
    7283/    292E :                     ; perform VARPTR()
    7284/    292E :                     
    7285/    292E :                     LAB_VARPTR
    7286/    292E : 101D                	MOVE.b	(a5)+,d0				; increment pointer
    7287/    2930 :                     LAB_VARCALL
    7288/    2930 : 6100 E74A           	BSR		LAB_GVAR				; get variable address in a0
    7289/    2934 : 6100 E522           	BSR		LAB_1BFB				; scan for ")", else do syntax error/warm start
    7290/    2938 : 2008                	MOVE.l	a0,d0					; copy the variable address
    7291/    293A : 6000 EA30           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
    7292/    293E :                     
    7293/    293E :                     
    7294/    293E :                     ;************************************************************************************
    7295/    293E :                     ;
    7296/    293E :                     ; perform RAMBASE
    7297/    293E :                     
    7298/    293E :                     LAB_RAM
    7299/    293E : 41F8 0400           	LEA		ram_base,a0			; get start of EhBASIC RAM
    7300/    2942 : 2008                	MOVE.l	a0,d0					; copy it
    7301/    2944 : 6000 EA26           	BRA		LAB_AYFC				; convert d0 to signed longword in FAC1 & return
    7302/    2948 :                     
    7303/    2948 :                     
    7304/    2948 :                     ;************************************************************************************
    7305/    2948 :                     ;
    7306/    2948 :                     ; perform PI
    7307/    2948 :                     
    7308/    2948 :                     LAB_PI
    7309/    2948 : 277C C90F DAA2      	MOVE.l	#$C90FDAA2,FAC1_m(a3)		; pi mantissa (32 bit)
             294E : 0590             
    7310/    2950 : 377C 8200 0594      	MOVE.w	#$8200,FAC1_e(a3)			; pi exponent and sign
    7311/    2956 : 4E75                	RTS
    7312/    2958 :                     
    7313/    2958 :                     
    7314/    2958 :                     ;************************************************************************************
    7315/    2958 :                     ;
    7316/    2958 :                     ; perform TWOPI
    7317/    2958 :                     
    7318/    2958 :                     LAB_TWOPI
    7319/    2958 : 277C C90F DAA2      	MOVE.l	#$C90FDAA2,FAC1_m(a3)		; 2pi mantissa (32 bit)
             295E : 0590             
    7320/    2960 : 377C 8300 0594      	MOVE.w	#$8300,FAC1_e(a3)			; 2pi exponent and sign
    7321/    2966 : 4E75                	RTS
    7322/    2968 :                     
    7323/    2968 :                     
    7324/    2968 :                     ;************************************************************************************
    7325/    2968 :                     ;
    7326/    2968 :                     ; get ASCII string equivalent into FAC1 as integer32 or float
    7327/    2968 :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 127 - 10/11/2023 16:23:32


    7328/    2968 :                     ; entry is with a5 pointing to the first character of the string
    7329/    2968 :                     ; exit with a5 pointing to the first character after the string
    7330/    2968 :                     
    7331/    2968 :                     ; d0 is character
    7332/    2968 :                     ; d1 is mantissa
    7333/    2968 :                     ; d2 is partial and table mantissa
    7334/    2968 :                     ; d3 is mantissa exponent (decimal & binary)
    7335/    2968 :                     ; d4 is decimal exponent
    7336/    2968 :                     
    7337/    2968 :                     ; get FAC1 from string
    7338/    2968 :                     ; this routine now handles hex and binary values from strings
    7339/    2968 :                     ; starting with "$" and "%" respectively
    7340/    2968 :                     
    7341/    2968 :                     LAB_2887
    7342/    2968 : 48E7 7C00           	MOVEM.l	d1-d5,-(sp)				; save registers
    7343/    296C : 7200                	MOVEQ		#$00,d1				; clear temp accumulator
    7344/    296E : 2601                	MOVE.l	d1,d3					; set mantissa decimal exponent count
    7345/    2970 : 2801                	MOVE.l	d1,d4					; clear decimal exponent
    7346/    2972 : 1741 0595           	MOVE.b	d1,FAC1_s(a3)			; clear sign byte
    7347/    2976 : 1741 05B5           	MOVE.b	d1,Dtypef(a3)			; set float data type
    7348/    297A : 1741 05AF           	MOVE.b	d1,expneg(a3)			; clear exponent sign
    7349/    297E : 6100 E4EC           	BSR		LAB_GBYT				; get first byte back
    7350/    2982 : 653C                	BCS.s		LAB_28FE				; go get floating if 1st character numeric
    7351/    2984 :                     
    7352/    2984 : B03C 002D           	CMP.b		#'-',d0				; or is it -ve number
    7353/    2988 : 6608                	BNE.s		LAB_289A				; branch if not
    7354/    298A :                     
    7355/    298A : 177C 00FF 0595      	MOVE.b	#$FF,FAC1_s(a3)			; set sign byte
    7356/    2990 : 6006                	BRA.s		LAB_289C				; now go scan & check for hex/bin/int
    7357/    2992 :                     
    7358/    2992 :                     LAB_289A
    7359/    2992 :                     								; first character wasn't numeric or -
    7360/    2992 : B03C 002B           	CMP.b		#'+',d0				; compare with '+'
    7361/    2996 : 6606                	BNE.s		LAB_289D				; branch if not '+' (go check for '.'/hex/binary
    7362/    2998 :                     								; /integer)
    7363/    2998 :                     	
    7364/    2998 :                     LAB_289C
    7365/    2998 :                     								; was "+" or "-" to start, so get next character
    7366/    2998 : 6100 E4D0           	BSR		LAB_IGBY				; increment & scan memory
    7367/    299C : 6522                	BCS.s		LAB_28FE				; branch if numeric character
    7368/    299E :                     
    7369/    299E :                     LAB_289D
    7370/    299E : B03C 002E           	CMP.b		#'.',d0				; else compare with '.'
    7371/    29A2 : 6700 0092           	BEQ		LAB_2904				; branch if '.'
    7372/    29A6 :                     
    7373/    29A6 :                     								; code here for hex/binary/integer numbers
    7374/    29A6 : B03C 0024           	CMP.b		#'$',d0				; compare with '$'
    7375/    29AA : 6700 010A           	BEQ		LAB_CHEX				; branch if '$'
    7376/    29AE :                     
    7377/    29AE : B03C 0025           	CMP.b		#'%',d0				; else compare with '%'
    7378/    29B2 : 6700 0164           	BEQ		LAB_CBIN				; branch if '%'
    7379/    29B6 :                     
    7380/    29B6 : 6000 008C           	BRA		LAB_2Y01				; not #.$%& so return 0
    7381/    29BA :                     
    7382/    29BA :                     LAB_28FD
    7383/    29BA : 6100 E4AE           	BSR		LAB_IGBY				; get next character
    7384/    29BE : 646C                	BCC.s		LAB_2902				; exit loop if not a digit
    7385/    29C0 :                     
    7386/    29C0 :                     LAB_28FE
    7387/    29C0 : 6100 01A8           	BSR		d1x10					; multiply d1 by 10 and add character
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 128 - 10/11/2023 16:23:32


    7388/    29C4 : 64F4                	BCC.s		LAB_28FD				; loop for more if no overflow
    7389/    29C6 :                     
    7390/    29C6 :                     LAB_28FF
    7391/    29C6 :                     								; overflowed mantissa, count 10s exponent
    7392/    29C6 : 5283                	ADDQ.l	#1,d3					; increment mantissa decimal exponent count
    7393/    29C8 : 6100 E4A0           	BSR		LAB_IGBY				; get next character
    7394/    29CC : 65F8                	BCS.s		LAB_28FF				; loop while numeric character
    7395/    29CE :                     
    7396/    29CE :                     								; done overflow, now flush fraction or do E
    7397/    29CE : B03C 002E           	CMP.b		#'.',d0				; else compare with '.'
    7398/    29D2 : 6606                	BNE.s		LAB_2901				; branch if not '.'
    7399/    29D4 :                     
    7400/    29D4 :                     LAB_2900
    7401/    29D4 :                     								; flush remaining fraction digits
    7402/    29D4 : 6100 E494           	BSR		LAB_IGBY				; get next character
    7403/    29D8 : 65FA                	BCS		LAB_2900				; loop while numeric character
    7404/    29DA :                     
    7405/    29DA :                     LAB_2901
    7406/    29DA :                     								; done number, only (possible) exponent remains
    7407/    29DA : B03C 0045           	CMP.b		#'E',d0				; else compare with 'E'
    7408/    29DE : 6664                	BNE.s		LAB_2Y01				; if not 'E' all done, go evaluate
    7409/    29E0 :                     
    7410/    29E0 :                     								; process exponent
    7411/    29E0 : 6100 E488           	BSR		LAB_IGBY				; get next character
    7412/    29E4 : 6528                	BCS.s		LAB_2X04				; branch if digit
    7413/    29E6 :                     
    7414/    29E6 : B03C 002D           	CMP.b		#'-',d0				; or is it -ve number
    7415/    29EA : 6706                	BEQ.s		LAB_2X01				; branch if so
    7416/    29EC :                     
    7417/    29EC : B03C 00B3           	CMP.b		#TK_MINUS,d0			; or is it -ve number
    7418/    29F0 : 6608                	BNE.s		LAB_2X02				; branch if not
    7419/    29F2 :                     
    7420/    29F2 :                     LAB_2X01
    7421/    29F2 : 177C 00FF 05AF      	MOVE.b	#$FF,expneg(a3)			; set exponent sign
    7422/    29F8 : 600E                	BRA.s		LAB_2X03				; now go scan & check exponent
    7423/    29FA :                     
    7424/    29FA :                     LAB_2X02
    7425/    29FA : B03C 002B           	CMP.b		#'+',d0				; or is it +ve number
    7426/    29FE : 6708                	BEQ.s		LAB_2X03				; branch if so
    7427/    2A00 :                     
    7428/    2A00 : B03C 00B2           	CMP.b		#TK_PLUS,d0				; or is it +ve number
    7429/    2A04 : 6600 D81E           	BNE		LAB_SNER				; wasn't - + TK_MINUS TK_PLUS or # so do error
    7430/    2A08 :                     
    7431/    2A08 :                     LAB_2X03
    7432/    2A08 : 6100 E460           	BSR		LAB_IGBY				; get next character
    7433/    2A0C : 6436                	BCC.s		LAB_2Y01				; if not digit all done, go evaluate
    7434/    2A0E :                     LAB_2X04
    7435/    2A0E : C8FC 000A           	MULU		#10,d4				; multiply decimal exponent by 10
    7436/    2A12 : C0BC 0000 00FF      	AND.l		#$FF,d0				; mask character
    7437/    2A18 : 903C 0030           	SUB.b		#'0',d0				; convert to value
    7438/    2A1C : D880                	ADD.l		d0,d4					; add to decimal exponent
    7439/    2A1E : B83C 0030           	CMP.b		#48,d4				; compare with decimal exponent limit+10
    7440/    2A22 : 6FE4                	BLE.s		LAB_2X03				; loop if no overflow/underflow
    7441/    2A24 :                     
    7442/    2A24 :                     LAB_2X05
    7443/    2A24 :                     								; exponent value has overflowed
    7444/    2A24 : 6100 E444           	BSR		LAB_IGBY				; get next character
    7445/    2A28 : 65FA                	BCS.s		LAB_2X05				; loop while numeric digit
    7446/    2A2A :                     
    7447/    2A2A : 6018                	BRA.s		LAB_2Y01				; all done, go evaluate
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 129 - 10/11/2023 16:23:32


    7448/    2A2C :                     
    7449/    2A2C :                     LAB_2902
    7450/    2A2C : B03C 002E           	CMP.b		#'.',d0				; else compare with '.'
    7451/    2A30 : 6704                	BEQ.s		LAB_2904				; branch if was '.'
    7452/    2A32 :                     
    7453/    2A32 : 60A6                	BRA.s		LAB_2901				; branch if not '.' (go check/do 'E')
    7454/    2A34 :                     
    7455/    2A34 :                     LAB_2903
    7456/    2A34 : 5383                	SUBQ.l	#1,d3					; decrement mantissa decimal exponent
    7457/    2A36 :                     LAB_2904
    7458/    2A36 :                     								; was dp so get fraction part
    7459/    2A36 : 6100 E432           	BSR		LAB_IGBY				; get next character
    7460/    2A3A : 649E                	BCC.s		LAB_2901				; exit loop if not a digit (go check/do 'E')
    7461/    2A3C :                     
    7462/    2A3C : 6100 012C           	BSR		d1x10					; multiply d1 by 10 and add character
    7463/    2A40 : 64F2                	BCC.s		LAB_2903				; loop for more if no overflow
    7464/    2A42 :                     
    7465/    2A42 : 6090                	BRA.s		LAB_2900				; else go flush remaining fraction part
    7466/    2A44 :                     
    7467/    2A44 :                     LAB_2Y01
    7468/    2A44 :                     								; now evaluate result
    7469/    2A44 : 4A2B 05AF           	TST.b		expneg(a3)				; test exponent sign
    7470/    2A48 : 6A02                	BPL.s		LAB_2Y02				; branch if sign positive
    7471/    2A4A :                     
    7472/    2A4A : 4484                	NEG.l		d4					; negate decimal exponent
    7473/    2A4C :                     LAB_2Y02
    7474/    2A4C : D883                	ADD.l		d3,d4					; add mantissa decimal exponent
    7475/    2A4E : 7620                	MOVEQ		#32,d3				; set up max binary exponent
    7476/    2A50 : 4A81                	TST.l		d1					; test mantissa
    7477/    2A52 : 6752                	BEQ.s		LAB_rtn0				; if mantissa=0 return 0
    7478/    2A54 :                     
    7479/    2A54 : 6B08                	BMI.s		LAB_2Y04				; branch if already mormalised
    7480/    2A56 :                     
    7481/    2A56 : 5383                	SUBQ.l	#1,d3					; decrement bianry exponent for DBMI loop
    7482/    2A58 :                     LAB_2Y03
    7483/    2A58 : D281                	ADD.l		d1,d1					; shift mantissa
    7484/    2A5A : 5BCB FFFC           	DBMI		d3,LAB_2Y03				; decrement & loop if not normalised
    7485/    2A5E :                     
    7486/    2A5E :                     								; ensure not too big or small
    7487/    2A5E :                     LAB_2Y04
    7488/    2A5E : B8BC 0000 0026      	CMP.l		#38,d4				; compare decimal exponent with max exponent
    7489/    2A64 : 6E00 D7AE           	BGT		LAB_OFER				; if greater do overflow error and warm start
    7490/    2A68 :                     
    7491/    2A68 : B8BC FFFF FFDA      	CMP.l		#-38,d4				; compare decimal exponent with min exponent
    7492/    2A6E : 6D34                	BLT.s		LAB_ret0				; if less just return zero
    7493/    2A70 :                     
    7494/    2A70 : 4484                	NEG.l		d4					; negate decimal exponent to go right way
    7495/    2A72 : C9FC 0006           	MULS		#6,d4					; 6 bytes per entry
    7496/    2A76 : 2F08                	MOVE.l	a0,-(sp)				; save register
    7497/    2A78 : 41FA 0210           	LEA		LAB_P_10(pc),a0			; point to table
    7498/    2A7C : 1770 4000 059C      	MOVE.b	(a0,d4.w),FAC2_e(a3)		; copy exponent for multiply
    7499/    2A82 : 2770 4002 0598      	MOVE.l	2(a0,d4.w),FAC2_m(a3)		; copy table mantissa
    7500/    2A88 : 205F                	MOVE.l	(sp)+,a0				; restore register
    7501/    2A8A :                     
    7502/    2A8A : 0A03 0080           	EORI.b	#$80,d3				; normalise input exponent
    7503/    2A8E : 2741 0590           	MOVE.l	d1,FAC1_m(a3)			; save input mantissa
    7504/    2A92 : 1743 0594           	MOVE.b	d3,FAC1_e(a3)			; save input exponent
    7505/    2A96 : 176B 0595 059E      	MOVE.b	FAC1_s(a3),FAC_sc(a3)		; set sign as sign compare
    7506/    2A9C :                     
    7507/    2A9C : 4CDF 003E           	MOVEM.l	(sp)+,d1-d5				; restore registers
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 130 - 10/11/2023 16:23:32


    7508/    2AA0 : 6000 F050           	BRA		LAB_MULTIPLY			; go multiply input by table
    7509/    2AA4 :                     
    7510/    2AA4 :                     LAB_ret0
    7511/    2AA4 : 7200                	MOVEQ		#0,d1					; clear mantissa
    7512/    2AA6 :                     LAB_rtn0
    7513/    2AA6 : 2601                	MOVE.l	d1,d3					; clear exponent
    7514/    2AA8 : 1743 0594           	MOVE.b	d3,FAC1_e(a3)			; save exponent
    7515/    2AAC : 2741 0590           	MOVE.l	d1,FAC1_m(a3)			; save mantissa
    7516/    2AB0 : 4CDF 003E           	MOVEM.l	(sp)+,d1-d5				; restore registers
    7517/    2AB4 : 4E75                	RTS
    7518/    2AB6 :                     
    7519/    2AB6 :                     
    7520/    2AB6 :                     ;************************************************************************************
    7521/    2AB6 :                     ;
    7522/    2AB6 :                     ; $ for hex add-on
    7523/    2AB6 :                     
    7524/    2AB6 :                     ; gets here if the first character was "$" for hex
    7525/    2AB6 :                     ; get hex number
    7526/    2AB6 :                     
    7527/    2AB6 :                     LAB_CHEX
    7528/    2AB6 : 177C 0040 05B5      	MOVE.b	#$40,Dtypef(a3)			; set integer numeric data type
    7529/    2ABC : 7620                	MOVEQ		#32,d3				; set up max binary exponent
    7530/    2ABE :                     LAB_CHXX
    7531/    2ABE : 6100 E3AA           	BSR		LAB_IGBY				; increment & scan memory
    7532/    2AC2 : 6514                	BCS.s		LAB_ISHN				; branch if numeric character
    7533/    2AC4 :                     
    7534/    2AC4 : 803C 0020           	OR.b		#$20,d0				; case convert, allow "A" to "F" and "a" to "f"
    7535/    2AC8 : 903C 0061           	SUB.b		#'a',d0				; subtract "a"
    7536/    2ACC : 652A                	BCS.s		LAB_CHX3				; exit if <"a"
    7537/    2ACE :                     
    7538/    2ACE : B03C 0006           	CMP.b		#$06,d0				; compare normalised with $06 (max+1)
    7539/    2AD2 : 6424                	BCC.s		LAB_CHX3				; exit if >"f"
    7540/    2AD4 :                     
    7541/    2AD4 : D03C 003A           	ADD.b		#$3A,d0				; convert to nibble+"0"
    7542/    2AD8 :                     LAB_ISHN
    7543/    2AD8 : 616C                	BSR.s		d1x16					; multiply d1 by 16 and add the character
    7544/    2ADA : 64E2                	BCC.s		LAB_CHXX				; loop for more if no overflow
    7545/    2ADC :                     
    7546/    2ADC :                     								; overflowed mantissa, count 16s exponent
    7547/    2ADC :                     LAB_CHX1
    7548/    2ADC : 5883                	ADDQ.l	#4,d3					; increment mantissa exponent count
    7549/    2ADE : 6900 D734           	BVS		LAB_OFER				; do overflow error if overflowed
    7550/    2AE2 :                     
    7551/    2AE2 : 6100 E386           	BSR		LAB_IGBY				; get next character
    7552/    2AE6 : 65F4                	BCS.s		LAB_CHX1				; loop while numeric character
    7553/    2AE8 :                     
    7554/    2AE8 : 803C 0020           	OR.b		#$20,d0				; case convert, allow "A" to "F" and "a" to "f"
    7555/    2AEC : 903C 0061           	SUB.b		#'a',d0				; subtract "a"
    7556/    2AF0 : 6506                	BCS.s		LAB_CHX3				; exit if <"a"
    7557/    2AF2 :                     
    7558/    2AF2 : B03C 0006           	CMP.b		#$06,d0				; compare normalised with $06 (max+1)
    7559/    2AF6 : 65E4                	BCS.s		LAB_CHX1				; loop if <="f"
    7560/    2AF8 :                     
    7561/    2AF8 :                     								; now return value
    7562/    2AF8 :                     LAB_CHX3
    7563/    2AF8 : 4A81                	TST.l		d1					; test mantissa
    7564/    2AFA : 67AA                	BEQ.s		LAB_rtn0				; if mantissa=0 return 0
    7565/    2AFC :                     
    7566/    2AFC : 6B08                	BMI.s		LAB_exxf				; branch if already mormalised
    7567/    2AFE :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 131 - 10/11/2023 16:23:32


    7568/    2AFE : 5383                	SUBQ.l	#1,d3					; decrement bianry exponent for DBMI loop
    7569/    2B00 :                     LAB_CHX2
    7570/    2B00 : D281                	ADD.l		d1,d1					; shift mantissa
    7571/    2B02 : 5BCB FFFC           	DBMI		d3,LAB_CHX2				; decrement & loop if not normalised
    7572/    2B06 :                     
    7573/    2B06 :                     LAB_exxf
    7574/    2B06 : 0A03 0080           	EORI.b	#$80,d3				; normalise exponent
    7575/    2B0A : 1743 0594           	MOVE.b	d3,FAC1_e(a3)			; save exponent
    7576/    2B0E : 2741 0590           	MOVE.l	d1,FAC1_m(a3)			; save mantissa
    7577/    2B12 : 4CDF 003E           	MOVEM.l	(sp)+,d1-d5				; restore registers
    7578/    2B16 :                     RTS_024
    7579/    2B16 : 4E75                	RTS
    7580/    2B18 :                     
    7581/    2B18 :                     
    7582/    2B18 :                     ;************************************************************************************
    7583/    2B18 :                     ;
    7584/    2B18 :                     ; % for binary add-on
    7585/    2B18 :                     
    7586/    2B18 :                     ; gets here if the first character was "%" for binary
    7587/    2B18 :                     ; get binary number
    7588/    2B18 :                     
    7589/    2B18 :                     LAB_CBIN
    7590/    2B18 : 177C 0040 05B5      	MOVE.b	#$40,Dtypef(a3)			; set integer numeric data type
    7591/    2B1E : 7620                	MOVEQ		#32,d3				; set up max binary exponent
    7592/    2B20 :                     LAB_CBXN
    7593/    2B20 : 6100 E348           	BSR		LAB_IGBY				; increment & scan memory
    7594/    2B24 : 64D2                	BCC.s		LAB_CHX3				; if not numeric character go return value
    7595/    2B26 :                     
    7596/    2B26 : B03C 0032           	CMP.b		#'2',d0				; compare with "2" (max+1)
    7597/    2B2A : 64CC                	BCC.s		LAB_CHX3				; if >="2" go return value
    7598/    2B2C :                     
    7599/    2B2C : 2401                	MOVE.l	d1,d2					; copy value
    7600/    2B2E : 6124                	BSR.s		d1x02					; multiply d1 by 2 and add character
    7601/    2B30 : 64EE                	BCC.s		LAB_CBXN				; loop for more if no overflow
    7602/    2B32 :                     
    7603/    2B32 :                     								; overflowed mantissa, count 2s exponent
    7604/    2B32 :                     LAB_CBX1
    7605/    2B32 : 5283                	ADDQ.l	#1,d3					; increment mantissa exponent count
    7606/    2B34 : 6900 D6DE           	BVS		LAB_OFER				; do overflow error if overflowed
    7607/    2B38 :                     
    7608/    2B38 : 6100 E330           	BSR		LAB_IGBY				; get next character
    7609/    2B3C : 64BA                	BCC.s		LAB_CHX3				; if not numeric character go return value
    7610/    2B3E :                     
    7611/    2B3E : B03C 0032           	CMP.b		#'2',d0				; compare with "2" (max+1)
    7612/    2B42 : 65EE                	BCS.s		LAB_CBX1				; loop if <"2"
    7613/    2B44 :                     
    7614/    2B44 : 60B2                	BRA.s		LAB_CHX3				; if not numeric character go return value
    7615/    2B46 :                     
    7616/    2B46 :                     ; half way decent times 16 and times 2 with overflow checks
    7617/    2B46 :                     
    7618/    2B46 :                     d1x16
    7619/    2B46 : 2401                	MOVE.l	d1,d2					; copy value
    7620/    2B48 : D482                	ADD.l		d2,d2					; times two
    7621/    2B4A : 65CA                	BCS.s		RTS_024				; return if overflow
    7622/    2B4C :                     
    7623/    2B4C : D482                	ADD.l		d2,d2					; times four
    7624/    2B4E : 65C6                	BCS.s		RTS_024				; return if overflow
    7625/    2B50 :                     
    7626/    2B50 : D482                	ADD.l		d2,d2					; times eight
    7627/    2B52 : 65C2                	BCS.s		RTS_024				; return if overflow
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 132 - 10/11/2023 16:23:32


    7628/    2B54 :                     
    7629/    2B54 :                     d1x02
    7630/    2B54 : D482                	ADD.l		d2,d2					; times sixteen (ten/two)
    7631/    2B56 : 65BE                	BCS.s		RTS_024				; return if overflow
    7632/    2B58 :                     
    7633/    2B58 :                     ; now add in new digit
    7634/    2B58 :                     
    7635/    2B58 : C0BC 0000 00FF      	AND.l		#$FF,d0				; mask character
    7636/    2B5E : 903C 0030           	SUB.b		#'0',d0				; convert to value
    7637/    2B62 : D480                	ADD.l		d0,d2					; add to result
    7638/    2B64 : 65B0                	BCS.s		RTS_024				; return if overflow, it should never ever do
    7639/    2B66 :                     								; this
    7640/    2B66 :                     
    7641/    2B66 : 2202                	MOVE.l	d2,d1					; copy result
    7642/    2B68 : 4E75                	RTS
    7643/    2B6A :                     
    7644/    2B6A :                     ; half way decent times 10 with overflow checks
    7645/    2B6A :                     
    7646/    2B6A :                     d1x10
    7647/    2B6A : 2401                	MOVE.l	d1,d2					; copy value
    7648/    2B6C : D482                	ADD.l		d2,d2					; times two
    7649/    2B6E : 6508                	BCS.s		RTS_025				; return if overflow
    7650/    2B70 :                     
    7651/    2B70 : D482                	ADD.l		d2,d2					; times four
    7652/    2B72 : 6504                	BCS.s		RTS_025				; return if overflow
    7653/    2B74 :                     
    7654/    2B74 : D481                	ADD.l		d1,d2					; times five
    7655/    2B76 : 64DC                	BCC.s		d1x02					; do times two and add in new digit if ok
    7656/    2B78 :                     
    7657/    2B78 :                     RTS_025
    7658/    2B78 : 4E75                	RTS
    7659/    2B7A :                     
    7660/    2B7A :                     
    7661/    2B7A :                     ;************************************************************************************
    7662/    2B7A :                     ;
    7663/    2B7A :                     ; token values needed for BASIC
    7664/    2B7A :                     
    7665/    2B7A : =$80                TK_END		EQU $80				; $80
    7666/    2B7A : =$81                TK_FOR		EQU TK_END+1			; $81
    7667/    2B7A : =$82                TK_NEXT		EQU TK_FOR+1			; $82
    7668/    2B7A : =$83                TK_DATA		EQU TK_NEXT+1			; $83
    7669/    2B7A : =$84                TK_INPUT		EQU TK_DATA+1			; $84
    7670/    2B7A : =$85                TK_DIM		EQU TK_INPUT+1			; $85
    7671/    2B7A : =$86                TK_READ		EQU TK_DIM+1			; $86
    7672/    2B7A : =$87                TK_LET		EQU TK_READ+1			; $87
    7673/    2B7A : =$88                TK_DEC		EQU TK_LET+1			; $88
    7674/    2B7A : =$89                TK_GOTO		EQU TK_DEC+1			; $89
    7675/    2B7A : =$8A                TK_RUN		EQU TK_GOTO+1			; $8A
    7676/    2B7A : =$8B                TK_IF			EQU TK_RUN+1			; $8B
    7677/    2B7A : =$8C                TK_RESTORE		EQU TK_IF+1				; $8C
    7678/    2B7A : =$8D                TK_GOSUB		EQU TK_RESTORE+1			; $8D
    7679/    2B7A : =$8E                TK_RETURN		EQU TK_GOSUB+1			; $8E
    7680/    2B7A : =$8F                TK_REM		EQU TK_RETURN+1			; $8F
    7681/    2B7A : =$90                TK_STOP		EQU TK_REM+1			; $90
    7682/    2B7A : =$91                TK_ON			EQU TK_STOP+1			; $91
    7683/    2B7A : =$92                TK_NULL		EQU TK_ON+1				; $92
    7684/    2B7A : =$93                TK_INC		EQU TK_NULL+1			; $93
    7685/    2B7A : =$94                TK_WAIT		EQU TK_INC+1			; $94
    7686/    2B7A : =$95                TK_LOAD		EQU TK_WAIT+1			; $95
    7687/    2B7A : =$96                TK_SAVE		EQU TK_LOAD+1			; $96
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 133 - 10/11/2023 16:23:32


    7688/    2B7A : =$97                TK_DEF		EQU TK_SAVE+1			; $97
    7689/    2B7A : =$98                TK_POKE		EQU TK_DEF+1			; $98
    7690/    2B7A : =$99                TK_DOKE		EQU TK_POKE+1			; $99
    7691/    2B7A : =$9A                TK_LOKE		EQU TK_DOKE+1			; $9A
    7692/    2B7A : =$9B                TK_CALL		EQU TK_LOKE+1			; $9B
    7693/    2B7A : =$9C                TK_DO			EQU TK_CALL+1			; $9C
    7694/    2B7A : =$9D                TK_LOOP		EQU TK_DO+1				; $9D
    7695/    2B7A : =$9E                TK_PRINT		EQU TK_LOOP+1			; $9E
    7696/    2B7A : =$9F                TK_CONT		EQU TK_PRINT+1			; $9F
    7697/    2B7A : =$A0                TK_LIST		EQU TK_CONT+1			; $A0
    7698/    2B7A : =$A1                TK_CLEAR		EQU TK_LIST+1			; $A1
    7699/    2B7A : =$A2                TK_NEW		EQU TK_CLEAR+1			; $A2
    7700/    2B7A : =$A3                TK_WIDTH		EQU TK_NEW+1			; $A3
    7701/    2B7A : =$A4                TK_GET		EQU TK_WIDTH+1			; $A4
    7702/    2B7A : =$A5                TK_SWAP		EQU TK_GET+1			; $A5
    7703/    2B7A : =$A6                TK_BITSET		EQU TK_SWAP+1			; $A6
    7704/    2B7A : =$A7                TK_BITCLR		EQU TK_BITSET+1			; $A7
    7705/    2B7A : =$A8                TK_TAB		EQU TK_BITCLR+1			; $A8
    7706/    2B7A : =$A9                TK_ELSE		EQU TK_TAB+1			; $A9
    7707/    2B7A : =$AA                TK_TO			EQU TK_ELSE+1			; $AA
    7708/    2B7A : =$AB                TK_FN			EQU TK_TO+1				; $AB
    7709/    2B7A : =$AC                TK_SPC		EQU TK_FN+1				; $AC
    7710/    2B7A : =$AD                TK_THEN		EQU TK_SPC+1			; $AD
    7711/    2B7A : =$AE                TK_NOT		EQU TK_THEN+1			; $AE
    7712/    2B7A : =$AF                TK_STEP		EQU TK_NOT+1			; $AF
    7713/    2B7A : =$B0                TK_UNTIL		EQU TK_STEP+1			; $B0
    7714/    2B7A : =$B1                TK_WHILE		EQU TK_UNTIL+1			; $B1
    7715/    2B7A : =$B2                TK_PLUS		EQU TK_WHILE+1			; $B2
    7716/    2B7A : =$B3                TK_MINUS		EQU TK_PLUS+1			; $B3
    7717/    2B7A : =$B4                TK_MULT		EQU TK_MINUS+1			; $B4
    7718/    2B7A : =$B5                TK_DIV		EQU TK_MULT+1			; $B5
    7719/    2B7A : =$B6                TK_POWER		EQU TK_DIV+1			; $B6
    7720/    2B7A : =$B7                TK_AND		EQU TK_POWER+1			; $B7
    7721/    2B7A : =$B8                TK_EOR		EQU TK_AND+1			; $B8
    7722/    2B7A : =$B9                TK_OR			EQU TK_EOR+1			; $B9
    7723/    2B7A : =$BA                TK_RSHIFT		EQU TK_OR+1				; $BA
    7724/    2B7A : =$BB                TK_LSHIFT		EQU TK_RSHIFT+1			; $BB
    7725/    2B7A : =$BC                TK_GT			EQU TK_LSHIFT+1			; $BC
    7726/    2B7A : =$BD                TK_EQUAL		EQU TK_GT+1				; $BD
    7727/    2B7A : =$BE                TK_LT			EQU TK_EQUAL+1			; $BE
    7728/    2B7A : =$BF                TK_SGN		EQU TK_LT+1				; $BF
    7729/    2B7A : =$C0                TK_INT		EQU TK_SGN+1			; $C0
    7730/    2B7A : =$C1                TK_ABS		EQU TK_INT+1			; $C1
    7731/    2B7A : =$C2                TK_USR		EQU TK_ABS+1			; $C2
    7732/    2B7A : =$C3                TK_FRE		EQU TK_USR+1			; $C3
    7733/    2B7A : =$C4                TK_POS		EQU TK_FRE+1			; $C4
    7734/    2B7A : =$C5                TK_SQR		EQU TK_POS+1			; $C5
    7735/    2B7A : =$C6                TK_RND		EQU TK_SQR+1			; $C6
    7736/    2B7A : =$C7                TK_LOG		EQU TK_RND+1			; $C7
    7737/    2B7A : =$C8                TK_EXP		EQU TK_LOG+1			; $C8
    7738/    2B7A : =$C9                TK_COS		EQU TK_EXP+1			; $C9
    7739/    2B7A : =$CA                TK_SIN		EQU TK_COS+1			; $CA
    7740/    2B7A : =$CB                TK_TAN		EQU TK_SIN+1			; $CB
    7741/    2B7A : =$CC                TK_ATN		EQU TK_TAN+1			; $CC
    7742/    2B7A : =$CD                TK_PEEK		EQU TK_ATN+1			; $CD
    7743/    2B7A : =$CE                TK_DEEK		EQU TK_PEEK+1			; $CE
    7744/    2B7A : =$CF                TK_LEEK		EQU TK_DEEK+1			; $CF
    7745/    2B7A : =$D0                TK_LEN		EQU TK_LEEK+1			; $D0
    7746/    2B7A : =$D1                TK_STRS		EQU TK_LEN+1			; $D1
    7747/    2B7A : =$D2                TK_VAL		EQU TK_STRS+1			; $D2
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 134 - 10/11/2023 16:23:32


    7748/    2B7A : =$D3                TK_ASC		EQU TK_VAL+1			; $D3
    7749/    2B7A : =$D4                TK_UCASES		EQU TK_ASC+1			; $D4
    7750/    2B7A : =$D5                TK_LCASES		EQU TK_UCASES+1			; $D5
    7751/    2B7A : =$D6                TK_CHRS		EQU TK_LCASES+1			; $D6
    7752/    2B7A : =$D7                TK_HEXS		EQU TK_CHRS+1			; $D7
    7753/    2B7A : =$D8                TK_BINS		EQU TK_HEXS+1			; $D8
    7754/    2B7A : =$D9                TK_BITTST		EQU TK_BINS+1			; $D9
    7755/    2B7A : =$DA                TK_MAX		EQU TK_BITTST+1			; $DA
    7756/    2B7A : =$DB                TK_MIN		EQU TK_MAX+1			; $DB
    7757/    2B7A : =$DC                TK_RAM		EQU TK_MIN+1			; $DC
    7758/    2B7A : =$DD                TK_PI			EQU TK_RAM+1			; $DD
    7759/    2B7A : =$DE                TK_TWOPI		EQU TK_PI+1				; $DE
    7760/    2B7A : =$DF                TK_VPTR		EQU TK_TWOPI+1			; $DF
    7761/    2B7A : =$E0                TK_SADD		EQU TK_VPTR+1			; $E0
    7762/    2B7A : =$E1                TK_LEFTS		EQU TK_SADD+1			; $E1
    7763/    2B7A : =$E2                TK_RIGHTS		EQU TK_LEFTS+1			; $E2
    7764/    2B7A : =$E3                TK_MIDS		EQU TK_RIGHTS+1			; $E3
    7765/    2B7A : =$E4                TK_USINGS		EQU TK_MIDS+1			; $E4
    7766/    2B7A :                     
    7767/    2B7A :                     
    7768/    2B7A :                     ;************************************************************************************
    7769/    2B7A :                     ;
    7770/    2B7A :                     ; binary to unsigned decimal table
    7771/    2B7A :                     
    7772/    2B7A :                     Bin2dec
    7773/    2B7A : 3B9A CA00           	dc.l	$3B9ACA00					; 1000000000
    7774/    2B7E : 05F5 E100           	dc.l	$05F5E100					; 100000000
    7775/    2B82 : 0098 9680           	dc.l	$00989680					; 10000000
    7776/    2B86 : 000F 4240           	dc.l	$000F4240					; 1000000
    7777/    2B8A : 0001 86A0           	dc.l	$000186A0					; 100000
    7778/    2B8E : 0000 2710           	dc.l	$00002710					; 10000
    7779/    2B92 : 0000 03E8           	dc.l	$000003E8					; 1000
    7780/    2B96 : 0000 0064           	dc.l	$00000064					; 100
    7781/    2B9A : 0000 000A           	dc.l	$0000000A					; 10
    7782/    2B9E : 0000 0000           	dc.l	$00000000					; 0 end marker
    7783/    2BA2 :                     
    7784/    2BA2 :                     LAB_RSED
    7785/    2BA2 : 332E 3232           	dc.l	$332E3232					; 858665522
    7786/    2BA6 :                     
    7787/    2BA6 :                     ; string to value exponent table
    7788/    2BA6 :                     
    7789/    2BA6 : FF00                	dc.w	255<<8					; 10**38
    7790/    2BA8 : 9676 9951           	dc.l	$96769951
    7791/    2BAC : FB00                	dc.w	251<<8					; 10**37
    7792/    2BAE : F0BD C21B           	dc.l	$F0BDC21B
    7793/    2BB2 : F800                	dc.w	248<<8					; 10**36
    7794/    2BB4 : C097 CE7C           	dc.l	$C097CE7C
    7795/    2BB8 : F500                	dc.w	245<<8					; 10**35
    7796/    2BBA : 9A13 0B96           	dc.l	$9A130B96
    7797/    2BBE : F100                	dc.w	241<<8					; 10**34
    7798/    2BC0 : F684 DF57           	dc.l	$F684DF57
    7799/    2BC4 : EE00                	dc.w	238<<8					; 10**33
    7800/    2BC6 : C537 1912           	dc.l	$C5371912
    7801/    2BCA : EB00                	dc.w	235<<8					; 10**32
    7802/    2BCC : 9DC5 ADA8           	dc.l	$9DC5ADA8
    7803/    2BD0 : E700                	dc.w	231<<8					; 10**31
    7804/    2BD2 : FC6F 7C40           	dc.l	$FC6F7C40
    7805/    2BD6 : E400                	dc.w	228<<8					; 10**30
    7806/    2BD8 : C9F2 C9CD           	dc.l	$C9F2C9CD
    7807/    2BDC : E100                	dc.w	225<<8					; 10**29
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 135 - 10/11/2023 16:23:32


    7808/    2BDE : A18F 07D7           	dc.l	$A18F07D7
    7809/    2BE2 : DE00                	dc.w	222<<8					; 10**28
    7810/    2BE4 : 813F 3979           	dc.l	$813F3979
    7811/    2BE8 : DA00                	dc.w	218<<8					; 10**27
    7812/    2BEA : CECB 8F28           	dc.l	$CECB8F28
    7813/    2BEE : D700                	dc.w	215<<8					; 10**26
    7814/    2BF0 : A56F A5BA           	dc.l	$A56FA5BA
    7815/    2BF4 : D400                	dc.w	212<<8					; 10**25
    7816/    2BF6 : 8459 5161           	dc.l	$84595161
    7817/    2BFA : D000                	dc.w	208<<8					; 10**24
    7818/    2BFC : D3C2 1BCF           	dc.l	$D3C21BCF
    7819/    2C00 : CD00                	dc.w	205<<8					; 10**23
    7820/    2C02 : A968 163F           	dc.l	$A968163F
    7821/    2C06 : CA00                	dc.w	202<<8					; 10**22
    7822/    2C08 : 8786 7832           	dc.l	$87867832
    7823/    2C0C : C600                	dc.w	198<<8					; 10**21
    7824/    2C0E : D8D7 26B7           	dc.l	$D8D726B7
    7825/    2C12 : C300                	dc.w	195<<8					; 10**20
    7826/    2C14 : AD78 EBC6           	dc.l	$AD78EBC6
    7827/    2C18 : C000                	dc.w	192<<8					; 10**19
    7828/    2C1A : 8AC7 2305           	dc.l	$8AC72305
    7829/    2C1E : BC00                	dc.w	188<<8					; 10**18
    7830/    2C20 : DE0B 6B3A           	dc.l	$DE0B6B3A
    7831/    2C24 : B900                	dc.w	185<<8					; 10**17
    7832/    2C26 : B1A2 BC2F           	dc.l	$B1A2BC2F
    7833/    2C2A : B600                	dc.w	182<<8					; 10**16
    7834/    2C2C : 8E1B C9BF           	dc.l	$8E1BC9BF
    7835/    2C30 : B200                	dc.w	178<<8					; 10**15
    7836/    2C32 : E35F A932           	dc.l	$E35FA932
    7837/    2C36 : AF00                	dc.w	175<<8					; 10**14
    7838/    2C38 : B5E6 20F5           	dc.l	$B5E620F5
    7839/    2C3C : AC00                	dc.w	172<<8					; 10**13
    7840/    2C3E : 9184 E72A           	dc.l	$9184E72A
    7841/    2C42 : A800                	dc.w	168<<8					; 10**12
    7842/    2C44 : E8D4 A510           	dc.l	$E8D4A510
    7843/    2C48 : A500                	dc.w	165<<8					; 10**11
    7844/    2C4A : BA43 B740           	dc.l	$BA43B740
    7845/    2C4E : A200                	dc.w	162<<8					; 10**10
    7846/    2C50 : 9502 F900           	dc.l	$9502F900
    7847/    2C54 : 9E00                	dc.w	158<<8					; 10**9
    7848/    2C56 : EE6B 2800           	dc.l	$EE6B2800
    7849/    2C5A : 9B00                	dc.w	155<<8					; 10**8
    7850/    2C5C : BEBC 2000           	dc.l	$BEBC2000
    7851/    2C60 : 9800                	dc.w	152<<8					; 10**7
    7852/    2C62 : 9896 8000           	dc.l	$98968000
    7853/    2C66 : 9400                	dc.w	148<<8					; 10**6
    7854/    2C68 : F424 0000           	dc.l	$F4240000
    7855/    2C6C : 9100                	dc.w	145<<8					; 10**5
    7856/    2C6E : C350 0000           	dc.l	$C3500000
    7857/    2C72 : 8E00                	dc.w	142<<8					; 10**4
    7858/    2C74 : 9C40 0000           	dc.l	$9C400000
    7859/    2C78 : 8A00                	dc.w	138<<8					; 10**3
    7860/    2C7A : FA00 0000           	dc.l	$FA000000
    7861/    2C7E : 8700                	dc.w	135<<8					; 10**2
    7862/    2C80 : C800 0000           	dc.l	$C8000000
    7863/    2C84 : 8400                	dc.w	132<<8					; 10**1
    7864/    2C86 : A000 0000           	dc.l	$A0000000
    7865/    2C8A :                     LAB_P_10
    7866/    2C8A : 8100                	dc.w	129<<8					; 10**0
    7867/    2C8C : 8000 0000           	dc.l	$80000000
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 136 - 10/11/2023 16:23:32


    7868/    2C90 : 7D00                	dc.w	125<<8					; 10**-1
    7869/    2C92 : CCCC CCCD           	dc.l	$CCCCCCCD
    7870/    2C96 : 7A00                	dc.w	122<<8					; 10**-2
    7871/    2C98 : A3D7 0A3D           	dc.l	$A3D70A3D
    7872/    2C9C : 7700                	dc.w	119<<8					; 10**-3
    7873/    2C9E : 8312 6E98           	dc.l	$83126E98
    7874/    2CA2 : 7300                	dc.w	115<<8					; 10**-4
    7875/    2CA4 : D1B7 1759           	dc.l	$D1B71759
    7876/    2CA8 : 7000                	dc.w	112<<8					; 10**-5
    7877/    2CAA : A7C5 AC47           	dc.l	$A7C5AC47
    7878/    2CAE : 6D00                	dc.w	109<<8					; 10**-6
    7879/    2CB0 : 8637 BD06           	dc.l	$8637BD06
    7880/    2CB4 : 6900                	dc.w	105<<8					; 10**-7
    7881/    2CB6 : D6BF 94D6           	dc.l	$D6BF94D6
    7882/    2CBA : 6600                	dc.w	102<<8					; 10**-8
    7883/    2CBC : ABCC 7712           	dc.l	$ABCC7712
    7884/    2CC0 : 6300                	dc.w	99<<8						; 10**-9
    7885/    2CC2 : 8970 5F41           	dc.l	$89705F41
    7886/    2CC6 : 5F00                	dc.w	95<<8						; 10**-10
    7887/    2CC8 : DBE6 FECF           	dc.l	$DBE6FECF
    7888/    2CCC : 5C00                	dc.w	92<<8						; 10**-11
    7889/    2CCE : AFEB FF0C           	dc.l	$AFEBFF0C
    7890/    2CD2 : 5900                	dc.w	89<<8						; 10**-12
    7891/    2CD4 : 8CBC CC09           	dc.l	$8CBCCC09
    7892/    2CD8 : 5500                	dc.w	85<<8						; 10**-13
    7893/    2CDA : E12E 1342           	dc.l	$E12E1342
    7894/    2CDE : 5200                	dc.w	82<<8						; 10**-14
    7895/    2CE0 : B424 DC35           	dc.l	$B424DC35
    7896/    2CE4 : 4F00                	dc.w	79<<8						; 10**-15
    7897/    2CE6 : 901D 7CF7           	dc.l	$901D7CF7
    7898/    2CEA : 4B00                	dc.w	75<<8						; 10**-16
    7899/    2CEC : E695 94BF           	dc.l	$E69594BF
    7900/    2CF0 : 4800                	dc.w	72<<8						; 10**-17
    7901/    2CF2 : B877 AA32           	dc.l	$B877AA32
    7902/    2CF6 : 4500                	dc.w	69<<8						; 10**-18
    7903/    2CF8 : 9392 EE8F           	dc.l	$9392EE8F
    7904/    2CFC : 4100                	dc.w	65<<8						; 10**-19
    7905/    2CFE : EC1E 4A7E           	dc.l	$EC1E4A7E
    7906/    2D02 : 3E00                	dc.w	62<<8						; 10**-20
    7907/    2D04 : BCE5 0865           	dc.l	$BCE50865
    7908/    2D08 : 3B00                	dc.w	59<<8						; 10**-21
    7909/    2D0A : 971D A050           	dc.l	$971DA050
    7910/    2D0E : 3700                	dc.w	55<<8						; 10**-22
    7911/    2D10 : F1C9 0081           	dc.l	$F1C90081
    7912/    2D14 : 3400                	dc.w	52<<8						; 10**-23
    7913/    2D16 : C16D 9A01           	dc.l	$C16D9A01
    7914/    2D1A : 3100                	dc.w	49<<8						; 10**-24
    7915/    2D1C : 9ABE 14CD           	dc.l	$9ABE14CD
    7916/    2D20 : 2D00                	dc.w	45<<8						; 10**-25
    7917/    2D22 : F796 87AE           	dc.l	$F79687AE
    7918/    2D26 : 2A00                	dc.w	42<<8						; 10**-26
    7919/    2D28 : C612 0625           	dc.l	$C6120625
    7920/    2D2C : 2700                	dc.w	39<<8						; 10**-27
    7921/    2D2E : 9E74 D1B8           	dc.l	$9E74D1B8
    7922/    2D32 : 2300                	dc.w	35<<8						; 10**-28
    7923/    2D34 : FD87 B5F3           	dc.l	$FD87B5F3
    7924/    2D38 : 2000                	dc.w	32<<8						; 10**-29
    7925/    2D3A : CAD2 F7F5           	dc.l	$CAD2F7F5
    7926/    2D3E : 1D00                	dc.w	29<<8						; 10**-30
    7927/    2D40 : A242 5FF7           	dc.l	$A2425FF7
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 137 - 10/11/2023 16:23:32


    7928/    2D44 : 1A00                	dc.w	26<<8						; 10**-31
    7929/    2D46 : 81CE B32C           	dc.l	$81CEB32C
    7930/    2D4A : 1600                	dc.w	22<<8						; 10**-32
    7931/    2D4C : CFB1 1EAD           	dc.l	$CFB11EAD
    7932/    2D50 : 1300                	dc.w	19<<8						; 10**-33
    7933/    2D52 : A627 4BBE           	dc.l	$A6274BBE
    7934/    2D56 : 1000                	dc.w	16<<8						; 10**-34
    7935/    2D58 : 84EC 3C98           	dc.l	$84EC3C98
    7936/    2D5C : 0C00                	dc.w	12<<8						; 10**-35
    7937/    2D5E : D4AD 2DC0           	dc.l	$D4AD2DC0
    7938/    2D62 : 0900                	dc.w	9<<8						; 10**-36
    7939/    2D64 : AA24 2499           	dc.l	$AA242499
    7940/    2D68 : 0600                	dc.w	6<<8						; 10**-37
    7941/    2D6A : 881C EA14           	dc.l	$881CEA14
    7942/    2D6E : 0200                	dc.w	2<<8						; 10**-38
    7943/    2D70 : D9C7 DCED           	dc.l	$D9C7DCED
    7944/    2D74 :                     
    7945/    2D74 :                     
    7946/    2D74 :                     ;************************************************************************************
    7947/    2D74 :                     ;
    7948/    2D74 :                     ; table of constants for cordic SIN/COS/TAN calculations
    7949/    2D74 :                     ; constants are un normalised fractions and are atn(2^-i)/2pi
    7950/    2D74 :                     
    7951/    2D74 : 4DBA 76D4           	dc.l	$4DBA76D4					; SIN/COS multiply constant
    7952/    2D78 :                     TAB_SNCO
    7953/    2D78 : 2000 0000           	dc.l	$20000000					; atn(2^0)/2pi
    7954/    2D7C : 12E4 051E           	dc.l	$12E4051E					; atn(2^1)/2pi
    7955/    2D80 : 09FB 385C           	dc.l	$09FB385C					; atn(2^2)/2pi
    7956/    2D84 : 0511 11D5           	dc.l	$051111D5					; atn(2^3)/2pi
    7957/    2D88 : 028B 0D44           	dc.l	$028B0D44					; atn(2^4)/2pi
    7958/    2D8C : 0145 D7E2           	dc.l	$0145D7E2					; atn(2^5)/2pi
    7959/    2D90 : 00A2 F61F           	dc.l	$00A2F61F					; atn(2^6)/2pi
    7960/    2D94 : 0051 7C56           	dc.l	$00517C56					; atn(2^7)/2pi
    7961/    2D98 : 0028 BE54           	dc.l	$0028BE54					; atn(2^8)/2pi
    7962/    2D9C : 0014 5F2F           	dc.l	$00145F2F					; atn(2^9)/2pi
    7963/    2DA0 : 000A 2F99           	dc.l	$000A2F99					; atn(2^10)/2pi
    7964/    2DA4 : 0005 17CD           	dc.l	$000517CD					; atn(2^11)/2pi
    7965/    2DA8 : 0002 8BE7           	dc.l	$00028BE7					; atn(2^12)/2pi
    7966/    2DAC : 0001 45F4           	dc.l	$000145F4					; atn(2^13)/2pi
    7967/    2DB0 : 0000 A2FA           	dc.l	$0000A2FA					; atn(2^14)/2pi
    7968/    2DB4 : 0000 517D           	dc.l	$0000517D					; atn(2^15)/2pi
    7969/    2DB8 : 0000 28BF           	dc.l	$000028BF					; atn(2^16)/2pi
    7970/    2DBC : 0000 1460           	dc.l	$00001460					; atn(2^17)/2pi
    7971/    2DC0 : 0000 0A30           	dc.l	$00000A30					; atn(2^18)/2pi
    7972/    2DC4 : 0000 0518           	dc.l	$00000518					; atn(2^19)/2pi
    7973/    2DC8 : 0000 028C           	dc.l	$0000028C					; atn(2^20)/2pi
    7974/    2DCC : 0000 0146           	dc.l	$00000146					; atn(2^21)/2pi
    7975/    2DD0 : 0000 00A3           	dc.l	$000000A3					; atn(2^22)/2pi
    7976/    2DD4 : 0000 0052           	dc.l	$00000052					; atn(2^23)/2pi
    7977/    2DD8 : 0000 0029           	dc.l	$00000029					; atn(2^24)/2pi
    7978/    2DDC : 0000 0015           	dc.l	$00000015					; atn(2^25)/2pi
    7979/    2DE0 : 0000 000B           	dc.l	$0000000B					; atn(2^26)/2pi
    7980/    2DE4 : 0000 0006           	dc.l	$00000006					; atn(2^27)/2pi
    7981/    2DE8 : 0000 0003           	dc.l	$00000003					; atn(2^28)/2pi
    7982/    2DEC : 0000 0002           	dc.l	$00000002					; atn(2^29)/2pi
    7983/    2DF0 : 0000 0001           	dc.l	$00000001					; atn(2^30)/2pi
    7984/    2DF4 : 0000 0001           	dc.l	$00000001					; atn(2^31)/2pi
    7985/    2DF8 :                     
    7986/    2DF8 :                     
    7987/    2DF8 :                     ;************************************************************************************
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 138 - 10/11/2023 16:23:32


    7988/    2DF8 :                     ;
    7989/    2DF8 :                     ; table of constants for cordic ATN calculation
    7990/    2DF8 :                     ; constants are normalised to two integer bits and are atn(2^-i)
    7991/    2DF8 :                     
    7992/    2DF8 :                     TAB_ATNC
    7993/    2DF8 : 1DAC 6705           	dc.l	$1DAC6705					; atn(2^-1)
    7994/    2DFC : 0FAD BAFD           	dc.l	$0FADBAFD					; atn(2^-2)
    7995/    2E00 : 07F5 6EA7           	dc.l	$07F56EA7					; atn(2^-3)
    7996/    2E04 : 03FE AB77           	dc.l	$03FEAB77					; atn(2^-4)
    7997/    2E08 : 01FF D55C           	dc.l	$01FFD55C					; atn(2^-5)
    7998/    2E0C : 00FF FAAB           	dc.l	$00FFFAAB					; atn(2^-6)
    7999/    2E10 : 007F FF55           	dc.l	$007FFF55					; atn(2^-7)
    8000/    2E14 : 003F FFEB           	dc.l	$003FFFEB					; atn(2^-8)
    8001/    2E18 : 001F FFFD           	dc.l	$001FFFFD					; atn(2^-9)
    8002/    2E1C : 0010 0000           	dc.l	$00100000					; atn(2^-10)
    8003/    2E20 : 0008 0000           	dc.l	$00080000					; atn(2^-11)
    8004/    2E24 : 0004 0000           	dc.l	$00040000					; atn(2^-12)
    8005/    2E28 : 0002 0000           	dc.l	$00020000					; atn(2^-13)
    8006/    2E2C : 0001 0000           	dc.l	$00010000					; atn(2^-14)
    8007/    2E30 : 0000 8000           	dc.l	$00008000					; atn(2^-15)
    8008/    2E34 : 0000 4000           	dc.l	$00004000					; atn(2^-16)
    8009/    2E38 : 0000 2000           	dc.l	$00002000					; atn(2^-17)
    8010/    2E3C : 0000 1000           	dc.l	$00001000					; atn(2^-18)
    8011/    2E40 : 0000 0800           	dc.l	$00000800					; atn(2^-19)
    8012/    2E44 : 0000 0400           	dc.l	$00000400					; atn(2^-20)
    8013/    2E48 : 0000 0200           	dc.l	$00000200					; atn(2^-21)
    8014/    2E4C : 0000 0100           	dc.l	$00000100					; atn(2^-22)
    8015/    2E50 : 0000 0080           	dc.l	$00000080					; atn(2^-23)
    8016/    2E54 : 0000 0040           	dc.l	$00000040					; atn(2^-24)
    8017/    2E58 : 0000 0020           	dc.l	$00000020					; atn(2^-25)
    8018/    2E5C : 0000 0010           	dc.l	$00000010					; atn(2^-26)
    8019/    2E60 : 0000 0008           	dc.l	$00000008					; atn(2^-27)
    8020/    2E64 : 0000 0004           	dc.l	$00000004					; atn(2^-28)
    8021/    2E68 : 0000 0002           	dc.l	$00000002					; atn(2^-29)
    8022/    2E6C : 0000 0001           	dc.l	$00000001					; atn(2^-30)
    8023/    2E70 :                     LAB_1D96
    8024/    2E70 : 0000 0000           	dc.l	$00000000					; atn(2^-31)
    8025/    2E74 : 0000 0000           	dc.l	$00000000					; atn(2^-32)
    8026/    2E78 :                     
    8027/    2E78 :                     ; constants are normalised to n integer bits and are tanh(2^-i)
    8028/    2E78 : =$2                 n	equ	2
    8029/    2E78 :                     TAB_HTHET
    8030/    2E78 : 2327 D4F4           	dc.l	$2327d4f4				; atnh(2^-1) .549306144
    8031/    2E7C : 1058 AEFA           	dc.l	$1058aefa				; atnh(2^-2) .255412812
    8032/    2E80 : 080A C48E           	dc.l	$080ac48e				; atnh(2^-3)
    8033/    2E84 : 0401 5622           	dc.l	$04015622				; atnh(2^-4)
    8034/    2E88 : 0200 2AB0           	dc.l	$02002ab0				; atnh(2^-5)
    8035/    2E8C : 0100 0554           	dc.l	$01000554				; atnh(2^-6)
    8036/    2E90 : 0080 00AA           	dc.l	$008000aa				; atnh(2^-7)
    8037/    2E94 : 0040 0014           	dc.l	$00400014				; atnh(2^-8)
    8038/    2E98 : 0020 0002           	dc.l	$00200002				; atnh(2^-9)
    8039/    2E9C : 0010 0000           	dc.l	$00100000				; atnh(2^-10)
    8040/    2EA0 : 0008 0000           	dc.l	$00080000				; atnh(2^-11)
    8041/    2EA4 : 0004 0000           	dc.l	$00040000				; atnh(2^-12)
    8042/    2EA8 : 0002 0000           	dc.l	$00020000				; atnh(2^-13)
    8043/    2EAC : 0001 0000           	dc.l	$00010000				; atnh(2^-14)
    8044/    2EB0 : 0000 8000           	dc.l	$00008000				; atnh(2^-15)
    8045/    2EB4 : 0000 4000           	dc.l	$00004000				; atnh(2^-16)
    8046/    2EB8 : 0000 2000           	dc.l	$00002000				; atnh(2^-17)
    8047/    2EBC : 0000 1000           	dc.l	$00001000				; atnh(2^-18)
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 139 - 10/11/2023 16:23:32


    8048/    2EC0 : 0000 0800           	dc.l	$00000800				; atnh(2^-19)
    8049/    2EC4 : 0000 0400           	dc.l	$00000400				; atnh(2^-20)
    8050/    2EC8 : 0000 0200           	dc.l	$00000200				; atnh(2^-21)
    8051/    2ECC : 0000 0100           	dc.l	$00000100				; atnh(2^-22)
    8052/    2ED0 : 0000 0080           	dc.l	$00000080				; atnh(2^-23)
    8053/    2ED4 : 0000 0040           	dc.l	$00000040				; atnh(2^-24)
    8054/    2ED8 : 0000 0020           	dc.l	$00000020				; atnh(2^-25)
    8055/    2EDC : 0000 0010           	dc.l	$00000010				; atnh(2^-26)
    8056/    2EE0 : 0000 0008           	dc.l	$00000008				; atnh(2^-27)
    8057/    2EE4 : 0000 0004           	dc.l	$00000004				; atnh(2^-28)
    8058/    2EE8 : 0000 0002           	dc.l	$00000002				; atnh(2^-29)
    8059/    2EEC : 0000 0001           	dc.l	$00000001				; atnh(2^-30)
    8060/    2EF0 : 0000 0000           	dc.l	$00000000				; atnh(2^-31)
    8061/    2EF4 : 0000 0000           	dc.l	$00000000				; atnh(2^-32)
    8062/    2EF8 : =$26A3D110          KFCTSEED	equ	$26A3D110			; $26A3D110
    8063/    2EF8 :                     
    8064/    2EF8 :                     
    8065/    2EF8 :                     ;************************************************************************************
    8066/    2EF8 :                     ;
    8067/    2EF8 :                     ; command vector table
    8068/    2EF8 :                     
    8069/    2EF8 :                     LAB_CTBL
    8070/    2EF8 : D79E                	dc.w	LAB_END-LAB_CTBL				; END
    8071/    2EFA : D6D2                	dc.w	LAB_FOR-LAB_CTBL				; FOR
    8072/    2EFC : DD44                	dc.w	LAB_NEXT-LAB_CTBL				; NEXT
    8073/    2EFE : D8F2                	dc.w	LAB_DATA-LAB_CTBL				; DATA
    8074/    2F00 : DC38                	dc.w	LAB_INPUT-LAB_CTBL			; INPUT
    8075/    2F02 : E116                	dc.w	LAB_DIM-LAB_CTBL				; DIM
    8076/    2F04 : DC5E                	dc.w	LAB_READ-LAB_CTBL				; READ
    8077/    2F06 : DA6A                	dc.w	LAB_LET-LAB_CTBL				; LET
    8078/    2F08 : DA06                	dc.w	LAB_DEC-LAB_CTBL				; DEC	
    8079/    2F0A : D85A                	dc.w	LAB_GOTO-LAB_CTBL				; GOTO
    8080/    2F0C : D822                	dc.w	LAB_RUN-LAB_CTBL				; RUN
    8081/    2F0E : D91A                	dc.w	LAB_IF-LAB_CTBL				; IF
    8082/    2F10 : D7CC                	dc.w	LAB_RESTORE-LAB_CTBL			; RESTORE
    8083/    2F12 : D848                	dc.w	LAB_GOSUB-LAB_CTBL			; GOSUB
    8084/    2F14 : D8DE                	dc.w	LAB_RETURN-LAB_CTBL			; RETURN
    8085/    2F16 : D98C                	dc.w	LAB_REM-LAB_CTBL				; REM
    8086/    2F18 : D7A6                	dc.w	LAB_STOP-LAB_CTBL				; STOP
    8087/    2F1A : D994                	dc.w	LAB_ON-LAB_CTBL				; ON
    8088/    2F1C : D7FA                	dc.w	LAB_NULL-LAB_CTBL				; NULL
    8089/    2F1E : DA0C                	dc.w	LAB_INC-LAB_CTBL				; INC	
    8090/    2F20 : EA1E                	dc.w	LAB_WAIT-LAB_CTBL				; WAIT
    8091/    2F22 : EA0C                	dc.w	LAB_LOAD-LAB_CTBL				; LOAD
    8092/    2F24 : EA10                	dc.w	LAB_SAVE-LAB_CTBL				; SAVE
    8093/    2F26 : E4A6                	dc.w	LAB_DEF-LAB_CTBL				; DEF
    8094/    2F28 : E98C                	dc.w	LAB_POKE-LAB_CTBL				; POKE
    8095/    2F2A : E9BC                	dc.w	LAB_DOKE-LAB_CTBL				; DOKE
    8096/    2F2C : E9C2                	dc.w	LAB_LOKE-LAB_CTBL				; LOKE
    8097/    2F2E : EA14                	dc.w	LAB_CALL-LAB_CTBL				; CALL
    8098/    2F30 : D836                	dc.w	LAB_DO-LAB_CTBL				; DO	
    8099/    2F32 : D888                	dc.w	LAB_LOOP-LAB_CTBL				; LOOP
    8100/    2F34 : DAFE                	dc.w	LAB_PRINT-LAB_CTBL			; PRINT
    8101/    2F36 : D804                	dc.w	LAB_CONT-LAB_CTBL				; CONT
    8102/    2F38 : D61C                	dc.w	LAB_LIST-LAB_CTBL				; LIST
    8103/    2F3A : D618                	dc.w	LAB_CLEAR-LAB_CTBL			; CLEAR
    8104/    2F3C : D5C6                	dc.w	LAB_NEW-LAB_CTBL				; NEW
    8105/    2F3E : F954                	dc.w	LAB_WDTH-LAB_CTBL				; WIDTH
    8106/    2F40 : DAC4                	dc.w	LAB_GET-LAB_CTBL				; GET
    8107/    2F42 : E9D6                	dc.w	LAB_SWAP-LAB_CTBL				; SWAP
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 140 - 10/11/2023 16:23:32


    8108/    2F44 : F49E                	dc.w	LAB_BITSET-LAB_CTBL			; BITSET
    8109/    2F46 : F4AE                	dc.w	LAB_BITCLR-LAB_CTBL			; BITCLR
    8110/    2F48 :                     
    8111/    2F48 :                     
    8112/    2F48 :                     ;************************************************************************************
    8113/    2F48 :                     ;
    8114/    2F48 :                     ; function pre process routine table
    8115/    2F48 :                     
    8116/    2F48 :                     LAB_FTPP
    8117/    2F48 : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; SGN(n)	process numeric expression in ()
    8118/    2F4A : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; INT(n)		"
    8119/    2F4C : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; ABS(n)		"
    8120/    2F4E : DDC4                	dc.w	LAB_EVEZ-LAB_FTPP				; USR(x)	process any expression
    8121/    2F50 : DF0C                	dc.w	LAB_1BF7-LAB_FTPP				; FRE(x)	process any expression in ()
    8122/    2F52 : DF0C                	dc.w	LAB_1BF7-LAB_FTPP				; POS(x)		"
    8123/    2F54 : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; SQR(n)	process numeric expression in ()
    8124/    2F56 : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; RND(n)		"
    8125/    2F58 : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; LOG(n)		"
    8126/    2F5A : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; EXP(n)		"
    8127/    2F5C : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; COS(n)		"
    8128/    2F5E : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; SIN(n)		"
    8129/    2F60 : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; TAN(n)		"
    8130/    2F62 : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; ATN(n)		"
    8131/    2F64 : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; PEEK(n)		"
    8132/    2F66 : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; DEEK(n)		"
    8133/    2F68 : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; LEEK(n)		"
    8134/    2F6A : DFB6                	dc.w	LAB_PPFS-LAB_FTPP				; LEN($)	process string expression in ()
    8135/    2F6C : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; STR$(n)	process numeric expression in ()
    8136/    2F6E : DFB6                	dc.w	LAB_PPFS-LAB_FTPP				; VAL($)	process string expression in ()
    8137/    2F70 : DFB6                	dc.w	LAB_PPFS-LAB_FTPP				; ASC($)		"
    8138/    2F72 : DFB6                	dc.w	LAB_PPFS-LAB_FTPP				; UCASE$($)		"
    8139/    2F74 : DFB6                	dc.w	LAB_PPFS-LAB_FTPP				; LCASE$($)		"
    8140/    2F76 : DFC4                	dc.w	LAB_PPFN-LAB_FTPP				; CHR$(n)	process numeric expression in ()
    8141/    2F78 : DFFE                	dc.w	LAB_BHSS-LAB_FTPP				; HEX$()	bin/hex pre process
    8142/    2F7A : DFFE                	dc.w	LAB_BHSS-LAB_FTPP				; BIN$()		"
    8143/    2F7C : 0000                	dc.w	$0000						; BITTST()	none
    8144/    2F7E : 0000                	dc.w	$0000						; MAX()		"
    8145/    2F80 : 0000                	dc.w	$0000						; MIN()		"
    8146/    2F82 : DFD2                	dc.w	LAB_PPBI-LAB_FTPP				; RAMBASE	advance pointer
    8147/    2F84 : DFD2                	dc.w	LAB_PPBI-LAB_FTPP				; PI			"
    8148/    2F86 : DFD2                	dc.w	LAB_PPBI-LAB_FTPP				; TWOPI		"
    8149/    2F88 : 0000                	dc.w	$0000						; VARPTR()	none
    8150/    2F8A : 0000                	dc.w	$0000						; SADD()		"
    8151/    2F8C : DFDC                	dc.w	LAB_LRMS-LAB_FTPP				; LEFT$()	process string expression
    8152/    2F8E : DFDC                	dc.w	LAB_LRMS-LAB_FTPP				; RIGHT$()		"
    8153/    2F90 : DFDC                	dc.w	LAB_LRMS-LAB_FTPP				; MID$()		"
    8154/    2F92 : DDC4                	dc.w	LAB_EVEZ-LAB_FTPP				; USING$(x)	process any expression
    8155/    2F94 :                     
    8156/    2F94 :                     
    8157/    2F94 :                     ;************************************************************************************
    8158/    2F94 :                     ;
    8159/    2F94 :                     ; action addresses for functions
    8160/    2F94 :                     
    8161/    2F94 :                     LAB_FTBL
    8162/    2F94 : ED4A                	dc.w	LAB_SGN-LAB_FTBL				; SGN()
    8163/    2F96 : EDCE                	dc.w	LAB_INT-LAB_FTBL				; INT()
    8164/    2F98 : ED5C                	dc.w	LAB_ABS-LAB_FTBL				; ABS()
    8165/    2F9A : E968                	dc.w	LAB_USR-LAB_FTBL				; USR()
    8166/    2F9C : E3C2                	dc.w	LAB_FRE-LAB_FTBL				; FRE()
    8167/    2F9E : E3F4                	dc.w	LAB_POS-LAB_FTBL				; POS()
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 141 - 10/11/2023 16:23:32


    8168/    2FA0 : F938                	dc.w	LAB_SQR-LAB_FTBL				; SQR()
    8169/    2FA2 : F21C                	dc.w	LAB_RND-LAB_FTBL				; RND()
    8170/    2FA4 : EA6C                	dc.w	LAB_LOG-LAB_FTBL				; LOG()
    8171/    2FA6 : F102                	dc.w	LAB_EXP-LAB_FTBL				; EXP()
    8172/    2FA8 : F270                	dc.w	LAB_COS-LAB_FTBL				; COS()
    8173/    2FAA : F288                	dc.w	LAB_SIN-LAB_FTBL				; SIN()
    8174/    2FAC : F24E                	dc.w	LAB_TAN-LAB_FTBL				; TAN()
    8175/    2FAE : F34E                	dc.w	LAB_ATN-LAB_FTBL				; ATN()
    8176/    2FB0 : E8E4                	dc.w	LAB_PEEK-LAB_FTBL				; PEEK()
    8177/    2FB2 : E8F6                	dc.w	LAB_DEEK-LAB_FTBL				; DEEK()
    8178/    2FB4 : E90C                	dc.w	LAB_LEEK-LAB_FTBL				; LEEK()
    8179/    2FB6 : E826                	dc.w	LAB_LENS-LAB_FTBL				; LEN()
    8180/    2FB8 : E4EA                	dc.w	LAB_STRS-LAB_FTBL				; STR$()
    8181/    2FBA : E86C                	dc.w	LAB_VAL-LAB_FTBL				; VAL()
    8182/    2FBC : E82E                	dc.w	LAB_ASC-LAB_FTBL				; ASC()
    8183/    2FBE : E7DC                	dc.w	LAB_UCASE-LAB_FTBL			; UCASE$()
    8184/    2FC0 : E7AC                	dc.w	LAB_LCASE-LAB_FTBL			; LCASE$()
    8185/    2FC2 : E714                	dc.w	LAB_CHRS-LAB_FTBL				; CHR$()
    8186/    2FC4 : F7DA                	dc.w	LAB_HEXS-LAB_FTBL				; HEX$()
    8187/    2FC6 : F788                	dc.w	LAB_BINS-LAB_FTBL				; BIN$()
    8188/    2FC8 : F422                	dc.w	LAB_BTST-LAB_FTBL				; BITTST()
    8189/    2FCA : F846                	dc.w	LAB_MAX-LAB_FTBL				; MAX()
    8190/    2FCC : F85C                	dc.w	LAB_MIN-LAB_FTBL				; MIN()
    8191/    2FCE : F9AA                	dc.w	LAB_RAM-LAB_FTBL				; RAMBASE
    8192/    2FD0 : F9B4                	dc.w	LAB_PI-LAB_FTBL				; PI
    8193/    2FD2 : F9C4                	dc.w	LAB_TWOPI-LAB_FTBL			; TWOPI
    8194/    2FD4 : F99A                	dc.w	LAB_VARPTR-LAB_FTBL			; VARPTR()
    8195/    2FD6 : E80E                	dc.w	LAB_SADD-LAB_FTBL				; SADD()
    8196/    2FD8 : E724                	dc.w	LAB_LEFT-LAB_FTBL				; LEFT$()
    8197/    2FDA : E738                	dc.w	LAB_RIGHT-LAB_FTBL			; RIGHT$()
    8198/    2FDC : E768                	dc.w	LAB_MIDS-LAB_FTBL				; MID$()
    8199/    2FDE : F450                	dc.w	LAB_USINGS-LAB_FTBL			; USING$()
    8200/    2FE0 :                     
    8201/    2FE0 :                     
    8202/    2FE0 :                     ;************************************************************************************
    8203/    2FE0 :                     ;
    8204/    2FE0 :                     ; hierarchy and action addresses for operator
    8205/    2FE0 :                     
    8206/    2FE0 :                     LAB_OPPT
    8207/    2FE0 : 0079                	dc.w	$0079						; +
    8208/    2FE2 : E96E                	dc.w	LAB_ADD-LAB_OPPT
    8209/    2FE4 : 0079                	dc.w	$0079						; -
    8210/    2FE6 : E95A                	dc.w	LAB_SUBTRACT-LAB_OPPT
    8211/    2FE8 : 007B                	dc.w	$007B						; *
    8212/    2FEA : EB12                	dc.w	LAB_MULTIPLY-LAB_OPPT
    8213/    2FEC : 007B                	dc.w	$007B						; /
    8214/    2FEE : EB9E                	dc.w	LAB_DIVIDE-LAB_OPPT
    8215/    2FF0 : 007F                	dc.w	$007F						; ^
    8216/    2FF2 : F000                	dc.w	LAB_POWER-LAB_OPPT
    8217/    2FF4 : 0050                	dc.w	$0050						; AND
    8218/    2FF6 : DFA6                	dc.w	LAB_AND-LAB_OPPT
    8219/    2FF8 : 0046                	dc.w	$0046						; EOR
    8220/    2FFA : DF96                	dc.w	LAB_EOR-LAB_OPPT
    8221/    2FFC : 0046                	dc.w	$0046						; OR
    8222/    2FFE : DF9E                	dc.w	LAB_OR-LAB_OPPT
    8223/    3000 : 0056                	dc.w	$0056						; >>
    8224/    3002 : E04A                	dc.w	LAB_RSHIFT-LAB_OPPT
    8225/    3004 : 0056                	dc.w	$0056						; <<
    8226/    3006 : E03A                	dc.w	LAB_LSHIFT-LAB_OPPT
    8227/    3008 : 007D                	dc.w	$007D						; >
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 142 - 10/11/2023 16:23:32


    8228/    300A : F064                	dc.w	LAB_GTHAN-LAB_OPPT			; used to evaluate -n
    8229/    300C : 005A                	dc.w	$005A						; =
    8230/    300E : DFBC                	dc.w	LAB_EQUAL-LAB_OPPT			; used to evaluate NOT
    8231/    3010 : 0064                	dc.w	$0064						; <
    8232/    3012 : DFC6                	dc.w	LAB_LTHAN-LAB_OPPT
    8233/    3014 :                     
    8234/    3014 :                     
    8235/    3014 :                     ;************************************************************************************
    8236/    3014 :                     ;
    8237/    3014 :                     ; misc constants
    8238/    3014 :                     
    8239/    3014 :                     ; This table is used in converting numbers to ASCII.
    8240/    3014 :                     ; first four entries for expansion to 9.25 digits
    8241/    3014 :                     
    8242/    3014 :                     LAB_2A9A
    8243/    3014 : FFF0 BDC0           	dc.l	$FFF0BDC0					; -1000000
    8244/    3018 : 0001 86A0           	dc.l	$000186A0					; 100000
    8245/    301C : FFFF D8F0           	dc.l	$FFFFD8F0					; -10000
    8246/    3020 : 0000 03E8           	dc.l	$000003E8					; 1000
    8247/    3024 : FFFF FF9C           	dc.l	$FFFFFF9C					; -100
    8248/    3028 : 0000 000A           	dc.l	$0000000A					; 10
    8249/    302C : FFFF FFFF           	dc.l	$FFFFFFFF					; -1
    8250/    3030 :                     LAB_2A9B
    8251/    3030 :                     
    8252/    3030 :                     
    8253/    3030 :                     ;************************************************************************************
    8254/    3030 :                     ;
    8255/    3030 :                     ; new keyword tables
    8256/    3030 :                     
    8257/    3030 :                     ; offsets to keyword tables
    8258/    3030 :                     
    8259/    3030 :                     TAB_CHRT
    8260/    3030 : 0000                	dc.w	TAB_STAR-TAB_STAR				; "*"	$2A
    8261/    3032 : 0002                	dc.w	TAB_PLUS-TAB_STAR				; "+"	$2B
    8262/    3034 : FFFF                	dc.w	-1						; "," $2C no keywords
    8263/    3036 : 0004                	dc.w	TAB_MNUS-TAB_STAR				; "-"	$2D
    8264/    3038 : FFFF                	dc.w	-1						; "." $2E no keywords
    8265/    303A : 0006                	dc.w	TAB_SLAS-TAB_STAR				; "/"	$2F
    8266/    303C : FFFF                	dc.w	-1						; "0" $30 no keywords
    8267/    303E : FFFF                	dc.w	-1						; "1" $31 no keywords
    8268/    3040 : FFFF                	dc.w	-1						; "2" $32 no keywords
    8269/    3042 : FFFF                	dc.w	-1						; "3" $33 no keywords
    8270/    3044 : FFFF                	dc.w	-1						; "4" $34 no keywords
    8271/    3046 : FFFF                	dc.w	-1						; "5" $35 no keywords
    8272/    3048 : FFFF                	dc.w	-1						; "6" $36 no keywords
    8273/    304A : FFFF                	dc.w	-1						; "7" $37 no keywords
    8274/    304C : FFFF                	dc.w	-1						; "8" $38 no keywords
    8275/    304E : FFFF                	dc.w	-1						; "9" $39 no keywords
    8276/    3050 : FFFF                	dc.w	-1						; ";" $3A no keywords
    8277/    3052 : FFFF                	dc.w	-1						; ":" $3B no keywords
    8278/    3054 : 0008                	dc.w	TAB_LESS-TAB_STAR				; "<"	$3C
    8279/    3056 : 000C                	dc.w	TAB_EQUL-TAB_STAR				; "="	$3D
    8280/    3058 : 000E                	dc.w	TAB_MORE-TAB_STAR				; ">"	$3E
    8281/    305A : 0012                	dc.w	TAB_QEST-TAB_STAR				; "?"	$3F
    8282/    305C : FFFF                	dc.w	-1						; "@" $40 no keywords
    8283/    305E : 0014                	dc.w	TAB_ASCA-TAB_STAR				; "A"	$41
    8284/    3060 : 0024                	dc.w	TAB_ASCB-TAB_STAR				; "B"	$42
    8285/    3062 : 003D                	dc.w	TAB_ASCC-TAB_STAR				; "C"	$43
    8286/    3064 : 0054                	dc.w	TAB_ASCD-TAB_STAR				; "D"	$44
    8287/    3066 : 006D                	dc.w	TAB_ASCE-TAB_STAR				; "E"	$45
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 143 - 10/11/2023 16:23:32


    8288/    3068 : 007C                	dc.w	TAB_ASCF-TAB_STAR				; "F"	$46
    8289/    306A : 0086                	dc.w	TAB_ASCG-TAB_STAR				; "G"	$47
    8290/    306C : 0093                	dc.w	TAB_ASCH-TAB_STAR				; "H"	$48
    8291/    306E : 0099                	dc.w	TAB_ASCI-TAB_STAR				; "I"	$49
    8292/    3070 : FFFF                	dc.w	-1						; "J" $4A no keywords
    8293/    3072 : FFFF                	dc.w	-1						; "K" $4B no keywords
    8294/    3074 : 00A8                	dc.w	TAB_ASCL-TAB_STAR				; "L"	$4C
    8295/    3076 : 00D6                	dc.w	TAB_ASCM-TAB_STAR				; "M"	$4D
    8296/    3078 : 00E4                	dc.w	TAB_ASCN-TAB_STAR				; "N"	$4E
    8297/    307A : 00F3                	dc.w	TAB_ASCO-TAB_STAR				; "O"	$4F
    8298/    307C : 00F8                	dc.w	TAB_ASCP-TAB_STAR				; "P"	$50
    8299/    307E : FFFF                	dc.w	-1						; "Q" $51 no keywords
    8300/    3080 : 010D                	dc.w	TAB_ASCR-TAB_STAR				; "R"	$52
    8301/    3082 : 0137                	dc.w	TAB_ASCS-TAB_STAR				; "S"	$53
    8302/    3084 : 0162                	dc.w	TAB_ASCT-TAB_STAR				; "T"	$54
    8303/    3086 : 0176                	dc.w	TAB_ASCU-TAB_STAR				; "U"	$55
    8304/    3088 : 018E                	dc.w	TAB_ASCV-TAB_STAR				; "V"	$56
    8305/    308A : 019A                	dc.w	TAB_ASCW-TAB_STAR				; "W"	$57
    8306/    308C : FFFF                	dc.w	-1						; "X" $58 no keywords
    8307/    308E : FFFF                	dc.w	-1						; "Y" $59 no keywords
    8308/    3090 : FFFF                	dc.w	-1						; "Z" $5A no keywords
    8309/    3092 : FFFF                	dc.w	-1						; "[" $5B no keywords
    8310/    3094 : FFFF                	dc.w	-1						; "\" $5C no keywords
    8311/    3096 : FFFF                	dc.w	-1						; "]" $5D no keywords
    8312/    3098 : 01A9                	dc.w	TAB_POWR-TAB_STAR				; "^"	$5E
    8313/    309A :                     
    8314/    309A :                     
    8315/    309A :                     ;************************************************************************************
    8316/    309A :                     ;
    8317/    309A :                     ; Table of Basic keywords for LIST command
    8318/    309A :                     ; [byte]first character,[byte]remaining length -1
    8319/    309A :                     ; [word]offset from table start
    8320/    309A :                     
    8321/    309A :                     LAB_KEYT
    8322/    309A : 4501                	dc.b	'E',1
    8323/    309C : 0071                	dc.w	KEY_END-TAB_STAR				; END
    8324/    309E : 4601                	dc.b	'F',1
    8325/    30A0 : 007C                	dc.w	KEY_FOR-TAB_STAR				; FOR
    8326/    30A2 : 4E02                	dc.b	'N',2
    8327/    30A4 : 00E7                	dc.w	KEY_NEXT-TAB_STAR				; NEXT
    8328/    30A6 : 4402                	dc.b	'D',2
    8329/    30A8 : 0054                	dc.w	KEY_DATA-TAB_STAR				; DATA
    8330/    30AA : 4903                	dc.b	'I',3
    8331/    30AC : 009E                	dc.w	KEY_INPUT-TAB_STAR			; INPUT
    8332/    30AE : 4401                	dc.b	'D',1
    8333/    30B0 : 0063                	dc.w	KEY_DIM-TAB_STAR				; DIM
    8334/    30B2 : 5202                	dc.b	'R',2
    8335/    30B4 : 0114                	dc.w	KEY_READ-TAB_STAR				; READ
    8336/    30B6 : 4C01                	dc.b	'L',1
    8337/    30B8 : 00BE                	dc.w	KEY_LET-TAB_STAR				; LET
    8338/    30BA : 4401                	dc.b	'D',1
    8339/    30BC : 0058                	dc.w	KEY_DEC-TAB_STAR				; DEC
    8340/    30BE : 4702                	dc.b	'G',2
    8341/    30C0 : 0089                	dc.w	KEY_GOTO-TAB_STAR				; GOTO
    8342/    30C2 : 5201                	dc.b	'R',1
    8343/    30C4 : 0133                	dc.w	KEY_RUN-TAB_STAR				; RUN
    8344/    30C6 : 4900                	dc.b	'I',0
    8345/    30C8 : 0099                	dc.w	KEY_IF-TAB_STAR				; IF
    8346/    30CA : 5205                	dc.b	'R',5
    8347/    30CC : 011B                	dc.w	KEY_RESTORE-TAB_STAR			; RESTORE
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 144 - 10/11/2023 16:23:32


    8348/    30CE : 4703                	dc.b	'G',3
    8349/    30D0 : 008D                	dc.w	KEY_GOSUB-TAB_STAR			; GOSUB
    8350/    30D2 : 5204                	dc.b	'R',4
    8351/    30D4 : 0122                	dc.w	KEY_RETURN-TAB_STAR			; RETURN
    8352/    30D6 : 5201                	dc.b	'R',1
    8353/    30D8 : 0118                	dc.w	KEY_REM-TAB_STAR				; REM
    8354/    30DA : 5302                	dc.b	'S',2
    8355/    30DC : 0154                	dc.w	KEY_STOP-TAB_STAR				; STOP
    8356/    30DE : 4F00                	dc.b	'O',0
    8357/    30E0 : 00F3                	dc.w	KEY_ON-TAB_STAR				; ON
    8358/    30E2 : 4E02                	dc.b	'N',2
    8359/    30E4 : 00EE                	dc.w	KEY_NULL-TAB_STAR				; NULL
    8360/    30E6 : 4901                	dc.b	'I',1
    8361/    30E8 : 009B                	dc.w	KEY_INC-TAB_STAR				; INC
    8362/    30EA : 5702                	dc.b	'W',2
    8363/    30EC : 019A                	dc.w	KEY_WAIT-TAB_STAR				; WAIT
    8364/    30EE : 4C02                	dc.b	'L',2
    8365/    30F0 : 00C5                	dc.w	KEY_LOAD-TAB_STAR				; LOAD
    8366/    30F2 : 5302                	dc.b	'S',2
    8367/    30F4 : 013C                	dc.w	KEY_SAVE-TAB_STAR				; SAVE
    8368/    30F6 : 4401                	dc.b	'D',1
    8369/    30F8 : 0060                	dc.w	KEY_DEF-TAB_STAR				; DEF
    8370/    30FA : 5002                	dc.b	'P',2
    8371/    30FC : 00FF                	dc.w	KEY_POKE-TAB_STAR				; POKE
    8372/    30FE : 4402                	dc.b	'D',2
    8373/    3100 : 0066                	dc.w	KEY_DOKE-TAB_STAR				; DOKE
    8374/    3102 : 4C02                	dc.b	'L',2
    8375/    3104 : 00CD                	dc.w	KEY_LOKE-TAB_STAR				; LOKE
    8376/    3106 : 4302                	dc.b	'C',2
    8377/    3108 : 003D                	dc.w	KEY_CALL-TAB_STAR				; CALL
    8378/    310A : 4400                	dc.b	'D',0
    8379/    310C : 006A                	dc.w	KEY_DO-TAB_STAR				; DO
    8380/    310E : 4C02                	dc.b	'L',2
    8381/    3110 : 00D1                	dc.w	KEY_LOOP-TAB_STAR				; LOOP
    8382/    3112 : 5003                	dc.b	'P',3
    8383/    3114 : 0107                	dc.w	KEY_PRINT-TAB_STAR			; PRINT
    8384/    3116 : 4302                	dc.b	'C',2
    8385/    3118 : 004B                	dc.w	KEY_CONT-TAB_STAR				; CONT
    8386/    311A : 4C02                	dc.b	'L',2
    8387/    311C : 00C1                	dc.w	KEY_LIST-TAB_STAR				; LIST
    8388/    311E : 4303                	dc.b	'C',3
    8389/    3120 : 0046                	dc.w	KEY_CLEAR-TAB_STAR			; CLEAR
    8390/    3122 : 4E01                	dc.b	'N',1
    8391/    3124 : 00E4                	dc.w	KEY_NEW-TAB_STAR				; NEW
    8392/    3126 : 5703                	dc.b	'W',3
    8393/    3128 : 01A3                	dc.w	KEY_WIDTH-TAB_STAR			; WIDTH
    8394/    312A : 4701                	dc.b	'G',1
    8395/    312C : 0086                	dc.w	KEY_GET-TAB_STAR				; GET
    8396/    312E : 5302                	dc.b	'S',2
    8397/    3130 : 015D                	dc.w	KEY_SWAP-TAB_STAR				; SWAP
    8398/    3132 : 4204                	dc.b	'B',4
    8399/    3134 : 002F                	dc.w	KEY_BITSET-TAB_STAR			; BITSET
    8400/    3136 : 4204                	dc.b	'B',4
    8401/    3138 : 0029                	dc.w	KEY_BITCLR-TAB_STAR			; BITCLR
    8402/    313A : 5402                	dc.b	'T',2
    8403/    313C : 0162                	dc.w	KEY_TAB-TAB_STAR				; TAB(
    8404/    313E : 4502                	dc.b	'E',2
    8405/    3140 : 006D                	dc.w	KEY_ELSE-TAB_STAR				; ELSE
    8406/    3142 : 5400                	dc.b	'T',0
    8407/    3144 : 016E                	dc.w	KEY_TO-TAB_STAR				; TO
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 145 - 10/11/2023 16:23:32


    8408/    3146 : 4600                	dc.b	'F',0
    8409/    3148 : 007F                	dc.w	KEY_FN-TAB_STAR				; FN
    8410/    314A : 5302                	dc.b	'S',2
    8411/    314C : 0148                	dc.w	KEY_SPC-TAB_STAR				; SPC(
    8412/    314E : 5402                	dc.b	'T',2
    8413/    3150 : 016A                	dc.w	KEY_THEN-TAB_STAR				; THEN
    8414/    3152 : 4E01                	dc.b	'N',1
    8415/    3154 : 00EB                	dc.w	KEY_NOT-TAB_STAR				; NOT
    8416/    3156 : 5302                	dc.b	'S',2
    8417/    3158 : 0150                	dc.w	KEY_STEP-TAB_STAR				; STEP
    8418/    315A : 5503                	dc.b	'U',3
    8419/    315C : 017D                	dc.w	KEY_UNTIL-TAB_STAR			; UNTIL
    8420/    315E : 5703                	dc.b	'W',3
    8421/    3160 : 019E                	dc.w	KEY_WHILE-TAB_STAR			; WHILE
    8422/    3162 :                     
    8423/    3162 : 2BFF                	dc.b	'+',-1
    8424/    3164 : 0002                	dc.w	KEY_PLUS-TAB_STAR				; +
    8425/    3166 : 2DFF                	dc.b	'-',-1
    8426/    3168 : 0004                	dc.w	KEY_MINUS-TAB_STAR			; -
    8427/    316A : 2AFF                	dc.b	'*',-1
    8428/    316C : 0000                	dc.w	KEY_MULT-TAB_STAR				; *
    8429/    316E : 2FFF                	dc.b	'/',-1
    8430/    3170 : 0006                	dc.w	KEY_DIV-TAB_STAR				; /
    8431/    3172 : 5EFF                	dc.b	'^',-1
    8432/    3174 : 01A9                	dc.w	KEY_POWER-TAB_STAR			; ^
    8433/    3176 : 4101                	dc.b	'A',1
    8434/    3178 : 0018                	dc.w	KEY_AND-TAB_STAR				; AND
    8435/    317A : 4501                	dc.b	'E',1
    8436/    317C : 0074                	dc.w	KEY_EOR-TAB_STAR				; EOR
    8437/    317E : 4F00                	dc.b	'O',0
    8438/    3180 : 00F5                	dc.w	KEY_OR-TAB_STAR				; OR
    8439/    3182 : 3E00                	dc.b	'>',0
    8440/    3184 : 000E                	dc.w	KEY_RSHIFT-TAB_STAR			; >>
    8441/    3186 : 3C00                	dc.b	'<',0
    8442/    3188 : 0008                	dc.w	KEY_LSHIFT-TAB_STAR			; <<
    8443/    318A : 3EFF                	dc.b	'>',-1
    8444/    318C : 0010                	dc.w	KEY_GT-TAB_STAR				; >
    8445/    318E : 3DFF                	dc.b	'=',-1
    8446/    3190 : 000C                	dc.w	KEY_EQUAL-TAB_STAR			; =
    8447/    3192 : 3CFF                	dc.b	'<',-1
    8448/    3194 : 000A                	dc.w	KEY_LT-TAB_STAR				; <
    8449/    3196 :                     
    8450/    3196 : 5302                	dc.b	'S',2
    8451/    3198 : 0140                	dc.w	KEY_SGN-TAB_STAR				; SGN(
    8452/    319A : 4902                	dc.b	'I',2
    8453/    319C : 00A3                	dc.w	KEY_INT-TAB_STAR				; INT(
    8454/    319E : 4102                	dc.b	'A',2
    8455/    31A0 : 0014                	dc.w	KEY_ABS-TAB_STAR				; ABS(
    8456/    31A2 : 5502                	dc.b	'U',2
    8457/    31A4 : 0189                	dc.w	KEY_USR-TAB_STAR				; USR(
    8458/    31A6 : 4602                	dc.b	'F',2
    8459/    31A8 : 0081                	dc.w	KEY_FRE-TAB_STAR				; FRE(
    8460/    31AA : 5002                	dc.b	'P',2
    8461/    31AC : 0103                	dc.w	KEY_POS-TAB_STAR				; POS(
    8462/    31AE : 5302                	dc.b	'S',2
    8463/    31B0 : 014C                	dc.w	KEY_SQR-TAB_STAR				; SQR(
    8464/    31B2 : 5202                	dc.b	'R',2
    8465/    31B4 : 012F                	dc.w	KEY_RND-TAB_STAR				; RND(
    8466/    31B6 : 4C02                	dc.b	'L',2
    8467/    31B8 : 00C9                	dc.w	KEY_LOG-TAB_STAR				; LOG(
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 146 - 10/11/2023 16:23:32


    8468/    31BA : 4502                	dc.b	'E',2
    8469/    31BC : 0077                	dc.w	KEY_EXP-TAB_STAR				; EXP(
    8470/    31BE : 4302                	dc.b	'C',2
    8471/    31C0 : 004F                	dc.w	KEY_COS-TAB_STAR				; COS(
    8472/    31C2 : 5302                	dc.b	'S',2
    8473/    31C4 : 0144                	dc.w	KEY_SIN-TAB_STAR				; SIN(
    8474/    31C6 : 5402                	dc.b	'T',2
    8475/    31C8 : 0166                	dc.w	KEY_TAN-TAB_STAR				; TAN(
    8476/    31CA : 4102                	dc.b	'A',2
    8477/    31CC : 001F                	dc.w	KEY_ATN-TAB_STAR				; ATN(
    8478/    31CE : 5003                	dc.b	'P',3
    8479/    31D0 : 00F8                	dc.w	KEY_PEEK-TAB_STAR				; PEEK(
    8480/    31D2 : 4403                	dc.b	'D',3
    8481/    31D4 : 005B                	dc.w	KEY_DEEK-TAB_STAR				; DEEK(
    8482/    31D6 : 4C03                	dc.b	'L',3
    8483/    31D8 : 00AF                	dc.w	KEY_LEEK-TAB_STAR				; LEEK(
    8484/    31DA : 4C02                	dc.b	'L',2
    8485/    31DC : 00BA                	dc.w	KEY_LEN-TAB_STAR				; LEN(
    8486/    31DE : 5303                	dc.b	'S',3
    8487/    31E0 : 0158                	dc.w	KEY_STRS-TAB_STAR				; STR$(
    8488/    31E2 : 5602                	dc.b	'V',2
    8489/    31E4 : 018E                	dc.w	KEY_VAL-TAB_STAR				; VAL(
    8490/    31E6 : 4102                	dc.b	'A',2
    8491/    31E8 : 001B                	dc.w	KEY_ASC-TAB_STAR				; ASC(
    8492/    31EA : 5505                	dc.b	'U',5
    8493/    31EC : 0176                	dc.w	KEY_UCASES-TAB_STAR			; UCASE$(
    8494/    31EE : 4C05                	dc.b	'L',5
    8495/    31F0 : 00A8                	dc.w	KEY_LCASES-TAB_STAR			; LCASE$(
    8496/    31F2 : 4303                	dc.b	'C',3
    8497/    31F4 : 0041                	dc.w	KEY_CHRS-TAB_STAR				; CHR$(
    8498/    31F6 : 4803                	dc.b	'H',3
    8499/    31F8 : 0093                	dc.w	KEY_HEXS-TAB_STAR				; HEX$(
    8500/    31FA : 4203                	dc.b	'B',3
    8501/    31FC : 0024                	dc.w	KEY_BINS-TAB_STAR				; BIN$(
    8502/    31FE : 4205                	dc.b	'B',5
    8503/    3200 : 0035                	dc.w	KEY_BITTST-TAB_STAR			; BITTST(
    8504/    3202 : 4D02                	dc.b	'M',2
    8505/    3204 : 00D6                	dc.w	KEY_MAX-TAB_STAR				; MAX(
    8506/    3206 : 4D02                	dc.b	'M',2
    8507/    3208 : 00DF                	dc.w	KEY_MIN-TAB_STAR				; MIN(
    8508/    320A : 5205                	dc.b	'R',5
    8509/    320C : 010D                	dc.w	KEY_RAM-TAB_STAR				; RAMBASE
    8510/    320E : 5000                	dc.b	'P',0
    8511/    3210 : 00FD                	dc.w	KEY_PI-TAB_STAR				; PI
    8512/    3212 : 5403                	dc.b	'T',3
    8513/    3214 : 0170                	dc.w	KEY_TWOPI-TAB_STAR			; TWOPI
    8514/    3216 : 5605                	dc.b	'V',5
    8515/    3218 : 0192                	dc.w	KEY_VPTR-TAB_STAR				; VARPTR(
    8516/    321A : 5303                	dc.b	'S',3
    8517/    321C : 0137                	dc.w	KEY_SADD-TAB_STAR				; SADD(
    8518/    321E : 4C04                	dc.b	'L',4
    8519/    3220 : 00B4                	dc.w	KEY_LEFTS-TAB_STAR			; LEFT$(
    8520/    3222 : 5205                	dc.b	'R',5
    8521/    3224 : 0128                	dc.w	KEY_RIGHTS-TAB_STAR			; RIGHT$(
    8522/    3226 : 4D03                	dc.b	'M',3
    8523/    3228 : 00DA                	dc.w	KEY_MIDS-TAB_STAR				; MID$(
    8524/    322A : 5505                	dc.b	'U',5
    8525/    322C : 0182                	dc.w	KEY_USINGS-TAB_STAR			; USING$(
    8526/    322E :                     
    8527/    322E :                     
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 147 - 10/11/2023 16:23:32


    8528/    322E :                     ;************************************************************************************
    8529/    322E :                     ;
    8530/    322E :                     ; BASIC error messages
    8531/    322E :                     
    8532/    322E :                     LAB_BAER
    8533/    322E : 0030                	dc.w	LAB_NF-LAB_BAER				; $00 NEXT without FOR
    8534/    3230 : 0041                	dc.w	LAB_SN-LAB_BAER				; $02 syntax
    8535/    3232 : 0048                	dc.w	LAB_RG-LAB_BAER				; $04 RETURN without GOSUB
    8536/    3234 : 005D                	dc.w	LAB_OD-LAB_BAER				; $06 out of data
    8537/    3236 : 0069                	dc.w	LAB_FC-LAB_BAER				; $08 function call
    8538/    3238 : 0077                	dc.w	LAB_OV-LAB_BAER				; $0A overflow
    8539/    323A : 0080                	dc.w	LAB_OM-LAB_BAER				; $0C out of memory
    8540/    323C : 008E                	dc.w	LAB_US-LAB_BAER				; $0E undefined statement
    8541/    323E : 00A2                	dc.w	LAB_BS-LAB_BAER				; $10 array bounds
    8542/    3240 : 00AF                	dc.w	LAB_DD-LAB_BAER				; $12 double dimension array
    8543/    3242 : 00C0                	dc.w	LAB_D0-LAB_BAER				; $14 divide by 0
    8544/    3244 : 00CF                	dc.w	LAB_ID-LAB_BAER				; $16 illegal direct
    8545/    3246 : 00DE                	dc.w	LAB_TM-LAB_BAER				; $18 type mismatch
    8546/    3248 : 00EC                	dc.w	LAB_LS-LAB_BAER				; $1A long string
    8547/    324A : 00FC                	dc.w	LAB_ST-LAB_BAER				; $1C string too complex
    8548/    324C : 010F                	dc.w	LAB_CN-LAB_BAER				; $1E continue error
    8549/    324E : 011E                	dc.w	LAB_UF-LAB_BAER				; $20 undefined function
    8550/    3250 : 0131                	dc.w	LAB_LD-LAB_BAER				; $22 LOOP without DO
    8551/    3252 : 0141                	dc.w	LAB_UV-LAB_BAER				; $24 undefined variable
    8552/    3254 : 0154                	dc.w	LAB_UA-LAB_BAER				; $26 undimensioned array
    8553/    3256 : 0168                	dc.w	LAB_WD-LAB_BAER				; $28 wrong dimensions
    8554/    3258 : 0179                	dc.w	LAB_AD-LAB_BAER				; $2A address
    8555/    325A : 0181                	dc.w	LAB_FO-LAB_BAER				; $2C format
    8556/    325C : 0188                	dc.w	LAB_NI-LAB_BAER				; $2E not implemented
    8557/    325E :                     
    8558/    325E : 4E45 5854 2077      LAB_NF	dc.b	'NEXT without FOR',$00
             3264 : 6974 686F 7574 
             326A : 2046 4F52 00       
    8559/    326F : 5379 6E74 6178 00   LAB_SN	dc.b	'Syntax',$00
    8560/    3276 : 5245 5455 524E      LAB_RG	dc.b	'RETURN without GOSUB',$00
             327C : 2077 6974 686F 
             3282 : 7574 2047 4F53 
             3288 : 5542 00          
    8561/    328B : 4F75 7420 6F66      LAB_OD	dc.b	'Out of DATA',$00
             3291 : 2044 4154 4100    
    8562/    3297 : 4675 6E63 7469      LAB_FC	dc.b	'Function call',$00
             329D : 6F6E 2063 616C 
             32A3 : 6C00             
    8563/    32A5 : 4F76 6572 666C      LAB_OV	dc.b	'Overflow',$00
             32AB : 6F77 00          
    8564/    32AE : 4F75 7420 6F66      LAB_OM	dc.b	'Out of memory',$00
             32B4 : 206D 656D 6F72 
             32BA : 7900             
    8565/    32BC : 556E 6465 6669      LAB_US	dc.b	'Undefined statement',$00
             32C2 : 6E65 6420 7374 
             32C8 : 6174 656D 656E 
             32CE : 7400             
    8566/    32D0 : 4172 7261 7920      LAB_BS	dc.b	'Array bounds',$00
             32D6 : 626F 756E 6473 00 
    8567/    32DD : 446F 7562 6C65      LAB_DD	dc.b	'Double dimension',$00
             32E3 : 2064 696D 656E 
             32E9 : 7369 6F6E 00       
    8568/    32EE : 4469 7669 6465      LAB_D0	dc.b	'Divide by zero',$00
             32F4 : 2062 7920 7A65 
             32FA : 726F 00          
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 148 - 10/11/2023 16:23:32


    8569/    32FD : 496C 6C65 6761      LAB_ID	dc.b	'Illegal direct',$00
             3303 : 6C20 6469 7265 
             3309 : 6374 00          
    8570/    330C : 5479 7065 206D      LAB_TM	dc.b	'Type mismatch',$00
             3312 : 6973 6D61 7463 
             3318 : 6800             
    8571/    331A : 5374 7269 6E67      LAB_LS	dc.b	'String too long',$00
             3320 : 2074 6F6F 206C 
             3326 : 6F6E 6700          
    8572/    332A : 5374 7269 6E67      LAB_ST	dc.b	'String too complex',$00
             3330 : 2074 6F6F 2063 
             3336 : 6F6D 706C 6578 00 
    8573/    333D : 4361 6E27 7420      LAB_CN	dc.b	"Can't continue",$00
             3343 : 636F 6E74 696E 
             3349 : 7565 00          
    8574/    334C : 556E 6465 6669      LAB_UF	dc.b	'Undefined function',$00
             3352 : 6E65 6420 6675 
             3358 : 6E63 7469 6F6E 00 
    8575/    335F : 4C4F 4F50 2077      LAB_LD	dc.b	'LOOP without DO',$00
             3365 : 6974 686F 7574 
             336B : 2044 4F00          
    8576/    336F : 556E 6465 6669      LAB_UV	dc.b	'Undefined variable',$00
             3375 : 6E65 6420 7661 
             337B : 7269 6162 6C65 00 
    8577/    3382 : 556E 6469 6D65      LAB_UA	dc.b	'Undimensioned array',$00
             3388 : 6E73 696F 6E65 
             338E : 6420 6172 7261 
             3394 : 7900             
    8578/    3396 : 5772 6F6E 6720      LAB_WD	dc.b	'Wrong dimensions',$00
             339C : 6469 6D65 6E73 
             33A2 : 696F 6E73 00       
    8579/    33A7 : 4164 6472 6573      LAB_AD	dc.b	'Address',$00
             33AD : 7300             
    8580/    33AF : 466F 726D 6174 00   LAB_FO	dc.b	'Format',$00
    8581/    33B6 : 4E6F 7420 696D      LAB_NI  dc.b    'Not implemented',$00
             33BC : 706C 656D 656E 
             33C2 : 7465 6400          
    8582/    33C6 :                     
    8583/    33C6 :                     
    8584/    33C6 :                     ;************************************************************************************
    8585/    33C6 :                     ;
    8586/    33C6 :                     ; keyword table for line (un)crunching
    8587/    33C6 :                     
    8588/    33C6 :                     ; [keyword,token
    8589/    33C6 :                     ; [keyword,token]]
    8590/    33C6 :                     ; end marker (#$00)
    8591/    33C6 :                     
    8592/    33C6 :                     TAB_STAR
    8593/    33C6 :                     KEY_MULT
    8594/    33C6 : B400                	dc.b TK_MULT,$00					; *
    8595/    33C8 :                     TAB_PLUS
    8596/    33C8 :                     KEY_PLUS
    8597/    33C8 : B200                	dc.b TK_PLUS,$00					; +
    8598/    33CA :                     TAB_MNUS
    8599/    33CA :                     KEY_MINUS
    8600/    33CA : B300                	dc.b TK_MINUS,$00					; -
    8601/    33CC :                     TAB_SLAS
    8602/    33CC :                     KEY_DIV
    8603/    33CC : B500                	dc.b TK_DIV,$00					; /
    8604/    33CE :                     TAB_LESS
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 149 - 10/11/2023 16:23:32


    8605/    33CE :                     KEY_LSHIFT
    8606/    33CE : 3CBB                	dc.b	'<',TK_LSHIFT				; <<
    8607/    33D0 :                     KEY_LT
    8608/    33D0 : BE                  	dc.b TK_LT						; <
    8609/    33D1 : 00                  	dc.b	$00
    8610/    33D2 :                     TAB_EQUL
    8611/    33D2 :                     KEY_EQUAL
    8612/    33D2 : BD00                	dc.b TK_EQUAL,$00					; =
    8613/    33D4 :                     TAB_MORE
    8614/    33D4 :                     KEY_RSHIFT
    8615/    33D4 : 3EBA                	dc.b	'>',TK_RSHIFT				; >>
    8616/    33D6 :                     KEY_GT
    8617/    33D6 : BC                  	dc.b TK_GT						; >
    8618/    33D7 : 00                  	dc.b	$00
    8619/    33D8 :                     TAB_QEST
    8620/    33D8 : 9E00                	dc.b TK_PRINT,$00					; ?
    8621/    33DA :                     TAB_ASCA
    8622/    33DA :                     KEY_ABS
    8623/    33DA : 4253 28C1           	dc.b	'BS(',TK_ABS				; ABS(
    8624/    33DE :                     KEY_AND
    8625/    33DE : 4E44 B7             	dc.b	'ND',TK_AND					; AND
    8626/    33E1 :                     KEY_ASC
    8627/    33E1 : 5343 28D3           	dc.b	'SC(',TK_ASC				; ASC(
    8628/    33E5 :                     KEY_ATN
    8629/    33E5 : 544E 28CC           	dc.b	'TN(',TK_ATN				; ATN(
    8630/    33E9 : 00                  	dc.b	$00
    8631/    33EA :                     TAB_ASCB
    8632/    33EA :                     KEY_BINS
    8633/    33EA : 494E 2428 D8        	dc.b	'IN$(',TK_BINS				; BIN$(
    8634/    33EF :                     KEY_BITCLR
    8635/    33EF : 4954 434C 52A7      	dc.b	'ITCLR',TK_BITCLR				; BITCLR
    8636/    33F5 :                     KEY_BITSET
    8637/    33F5 : 4954 5345 54A6      	dc.b	'ITSET',TK_BITSET				; BITSET
    8638/    33FB :                     KEY_BITTST
    8639/    33FB : 4954 5453 5428 D9   	dc.b	'ITTST(',TK_BITTST			; BITTST(
    8640/    3402 : 00                  	dc.b	$00
    8641/    3403 :                     TAB_ASCC
    8642/    3403 :                     KEY_CALL
    8643/    3403 : 414C 4C9B           	dc.b	'ALL',TK_CALL				; CALL
    8644/    3407 :                     KEY_CHRS
    8645/    3407 : 4852 2428 D6        	dc.b	'HR$(',TK_CHRS				; CHR$(
    8646/    340C :                     KEY_CLEAR
    8647/    340C : 4C45 4152 A1        	dc.b	'LEAR',TK_CLEAR				; CLEAR
    8648/    3411 :                     KEY_CONT
    8649/    3411 : 4F4E 549F           	dc.b	'ONT',TK_CONT				; CONT
    8650/    3415 :                     KEY_COS
    8651/    3415 : 4F53 28C9           	dc.b	'OS(',TK_COS				; COS(
    8652/    3419 : 00                  	dc.b	$00
    8653/    341A :                     TAB_ASCD
    8654/    341A :                     KEY_DATA
    8655/    341A : 4154 4183           	dc.b	'ATA',TK_DATA				; DATA
    8656/    341E :                     KEY_DEC
    8657/    341E : 4543 88             	dc.b	'EC',TK_DEC					; DEC
    8658/    3421 :                     KEY_DEEK
    8659/    3421 : 4545 4B28 CE        	dc.b	'EEK(',TK_DEEK				; DEEK(
    8660/    3426 :                     KEY_DEF
    8661/    3426 : 4546 97             	dc.b	'EF',TK_DEF					; DEF
    8662/    3429 :                     KEY_DIM
    8663/    3429 : 494D 85             	dc.b	'IM',TK_DIM					; DIM
    8664/    342C :                     KEY_DOKE
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 150 - 10/11/2023 16:23:32


    8665/    342C : 4F4B 4599           	dc.b	'OKE',TK_DOKE				; DOKE
    8666/    3430 :                     KEY_DO
    8667/    3430 : 4F9C                	dc.b	'O',TK_DO					; DO
    8668/    3432 : 00                  	dc.b	$00
    8669/    3433 :                     TAB_ASCE
    8670/    3433 :                     KEY_ELSE
    8671/    3433 : 4C53 45A9           	dc.b	'LSE',TK_ELSE				; ELSE
    8672/    3437 :                     KEY_END
    8673/    3437 : 4E44 80             	dc.b	'ND',TK_END					; END
    8674/    343A :                     KEY_EOR
    8675/    343A : 4F52 B8             	dc.b	'OR',TK_EOR					; EOR
    8676/    343D :                     KEY_EXP
    8677/    343D : 5850 28C8           	dc.b	'XP(',TK_EXP				; EXP(
    8678/    3441 : 00                  	dc.b	$00
    8679/    3442 :                     TAB_ASCF
    8680/    3442 :                     KEY_FOR
    8681/    3442 : 4F52 81             	dc.b	'OR',TK_FOR					; FOR
    8682/    3445 :                     KEY_FN
    8683/    3445 : 4EAB                	dc.b	'N',TK_FN					; FN
    8684/    3447 :                     KEY_FRE
    8685/    3447 : 5245 28C3           	dc.b	'RE(',TK_FRE				; FRE(
    8686/    344B : 00                  	dc.b	$00
    8687/    344C :                     TAB_ASCG
    8688/    344C :                     KEY_GET
    8689/    344C : 4554 A4             	dc.b	'ET',TK_GET					; GET
    8690/    344F :                     KEY_GOTO
    8691/    344F : 4F54 4F89           	dc.b	'OTO',TK_GOTO				; GOTO
    8692/    3453 :                     KEY_GOSUB
    8693/    3453 : 4F53 5542 8D        	dc.b	'OSUB',TK_GOSUB				; GOSUB
    8694/    3458 : 00                  	dc.b	$00
    8695/    3459 :                     TAB_ASCH
    8696/    3459 :                     KEY_HEXS
    8697/    3459 : 4558 2428 D700      	dc.b	'EX$(',TK_HEXS,$00			; HEX$(
    8698/    345F :                     TAB_ASCI
    8699/    345F :                     KEY_IF
    8700/    345F : 468B                	dc.b	'F',TK_IF					; IF
    8701/    3461 :                     KEY_INC
    8702/    3461 : 4E43 93             	dc.b	'NC',TK_INC					; INC
    8703/    3464 :                     KEY_INPUT
    8704/    3464 : 4E50 5554 84        	dc.b	'NPUT',TK_INPUT				; INPUT
    8705/    3469 :                     KEY_INT
    8706/    3469 : 4E54 28C0           	dc.b	'NT(',TK_INT				; INT(
    8707/    346D : 00                  	dc.b	$00
    8708/    346E :                     TAB_ASCL
    8709/    346E :                     KEY_LCASES
    8710/    346E : 4341 5345 2428 D5   	dc.b	'CASE$(',TK_LCASES			; LCASE$(
    8711/    3475 :                     KEY_LEEK
    8712/    3475 : 4545 4B28 CF        	dc.b	'EEK(',TK_LEEK				; LEEK(
    8713/    347A :                     KEY_LEFTS
    8714/    347A : 4546 5424 28E1      	dc.b	'EFT$(',TK_LEFTS				; LEFT$(
    8715/    3480 :                     KEY_LEN
    8716/    3480 : 454E 28D0           	dc.b	'EN(',TK_LEN				; LEN(
    8717/    3484 :                     KEY_LET
    8718/    3484 : 4554 87             	dc.b	'ET',TK_LET					; LET
    8719/    3487 :                     KEY_LIST
    8720/    3487 : 4953 54A0           	dc.b	'IST',TK_LIST				; LIST
    8721/    348B :                     KEY_LOAD
    8722/    348B : 4F41 4495           	dc.b	'OAD',TK_LOAD				; LOAD
    8723/    348F :                     KEY_LOG
    8724/    348F : 4F47 28C7           	dc.b	'OG(',TK_LOG				; LOG(
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 151 - 10/11/2023 16:23:32


    8725/    3493 :                     KEY_LOKE
    8726/    3493 : 4F4B 459A           	dc.b	'OKE',TK_LOKE				; LOKE
    8727/    3497 :                     KEY_LOOP
    8728/    3497 : 4F4F 509D           	dc.b	'OOP',TK_LOOP				; LOOP
    8729/    349B : 00                  	dc.b	$00
    8730/    349C :                     TAB_ASCM
    8731/    349C :                     KEY_MAX
    8732/    349C : 4158 28DA           	dc.b	'AX(',TK_MAX				; MAX(
    8733/    34A0 :                     KEY_MIDS
    8734/    34A0 : 4944 2428 E3        	dc.b	'ID$(',TK_MIDS				; MID$(
    8735/    34A5 :                     KEY_MIN
    8736/    34A5 : 494E 28DB           	dc.b	'IN(',TK_MIN				; MIN(
    8737/    34A9 : 00                  	dc.b	$00
    8738/    34AA :                     TAB_ASCN
    8739/    34AA :                     KEY_NEW
    8740/    34AA : 4557 A2             	dc.b	'EW',TK_NEW					; NEW
    8741/    34AD :                     KEY_NEXT
    8742/    34AD : 4558 5482           	dc.b	'EXT',TK_NEXT				; NEXT
    8743/    34B1 :                     KEY_NOT
    8744/    34B1 : 4F54 AE             	dc.b	'OT',TK_NOT					; NOT
    8745/    34B4 :                     KEY_NULL
    8746/    34B4 : 554C 4C92           	dc.b	'ULL',TK_NULL				; NULL
    8747/    34B8 : 00                  	dc.b	$00
    8748/    34B9 :                     TAB_ASCO
    8749/    34B9 :                     KEY_ON
    8750/    34B9 : 4E91                	dc.b	'N',TK_ON					; ON
    8751/    34BB :                     KEY_OR
    8752/    34BB : 52B9                	dc.b	'R',TK_OR					; OR
    8753/    34BD : 00                  	dc.b	$00
    8754/    34BE :                     TAB_ASCP
    8755/    34BE :                     KEY_PEEK
    8756/    34BE : 4545 4B28 CD        	dc.b	'EEK(',TK_PEEK				; PEEK(
    8757/    34C3 :                     KEY_PI
    8758/    34C3 : 49DD                	dc.b	'I',TK_PI					; PI
    8759/    34C5 :                     KEY_POKE
    8760/    34C5 : 4F4B 4598           	dc.b	'OKE',TK_POKE				; POKE
    8761/    34C9 :                     KEY_POS
    8762/    34C9 : 4F53 28C4           	dc.b	'OS(',TK_POS				; POS(
    8763/    34CD :                     KEY_PRINT
    8764/    34CD : 5249 4E54 9E        	dc.b	'RINT',TK_PRINT				; PRINT
    8765/    34D2 : 00                  	dc.b	$00
    8766/    34D3 :                     TAB_ASCR
    8767/    34D3 :                     KEY_RAM
    8768/    34D3 : 414D 4241 5345 DC   	dc.b	'AMBASE',TK_RAM				; RAMBASE
    8769/    34DA :                     KEY_READ
    8770/    34DA : 4541 4486           	dc.b	'EAD',TK_READ				; READ
    8771/    34DE :                     KEY_REM
    8772/    34DE : 454D 8F             	dc.b	'EM',TK_REM					; REM
    8773/    34E1 :                     KEY_RESTORE
    8774/    34E1 : 4553 544F 5245 8C   	dc.b	'ESTORE',TK_RESTORE			; RESTORE
    8775/    34E8 :                     KEY_RETURN
    8776/    34E8 : 4554 5552 4E8E      	dc.b	'ETURN',TK_RETURN				; RETURN
    8777/    34EE :                     KEY_RIGHTS
    8778/    34EE : 4947 4854 2428 E2   	dc.b	'IGHT$(',TK_RIGHTS			; RIGHT$(
    8779/    34F5 :                     KEY_RND
    8780/    34F5 : 4E44 28C6           	dc.b	'ND(',TK_RND				; RND(
    8781/    34F9 :                     KEY_RUN
    8782/    34F9 : 554E 8A             	dc.b	'UN',TK_RUN					; RUN
    8783/    34FC : 00                  	dc.b	$00
    8784/    34FD :                     TAB_ASCS
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 152 - 10/11/2023 16:23:32


    8785/    34FD :                     KEY_SADD
    8786/    34FD : 4144 4428 E0        	dc.b	'ADD(',TK_SADD				; SADD(
    8787/    3502 :                     KEY_SAVE
    8788/    3502 : 4156 4596           	dc.b	'AVE',TK_SAVE				; SAVE
    8789/    3506 :                     KEY_SGN
    8790/    3506 : 474E 28BF           	dc.b	'GN(',TK_SGN				; SGN(
    8791/    350A :                     KEY_SIN
    8792/    350A : 494E 28CA           	dc.b	'IN(',TK_SIN				; SIN(
    8793/    350E :                     KEY_SPC
    8794/    350E : 5043 28AC           	dc.b	'PC(',TK_SPC				; SPC(
    8795/    3512 :                     KEY_SQR
    8796/    3512 : 5152 28C5           	dc.b	'QR(',TK_SQR				; SQR(
    8797/    3516 :                     KEY_STEP
    8798/    3516 : 5445 50AF           	dc.b	'TEP',TK_STEP				; STEP
    8799/    351A :                     KEY_STOP
    8800/    351A : 544F 5090           	dc.b	'TOP',TK_STOP				; STOP
    8801/    351E :                     KEY_STRS
    8802/    351E : 5452 2428 D1        	dc.b	'TR$(',TK_STRS				; STR$(
    8803/    3523 :                     KEY_SWAP
    8804/    3523 : 5741 50A5           	dc.b	'WAP',TK_SWAP				; SWAP
    8805/    3527 : 00                  	dc.b	$00
    8806/    3528 :                     TAB_ASCT
    8807/    3528 :                     KEY_TAB
    8808/    3528 : 4142 28A8           	dc.b	'AB(',TK_TAB				; TAB(
    8809/    352C :                     KEY_TAN
    8810/    352C : 414E 28CB           	dc.b	'AN(',TK_TAN				; TAN
    8811/    3530 :                     KEY_THEN
    8812/    3530 : 4845 4EAD           	dc.b	'HEN',TK_THEN				; THEN
    8813/    3534 :                     KEY_TO
    8814/    3534 : 4FAA                	dc.b	'O',TK_TO					; TO
    8815/    3536 :                     KEY_TWOPI
    8816/    3536 : 574F 5049 DE        	dc.b	'WOPI',TK_TWOPI				; TWOPI
    8817/    353B : 00                  	dc.b	$00
    8818/    353C :                     TAB_ASCU
    8819/    353C :                     KEY_UCASES
    8820/    353C : 4341 5345 2428 D4   	dc.b	'CASE$(',TK_UCASES			; UCASE$(
    8821/    3543 :                     KEY_UNTIL
    8822/    3543 : 4E54 494C B0        	dc.b	'NTIL',TK_UNTIL				; UNTIL
    8823/    3548 :                     KEY_USINGS
    8824/    3548 : 5349 4E47 2428 E4   	dc.b	'SING$(',TK_USINGS			; USING$(
    8825/    354F :                     KEY_USR
    8826/    354F : 5352 28C2           	dc.b	'SR(',TK_USR				; USR(
    8827/    3553 : 00                  	dc.b	$00
    8828/    3554 :                     TAB_ASCV
    8829/    3554 :                     KEY_VAL
    8830/    3554 : 414C 28D2           	dc.b	'AL(',TK_VAL				; VAL(
    8831/    3558 :                     KEY_VPTR
    8832/    3558 : 4152 5054 5228 DF   	dc.b	'ARPTR(',TK_VPTR				; VARPTR(
    8833/    355F : 00                  	dc.b	$00
    8834/    3560 :                     TAB_ASCW
    8835/    3560 :                     KEY_WAIT
    8836/    3560 : 4149 5494           	dc.b	'AIT',TK_WAIT				; WAIT
    8837/    3564 :                     KEY_WHILE
    8838/    3564 : 4849 4C45 B1        	dc.b	'HILE',TK_WHILE				; WHILE
    8839/    3569 :                     KEY_WIDTH
    8840/    3569 : 4944 5448 A3        	dc.b	'IDTH',TK_WIDTH				; WIDTH
    8841/    356E : 00                  	dc.b	$00
    8842/    356F :                     TAB_POWR
    8843/    356F :                     KEY_POWER
    8844/    356F : B600                	dc.b	TK_POWER,$00				; ^
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 153 - 10/11/2023 16:23:32


    8845/    3571 :                     
    8846/    3571 :                     
    8847/    3571 :                     ;************************************************************************************
    8848/    3571 :                     ;
    8849/    3571 :                     ; just messages
    8850/    3571 :                     
    8851/    3571 :                     LAB_BMSG
    8852/    3571 : 0D0A 4272 6561      	dc.b	$0D,$0A,'Break',$00
             3577 : 6B00             
    8853/    3579 :                     LAB_EMSG
    8854/    3579 : 2045 7272 6F72 00   	dc.b	' Error',$00
    8855/    3580 :                     LAB_LMSG
    8856/    3580 : 2069 6E20 6C69      	dc.b	' in line ',$00
             3586 : 6E65 2000          
    8857/    358A :                     LAB_IMSG
    8858/    358A : 4578 7472 6120      	dc.b	'Extra ignored',$0D,$0A,$00
             3590 : 6967 6E6F 7265 
             3596 : 640D 0A00          
    8859/    359A :                     LAB_REDO
    8860/    359A : 5265 646F 2066      	dc.b	'Redo from start',$0D,$0A,$00
             35A0 : 726F 6D20 7374 
             35A6 : 6172 740D 0A00    
    8861/    35AC :                     LAB_RMSG
    8862/    35AC : 0D0A 5265 6164      	dc.b	$0D,$0A,'Ready',$0D,$0A,$00
             35B2 : 790D 0A00          
    8863/    35B6 :                     LAB_SMSG
    8864/    35B6 : 2042 7974 6573      	dc.b	' Bytes free',$0D,$0A,$0A
             35BC : 2066 7265 650D 
             35C2 : 0A0A             
    8865/    35C4 : 456E 6861 6E63      	dc.b	'Enhanced 68k BASIC Version 3.54',$0D,$0A,$00
             35CA : 6564 2036 386B 
             35D0 : 2042 4153 4943 
             35D6 : 2056 6572 7369 
             35DC : 6F6E 2033 2E35 
             35E2 : 340D 0A00          
    8866/    35E6 :                     
    8867/    35E6 :                     
    8868/    35E6 :                     ;************************************************************************************
    8869/    35E6 :                     ;
    8870/    35E6 :                     ; This lot is in RAM
    8871/    35E6 :                     
    8872/    35E6 :                     ;    		ORG     ram_addr	; start of RAM
    8873/    35E6 :                     ; 
    8874/    35E6 :                     ;ram_strt	ds.l	$100		; allow 1K for the stack, this should be plenty
    8875/    35E6 :                     ;								; for any BASIC program that doesn't do something
    8876/    35E6 :                     ;								; silly, it could even be much less.
    8877/    35E6 :                     ;ram_base
    8878/    35E6 :                     ;LAB_WARM	ds.w	1			; BASIC warm start entry point
    8879/    35E6 :                     ;Wrmjpv		ds.l	1			; BASIC warm start jump vector
    8880/    35E6 :                     ;
    8881/    35E6 :                     ;Usrjmp		ds.w	1			; USR function JMP address
    8882/    35E6 :                     ;Usrjpv		ds.l	1			; USR function JMP vector
    8883/    35E6 :                     ;
    8884/    35E6 :                     ;; system dependant i/o vectors
    8885/    35E6 :                     ;; these are in RAM and are set at start-up
    8886/    35E6 :                     ;
    8887/    35E6 :                     ;V_INPT		ds.w	1			; non halting scan input device entry point
    8888/    35E6 :                     ;V_INPTv		ds.l	1			; non halting scan input device jump vector
    8889/    35E6 :                     ;
    8890/    35E6 :                     ;V_OUTP		ds.w	1			; send byte to output device entry point
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 154 - 10/11/2023 16:23:32


    8891/    35E6 :                     ;V_OUTPv		ds.l	1			; send byte to output device jump vector
    8892/    35E6 :                     ;
    8893/    35E6 :                     ;V_LOAD		ds.w	1			; load BASIC program entry point
    8894/    35E6 :                     ;V_LOADv		ds.l	1			; load BASIC program jump vector
    8895/    35E6 :                     ;
    8896/    35E6 :                     ;V_SAVE		ds.w	1			; save BASIC program entry point
    8897/    35E6 :                     ;V_SAVEv		ds.l	1			; save BASIC program jump vector
    8898/    35E6 :                     ;
    8899/    35E6 :                     ;V_CTLC		ds.w	1			; save CTRL-C check entry point
    8900/    35E6 :                     ;V_CTLCv		ds.l	1			; save CTRL-C check jump vector
    8901/    35E6 :                     ;
    8902/    35E6 :                     ;Itemp		ds.l	1			; temporary integer	(for GOTO etc)
    8903/    35E6 :                     ;
    8904/    35E6 :                     ;Smeml		ds.l	1			; start of memory		(start of program)
    8905/    35E6 :                     ;
    8906/    35E6 :                     ;; the program is stored as a series of lines each line having the following format
    8907/    35E6 :                     ;;
    8908/    35E6 :                     ;;		ds.l	1			; pointer to the next line or $00000000 if [EOT]
    8909/    35E6 :                     ;;		ds.l	1			; line number
    8910/    35E6 :                     ;;		ds.b	n			; program bytes
    8911/    35E6 :                     ;;		dc.b	$00			; [EOL] marker, there will be a second $00 byte, if
    8912/    35E6 :                     ;;						; needed, to pad the line to an even number of bytes
    8913/    35E6 :                     ;
    8914/    35E6 :                     ;Sfncl		ds.l	1			; start of functions	(end of Program)
    8915/    35E6 :                     ;
    8916/    35E6 :                     ;; the functions are stored as function name, function execute pointer and function
    8917/    35E6 :                     ;; variable name
    8918/    35E6 :                     ;;
    8919/    35E6 :                     ;;		ds.l	1			; name
    8920/    35E6 :                     ;;		ds.l	1			; execute pointer
    8921/    35E6 :                     ;;		ds.l	1			; function variable
    8922/    35E6 :                     ;
    8923/    35E6 :                     ;Svarl		ds.l	1			; start of variables	(end of functions)
    8924/    35E6 :                     ;
    8925/    35E6 :                     ;; the variables are stored as variable name, variable value
    8926/    35E6 :                     ;;
    8927/    35E6 :                     ;;		ds.l	1			; name
    8928/    35E6 :                     ;;		ds.l	1			; packed float or integer value
    8929/    35E6 :                     ;
    8930/    35E6 :                     ;Sstrl		ds.l	1			; start of strings	(end of variables)
    8931/    35E6 :                     ;
    8932/    35E6 :                     ;; the strings are stored as string name, string pointer and string length
    8933/    35E6 :                     ;;
    8934/    35E6 :                     ;;		ds.l	1			; name
    8935/    35E6 :                     ;;		ds.l	1			; string pointer
    8936/    35E6 :                     ;;		ds.w	1			; string length
    8937/    35E6 :                     ;
    8938/    35E6 :                     ;Sarryl		ds.l	1			; start of arrays		(end of strings)
    8939/    35E6 :                     ;
    8940/    35E6 :                     ;; the arrays are stored as array name, array size, array dimensions count, array
    8941/    35E6 :                     ;; dimensions upper bounds and array elements
    8942/    35E6 :                     ;;
    8943/    35E6 :                     ;;		ds.l	1			; name
    8944/    35E6 :                     ;;		ds.l	1			; size including this header
    8945/    35E6 :                     ;;		ds.w	1			; dimensions count
    8946/    35E6 :                     ;;		ds.w	1			; 1st dimension upper bound
    8947/    35E6 :                     ;;		ds.w	1			; 2nd dimension upper bound
    8948/    35E6 :                     ;;		...				; ...
    8949/    35E6 :                     ;;		ds.w	1			; nth dimension upper bound
    8950/    35E6 :                     ;;
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 155 - 10/11/2023 16:23:32


    8951/    35E6 :                     ;; then (i1+1)*(i2+1)...*(in+1) of either ..
    8952/    35E6 :                     ;;
    8953/    35E6 :                     ;;		ds.l	1			; packed float or integer value
    8954/    35E6 :                     ;;
    8955/    35E6 :                     ;; .. if float or integer, or ..
    8956/    35E6 :                     ;;
    8957/    35E6 :                     ;;		ds.l	1			; string pointer
    8958/    35E6 :                     ;;		ds.w	1			; string length
    8959/    35E6 :                     ;;
    8960/    35E6 :                     ;; .. if string
    8961/    35E6 :                     ;
    8962/    35E6 :                     ;Earryl		ds.l	1			; end of arrays		(start of free mem)
    8963/    35E6 :                     ;Sstorl		ds.l	1			; string storage		(moving down)
    8964/    35E6 :                     ;Ememl		ds.l	1			; end of memory		(upper bound of RAM)
    8965/    35E6 :                     ;Sutill		ds.l	1			; string utility ptr
    8966/    35E6 :                     ;Clinel		ds.l	1			; current line		(Basic line number)
    8967/    35E6 :                     ;Blinel		ds.l	1			; break line		(Basic line number)
    8968/    35E6 :                     ;
    8969/    35E6 :                     ;Cpntrl		ds.l	1			; continue pointer
    8970/    35E6 :                     ;Dlinel		ds.l	1			; current DATA line
    8971/    35E6 :                     ;Dptrl		ds.l	1			; DATA pointer
    8972/    35E6 :                     ;Rdptrl		ds.l	1			; read pointer
    8973/    35E6 :                     ;Varname		ds.l	1			; current var name
    8974/    35E6 :                     ;Cvaral		ds.l	1			; current var address
    8975/    35E6 :                     ;Lvarpl		ds.l	1			; variable pointer for LET and FOR/NEXT
    8976/    35E6 :                     ;
    8977/    35E6 :                     ;des_sk_e	ds.l	6			; descriptor stack end address
    8978/    35E6 :                     ;des_sk							; descriptor stack start address
    8979/    35E6 :                     ;								; use a4 for the descriptor pointer
    8980/    35E6 :                     ;			ds.w	1			
    8981/    35E6 :                     ;Ibuffs		ds.l	$40			; start of input buffer
    8982/    35E6 :                     ;Ibuffe
    8983/    35E6 :                     ;								; end of input buffer
    8984/    35E6 :                     ;
    8985/    35E6 :                     ;FAC1_m		ds.l	1			; FAC1 mantissa1
    8986/    35E6 :                     ;FAC1_e		ds.w	1			; FAC1 exponent
    8987/    35E6 :                     ;FAC1_s		EQU	FAC1_e+1		; FAC1 sign (b7)
    8988/    35E6 :                     ;			ds.w	1			
    8989/    35E6 :                     ;
    8990/    35E6 :                     ;FAC2_m		ds.l	1			; FAC2 mantissa1
    8991/    35E6 :                     ;FAC2_e		ds.l	1			; FAC2 exponent
    8992/    35E6 :                     ;FAC2_s		EQU	FAC2_e+1		; FAC2 sign (b7)
    8993/    35E6 :                     ;FAC_sc		EQU	FAC2_e+2		; FAC sign comparison, Acc#1 vs #2
    8994/    35E6 :                     ;flag		EQU	FAC2_e+3		; flag byte for divide routine
    8995/    35E6 :                     ;
    8996/    35E6 :                     ;PRNlword	ds.l	1			; PRNG seed long word
    8997/    35E6 :                     ;
    8998/    35E6 :                     ;ut1_pl		ds.l	1			; utility pointer 1
    8999/    35E6 :                     ;
    9000/    35E6 :                     ;Asptl		ds.l	1			; array size/pointer
    9001/    35E6 :                     ;Astrtl		ds.l	1			; array start pointer
    9002/    35E6 :                     ;
    9003/    35E6 :                     ;numexp		EQU	Astrtl			; string to float number exponent count
    9004/    35E6 :                     ;expcnt		EQU	Astrtl+1		; string to float exponent count
    9005/    35E6 :                     ;
    9006/    35E6 :                     ;expneg		EQU	Astrtl+3		; string to float eval exponent -ve flag
    9007/    35E6 :                     ;
    9008/    35E6 :                     ;func_l		ds.l	1			; function pointer
    9009/    35E6 :                     ;
    9010/    35E6 :                     ;
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 156 - 10/11/2023 16:23:32


    9011/    35E6 :                     ;								; these two need to be a word aligned pair !
    9012/    35E6 :                     ;Defdim		ds.w	1			; default DIM flag
    9013/    35E6 :                     ;cosout		EQU	Defdim			; flag which CORDIC output (re-use byte)
    9014/    35E6 :                     ;Dtypef		EQU	Defdim+1		; data type flag, $80=string, $40=integer, $00=float
    9015/    35E6 :                     ;
    9016/    35E6 :                     ;
    9017/    35E6 :                     ;Binss		ds.l	4			; number to bin string start (32 chrs)
    9018/    35E6 :                     ;
    9019/    35E6 :                     ;Decss		ds.l	1			; number to decimal string start (16 chrs)
    9020/    35E6 :                     ;			ds.w	1
    9021/    35E6 :                     ;Usdss		ds.w	1			; unsigned decimal string start (10 chrs)
    9022/    35E6 :                     ;
    9023/    35E6 :                     ;Hexss		ds.l	2			; number to hex string start (8 chrs)
    9024/    35E6 :                     ;
    9025/    35E6 :                     ;BHsend		ds.w	1			; bin/decimal/hex string end
    9026/    35E6 :                     ;
    9027/    35E6 :                     ;
    9028/    35E6 :                     ;prstk		ds.b	1			; stacked function index
    9029/    35E6 :                     ;
    9030/    35E6 :                     ;tpower		ds.b	1			; remember CORDIC power
    9031/    35E6 :                     ;
    9032/    35E6 :                     ;Asrch		ds.b	1			; scan-between-quotes flag, alt search character
    9033/    35E6 :                     ;
    9034/    35E6 :                     ;Dimcnt		ds.b	1			; # of dimensions
    9035/    35E6 :                     ;
    9036/    35E6 :                     ;Breakf		ds.b	1			; break flag, $00=END else=break
    9037/    35E6 :                     ;Oquote		ds.b	1			; open quote flag (Flag: DATA; LIST; memory)
    9038/    35E6 :                     ;Gclctd		ds.b	1			; garbage collected flag
    9039/    35E6 :                     ;Sufnxf		ds.b	1			; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
    9040/    35E6 :                     ;Imode		ds.b	1			; input mode flag, $00=INPUT, $98=READ
    9041/    35E6 :                     ;
    9042/    35E6 :                     ;Cflag		ds.b	1			; comparison evaluation flag
    9043/    35E6 :                     ;
    9044/    35E6 :                     ;TabSiz		ds.b	1			; TAB step size
    9045/    35E6 :                     ;
    9046/    35E6 :                     ;comp_f		ds.b	1			; compare function flag, bits 0,1 and 2 used
    9047/    35E6 :                     ;								; bit 2 set if >
    9048/    35E6 :                     ;								; bit 1 set if =
    9049/    35E6 :                     ;								; bit 0 set if <
    9050/    35E6 :                     ;
    9051/    35E6 :                     ;Nullct		ds.b	1			; nulls output after each line
    9052/    35E6 :                     ;TPos		ds.b	1			; BASIC terminal position byte
    9053/    35E6 :                     ;TWidth		ds.b	1			; BASIC terminal width byte
    9054/    35E6 :                     ;Iclim		ds.b	1			; input column limit
    9055/    35E6 :                     ;ccflag		ds.b	1			; CTRL-C check flag
    9056/    35E6 :                     ;ccbyte		ds.b	1			; CTRL-C last received byte
    9057/    35E6 :                     ;ccnull		ds.b	1			; CTRL-C last received byte 'life' timer
    9058/    35E6 :                     ;
    9059/    35E6 :                     ;
    9060/    35E6 :                     ;prg_strt
    9061/    35E6 :                     
    9062/    35E6 :                     ;************************************************************************************
    9063/    35E6 :                     ; EhBASIC keywords quick reference list												*
    9064/    35E6 :                     ;************************************************************************************
    9065/    35E6 :                     
    9066/    35E6 :                     ; glossary
    9067/    35E6 :                     
    9068/    35E6 :                     ;		<.>		  required
    9069/    35E6 :                     ;		{.|.}		  one of required
    9070/    35E6 :                     ;		[.]		  optional
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 157 - 10/11/2023 16:23:32


    9071/    35E6 :                     ;		...		  may repeat as last
    9072/    35E6 :                     
    9073/    35E6 :                     ;		any		= anything
    9074/    35E6 :                     ;		num		= number
    9075/    35E6 :                     ;		state		= statement
    9076/    35E6 :                     ;		n		= positive integer
    9077/    35E6 :                     ;		str		= string
    9078/    35E6 :                     ;		var		= variable
    9079/    35E6 :                     ;		nvar		= numeric variable
    9080/    35E6 :                     ;		svar		= string variable
    9081/    35E6 :                     ;		expr		= expression
    9082/    35E6 :                     ;		nexpr		= numeric expression
    9083/    35E6 :                     ;		sexpr		= string expression
    9084/    35E6 :                     
    9085/    35E6 :                     ; statement separator
    9086/    35E6 :                     
    9087/    35E6 :                     ; :			. [<state>] : [<state>]							; done
    9088/    35E6 :                     
    9089/    35E6 :                     ; number bases
    9090/    35E6 :                     
    9091/    35E6 :                     ; %			. %<binary num>								; done
    9092/    35E6 :                     ; $			. $<hex num>								; done
    9093/    35E6 :                     
    9094/    35E6 :                     ; commands
    9095/    35E6 :                     
    9096/    35E6 :                     ; END		. END										; done
    9097/    35E6 :                     ; FOR		. FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]	; done
    9098/    35E6 :                     ; NEXT		. NEXT [<nvar>[,<nvar>]...]						; done
    9099/    35E6 :                     ; DATA		. DATA [{num|["]str["]}[,{num|["]str["]}]...]	; done
    9100/    35E6 :                     ; INPUT		. INPUT [<">str<">;] <var>[,<var>[,<var>]...]	; done
    9101/    35E6 :                     ; DIM		. DIM <var>(<nexpr>[,<nexpr>[,<nexpr>]])		; done
    9102/    35E6 :                     ; READ		. READ <var>[,<var>[,<var>]...]				; done
    9103/    35E6 :                     ; LET		. [LET] <var>=<expr>						; done
    9104/    35E6 :                     ; DEC		. DEC <nvar>[,<nvar>[,<nvar>]...]			; done
    9105/    35E6 :                     ; GOTO		. GOTO <n>									; done
    9106/    35E6 :                     ; RUN		. RUN [<n>]									; done
    9107/    35E6 :                     ; IF		. IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]	; done
    9108/    35E6 :                     ; RESTORE	. RESTORE [<n>]								; done
    9109/    35E6 :                     ; GOSUB		. GOSUB <n>									; done
    9110/    35E6 :                     ; RETURN	. RETURN									; done
    9111/    35E6 :                     ; REM		. REM [<any>]								; done
    9112/    35E6 :                     ; STOP		. STOP										; done
    9113/    35E6 :                     ; ON		. ON <nexpr>{GOTO|GOSUB}<n>[,<n>[,<n>]...]	; done
    9114/    35E6 :                     ; NULL		. NULL <nexpr>								; done
    9115/    35E6 :                     ; INC		. INC <nvar>[,<nvar>[,<nvar>]...]			; done
    9116/    35E6 :                     ; WAIT		. WAIT <nexpr>,<nexpr>[,<nexpr>]			; done
    9117/    35E6 :                     ; LOAD		. LOAD [<sexpr>]							; done for sim
    9118/    35E6 :                     ; SAVE		. SAVE [<sexpr>][,[<n>][-<n>]]				; done for sim
    9119/    35E6 :                     ; DEF		. DEF FN<var>(<var>)=<expr>					; done
    9120/    35E6 :                     ; POKE		. POKE <nexpr>,<nexpr>						; done
    9121/    35E6 :                     ; DOKE		. DOKE <nexpr>,<nexpr>						; done
    9122/    35E6 :                     ; LOKE		. LOKE <nexpr>,<nexpr>						; done
    9123/    35E6 :                     ; CALL		. CALL <nexpr>								; done
    9124/    35E6 :                     ; DO		. DO										; done
    9125/    35E6 :                     ; LOOP		. LOOP [{WHILE|UNTIL}<nexpr>]				; done
    9126/    35E6 :                     ; PRINT		. PRINT [{;|,}][<expr>][{;|,}[<expr>]...]	; done
    9127/    35E6 :                     ; CONT		. CONT										; done
    9128/    35E6 :                     ; LIST		. LIST [<n>][-<n>]							; done
    9129/    35E6 :                     ; CLEAR		. CLEAR										; done
    9130/    35E6 :                     ; NEW		. NEW										; done
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 158 - 10/11/2023 16:23:32


    9131/    35E6 :                     ; WIDTH		. WIDTH [<n>][,<n>]							; done
    9132/    35E6 :                     ; GET		. GET <var>									; done
    9133/    35E6 :                     ; SWAP		. SWAP <var>,<var>							; done
    9134/    35E6 :                     ; BITSET	. BITSET <nexpr>,<nexpr>					; done
    9135/    35E6 :                     ; BITCLR	. BITCLR <nexpr>,<nexpr>					; done
    9136/    35E6 :                     
    9137/    35E6 :                     ; sub commands (may not start a statement)
    9138/    35E6 :                     
    9139/    35E6 :                     ; TAB		. TAB(<nexpr>)								; done
    9140/    35E6 :                     ; ELSE		. IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]	; done
    9141/    35E6 :                     ; TO		. FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]			; done
    9142/    35E6 :                     ; FN		. FN <var>(<expr>)							; done
    9143/    35E6 :                     ; SPC		. SPC(<nexpr>)								; done
    9144/    35E6 :                     ; THEN		. IF <nexpr> {THEN <{n|comm}>|GOTO <n>}		; done
    9145/    35E6 :                     ; NOT		. NOT <nexpr>								; done
    9146/    35E6 :                     ; STEP		. FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]			; done
    9147/    35E6 :                     ; UNTIL		. LOOP [{WHILE|UNTIL}<nexpr>]				; done
    9148/    35E6 :                     ; WHILE		. LOOP [{WHILE|UNTIL}<nexpr>]				; done
    9149/    35E6 :                     
    9150/    35E6 :                     ; operators
    9151/    35E6 :                     
    9152/    35E6 :                     ; +			. [expr] + <expr>							; done
    9153/    35E6 :                     ; -			. [nexpr] - <nexpr>							; done
    9154/    35E6 :                     ; *			. <nexpr>	; <nexpr>						; done fast hardware
    9155/    35E6 :                     ; /			. <nexpr> / <nexpr>							; done fast hardware
    9156/    35E6 :                     ; ^			. <nexpr> ^ <nexpr>							; done
    9157/    35E6 :                     ; AND		. <nexpr> AND <nexpr>						; done
    9158/    35E6 :                     ; EOR		. <nexpr> EOR <nexpr>						; done
    9159/    35E6 :                     ; OR		. <nexpr> OR <nexpr>						; done
    9160/    35E6 :                     ; >>		. <nexpr> >> <nexpr>						; done
    9161/    35E6 :                     ; <<		. <nexpr> << <nexpr>						; done
    9162/    35E6 :                     
    9163/    35E6 :                     ; compare functions
    9164/    35E6 :                     
    9165/    35E6 :                     ; <			. <expr> < <expr>							; done
    9166/    35E6 :                     ; =			. <expr> = <expr>							; done
    9167/    35E6 :                     ; >			. <expr> > <expr>							; done
    9168/    35E6 :                     
    9169/    35E6 :                     ; functions
    9170/    35E6 :                     
    9171/    35E6 :                     ; SGN		. SGN(<nexpr>)								; done
    9172/    35E6 :                     ; INT		. INT(<nexpr>)								; done
    9173/    35E6 :                     ; ABS		. ABS(<nexpr>)								; done
    9174/    35E6 :                     ; USR		. USR(<expr>)								; done
    9175/    35E6 :                     ; FRE		. FRE(<expr>)								; done
    9176/    35E6 :                     ; POS		. POS(<expr>)								; done
    9177/    35E6 :                     ; SQR		. SQR(<nexpr>)								; done fast shift/sub
    9178/    35E6 :                     ; RND		. RND(<nexpr>)								; done 32 bit PRNG
    9179/    35E6 :                     ; LOG		. LOG(<nexpr>)								; done fast cordic
    9180/    35E6 :                     ; EXP		. EXP(<nexpr>)								; done fast cordic
    9181/    35E6 :                     ; COS		. COS(<nexpr>)								; done fast cordic
    9182/    35E6 :                     ; SIN		. SIN(<nexpr>)								; done fast cordic
    9183/    35E6 :                     ; TAN		. TAN(<nexpr>)								; done fast cordic
    9184/    35E6 :                     ; ATN		. ATN(<nexpr>)								; done fast cordic
    9185/    35E6 :                     ; PEEK		. PEEK(<nexpr>)								; done
    9186/    35E6 :                     ; DEEK		. DEEK(<nexpr>)								; done
    9187/    35E6 :                     ; LEEK		. LEEK(<nexpr>)								; done
    9188/    35E6 :                     ; LEN		. LEN(<sexpr>)								; done
    9189/    35E6 :                     ; STR$		. STR$(<nexpr>)								; done
    9190/    35E6 :                     ; VAL		. VAL(<sexpr>)								; done
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 159 - 10/11/2023 16:23:32


    9191/    35E6 :                     ; ASC		. ASC(<sexpr>)								; done
    9192/    35E6 :                     ; UCASE$	. UCASE$(<sexpr>)							; done
    9193/    35E6 :                     ; LCASE$	. LCASE$(<sexpr>)							; done
    9194/    35E6 :                     ; CHR$		. CHR$(<nexpr>)								; done
    9195/    35E6 :                     ; HEX$		. HEX$(<nexpr>)								; done
    9196/    35E6 :                     ; BIN$		. BIN$(<nexpr>)								; done
    9197/    35E6 :                     ; BTST		. BTST(<nexpr>,<nexpr>)						; done
    9198/    35E6 :                     ; MAX		. MAX(<nexpr>[,<nexpr>[,<nexpr>]...])		; done
    9199/    35E6 :                     ; MIN		. MIN(<nexpr>[,<nexpr>[,<nexpr>]...])		; done
    9200/    35E6 :                     ; PI		. PI										; done
    9201/    35E6 :                     ; TWOPI		. TWOPI										; done
    9202/    35E6 :                     ; VARPTR	. VARPTR(<var>)								; done
    9203/    35E6 :                     ; SADD		. SADD(<svar>)								; done
    9204/    35E6 :                     ; LEFT$		. LEFT$(<sexpr>,<nexpr>)					; done
    9205/    35E6 :                     ; RIGHT$	. RIGHT$(<sexpr>,<nexpr>)					; done
    9206/    35E6 :                     ; MID$		. MID$(<sexpr>,<nexpr>[,<nexpr>])			; done
    9207/    35E6 :                     ; USING$	. USING$(<sexpr>,<nexpr>[,<nexpr>]...])		; done
    9208/    35E6 :                     
    9209/    35E6 :                     
    9210/    35E6 :                     ;************************************************************************************
    9211/    35E6 :                     
    9212/    35E6 :                     	END	code_start
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 160 - 10/11/2023 16:23:32


  Symbol Table (* = unused):
  --------------------------

 AC1GTAC2 :                    1BB6 C |  ACIAC :                   40000001 - |
 ACIAD :                   40000000 - |
*ARCHITECTURE :                                        "i386-unknown-win32" - |
 ASPTL :                        5A8 C |  ASRCH :                        5DA C |
 ASTRTL :                       5AC C |  BHSEND :                       5D6 C |
 BIN2DEC :                     2B7A C |  BINPR :                       2760 C |
 BINSS :                        5B6 C |  BLINEL :                       456 C |
 BREAKF :                       5DC C | *CASESENSITIVE :                  0 - |
 CCBYTE :                       5E9 C |  CCFLAG :                       5E8 C |
 CCNULL :                       5EA C |  CFLAG :                        5E1 C |
 CLINEL :                       452 C |  CO0 :                           C2 C |
 CODE_START :                   106 C |  COMP_F :                       5E3 C |
*CONSTPI :        3.141592653589793 - |  COSOUT :                       5B4 - |
 CPNTRL :                       45A C | *CVARAL :                       46E C |
 D1X02 :                       2B54 C |  D1X10 :                       2B6A C |
 D1X16 :                       2B46 C | *DATE :                "10/11/2023" - |
 DECSS :                        5C6 C |  DEFDIM :                       5B4 C |
 DES_SK :                       48E C |  DES_SK_E :                     476 C |
 DIMCNT :                       5DB C |  DLINEL :                       45E C |
 DOCMP :                        7B6 C |  DOREST :                       7A2 C |
 DPTRL :                        462 C |  DTYPEF :                       5B5 - |
 EARRYL :                       442 C |  EMEML :                        44A C |
 ENDBHS :                      273A C |  EXPCNT :                       5AD - |
 EXPNEG :                       5AF - |  FAC1_E :                       594 C |
 FAC1_M :                       590 C |  FAC1_S :                       595 - |
 FAC2_E :                       59C C |  FAC2_M :                       598 C |
 FAC2_S :                       59D - |  FAC_SC :                       59E - |
*FALSE :                          0 - |  FEND :                           8 - |
 FLAG :                         59F - | *FLASH_SUPPORT :                  0 - |
 FSD :                            0 - |  FSDC :                           A - |
 FSDPI :                          8 - |  FSLI :                           6 - |
 FSTI :                           4 - | *FULLPMMU :                       0 - |
 FUNC_L :                       5B0 C |  GCLCTD :                       5DE C |
 GETFIRST :                     F8E C |  GETPAIR :                     104A C |
 GOPR :                        276A C | *HAS64 :                          0 - |
*HASFPU :                         0 - | *HASPMMU :                        0 - |
 HEXSS :                        5CE C |  IBUFFE :                       590 C |
 IBUFFS :                       490 C |  ICLIM :                        5E7 C |
 IMODE :                        5E0 C |  INGET :                       27BE C |
*INIVEC :                         0 C | *INSUPMODE :                      1 - |
 ITEMP :                        42A C |  KEY_ABS :                     33DA C |
 KEY_AND :                     33DE C |  KEY_ASC :                     33E1 C |
 KEY_ATN :                     33E5 C |  KEY_BINS :                    33EA C |
 KEY_BITCLR :                  33EF C |  KEY_BITSET :                  33F5 C |
 KEY_BITTST :                  33FB C |  KEY_CALL :                    3403 C |
 KEY_CHRS :                    3407 C |  KEY_CLEAR :                   340C C |
 KEY_CONT :                    3411 C |  KEY_COS :                     3415 C |
 KEY_DATA :                    341A C |  KEY_DEC :                     341E C |
 KEY_DEEK :                    3421 C |  KEY_DEF :                     3426 C |
 KEY_DIM :                     3429 C |  KEY_DIV :                     33CC C |
 KEY_DO :                      3430 C |  KEY_DOKE :                    342C C |
 KEY_ELSE :                    3433 C |  KEY_END :                     3437 C |
 KEY_EOR :                     343A C |  KEY_EQUAL :                   33D2 C |
 KEY_EXP :                     343D C |  KEY_FN :                      3445 C |
 KEY_FOR :                     3442 C |  KEY_FRE :                     3447 C |
 KEY_GET :                     344C C |  KEY_GOSUB :                   3453 C |
 KEY_GOTO :                    344F C |  KEY_GT :                      33D6 C |
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 161 - 10/11/2023 16:23:32


 KEY_HEXS :                    3459 C |  KEY_IF :                      345F C |
 KEY_INC :                     3461 C |  KEY_INPUT :                   3464 C |
 KEY_INT :                     3469 C |  KEY_LCASES :                  346E C |
 KEY_LEEK :                    3475 C |  KEY_LEFTS :                   347A C |
 KEY_LEN :                     3480 C |  KEY_LET :                     3484 C |
 KEY_LIST :                    3487 C |  KEY_LOAD :                    348B C |
 KEY_LOG :                     348F C |  KEY_LOKE :                    3493 C |
 KEY_LOOP :                    3497 C |  KEY_LSHIFT :                  33CE C |
 KEY_LT :                      33D0 C |  KEY_MAX :                     349C C |
 KEY_MIDS :                    34A0 C |  KEY_MIN :                     34A5 C |
 KEY_MINUS :                   33CA C |  KEY_MULT :                    33C6 C |
 KEY_NEW :                     34AA C |  KEY_NEXT :                    34AD C |
 KEY_NOT :                     34B1 C |  KEY_NULL :                    34B4 C |
 KEY_ON :                      34B9 C |  KEY_OR :                      34BB C |
 KEY_PEEK :                    34BE C |  KEY_PI :                      34C3 C |
 KEY_PLUS :                    33C8 C |  KEY_POKE :                    34C5 C |
 KEY_POS :                     34C9 C |  KEY_POWER :                   356F C |
 KEY_PRINT :                   34CD C |  KEY_RAM :                     34D3 C |
 KEY_READ :                    34DA C |  KEY_REM :                     34DE C |
 KEY_RESTORE :                 34E1 C |  KEY_RETURN :                  34E8 C |
 KEY_RIGHTS :                  34EE C |  KEY_RND :                     34F5 C |
 KEY_RSHIFT :                  33D4 C |  KEY_RUN :                     34F9 C |
 KEY_SADD :                    34FD C |  KEY_SAVE :                    3502 C |
 KEY_SGN :                     3506 C |  KEY_SIN :                     350A C |
 KEY_SPC :                     350E C |  KEY_SQR :                     3512 C |
 KEY_STEP :                    3516 C |  KEY_STOP :                    351A C |
 KEY_STRS :                    351E C |  KEY_SWAP :                    3523 C |
 KEY_TAB :                     3528 C |  KEY_TAN :                     352C C |
 KEY_THEN :                    3530 C |  KEY_TO :                      3534 C |
 KEY_TWOPI :                   3536 C |  KEY_UCASES :                  353C C |
 KEY_UNTIL :                   3543 C |  KEY_USINGS :                  3548 C |
 KEY_USR :                     354F C |  KEY_VAL :                     3554 C |
 KEY_VPTR :                    3558 C |  KEY_WAIT :                    3560 C |
 KEY_WHILE :                   3564 C |  KEY_WIDTH :                   3569 C |
 KFCTSEED :                26A3D110 - |  LAB_11A5 :                     C5C C |
 LAB_11A6 :                     C5E C |  LAB_11BD :                     C6A C |
 LAB_1269 :                     246 C |  LAB_1274 :                     254 C |
 LAB_127D :                     25C C |  LAB_127E :                     26A C |
 LAB_1295 :                     27E C |  LAB_12AE :                     2A0 C |
 LAB_12B0 :                     2A2 C |  LAB_12E6 :                     2C2 C |
 LAB_12FF :                     2F4 C |  LAB_1301 :                     2F6 C |
 LAB_1303 :                     314 C |  LAB_1325 :                     32C C |
 LAB_132E :                     31C C |  LAB_1330 :                     31E C |
 LAB_134B :                     33A C |  LAB_1357 :                     358 C |
 LAB_1359 :                     35E C |  LAB_1374 :                     37E C |
 LAB_1378 :                     384 C |  LAB_137F :                     390 C |
 LAB_138E :                     396 C |  LAB_1392 :                     39A C |
 LAB_13A6 :                     3CE C |  LAB_13AC :                     3D6 C |
 LAB_13C6 :                     400 C |  LAB_13CC :                     406 C |
 LAB_13D6 :                     428 C |  LAB_13D8 :                     42E C |
 LAB_13EA :                     43A C |  LAB_13EC :                     43C C |
 LAB_13FF :                     454 C |  LAB_1401 :                     458 C |
 LAB_1408 :                     464 C |  LAB_1410 :                     470 C |
 LAB_1417 :                     47A C |  LAB_141B :                     47C C |
 LAB_141F :                     48C C |  LAB_142A :                     492 C |
 LAB_142C :                     49E C |  LAB_145E :                     4B8 C |
 LAB_145F :                     4AA C |  LAB_1463 :                     4C0 C |
 LAB_1477 :                     4CC C |  LAB_147A :                     4D2 C |
*LAB_1480 :                     4EC C |  LAB_1491 :                     4F6 C |
 LAB_14BD :                     528 C |  LAB_14C0 :                     52C C |
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 162 - 10/11/2023 16:23:32


 LAB_14D4 :                     54C C | *LAB_14E2 :                     568 C |
 LAB_150C :                     576 C |  LAB_1519 :                     586 C |
 LAB_152E :                     592 C |  LAB_1540 :                     5BE C |
 LAB_15B3 :                     61E C |  LAB_15C2 :                     648 C |
 LAB_15D1 :                     654 C |  LAB_15DC :                     630 C |
 LAB_15F6 :                     642 C |  LAB_15FF :                     662 C |
 LAB_1602 :                     666 C |  LAB_1624 :                     6EA C |
 LAB_1629 :                     68A C |  LAB_1636 :                     68E C |
 LAB_1639 :                     694 C |  LAB_163B :                     6A0 C |
 LAB_1647 :                     6AC C |  LAB_164F :                     6B2 C |
 LAB_16B0 :                     74A C |  LAB_16D0 :                     76E C |
 LAB_1723 :                     808 C |  LAB_1725 :                     80C C |
 LAB_172C :                     7F8 C |  LAB_172D :                     800 C |
 LAB_174B :                     834 C |  LAB_174E :                     858 C |
 LAB_1750 :                     864 C |  LAB_1752 :                     870 C |
 LAB_1754 :                     888 C | *LAB_1756 :                     874 C |
 LAB_176C :                     8A6 C |  LAB_1773 :                     8B0 C |
 LAB_1785 :                     8CC C |  LAB_1786 :                     8F8 C |
 LAB_17B7 :                     90E C |  LAB_17B8 :                     90A C |
 LAB_17D5 :                     98A C |  LAB_17D6 :                     98E C |
*LAB_1810 :                     9A0 C |  LAB_1811 :                     9B0 C |
 LAB_1813 :                     9B6 C |  LAB_1829 :                     9EE C |
 LAB_182C :                     9F2 C |  LAB_1831 :                     9F8 C |
 LAB_185E :                     A38 C |  LAB_1866 :                     A3C C |
 LAB_1880 :                     AFE C |  LAB_1886 :                     B08 C |
 LAB_188A :                     B0C C |  LAB_188B :                     A4A C |
 LAB_1898 :                     A58 C |  LAB_18A2 :                     A62 C |
 LAB_18B7 :                     A84 C |  LAB_18B8 :                     A90 C |
 LAB_18BD :                     A96 C |  LAB_18C3 :                     AA0 C |
 LAB_18C6 :                     AA4 C |  LAB_18CD :                     AAE C |
 LAB_18E3 :                     AB8 C |  LAB_18F0 :                     AD8 C |
 LAB_18F7 :                     AE6 C |  LAB_18F9 :                     AEA C |
 LAB_1904 :                     B10 C |  LAB_1913 :                     B22 C |
 LAB_1934 :                     B48 C |  LAB_1953 :                     B5C C |
 LAB_195B :                     B64 C | *LAB_1961 :                     B6E C |
 LAB_1984 :                     B8E C |  LAB_1985 :                     B92 C |
 LAB_1986 :                     B96 C |  LAB_1999 :                     BAA C |
 LAB_19B0 :                     BBC C |  LAB_19B6 :                     BCC C |
 LAB_19C2 :                     BDC C |  LAB_19DD :                     BF0 C |
 LAB_19F6 :                     C10 C |  LAB_1A03 :                     C1E C |
 LAB_1A0E :                     C2E C |  LAB_1A1B :                     C34 C |
 LAB_1A46 :                     C4E C |  LAB_1A90 :                     CCC C |
 LAB_1A9B :                     CDA C |  LAB_1ABA :                     D04 C |
 LAB_1ACD :                     D30 C |  LAB_1ADB :                     D3C C |
 LAB_1ADE :                     D40 C |  LAB_1AE0 :                     D56 C |
 LAB_1AFA :                     D70 C |  LAB_1B0B :                     D86 C |
 LAB_1B13 :                     D8E C |  LAB_1B1C :                     D9E C |
 LAB_1B1D :                     DA0 C |  LAB_1B2A :                     DB2 C |
 LAB_1B3C :                     DCE C |  LAB_1B43 :                     D14 C |
 LAB_1B78 :                     DDA C |  LAB_1B7B :                     DDE C |
 LAB_1B7D :                     DE0 C |  LAB_1B84 :                     DEA C |
 LAB_1B86 :                     DEE C |  LAB_1B9D :                     E12 C |
 LAB_1BC1 :                     E42 C |  LAB_1BD0 :                     EB2 C |
 LAB_1BE7 :                     ECC C |  LAB_1BF3 :                     E4E C |
 LAB_1BF7 :                     E54 C |  LAB_1BFB :                     E58 C |
 LAB_1C01 :                     E60 C |  LAB_1C11 :                     E8A C |
 LAB_1C13 :                     E90 C |  LAB_1C18 :                     E98 C |
 LAB_1C19 :                     E9C C |  LAB_1C1A :                     EAC C |
 LAB_1C2A :                     F0A C |  LAB_1CAE :                     FB2 C |
 LAB_1CB5 :                     FD0 C |  LAB_1CD4 :                     FDA C |
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 163 - 10/11/2023 16:23:32


 LAB_1CD5 :                     FE0 C |  LAB_1CD6 :                     FE2 C |
 LAB_1CDB :                     FF2 C |  LAB_1CE6 :                     FE4 C |
 LAB_1CF2 :                     FF4 C |  LAB_1CFE :                    100A C |
 LAB_1D10 :                    1082 C |  LAB_1D12 :                    1086 C |
 LAB_1D2D :                    1098 C |  LAB_1D2E :                    10A4 C |
 LAB_1D44 :                    10C0 C |  LAB_1D45 :                    10D0 C |
 LAB_1D48 :                    10E4 C |  LAB_1D49 :                    10EC C |
 LAB_1D4A :                    10F0 C |  LAB_1D4B :                    1100 C |
 LAB_1D5D :                    1108 C |  LAB_1D5E :                    110E C |
 LAB_1D83 :                    1072 C |  LAB_1D8A :                    106C C |
 LAB_1D94 :                    1122 C | *LAB_1D96 :                    2E70 C |
*LAB_1D98 :                    112C C |  LAB_1DAC :                    1146 C |
 LAB_1DAE :                    1148 C |  LAB_1DAF :                    1154 C |
 LAB_1DB0 :                    1162 C |  LAB_1DB1 :                    1166 C |
 LAB_1DB2 :                    116A C |  LAB_1DD7 :                    1182 C |
 LAB_1DE6 :                    119C C |  LAB_1E17 :                    11DE C |
 LAB_1E1F :                    11E4 C |  LAB_1E5C :                    121E C |
 LAB_1E8D :                    123A C |  LAB_1EA1 :                    1256 C |
 LAB_1EC0 :                    127E C |  LAB_1ED6 :                    12AA C |
 LAB_1ED8 :                    12B8 C |  LAB_1EDF :                    1272 C |
 LAB_1F07 :                    12CA C |  LAB_1F28 :                    12E4 C |
 LAB_1F2C :                    12EA C |  LAB_1F5A :                    12F8 C |
 LAB_1F6A :                    1320 C |  LAB_1F6B :                    132C C |
 LAB_1F7C :                    1332 C |  LAB_1FB4 :                    1360 C |
 LAB_1FD0 :                    138C C |  LAB_201E :                    13E6 C |
 LAB_2043 :                    1434 C |  LAB_2044 :                    1466 C |
 LAB_2045 :                    1470 C |  LAB_204S :                    1436 C |
 LAB_204T :                    1464 C |  LAB_20AE :                    1482 C |
 LAB_20B4 :                    1486 C |  LAB_20BE :                    148C C |
 LAB_20C9 :                    14B0 C |  LAB_20CB :                    149C C |
 LAB_20D0 :                    14A4 C |  LAB_20D8 :                    14BA C |
 LAB_20E0 :                    14C2 C |  LAB_2115 :                    14E2 C |
 LAB_2117 :                    14FA C |  LAB_2128 :                    1514 C |
 LAB_2137 :                    1518 C |  LAB_214B :                    1538 C |
 LAB_2161 :                    154E C |  LAB_2176 :                    1556 C |
 LAB_217E :                    1564 C |  LAB_2183 :                    157E C |
 LAB_218B :                    1586 C |  LAB_218F :                    1588 C |
 LAB_21C2 :                    1594 C |  LAB_21C4 :                    159A C |
 LAB_21D1 :                    15CE C |  LAB_2206 :                    15D4 C |
 LAB_2212 :                    15FC C |  LAB_2216 :                    15BE C |
 LAB_2240 :                    15C6 C |  LAB_224D :                    1602 C |
 LAB_224E :                    1618 C |  LAB_229E :                    165C C |
 LAB_22A0 :                    1668 C |  LAB_22B6 :                    1676 C |
 LAB_22BA :                    167A C |  LAB_22BD :                    1684 C |
 LAB_22E6 :                    169E C | *LAB_2316 :                    16DE C |
 LAB_2317 :                    16E0 C |  LAB_231C :                    16E4 C |
 LAB_2358 :                    1718 C |  LAB_2368 :                    1738 C |
 LAB_2441 :                    192C C |  LAB_2445 :                    1930 C |
 LAB_2467 :                    1980 C |  LAB_2468 :                    1984 C |
 LAB_249C :                    1972 C |  LAB_24A8 :                    1988 C |
 LAB_24B4 :                    19B2 C |  LAB_24D0 :                    19BE C |
 LAB_24D5 :                    19CA C |  LAB_24D6 :                    19E4 C |
 LAB_24D7 :                    19F2 C |  LAB_24D8 :                    19F8 C |
 LAB_24D9 :                    19D8 C |  LAB_24DA :                    19FE C |
 LAB_24F7 :                    19A2 C |  LAB_24F8 :                    19A8 C |
 LAB_2778 :                    1C66 C |  LAB_277C :                    1C68 C |
 LAB_279B :                    1C8C C |  LAB_27BA :                    1C9A C |
 LAB_27C3 :                    1CB6 C |  LAB_27C4 :                    1CC0 C |
 LAB_27CA :                    1CC6 C |  LAB_27CE :                    1CCE C |
 LAB_27D0 :                    1CD2 C |  LAB_27DB :                    1CE0 C |
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 164 - 10/11/2023 16:23:32


 LAB_27F0 :                    1FA4 C |  LAB_27F1 :                    1FBA C |
 LAB_27F2 :                    1FC0 C |  LAB_27F3 :                    1FC2 C |
 LAB_27FA :                    1CF8 C |  LAB_2828 :                    1D18 C |
*LAB_282E :                    1D1E C |  LAB_282F :                    1D20 C |
 LAB_2831 :                    1D24 C |  LAB_284G :                    1D48 C |
 LAB_284H :                    1D5A C |  LAB_284J :                    1D5C C |
 LAB_284L :                    1D50 C |  LAB_2887 :                    2968 C |
 LAB_289A :                    2992 C |  LAB_289C :                    2998 C |
 LAB_289D :                    299E C |  LAB_28FD :                    29BA C |
 LAB_28FE :                    29C0 C |  LAB_28FF :                    29C6 C |
 LAB_2900 :                    29D4 C |  LAB_2901 :                    29DA C |
 LAB_2902 :                    2A2C C |  LAB_2903 :                    2A34 C |
 LAB_2904 :                    2A36 C |  LAB_2953 :                    1D7E C |
 LAB_295E :                    1D8A C |  LAB_2967 :                    1D96 C |
 LAB_2968 :                    1D9E C |  LAB_2969 :                    1DB0 C |
 LAB_296A :                    1DBA C |  LAB_2970 :                    1DD0 C |
 LAB_2978 :                    1DE0 C |  LAB_2989 :                    1DF0 C |
 LAB_299C :                    1E44 C |  LAB_29A7 :                    1E6C C |
 LAB_29B7 :                    1E84 C |  LAB_29B9 :                    1E1C C |
 LAB_29C0 :                    1E92 C |  LAB_29C3 :                    1EAA C |
 LAB_29D9 :                    1EC6 C |  LAB_29E4 :                    1ED8 C |
 LAB_29F7 :                    1EEC C |  LAB_29FB :                    1EF0 C |
 LAB_29FD :                    1EF8 C |  LAB_2A18 :                    1F08 C |
 LAB_2A1A :                    1F0A C |  LAB_2A21 :                    1F12 C |
 LAB_2A3B :                    1F34 C |  LAB_2A4B :                    1F42 C |
 LAB_2A58 :                    1F56 C |  LAB_2A68 :                    1F6E C |
 LAB_2A74 :                    1F7A C |  LAB_2A89 :                    1F96 C |
 LAB_2A8C :                    1F9A C |  LAB_2A91 :                    1FA0 C |
 LAB_2A9A :                    3014 C |  LAB_2A9B :                    3030 C |
 LAB_2X01 :                    29F2 C |  LAB_2X02 :                    29FA C |
 LAB_2X03 :                    2A08 C |  LAB_2X04 :                    2A0E C |
 LAB_2X05 :                    2A24 C |  LAB_2Y01 :                    2A44 C |
 LAB_2Y02 :                    2A4C C |  LAB_2Y03 :                    2A58 C |
 LAB_2Y04 :                    2A5E C |  LAB_3216 :                    1C00 C |
 LAB_32_16 :                   1BFE C |  LAB_ABER :                     208 C |
 LAB_ABS :                     1CF0 C |  LAB_AD :                      33A7 C |
 LAB_ADD :                     194E C |  LAB_ADER :                     1D4 C |
 LAB_AND :                      F86 C |  LAB_ASC :                     17C2 C |
 LAB_ATCD :                    2344 C |  LAB_ATGO :                    2300 C |
 LAB_ATLE :                    231E C |  LAB_ATN :                     22E2 C |
 LAB_ATNP :                    233E C |  LAB_AYFC :                    136C C |
 LAB_BAER :                    322E C |  LAB_BHCB :                     F6C C |
 LAB_BHSS :                     F46 C |  LAB_BINS :                    271C C |
 LAB_BITCLR :                  23A6 C |  LAB_BITSET :                  2396 C |
 LAB_BMSG :                    3571 C |  LAB_BS :                      32D0 C |
 LAB_BTST :                    23B6 C |  LAB_CALL :                    190C C |
 LAB_CASC :                    105C C |  LAB_CATN :                    234A C |
*LAB_CAUC :                    1062 C |  LAB_CBIN :                    2B18 C |
 LAB_CBX1 :                    2B32 C |  LAB_CBXN :                    2B20 C |
 LAB_CCER :                     1EC C |  LAB_CHEX :                    2AB6 C |
 LAB_CHRS :                    16A8 C |  LAB_CHX1 :                    2ADC C |
 LAB_CHX2 :                    2B00 C |  LAB_CHX3 :                    2AF8 C |
 LAB_CHXX :                    2ABE C |  LAB_CKRN :                    1394 C |
 LAB_CKTM :                     CF6 C |  LAB_CLEAR :                    510 C |
 LAB_CN :                      333D C |  LAB_COLD :                     11C C |
 LAB_CONT :                     6FC C |  LAB_CORD :                    2274 C |
 LAB_COS :                     2204 C |  LAB_CRLF :                     A42 C |
 LAB_CTBL :                    2EF8 C |  LAB_CTNM :                     CF4 C |
 LAB_D0 :                      32EE C |  LAB_D002 :                    2680 C |
 LAB_D00A :                    2690 C |  LAB_D00E :                    26A0 C |
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 165 - 10/11/2023 16:23:32


 LAB_DATA :                     7EA C |  LAB_DD :                      32DD C |
 LAB_DDER :                     204 C |  LAB_DEC :                      8FE C |
 LAB_DECI :                     95E C |  LAB_DEEK :                    188A C |
 LAB_DEF :                     139E C |  LAB_DIM :                     100E C |
 LAB_DIV0 :                    1BF8 C |  LAB_DIVIDE :                  1B7E C |
 LAB_DIVX :                    1BCE C |  LAB_DO :                       72E C |
 LAB_DOKE :                    18B4 C |  LAB_DUPFMT :                  2668 C |
 LAB_DZER :                     200 C |  LAB_EMSG :                    3579 C |
 LAB_END :                      696 C |  LAB_EOR :                      F76 C |
 LAB_EQUAL :                    F9C C |  LAB_ESML :                    211A C |
 LAB_EVBY :                    17DA C |  LAB_EVEX :                     D0A C |
 LAB_EVEZ :                     D0C C |  LAB_EVIN :                    11A8 C |
 LAB_EVIR :                    11B8 C |  LAB_EVNM :                     CF2 C |
 LAB_EVPI :                    11B0 C |  LAB_EX1 :                     2052 C |
 LAB_EXAD :                    21A4 C |  LAB_EXCC :                    218A C |
 LAB_EXCM :                    20BC C |  LAB_EXNN :                    2176 C |
 LAB_EXOF :                    2076 C |  LAB_EXOL :                    208C C |
 LAB_EXOU :                    2062 C |  LAB_EXP :                     2096 C |
 LAB_EXPL :                    2170 C |  LAB_EXPS :                    20CE C |
 LAB_EXRN :                    217C C |  LAB_EXXF :                    2B06 C |
 LAB_FB95 :                    27CE C |  LAB_FBA0 :                    27B2 C |
 LAB_FC :                      3297 C |  LAB_FCER :                     218 C |
 LAB_FO :                      33AF C |  LAB_FOER :                     1D0 C |
 LAB_FOR :                      5CA C |  LAB_FRE :                     1356 C |
 LAB_FTBL :                    2F94 C |  LAB_FTPP :                    2F48 C |
 LAB_FVAR :                    107A C |  LAB_GADB :                    182E C |
 LAB_GADW :                    1842 C |  LAB_GARB :                    152E C |
 LAB_GBYT :                     E6C C |  LAB_GEAD :                    1862 C |
 LAB_GET :                      9BC C |  LAB_GETS :                     9D6 C |
 LAB_GFPN :                     8C0 C |  LAB_GOSUB :                    740 C |
 LAB_GOTO :                     752 C |  LAB_GOTS :                     762 C |
 LAB_GSCH :                     6E2 C |  LAB_GTBY :                    17D6 C |
 LAB_GTHAN :                   2044 C |  LAB_GTWO :                    17EC C |
 LAB_GVAL :                     E18 C |  LAB_GVAR :                    107C C |
 LAB_HEXS :                    276E C |  LAB_ID :                      32FD C |
 LAB_IDER :                     1FC C |  LAB_IF :                       812 C |
 LAB_IGBY :                     E6A C |  LAB_IMSG :                    358A C |
 LAB_INC :                      904 C |  LAB_INCI :                     954 C |
 LAB_INCT :                     946 C |  LAB_INLN :                     34E C |
 LAB_INPUT :                    B30 C |  LAB_INT :                     1D62 C |
 LAB_IRTS :                    1D7C C |  LAB_ISHN :                    2AD8 C |
 LAB_KEYT :                    309A C |  LAB_LAAD :                    1A78 C |
 LAB_LCASE :                   1740 C |  LAB_LD :                      335F C |
 LAB_LDER :                     1E4 C |  LAB_LEEK :                    18A0 C |
 LAB_LEFT :                    16B8 C |  LAB_LENS :                    17BA C |
 LAB_LET :                      962 C |  LAB_LIST :                     514 C |
 LAB_LMSG :                    3580 C |  LAB_LOAD :                    1904 C |
 LAB_LOCC :                    1A7E C |  LAB_LOCX :                    1A9A C |
 LAB_LOG :                     1A00 C |  LAB_LOKE :                    18BA C |
 LAB_LOLP :                    1A88 C |  LAB_LONE :                    1AB6 C |
 LAB_LONN :                    1A9E C |  LAB_LOOP :                     780 C |
 LAB_LOWZ :                    1AF0 C |  LAB_LOXO :                    1ABC C |
 LAB_LOXP :                    1AAC C |  LAB_LRMS :                     F24 C |
 LAB_LS :                      331A C |  LAB_LSHIFT :                  101A C |
 LAB_LTHAN :                    FA6 C |  LAB_LTPF :                    2284 C |
 LAB_LTPT :                    2294 C |  LAB_LT_1 :                    1C0C C |
 LAB_MADD :                    1B1E C |  LAB_MAN1 :                    1BF2 C |
 LAB_MAX :                     27DA C |  LAB_MAXN :                    27E6 C |
 LAB_MIDS :                    16FC C |  LAB_MIN :                     27F0 C |
 LAB_MINN :                    27FC C | *LAB_MKCHR :                   16AC C |
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 166 - 10/11/2023 16:23:32


 LAB_MMEC :                    2806 C |  LAB_MNOC :                    1B18 C |
 LAB_MUEX :                    1B6C C | *LAB_MUF1 :                    1B48 C |
 LAB_MUF2 :                    1B52 C |  LAB_MUF3 :                    1B68 C |
 LAB_MULTIPLY :                1AF2 C |  LAB_MUUF :                    1B72 C |
 LAB_NB1T :                    1C44 C |  LAB_NEW :                      4BE C |
 LAB_NEXT :                     C3C C |  LAB_NF :                      325E C |
 LAB_NFER :                     228 C |  LAB_NI :                      33B6 C |
 LAB_NOST :                     9E8 C |  LAB_NSTT :                    286C C |
 LAB_NULL :                     6F2 C |  LAB_OD :                      328B C |
 LAB_ODER :                     21C C |  LAB_OFER :                     214 C |
 LAB_OM :                      32AE C |  LAB_OMER :                     210 C |
 LAB_ON :                       88C C |  LAB_OPPT :                    2FE0 C |
 LAB_OR :                       F7E C |  LAB_OV :                      32A5 C |
 LAB_P004 :                    26BE C |  LAB_P008 :                    26D4 C |
 LAB_P00C :                    26DC C |  LAB_P00E :                    26E8 C |
 LAB_P010 :                    26EC C |  LAB_P018 :                    2706 C |
 LAB_P01A :                    270A C |  LAB_P01E :                    2712 C |
 LAB_PEEK :                    1878 C |  LAB_PFAC :                    1C4E C |
 LAB_PHFA :                    2816 C |  LAB_PI :                      2948 C |
 LAB_POKE :                    1884 C |  LAB_POON :                    1FC4 C |
 LAB_POS :                     1388 C |  LAB_POWER :                   1FE0 C |
 LAB_POWP :                    2012 C |  LAB_POZE :                    1FD4 C |
 LAB_PPBI :                     F1A C |  LAB_PPFN :                     F0C C |
 LAB_PPFS :                     EFE C |  LAB_PRINT :                    9F6 C |
 LAB_PRNA :                     ABA C |  LAB_PROCFO :                  26A6 C |
 LAB_P_10 :                    2C8A C |  LAB_RAM :                     293E C |
 LAB_READ :                     B56 C |  LAB_REDO :                    359A C |
 LAB_REM :                      884 C |  LAB_REMM :                    1C24 C |
 LAB_RESS :                     6D6 C |  LAB_RESTORE :                  6C4 C |
 LAB_RET0 :                    2AA4 C |  LAB_RETURN :                   7D6 C |
 LAB_RG :                      3276 C |  LAB_RGER :                     220 C |
 LAB_RIGHT :                   16CC C |  LAB_RMSG :                    35AC C |
 LAB_RND :                     21B0 C |  LAB_RSED :                    2BA2 C |
 LAB_RSHIFT :                  102A C |  LAB_RTN0 :                    2AA6 C |
 LAB_RTST :                    14C8 C |  LAB_RUN :                      71A C |
 LAB_RUNN :                     728 C |  LAB_SADD :                    17A2 C |
 LAB_SAVE :                    1908 C |  LAB_SCCA :                     E62 C |
 LAB_SCER :                     1F0 C |  LAB_SCGB :                     E5C C |
 LAB_SCL0 :                    226A C |  LAB_SCLN :                     4AC C |
 LAB_SCZE :                    225C C |  LAB_SET1 :                    1BD6 C |
 LAB_SGBY :                    17D2 C |  LAB_SGN :                     1CDE C |
 LAB_SIN :                     221C C |  LAB_SLER :                     1F4 C |
 LAB_SMSG :                    35B6 C |  LAB_SN :                      326F C |
 LAB_SNBS :                     7F0 C |  LAB_SNER :                     224 C |
 LAB_SQE1 :                    28F0 C |  LAB_SQE2 :                    28F6 C |
 LAB_SQNA :                    291E C |  LAB_SQNS :                    2908 C |
 LAB_SQR :                     28CC C |  LAB_SSLN :                     4A4 C |
 LAB_ST :                      332A C |  LAB_STOP :                     69E C |
 LAB_STRS :                    147E C |  LAB_SUBTRACT :                193A C |
 LAB_SVAR :                    1078 C |  LAB_SVTB :                    289E C |
 LAB_SWAP :                    18CE C |  LAB_TAN :                     21E2 C |
 LAB_TBSZ :                    287E C |  LAB_TM :                      330C C |
 LAB_TMER :                     1F8 C |  LAB_TWOPI :                   2958 C |
 LAB_U002 :                    240E C |  LAB_U004 :                    2464 C |
 LAB_U005 :                    2474 C |  LAB_U006 :                    2476 C |
 LAB_U008 :                    248A C |  LAB_U009 :                    24AC C |
 LAB_U00A :                    24B4 C |  LAB_U00B :                    24BE C |
 LAB_U00C :                    24D2 C |  LAB_U00D :                    24D6 C |
 LAB_U00E :                    24E8 C |  LAB_U00F :                    24F4 C |
 LAB_U010 :                    24F8 C |  LAB_U014 :                    24FE C |
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 167 - 10/11/2023 16:23:32


 LAB_U018 :                    2506 C |  LAB_U01C :                    251C C |
 LAB_U020 :                    2528 C |  LAB_U022 :                    252E C |
 LAB_U026 :                    253E C |  LAB_U02A :                    2548 C |
 LAB_U02B :                    2560 C |  LAB_U02C :                    2566 C |
 LAB_U02E :                    2578 C |  LAB_U030 :                    257C C |
 LAB_U034 :                    2592 C |  LAB_U036 :                    2598 C |
 LAB_U038 :                    25A0 C |  LAB_U03C :                    25A8 C |
 LAB_U03E :                    25AE C |  LAB_U040 :                    25C6 C |
 LAB_U044 :                    25D6 C |  LAB_U046 :                    25FE C |
 LAB_U048 :                    2600 C |  LAB_U04A :                    260A C |
 LAB_U04C :                    263C C |  LAB_UA :                      3382 C |
 LAB_UCASE :                   1770 C |  LAB_UDER :                     1DC C |
 LAB_UF :                      334C C |  LAB_UFAC :                    1C32 C |
 LAB_UFER :                     1E8 C |  LAB_US :                      32BC C |
 LAB_USER :                     20C C |  LAB_USINGS :                  23E4 C |
 LAB_USR :                     18FC C |  LAB_UV :                      336F C |
 LAB_UVER :                     1E0 C |  LAB_VAL :                     1800 C |
 LAB_VALZ :                    1828 C | *LAB_VARCALL :                 2930 C |
 LAB_VARPTR :                  292E C |  LAB_WAIT :                    1916 C |
 LAB_WARM :                     400 C |  LAB_WD :                      3396 C |
 LAB_WDER :                     1D8 C |  LAB_WDLP :                    28B2 C |
 LAB_WDTH :                    284C C |  LAB_XDIV :                    1BE6 C |
 LAB_XERR :                     22A C |  LAB_XGADW :                   185C C |
 LC_LOOP :                     1756 C | *LISTON :                         1 - |
 LOOPALWAYS :                   7BC C |  LOOPDONE :                     7D0 C |
 LVARPL :                       472 C |  L_DDIV :                      1C2C C |
 L_DIVRND :                    1BDA C | *MACEXP :                         7 - |
 MAINLOOP :                    22AC C | *MOMCPU :                     68030 - |
*MOMCPUNAME :               "68030" - | *N :                              2 - |
*NESTMAX :                      100 - |  NEXTA :                       22BE C |
 NEXTB1 :                      272C C |  NEXTB2 :                      2752 C |
 NEXTH1 :                      277E C |  NEXTPRN :                     21BE C |
 NINC0 :                       21C6 C |  NINC1 :                       21CC C |
*NOBRK :                          0 - |  NOCHR :                         F4 C |
 NOLCASE :                     1798 C |  NOSHIFT :                     1026 C |
 NOSTRING :                    179E C |  NOT2BIG :                     103E C |
 NOUCASE :                     1768 C | *NOVAR :                          0 - |
 NULLCT :                       5E4 C |  NUMEXP :                       5AC - |
 OFCHR :                        '#' - |  OQUOTE :                       5DD C |
 OUTLOOP :                     22CC C | *PADDING :                        1 - |
 PRG_STRT :                     5EC C |  PRNLWORD :                     5A0 C |
 PRSTK :                        5D8 C |  RAM_ADDR :                    4000 - |
 RAM_BASE :                     400 C |  RAM_SIZE :                   1C000 - |
*RAM_STRT :                       0 C |  RDPTRL :                       466 C |
*RELAXED :                        0 - |  RTS_001 :                      E88 C |
 RTS_005 :                      50E C |  RTS_006 :                      6F0 C |
 RTS_007 :                      7EE C |  RTS_007A :                     804 C |
*RTS_008 :                      9BA C |  RTS_009 :                      AB6 C |
 RTS_011 :                     1330 C |  RTS_012 :                     1600 C |
 RTS_013 :                     1674 C |  RTS_015 :                     18CC C |
 RTS_016 :                     19A6 C |  RTS_017 :                     1CC4 C |
 RTS_020 :                     2050 C |  RTS_021 :                     2394 C |
 RTS_022 :                     27BC C |  RTS_023 :                     28CA C |
 RTS_024 :                     2B16 C |  RTS_025 :                     2B78 C |
 SARRYL :                       43E C |  SFNCL :                        432 C |
 SMEML :                        42E C |  SSTORL :                       446 C |
 SSTRL :                        43A C |  SUBEXIT :                     22D6 C |
 SUBLOOP :                     22A4 C |  SUFNXF :                       5DF C |
 SUTILL :                       44E C |  SVARL :                        436 C |
 TABSIZ :                       5E2 C |  TAB_ASCA :                    33DA C |
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 168 - 10/11/2023 16:23:32


 TAB_ASCB :                    33EA C |  TAB_ASCC :                    3403 C |
 TAB_ASCD :                    341A C |  TAB_ASCE :                    3433 C |
 TAB_ASCF :                    3442 C |  TAB_ASCG :                    344C C |
 TAB_ASCH :                    3459 C |  TAB_ASCI :                    345F C |
 TAB_ASCL :                    346E C |  TAB_ASCM :                    349C C |
 TAB_ASCN :                    34AA C |  TAB_ASCO :                    34B9 C |
 TAB_ASCP :                    34BE C |  TAB_ASCR :                    34D3 C |
 TAB_ASCS :                    34FD C |  TAB_ASCT :                    3528 C |
 TAB_ASCU :                    353C C |  TAB_ASCV :                    3554 C |
 TAB_ASCW :                    3560 C |  TAB_ATNC :                    2DF8 C |
 TAB_CHRT :                    3030 C |  TAB_EQUL :                    33D2 C |
 TAB_HTHET :                   2E78 C |  TAB_LESS :                    33CE C |
 TAB_MNUS :                    33CA C |  TAB_MORE :                    33D4 C |
 TAB_PLUS :                    33C8 C |  TAB_POWR :                    356F C |
 TAB_QEST :                    33D8 C |  TAB_SLAS :                    33CC C |
 TAB_SNCO :                    2D78 C |  TAB_STAR :                    33C6 C |
*TIME :                  "16:23:32" - |  TK_ABS :                        C1 - |
 TK_AND :                        B7 - |  TK_ASC :                        D3 - |
 TK_ATN :                        CC - |  TK_BINS :                       D8 - |
 TK_BITCLR :                     A7 - |  TK_BITSET :                     A6 - |
 TK_BITTST :                     D9 - |  TK_CALL :                       9B - |
 TK_CHRS :                       D6 - |  TK_CLEAR :                      A1 - |
 TK_CONT :                       9F - |  TK_COS :                        C9 - |
 TK_DATA :                       83 - |  TK_DEC :                        88 - |
 TK_DEEK :                       CE - |  TK_DEF :                        97 - |
 TK_DIM :                        85 - |  TK_DIV :                        B5 - |
 TK_DO :                         9C - |  TK_DOKE :                       99 - |
 TK_ELSE :                       A9 - |  TK_END :                        80 - |
 TK_EOR :                        B8 - |  TK_EQUAL :                      BD - |
 TK_EXP :                        C8 - |  TK_FN :                         AB - |
 TK_FOR :                        81 - |  TK_FRE :                        C3 - |
 TK_GET :                        A4 - |  TK_GOSUB :                      8D - |
 TK_GOTO :                       89 - |  TK_GT :                         BC - |
 TK_HEXS :                       D7 - |  TK_IF :                         8B - |
 TK_INC :                        93 - |  TK_INPUT :                      84 - |
 TK_INT :                        C0 - |  TK_LCASES :                     D5 - |
 TK_LEEK :                       CF - |  TK_LEFTS :                      E1 - |
 TK_LEN :                        D0 - |  TK_LET :                        87 - |
 TK_LIST :                       A0 - |  TK_LOAD :                       95 - |
 TK_LOG :                        C7 - |  TK_LOKE :                       9A - |
 TK_LOOP :                       9D - |  TK_LSHIFT :                     BB - |
 TK_LT :                         BE - |  TK_MAX :                        DA - |
 TK_MIDS :                       E3 - |  TK_MIN :                        DB - |
 TK_MINUS :                      B3 - |  TK_MULT :                       B4 - |
 TK_NEW :                        A2 - |  TK_NEXT :                       82 - |
 TK_NOT :                        AE - |  TK_NULL :                       92 - |
 TK_ON :                         91 - |  TK_OR :                         B9 - |
 TK_PEEK :                       CD - |  TK_PI :                         DD - |
 TK_PLUS :                       B2 - |  TK_POKE :                       98 - |
 TK_POS :                        C4 - |  TK_POWER :                      B6 - |
 TK_PRINT :                      9E - |  TK_RAM :                        DC - |
 TK_READ :                       86 - |  TK_REM :                        8F - |
 TK_RESTORE :                    8C - |  TK_RETURN :                     8E - |
 TK_RIGHTS :                     E2 - |  TK_RND :                        C6 - |
 TK_RSHIFT :                     BA - |  TK_RUN :                        8A - |
 TK_SADD :                       E0 - |  TK_SAVE :                       96 - |
 TK_SGN :                        BF - |  TK_SIN :                        CA - |
 TK_SPC :                        AC - |  TK_SQR :                        C5 - |
 TK_STEP :                       AF - |  TK_STOP :                       90 - |
 TK_STRS :                       D1 - |  TK_SWAP :                       A5 - |
 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 169 - 10/11/2023 16:23:32


 TK_TAB :                        A8 - |  TK_TAN :                        CB - |
 TK_THEN :                       AD - |  TK_TO :                         AA - |
 TK_TWOPI :                      DE - |  TK_UCASES :                     D4 - |
 TK_UNTIL :                      B0 - |  TK_USINGS :                     E4 - |
 TK_USR :                        C2 - |  TK_VAL :                        D2 - |
 TK_VPTR :                       DF - |  TK_WAIT :                       94 - |
 TK_WHILE :                      B1 - |  TK_WIDTH :                      A3 - |
 TOOBIG :                      1044 C |  TPOS :                         5E5 C |
 TPOWER :                       5D9 C | *TRUE :                           1 - |
 TWIDTH :                       5E6 C |  UC_LOOP :                     1786 C |
 USDSS :                        5CC C |  USRJMP :                       406 C |
*USRJPV :                       408 C | *UT1_PL :                       5A4 C |
 VARNAME :                      46A C |  VEC_CC :                      2798 C |
 VEC_IN :                        D8 C |  VEC_LD :                        FA C |
 VEC_OUT :                       C0 C |  VEC_SV :                       100 C |
*VERSION :                     142F - |  V_CTLC :                       424 C |
*V_CTLCV :                      426 C |  V_INPT :                       40C C |
*V_INPTV :                      40E C |  V_LOAD :                       418 C |
*V_LOADV :                      41A C |  V_OUTP :                       412 C |
*V_OUTPV :                      414 C |  V_SAVE :                       41E C |
*V_SAVEV :                      420 C |  WEXIT :                       28A2 C |
 WRMJPV :                       402 C |

   1115 symbols
     48 unused symbols

 AS V1.42 Beta [Bld 246] - Source File basic68k.asm - Page 170 - 10/11/2023 16:23:32


  Code Pages:
  ----------

STANDARD (0 changed characters)

1 code page

0.37 seconds assembly time

   9428 lines source file
      6 passes
      0 errors
      0 warnings
